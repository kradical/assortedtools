</div><p>\n\n<a name="%_chap_Temp_2"></a>\n<h1 class=chapter>\n<div class=chapterheading>&nbsp;</div><p>\n<a href="book-Z-H-4.html#%_toc_%_chap_Temp_2">Foreword</a></h1><p>\n\nEducators, generals, dieticians, psychologists, and parents program.\nArmies, students, and some societies are programmed.  An assault on\nlarge problems employs a succession of programs, most of which spring\ninto existence en route.  These programs are rife with issues that\nappear to be particular to the problem at hand.  To appreciate\nprogramming as an intellectual activity in its own right you must turn\nto computer programming; you must read and write computer\nprograms -- many of them.  It doesn\'t matter much what the programs are\nabout or what applications they serve.  What does matter is how well\nthey perform and how smoothly they fit with other programs in the\ncreation of still greater programs.  The programmer must seek both\nperfection of part and adequacy of collection.  In this book the use\nof ``program\'\' is focused on the creation, execution, and study of\nprograms written in a dialect of Lisp for execution on a digital\ncomputer.  Using Lisp we restrict or limit not what we may program,\nbut only the notation for our program descriptions.<p>\n\nOur traffic with the subject matter of this book involves us with\nthree foci of phenomena: the human mind, collections of computer\nprograms, and the computer.  Every computer program is a model,\nhatched in the mind, of a real or mental process.  These processes,\narising from human experience and thought, are huge in number,\nintricate in detail, and at any time only partially understood.  They\nare modeled to our permanent satisfaction rarely by our computer\nprograms.  Thus even though our programs are carefully handcrafted\ndiscrete collections of symbols, mosaics of interlocking functions,\nthey continually evolve: we change them as our perception of the model\ndeepens, enlarges, generalizes until the model ultimately attains a\nmetastable place within still another model with which we struggle.\nThe source of the exhilaration associated with computer programming is\nthe continual unfolding within the mind and on the computer of\nmechanisms expressed as programs and the explosion of perception they\ngenerate.  If art interprets our dreams, the computer executes them in\nthe guise of programs!<p>\n\nFor all its power, the computer is a harsh taskmaster.  Its programs\nmust be correct, and what we wish to say must be said accurately in\nevery detail.  As in every other symbolic activity, we become\nconvinced of program truth through argument.  Lisp itself can be\nassigned a semantics (another model, by the way), and if a program\'s\nfunction can be specified, say, in the predicate calculus, the proof\nmethods of logic can be used to make an acceptable correctness\nargument.  Unfortunately, as programs get large and complicated, as\nthey almost always do, the adequacy, consistency, and correctness of\nthe specifications themselves become open to doubt, so that complete\nformal arguments of correctness seldom accompany large programs.\nSince large programs grow from small ones, it is crucial that we\ndevelop an arsenal of standard program structures of whose correctness\nwe have become sure -- we call them idioms -- and learn to combine them\ninto larger structures using organizational techniques of proven\nvalue.  These techniques are treated at length in this book, and\nunderstanding them is essential to participation in the Promethean\nenterprise called programming.  More than anything else, the\nuncovering and mastery of powerful organizational techniques\naccelerates our ability to create large, significant programs.\nConversely, since writing large programs is very taxing, we are\nstimulated to invent new methods of reducing the mass of function and\ndetail to be fitted into large programs.<p>\n\nUnlike programs, computers must obey the laws of physics.  If they\nwish to perform rapidly -- a few nanoseconds per state change -- they\nmust transmit electrons only small distances (at most 1 <small><sup>1</sup>/<small>2</small></small>\nfeet).  The heat generated by the huge number of devices so\nconcentrated in space has to be removed.  An exquisite engineering art\nhas been developed balancing between multiplicity of function and\ndensity of devices.  In any event, hardware always operates at a level\nmore primitive than that at which we care to program.  The processes\nthat transform our Lisp programs to ``machine\'\' programs are\nthemselves abstract models which we program.  Their study and creation\ngive a great deal of insight into the organizational programs\nassociated with programming arbitrary models.  Of course the computer\nitself can be so modeled.  Think of it: the behavior of the smallest\nphysical switching element is modeled by quantum mechanics described\nby differential equations whose detailed behavior is captured by\nnumerical approximations represented in computer programs executing on\ncomputers composed of <tt>...</tt>!<p>\n\nIt is not merely a matter of tactical convenience to separately\nidentify the three foci.  Even though, as they say, it\'s all in the\nhead, this logical separation induces an acceleration of symbolic\ntraffic between these foci whose richness, vitality, and potential is\nexceeded in human experience only by the evolution of life itself.  At\nbest, relationships between the foci are metastable.  The computers\nare never large enough or fast enough.  Each breakthrough in hardware\ntechnology leads to more massive programming enterprises, new\norganizational principles, and an enrichment of abstract models.\nEvery reader should ask himself periodically ``Toward what end, toward\nwhat end?\'\' -- but do not ask it too often lest you pass up the fun of\nprogramming for the constipation of bittersweet philosophy.<p>\n\nAmong the programs we write, some (but never enough) perform a precise\nmathematical function such as sorting or finding the maximum of a\nsequence of numbers, determining primality, or finding the square\nroot.  We call such programs algorithms, and a great deal is known of\ntheir optimal behavior, particularly with respect to the two important\nparameters of execution time and data storage requirements.  A\nprogrammer should acquire good algorithms and idioms.  Even though\nsome programs resist precise specifications, it is the responsibility\nof the programmer to estimate, and always to attempt to improve, their\nperformance.<p>\n\nLisp is a survivor, having been in use for about a quarter of a\ncentury.  Among the active programming languages only Fortran has had\na longer life.  Both languages have supported the programming needs of\nimportant areas of application, Fortran for scientific and engineering\ncomputation and Lisp for artificial intelligence.  These two areas\ncontinue to be important, and their programmers are so devoted to\nthese two languages that Lisp and Fortran may well continue in active\nuse for at least another quarter-century.<p>\n\nLisp changes.  The Scheme dialect used in this text has evolved from\nthe original Lisp and differs from the latter in several important\nways, including static scoping for variable binding and permitting\nfunctions to yield functions as values.  In its semantic structure\nScheme is as closely akin to Algol 60 as to early Lisps.  Algol 60,\nnever to be an active language again, lives on in the genes of Scheme\nand Pascal.  It would be difficult to find two languages that are the\ncommunicating coin of two more different cultures than those gathered\naround these two languages.  Pascal is for building\npyramids -- imposing, breathtaking, static structures built by armies\npushing heavy blocks into place.  Lisp is for building\norganisms -- imposing, breathtaking, dynamic structures built by squads\nfitting fluctuating myriads of simpler organisms into place.  The\norganizing principles used are the same in both cases, except for one\nextraordinarily important difference: The discretionary exportable\nfunctionality entrusted to the individual Lisp programmer is more than\nan order of magnitude greater than that to be found within Pascal\nenterprises.  Lisp programs inflate libraries with functions whose\nutility transcends the application that produced them.  The list,\nLisp\'s native data structure, is largely responsible for such growth\nof utility.  The simple structure and natural applicability of lists\nare reflected in functions that are amazingly nonidiosyncratic.  In\nPascal the plethora of declarable data structures induces a\nspecialization within functions that inhibits and penalizes casual\ncooperation.  It is better to have 100 functions operate on one data\nstructure than to have 10 functions operate on 10 data structures.  As\na result the pyramid must stand unchanged for a millennium; the\norganism must evolve or perish.<p>\n\nTo illustrate this difference, compare the treatment of material and\nexercises within this book with that in any first-course text using\nPascal.  Do not labor under the illusion that this is a text\ndigestible at MIT only, peculiar to the breed found there.  It is\nprecisely what a serious book on programming Lisp must be, no matter\nwho the student is or where it is used.<p>\n\nNote that this is a text about programming, unlike most Lisp books,\nwhich are used as a preparation for work in artificial intelligence.\nAfter all, the critical programming concerns of software engineering\nand artificial intelligence tend to coalesce as the systems under\ninvestigation become larger.  This explains why there is such growing\ninterest in Lisp outside of artificial intelligence.<p>\n\nAs one would expect from its goals, artificial intelligence research\ngenerates many significant programming problems.  In other\nprogramming cultures this spate of problems spawns new languages.\nIndeed, in any very large programming task a useful organizing\nprinciple is to control and isolate traffic within the task modules\nvia the invention of language.  These languages tend to become less\nprimitive as one approaches the boundaries of the system where we\nhumans interact most often.  As a result, such systems contain complex\nlanguage-processing functions replicated many times.  Lisp has such a\nsimple syntax and semantics that parsing can be treated as an\nelementary task.  Thus parsing technology plays almost no role in Lisp\nprograms, and the construction of language processors is rarely an\nimpediment to the rate of growth and change of large Lisp systems.\nFinally, it is this very simplicity of syntax and semantics that is\nresponsible for the burden and freedom borne by all Lisp programmers.\nNo Lisp program of any size beyond a few lines can be written without\nbeing saturated with discretionary functions.  Invent and fit; have\nfits and reinvent!  We toast the Lisp programmer who pens his thoughts\nwithin nests of parentheses.<p>\n\n<p><p><p>\n\n<p><div align=left><table><tr><td>\n\nAlan J. Perlis<br>\nNew Haven, Connecticut\n</td></tr></table></div><p>\n<p>\n\n\n<p><div class=navigation></div><p>\n\n<a name="%_chap_Temp_3"></a>\n<h1 class=chapter>\n<div class=chapterheading>&nbsp;</div><p>\n<a href="book-Z-H-4.html#%_toc_%_chap_Temp_3">Preface to the Second Edition</a></h1><p>\n\n<p>\n<div align=right> \n<table width=60%><tr><td>\n<span class=epigraph>\n<p>\n\nIs it possible that software is not like anything else, that it\nis meant to be discarded: that the whole point is to \nalways see it as a soap bubble?<p>\n\n<a name="%_idx_2"></a>Alan J. Perlis<p>\n\n</span>\n</td></tr></table>\n</div>\n\n<p><p>\n\nThe material in this book has been the basis of MIT\'s entry-level\ncomputer science subject since 1980.  We had been teaching this\nmaterial for four years when the first edition was published, and\ntwelve more years have elapsed until the appearance of this second\nedition.  We are pleased that our work has been widely adopted and\nincorporated into other texts.  We have seen our students take the\nideas and programs in this book and build them in as the core of new\ncomputer systems and languages.  In literal realization of an ancient\nTalmudic pun, our students have become our builders.  We are lucky to\nhave such capable students and such accomplished builders.<p>\n\nIn preparing this edition, we have incorporated hundreds of \nclarifications suggested by our own teaching experience and the\ncomments of colleagues at MIT and elsewhere.  We have redesigned\nmost of the major programming systems in the book, including\nthe generic-arithmetic system, the interpreters, the register-machine\nsimulator, and the compiler; and we have rewritten all the program\nexamples to ensure that any Scheme implementation conforming to\nthe IEEE Scheme standard (IEEE 1990) will be able to run the code.<p>\n\nThis edition emphasizes several new themes.  The most important\nof these is the central role played by different approaches to\ndealing with time in computational models: objects with state,\nconcurrent programming, functional programming, lazy evaluation,\nand nondeterministic programming.  We have included new sections on \nconcurrency and nondeterminism, and we have tried to integrate this\ntheme throughout the book.<p>\n\nThe first edition of the book closely followed the syllabus of our MIT\none-semester subject.  With all the new material in the second\nedition, it will not be possible to cover everything in a single\nsemester, so the instructor will have to pick and choose.  In our own\nteaching, we sometimes skip the section on logic programming\n(section&nbsp;<a href="book-Z-H-29.html#%_sec_4.4">4.4</a>), we have students use the\nregister-machine simulator but we do not cover its implementation\n(section&nbsp;<a href="book-Z-H-32.html#%_sec_5.2">5.2</a>), and we give only a cursory overview of\nthe compiler (section&nbsp;<a href="book-Z-H-35.html#%_sec_5.5">5.5</a>).  Even so, this is still\nan intense course.  Some instructors may wish to cover only the first\nthree or four chapters, leaving the other material for subsequent\ncourses.<p>\n\nThe World-Wide-Web site <tt>www-mitpress.mit.edu/sicp</tt>\nprovides support for users of this book.\nThis includes programs from the book,\nsample programming assignments, supplementary materials,\nand downloadable implementations of the Scheme dialect of Lisp.<p>\n\n\n<p><div class=navigation></div><p>\n\n<a name="%_chap_Temp_4"></a>\n<h1 class=chapter>\n<div class=chapterheading>&nbsp;</div><p>\n<a href="book-Z-H-4.html#%_toc_%_chap_Temp_4">Preface to the First Edition</a></h1><p>\n\n<p>\n<div align=right> \n<table width=60%><tr><td>\n<span class=epigraph>\n<p>\n\nA computer is like a violin.  You can imagine a novice trying first a\nphonograph and then a violin.  The latter, he says, sounds terrible.\nThat is the argument we have heard from our humanists and most of our\ncomputer scientists.  Computer programs are good, they say, for\nparticular purposes, but they aren\'t flexible.  Neither is a violin,\nor a typewriter, until you learn how to use it.<p>\n\n<a name="%_idx_4"></a>Marvin Minsky, ``Why Programming Is a Good<br>\nMedium for Expressing Poorly-Understood and Sloppily-Formulated\nIdeas\'\'<p>\n\n</span>\n</td></tr></table>\n</div>\n\n<p><p>\n\n``The Structure and Interpretation of Computer Programs\'\' is the\nentry-level subject in computer science at the Massachusetts Institute\nof Technology.  It is required of all students at MIT who major\nin electrical engineering or in computer science, as one-fourth of the\n``common core curriculum,\'\' which also includes two subjects on\ncircuits and linear systems and a subject on the design of digital\nsystems.  We have been involved in the development of this subject\nsince 1978, and we have taught this material in its present form since\nthe fall of 1980 to between 600 and 700 students each year.  Most of\nthese students have had little or no prior formal training in\ncomputation, although many have played with computers a bit and a few\nhave had extensive programming or hardware-design experience.<p>\n\nOur design of this introductory computer-science subject reflects two\nmajor concerns.  First, we want to establish the idea that a computer\nlanguage is not just a way of getting a computer to perform operations\nbut rather that it is a novel formal medium for expressing ideas about\nmethodology.  Thus, programs must be written for people to read, and\nonly incidentally for machines to execute.  Second, we believe that\nthe essential material to be addressed by a subject at this level is\nnot the syntax of particular programming-language constructs, nor\nclever algorithms for computing particular functions efficiently, nor\neven the mathematical analysis of algorithms and the foundations of\ncomputing, but rather the techniques used to control the intellectual\ncomplexity of large software systems.<p>\n\nOur goal is that students who complete this subject should have a good\nfeel for the elements of style and the aesthetics of programming.\nThey should have command of the major techniques for controlling\ncomplexity in a large system. They should be capable of reading a\n50-page-long program, if it is written in an exemplary style. They\nshould know what not to read, and what they need not understand at any\nmoment.  They should feel secure about modifying a program, retaining\nthe spirit and style of the original author.<p>\n\nThese skills are by no means unique to computer programming.  The\ntechniques we teach and draw upon are common to all of engineering\ndesign.  We control complexity by building abstractions that hide\ndetails when appropriate.  We control complexity by establishing\nconventional interfaces that enable us to construct systems by\ncombining standard, well-understood pieces in a ``mix and match\'\' way.\nWe control complexity by establishing new languages for describing a\ndesign, each of which emphasizes particular aspects of the design and\ndeemphasizes others.<p>\n\nUnderlying our approach to this subject is our conviction that\n``computer science\'\' is not a science and that its significance has\nlittle to do with computers.  The computer revolution is a revolution\nin the way we think and in the way we express what we think.  The\nessence of this change is the emergence of what might best be called\n<em>procedural epistemology</em> -- the study of the structure of\nknowledge from an imperative point of view, as opposed to the more\ndeclarative point of view taken by classical mathematical subjects.\nMathematics provides a framework for dealing precisely with notions of\n``what is.\'\'  Computation provides a framework for dealing precisely\nwith notions of ``how to.\'\'<p>\n\nIn teaching our material we use a dialect of the programming language\nLisp.  We never formally teach the language, because we don\'t have to.\nWe just use it, and students pick it up in a few days.  This is one\ngreat advantage of Lisp-like languages: They have very few ways of\nforming compound expressions, and almost no syntactic structure.  All\nof the formal properties can be covered in an hour, like the rules of\nchess.  After a short time we forget about syntactic details of the\nlanguage (because there are none) and get on with the real\nissues -- figuring out what we want to compute, how we will decompose\nproblems into manageable parts, and how we will work on the parts.\nAnother advantage of Lisp is that it supports (but does not enforce)\nmore of the large-scale strategies for modular decomposition of\nprograms than any other language we know.  We can make procedural and\ndata abstractions, we can use higher-order functions to capture common\npatterns of usage, we can model local state using assignment and data\nmutation, we can link parts of a program with streams and delayed\nevaluation, and we can easily implement embedded languages.  All of\nthis is embedded in an interactive environment with excellent support\nfor incremental program design, construction, testing, and debugging.\nWe thank all the generations of Lisp wizards, starting with John\nMcCarthy, who have fashioned a fine tool of unprecedented power and\nelegance.<p>\n\nScheme, the dialect of Lisp that we use, is an attempt to bring\ntogether the power and elegance of Lisp and Algol.  From Lisp we take\nthe metalinguistic power that derives from the simple syntax, the\nuniform representation of programs as data objects, and the\ngarbage-collected heap-allocated data.  From Algol we take lexical\nscoping and block structure, which are gifts from the pioneers of\nprogramming-language design who were on the Algol committee.  We wish\nto cite John Reynolds and Peter Landin for their insights into the\nrelationship of Church\'s lambda calculus to the structure of\nprogramming languages.  We also recognize our debt to the\nmathematicians who scouted out this territory decades before computers\nappeared on the scene.  These pioneers include Alonzo Church, Barkley\nRosser, Stephen Kleene, and Haskell Curry.<p>\n\n<p>\n\n\n<p><div class=navigation></div><p>\n\n<a name="%_chap_Temp_5"></a>\n<h1 class=chapter>\n<div class=chapterheading>&nbsp;</div><p>\n<a href="book-Z-H-4.html#%_toc_%_chap_Temp_5">Acknowledgments</a></h1><p>\n\nWe would like to thank the many people who have helped us develop this\nbook and this curriculum.<p>\n\nOur subject is a clear intellectual descendant of ``6.231,\'\' a\nwonderful subject on programming linguistics and the lambda calculus\ntaught at MIT in the late 1960s by Jack Wozencraft and Arthur Evans,\nJr.<p>\n\nWe owe a great debt to Robert Fano, who reorganized MIT\'s introductory\ncurriculum in electrical engineering and computer science to emphasize\nthe principles of engineering design.  He led us in starting out on\nthis enterprise and wrote the first set of subject notes from which\nthis book evolved.<p>\n\nMuch of the style and aesthetics of programming that we try to teach\nwere developed in conjunction with Guy Lewis Steele Jr., who\ncollaborated with Gerald Jay Sussman in the initial development of the\nScheme language.  In addition, David Turner, Peter Henderson, Dan\nFriedman, David Wise, and Will Clinger have taught us many of the\ntechniques of the functional programming community that appear in this\nbook.<p>\n\nJoel Moses taught us about structuring large systems.  His experience\nwith the Macsyma system for symbolic computation provided the insight\nthat one should avoid complexities of control and concentrate on\norganizing the data to reflect the real structure of the world being\nmodeled.<p>\n\nMarvin Minsky and Seymour Papert formed many of our attitudes about\nprogramming and its place in our intellectual lives.  To them we owe\nthe understanding that computation provides a means of expression for\nexploring ideas that would otherwise be too complex to deal with\nprecisely.  They emphasize that a student\'s ability to write and\nmodify programs provides a powerful medium in which exploring becomes\na natural activity.<p>\n\nWe also strongly agree with Alan Perlis that programming is lots of\nfun and we had better be careful to support the joy of programming.\nPart of this joy derives from observing great masters at work.  We are\nfortunate to have been apprentice programmers at the feet of Bill\nGosper and Richard Greenblatt.<p>\n\nIt is difficult to identify all the people who have contributed to the\ndevelopment of our curriculum.  We thank all the lecturers, recitation\ninstructors, and tutors who have worked with us over the past fifteen\nyears and put in many extra hours on our subject, especially Bill\nSiebert, Albert Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric\nGrimson, Rod Brooks, Lynn Stein, and Peter Szolovits.\nWe would like to specially acknowledge the outstanding teaching\ncontributions of Franklyn Turbak, now at Wellesley; his work\nin undergraduate instruction set a standard that we can\nall aspire to.\nWe are grateful to Jerry Saltzer and Jim Miller for\nhelping us grapple with the mysteries of concurrency, and to\nPeter Szolovits and David McAllester for their contributions\nto the exposition of nondeterministic evaluation in chapter&nbsp;4.<p>\n\nMany people have put in significant effort presenting this material at\nother universities.  Some of the people we have worked closely with\nare Jacob Katzenelson at the Technion, Hardy Mayer at the University\nof California at Irvine, Joe Stoy at Oxford, Elisha Sacks at Purdue,\nand Jan Komorowski at the Norwegian University of Science and\nTechnology.  We are exceptionally proud of our colleagues who have\nreceived major teaching awards for their adaptations of this subject\nat other universities, including Kenneth Yip at Yale, Brian Harvey at\nthe University of California at Berkeley, and Dan Huttenlocher at\nCornell.<p>\n\nAl Moy&eacute; arranged for us to teach this material to engineers at\nHewlett-Packard, and for the production of videotapes of these\nlectures.\nWe would like to thank the talented instructors -- in\nparticular Jim Miller, Bill Siebert, and Mike Eisenberg -- who have\ndesigned continuing education courses incorporating these tapes and\ntaught them at universities and industry all over the world.<p>\n\nMany educators in other countries have put in significant\nwork translating the first edition.\nMichel Briand, Pierre Chamard, and Andr&eacute; Pic produced a French edition;\nSusanne Daniels-Herold produced a German\nedition; and Fumio Motoyoshi produced a Japanese edition.\nWe do not know who produced the Chinese edition,\nbut we consider it an honor to have been selected as the\nsubject of an ``unauthorized\'\' translation.<p>\n\nIt is hard to enumerate all the people who have made technical\ncontributions to the development of the Scheme systems we use for\ninstructional purposes.  In addition to Guy Steele, principal wizards\nhave included Chris Hanson, Joe Bowbeer, Jim Miller, Guillermo Rozas,\nand Stephen Adams.  Others who have put in significant time are\nRichard Stallman, Alan Bawden, Kent Pitman, Jon Taft, Neil Mayle, John\nLamping, Gwyn Osnos, Tracy Larrabee, George Carrette, Soma\nChaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss,\nTodd Cass, Patrick O\'Donnell, Kevin Theobald, Daniel Weise, Kenneth\nSinclair, Anthony Courtemanche, Henry M. Wu, Andrew Berlin, and Ruth\nShyu.<p>\n\nBeyond the MIT implementation, we would like to thank the many people\nwho worked on the IEEE Scheme standard, including William Clinger and\nJonathan Rees, who edited the R<sup>4</sup>RS, and Chris Haynes, David\nBartley, Chris Hanson, and Jim Miller, who prepared the IEEE standard.<p>\n\nDan Friedman has been a long-time leader of the Scheme community.\nThe community\'s broader work goes beyond issues of language design to\nencompass significant educational innovations, such as the high-school\ncurriculum based on EdScheme by Schemer\'s Inc., and the wonderful\nbooks by Mike Eisenberg and by Brian Harvey and Matthew Wright.<p>\n\nWe appreciate the work of those who contributed to making this a real\nbook, especially Terry Ehling, Larry Cohen, and Paul Bethge at the MIT\nPress.  Ella Mazel found the wonderful cover image.  For the second\nedition we are particularly grateful to Bernard and Ella Mazel for\nhelp with the book design, and to David Jones, T<small>E</small>X wizard\nextraordinaire.  We also are indebted to those readers who made\npenetrating comments on the new draft: Jacob Katzenelson, Hardy\nMayer, Jim Miller, and especially Brian Harvey, who did unto this book\nas Julie did unto his book <em>Simply Scheme</em>.\n<p> Finally, we would like to acknowledge the support of the organizations that \n  have encouraged this work over the years, including support from Hewlett-Packard, \n  made possible by Ira Goldstein and Joel Birnbaum, and support from DARPA, made \n  possible by Bob Kahn.\n<p>\n\n\n<p>\n\n<p>\n\n<p>\n\n\n\n<p><div class=navigation></div><p>\n\n<a name="%_chap_1"></a>\n<h1 class=chapter>\n<div class=chapterheading><a href="book-Z-H-4.html#%_toc_%_chap_1">Chapter 1</a></div><p>\n<a href="book-Z-H-4.html#%_toc_%_chap_1">Building Abstractions with Procedures</a></h1><p>\n\n<p>\n<div align=right> \n<table width=60%><tr><td>\n<span class=epigraph>\n<p>\n\nThe acts of the mind, wherein it exerts its power over simple ideas,\nare chiefly these three: 1. Combining several simple ideas into one\ncompound one, and thus all complex ideas are made.  2. The second is\nbringing two ideas, whether simple or complex, together, and setting\nthem by one another so as to take a view of them at once, without\nuniting them into one, by which it gets all its ideas of relations.\n3.  The third is separating them from all other ideas that accompany\nthem in their real existence: this is called abstraction, and thus all\nits general ideas are made.<p>\n\n<a name="%_idx_6"></a>John Locke, <em>An Essay Concerning Human Understanding</em>\n(1690)<p>\n\n</span>\n</td></tr></table>\n</div>\n\n<p><p>\n\nWe are about to study the idea of a <a name="%_idx_8"></a><a name="%_idx_10"></a><em>computational process</em>.\nComputational processes are abstract beings that inhabit computers.\nAs they evolve, processes manipulate other abstract things called <a name="%_idx_12"></a><em>data</em>.  The evolution of a process is directed by a pattern of rules\ncalled a <a name="%_idx_14"></a><em>program</em>.  People create programs to direct processes.\nIn effect, we conjure the spirits of the computer with our spells.<p>\n\nA computational process is indeed much like a sorcerer\'s idea of a\nspirit.  It cannot be seen or touched.  It is not composed of matter\nat all.  However, it is very real.  It can perform intellectual work.\nIt can answer questions.  It can affect the world by disbursing money\nat a bank or by controlling a robot arm in a factory.  The programs we\nuse to conjure processes are like a sorcerer\'s spells.  They are\ncarefully composed from symbolic expressions in arcane and esoteric\n<a name="%_idx_16"></a><em>programming languages</em> that prescribe the tasks we want our\nprocesses to perform.<p>\n\nA computational process, in a correctly working computer, executes\nprograms precisely and accurately.  Thus, like the sorcerer\'s\napprentice, novice programmers must learn to understand and to\nanticipate the consequences of their conjuring.  Even small errors\n(usually called <a name="%_idx_18"></a><em>bugs</em> or <a name="%_idx_20"></a><em>glitches</em>) in programs can have\ncomplex and unanticipated consequences.<p>\n\nFortunately, learning to program is considerably less dangerous than\nlearning sorcery, because the spirits we deal with are conveniently\ncontained in a secure way.  Real-world programming, however,\nrequires care, expertise, and wisdom.  A small bug in a computer-aided\ndesign program, for example, can lead to the catastrophic collapse of\nan airplane or a dam or the self-destruction of an industrial robot.<p>\n\nMaster software engineers have the ability to organize programs so\nthat they can be reasonably sure that the resulting processes will\nperform the tasks intended.  They can visualize the behavior of their\nsystems in advance.  They know how to structure programs so that\nunanticipated problems do not lead to catastrophic consequences, and\nwhen problems do arise, they can <a name="%_idx_22"></a><em>debug</em> their programs.  Well-designed\ncomputational systems, like well-designed automobiles or nuclear\nreactors, are designed in a modular manner, so that the parts can be\nconstructed, replaced, and debugged separately.<p>\n\n<a name="%_sec_Temp_6"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_6">Programming in Lisp</a></h4><p>\n\nWe need an appropriate language for describing processes, and we will\nuse for this purpose the programming language Lisp.  Just as our\neveryday thoughts are usually expressed in our natural language (such\nas English, French, or Japanese), and descriptions of quantitative\nphenomena are expressed with mathematical notations, our procedural\nthoughts will be expressed in Lisp.  <a name="%_idx_24"></a>Lisp was invented in the late\n1950s as a formalism for reasoning about the use of certain kinds of\nlogical expressions, called <a name="%_idx_26"></a><em>recursion equations</em>, as a model for\ncomputation.  The language was conceived by <a name="%_idx_28"></a>John McCarthy and is based\non his paper ``Recursive Functions of Symbolic Expressions and Their\nComputation by Machine\'\' (McCarthy 1960).<p>\n\nDespite its inception as a mathematical formalism, Lisp is a practical\nprogramming language.  A Lisp <a name="%_idx_30"></a><em>interpreter</em> is a machine that\ncarries out processes described in the Lisp language.  The first Lisp\ninterpreter was implemented by <a name="%_idx_32"></a>McCarthy with the help of colleagues\nand students in the Artificial Intelligence Group of the <a name="%_idx_34"></a>MIT Research\nLaboratory of Electronics and in the MIT Computation\nCenter.<a name="call_footnote_Temp_7" href="#footnote_Temp_7"><sup><small>1</small></sup></a> <a name="%_idx_38"></a>Lisp, whose name is an acronym for LISt Processing,\nwas designed to provide symbol-manipulating capabilities for\nattacking programming problems such as the symbolic differentiation\nand integration of algebraic expressions.  It included for this\npurpose new data objects known as atoms and lists, which most\nstrikingly set it apart from all other languages of the period.<p>\n\nLisp was not the product of a concerted design effort.  Instead, it\nevolved informally in an experimental manner in response to users\'\nneeds and to pragmatic implementation considerations.  Lisp\'s informal\nevolution has continued through the years, and the community of Lisp\nusers has traditionally resisted attempts to promulgate any\n``official\'\' definition of the language.  This evolution, together\nwith the flexibility and elegance of the initial conception, has\nenabled Lisp, which is the second oldest language in widespread use\ntoday (only <a name="%_idx_40"></a>Fortran is older), to continually adapt to encompass the\nmost modern ideas about program design.  Thus, Lisp is by now a family\nof dialects, which, while sharing most of the original features, may\ndiffer from one another in significant ways.  The dialect of Lisp used\nin this book is called <a name="%_idx_42"></a><a name="%_idx_44"></a>Scheme.<a name="call_footnote_Temp_8" href="#footnote_Temp_8"><sup><small>2</small></sup></a><p>\n\nBecause of its experimental character and its emphasis on symbol\nmanipulation, <a name="%_idx_96"></a><a name="%_idx_98"></a><a name="%_idx_100"></a>Lisp was at first very inefficient for numerical\ncomputations, at least in comparison with Fortran.  Over the years,\nhowever, Lisp compilers have been developed that translate programs\ninto machine code that can perform numerical computations reasonably\nefficiently.  And for special applications, Lisp has been used with\ngreat effectiveness.<a name="call_footnote_Temp_9" href="#footnote_Temp_9"><sup><small>3</small></sup></a>  Although Lisp has not yet overcome its old reputation\nas hopelessly inefficient, Lisp is now used in many applications where\nefficiency is not the central concern.  For example, Lisp has become\na language of choice for operating-system shell languages and for\nextension languages for editors and computer-aided design systems.<p>\n\nIf Lisp is not a mainstream language, why are we using it as the\nframework for our discussion of programming?  Because the language\npossesses <a name="%_idx_112"></a>unique features that make it an excellent medium for\nstudying important programming constructs and data structures and for\nrelating them to the linguistic features that support them.  The most\nsignificant of these features is the fact that Lisp descriptions of\nprocesses, called <a name="%_idx_114"></a><a name="%_idx_116"></a><em>procedures</em>, can\nthemselves be represented and manipulated as Lisp data.  The\nimportance of this is that there are powerful program-design\ntechniques that rely on the ability to blur the traditional\ndistinction between ``passive\'\' data and ``active\'\' processes.  As we\nshall discover, Lisp\'s flexibility in handling procedures as data\nmakes it one of the most convenient languages in existence for\nexploring these techniques.  The ability to represent procedures as\ndata also makes Lisp an excellent language for writing programs that\nmust manipulate other programs as data, such as the interpreters and\ncompilers that support computer languages.  Above and beyond these\nconsiderations, programming in Lisp is great fun.<p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_7" href="#call_footnote_Temp_7"><sup><small>1</small></sup></a> The <em>Lisp 1 Programmer\'s Manual</em> appeared in\n1960, and the <em>Lisp 1.5 Programmer\'s Manual</em> <a name="%_idx_36"></a>(McCarthy 1965)\nwas published in 1962.  The early history of Lisp is described in\nMcCarthy 1978.\n\n<p><a name="footnote_Temp_8" href="#call_footnote_Temp_8"><sup><small>2</small></sup></a> The two dialects in which most\nmajor Lisp programs of the 1970s were written are <a name="%_idx_46"></a><a name="%_idx_48"></a>MacLisp <a name="%_idx_50"></a>(Moon 1978;\n<a name="%_idx_52"></a>Pitman 1983), developed at the <a name="%_idx_54"></a>MIT Project MAC, and <a name="%_idx_56"></a><a name="%_idx_58"></a>Interlisp\n<a name="%_idx_60"></a>(Teitelman 1974), developed at <a name="%_idx_62"></a>Bolt Beranek and Newman Inc. and the\n<a name="%_idx_64"></a>Xerox Palo Alto Research Center.  <a name="%_idx_66"></a><a name="%_idx_68"></a>Portable Standard Lisp <a name="%_idx_70"></a>(Hearn 1969;\n<a name="%_idx_72"></a>Griss 1981) was a Lisp dialect designed to be easily portable\nbetween different machines.  MacLisp spawned a number of subdialects,\nsuch as <a name="%_idx_74"></a><a name="%_idx_76"></a>Franz Lisp, which was developed at the <a name="%_idx_78"></a>University of\nCalifornia at Berkeley, and <a name="%_idx_80"></a><a name="%_idx_82"></a>Zetalisp (Moon 1981), which was based on a\nspecial-purpose processor designed at the <a name="%_idx_84"></a>MIT Artificial Intelligence\nLaboratory to run Lisp very efficiently.  The Lisp dialect used in\nthis book, called <a name="%_idx_86"></a>Scheme (Steele 1975), was invented in 1975 by <a name="%_idx_88"></a><a name="%_idx_90"></a>Guy\nLewis Steele Jr. and Gerald Jay Sussman of the MIT Artificial\nIntelligence Laboratory and later reimplemented for instructional use\nat MIT.  Scheme became an IEEE standard in 1990 (IEEE 1990).  The\n<a name="%_idx_92"></a><a name="%_idx_94"></a>Common Lisp dialect (Steele 1982, Steele 1990) was developed by the\nLisp community to combine features from the earlier Lisp dialects\nto make an industrial standard for Lisp.  Common Lisp became an ANSI\nstandard in 1994 (ANSI&nbsp;1994).\n\n<p><a name="footnote_Temp_9" href="#call_footnote_Temp_9"><sup><small>3</small></sup></a> One such special application was a\nbreakthrough computation of scientific importance -- an integration of\nthe motion of the <a name="%_idx_102"></a><a name="%_idx_104"></a>Solar System that extended previous results by\nnearly two orders of magnitude, and demonstrated that the dynamics of\nthe Solar System is chaotic.  This computation was made possible by\nnew integration algorithms, a special-purpose compiler, and a\nspecial-purpose computer all implemented with the aid of software\ntools written in Lisp <a name="%_idx_106"></a>(Abelson et al. 1992; <a name="%_idx_108"></a><a name="%_idx_110"></a>Sussman and\nWisdom 1992).\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_1.1"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_1.1">1.1&nbsp;&nbsp;The Elements of Programming</a></h2><p>\n\n\n<a name="%_idx_118"></a>\nA powerful programming language is more than just a means for\ninstructing a computer to perform tasks.  The language also serves as\na framework within which we organize our ideas about processes.  Thus,\nwhen we describe a language, we should pay particular attention to the\nmeans that the language provides for combining simple ideas to form\nmore complex ideas.  Every powerful language has three mechanisms for\naccomplishing this:<p>\n\n<p><ul>\n<a name="%_idx_120"></a><li><strong>primitive expressions</strong>, which represent the simplest\nentities the language is concerned with,<p>\n\n<a name="%_idx_122"></a><a name="%_idx_124"></a><li><strong>means of combination</strong>, by which compound\nelements are built from simpler ones, and<p>\n\n<a name="%_idx_126"></a><li><strong>means of abstraction</strong>, by\nwhich compound elements can be named and manipulated as units.<p>\n\n</ul><p><p>\n\nIn programming, we deal with two kinds of elements: <a name="%_idx_128"></a>procedures and\n<a name="%_idx_130"></a>data. (Later we will discover that they are really not so distinct.)\nInformally, data is ``stuff\'\' that we want to manipulate, and\nprocedures are descriptions of the rules for manipulating the data.\nThus, any powerful programming language should be able to describe\nprimitive data and primitive procedures and should have methods for\ncombining and abstracting procedures and data.<p>\n\nIn this chapter we will deal only with simple <a name="%_idx_132"></a><a name="%_idx_134"></a>numerical data so that\nwe can focus on the rules for building procedures.<a name="call_footnote_Temp_10" href="#footnote_Temp_10"><sup><small>4</small></sup></a> In later chapters we will see that\nthese same rules allow us to build procedures to manipulate compound\ndata as well.<p>\n\n<a name="%_sec_1.1.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.1">1.1.1&nbsp;&nbsp;Expressions</a></h3><p>\n\n<p>\n\nOne easy way to get started at programming is to examine some typical\ninteractions with an interpreter for the Scheme dialect of Lisp.\nImagine that you are sitting at a computer terminal.  You type an\n<em>expression</em>, and the interpreter responds by displaying the result of\nits <em>evaluating</em> that expression.<p>\n\n<a name="%_idx_148"></a><a name="%_idx_150"></a>One kind of primitive expression you might type is a number.  (More\nprecisely, the expression that you type consists of the numerals that\nrepresent the number in base 10.)  If you present Lisp with\na number<p>\n\n<p><p><tt>486<br>\n</tt><p><p>\nthe interpreter will respond by printing<a name="call_footnote_Temp_11" href="#footnote_Temp_11"><sup><small>5</small></sup></a><p>\n\n<p><p><tt><i>486</i><br>\n</tt><p><p><p>\n\n<a name="%_idx_154"></a><a name="%_idx_156"></a>Expressions representing numbers may be combined with an <a name="%_idx_158"></a>expression\nrepresenting a <a name="%_idx_160"></a><a name="%_idx_162"></a><a name="%_idx_164"></a><a name="%_idx_166"></a><a name="%_idx_168"></a>primitive procedure (such as <tt>+</tt> or <tt>*</tt>) to form a\ncompound expression that represents the\napplication of the procedure to those numbers.  For example:<p>\n\n<p><p><tt>(+&nbsp;137&nbsp;349)<br>\n<i>486</i><br>\n<a name="%_idx_170"></a><a name="%_idx_172"></a>(-&nbsp;1000&nbsp;334)<br>\n<i>666</i><br>\n(*&nbsp;5&nbsp;99)<br>\n<i>495</i><br>\n<a name="%_idx_174"></a><a name="%_idx_176"></a>(/&nbsp;10&nbsp;5)<br>\n<i>2</i><br>\n(+&nbsp;2.7&nbsp;10)<br>\n<i>12.7</i><br>\n</tt><p><p><p>\n\nExpressions such as these, formed by <a name="%_idx_178"></a>delimiting a list of expressions\nwithin parentheses in order to denote <a name="%_idx_180"></a>procedure application,\nare called <em>combinations</em>.  The leftmost\nelement in the list is called the <a name="%_idx_182"></a><em>operator</em>, and the other\nelements are called <a name="%_idx_184"></a><em>operands</em>.  The <a name="%_idx_186"></a>value of a combination is\nobtained by applying the procedure specified by the operator to the\n<a name="%_idx_188"></a><em>arguments</em> that are the values of the operands.<p>\n\nThe convention of placing the operator to the left of the operands is\nknown as <a name="%_idx_190"></a><em>prefix notation</em>, and it may be somewhat confusing at\nfirst because it departs significantly from the customary mathematical\nconvention.  Prefix notation has several advantages, however.  One of\nthem is that it can accommodate <a name="%_idx_192"></a><a name="%_idx_194"></a>procedures that may take an arbitrary\nnumber of arguments, as in the following examples:<p>\n\n<p><p><tt>(+&nbsp;21&nbsp;35&nbsp;12&nbsp;7)<br>\n<i>75</i><br>\n<br>\n(*&nbsp;25&nbsp;4&nbsp;12)<br>\n<i>1200</i><br>\n</tt><p><p>\nNo ambiguity can arise, because the operator is always the leftmost\nelement and the entire combination is delimited by the\nparentheses.<p>\n\n<a name="%_idx_196"></a>A second advantage of prefix notation is that it extends in a\nstraightforward way to allow combinations to be <em>nested</em>, that is,\nto have combinations whose elements are themselves\ncombinations:<p>\n\n<p><p><tt>(+&nbsp;(*&nbsp;3&nbsp;5)&nbsp;(-&nbsp;10&nbsp;6))<br>\n<i>19</i><br>\n</tt><p><p><p>\n\nThere is no limit (in principle) to the depth of such nesting and to\nthe overall complexity of the expressions that the Lisp interpreter\ncan evaluate.\nIt is we humans who get confused by still relatively\nsimple expressions such as<p>\n\n<p><p><tt>(+&nbsp;(*&nbsp;3&nbsp;(+&nbsp;(*&nbsp;2&nbsp;4)&nbsp;(+&nbsp;3&nbsp;5)))&nbsp;(+&nbsp;(-&nbsp;10&nbsp;7)&nbsp;6))<br>\n</tt><p><p>\nwhich the interpreter would readily evaluate to be 57.  We can help\nourselves by writing such an expression in the form<p>\n\n<p><p><tt>(+&nbsp;(*&nbsp;3<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(*&nbsp;2&nbsp;4)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;3&nbsp;5)))<br>\n&nbsp;&nbsp;&nbsp;(+&nbsp;(-&nbsp;10&nbsp;7)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6))<br>\n</tt><p><p>\nfollowing a formatting convention known as <a name="%_idx_198"></a><em>pretty-printing</em>, in\nwhich each long combination is written so that the operands are\naligned vertically.  The resulting indentations display clearly the\nstructure of the expression.<a name="call_footnote_Temp_12" href="#footnote_Temp_12"><sup><small>6</small></sup></a><p>\n\nEven with complex expressions, the interpreter always operates in the\nsame basic cycle: It reads an expression from the terminal, \nevaluates the expression, and prints the result.\nThis mode of operation is often expressed by saying that the\ninterpreter runs in a <a name="%_idx_204"></a><a name="%_idx_206"></a><em>read-eval-print loop</em>.\nObserve in particular that it is not necessary to explicitly\ninstruct the interpreter to print the value of the expression.<a name="call_footnote_Temp_13" href="#footnote_Temp_13"><sup><small>7</small></sup></a><p>\n\n<a name="%_sec_1.1.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.2">1.1.2&nbsp;&nbsp;Naming and the Environment</a></h3><p>\n\nA critical aspect of a programming language is the means it provides\nfor using <a name="%_idx_216"></a>names to refer to computational objects.  We say that the\n<a name="%_idx_218"></a>name identifies a <a name="%_idx_220"></a><em>variable</em> whose <a name="%_idx_222"></a><em>value</em> is the object.<p>\n\nIn the Scheme dialect of Lisp, we\nname things with <a name="%_idx_224"></a><a name="%_idx_226"></a><tt>define</tt>.  Typing<p>\n\n<p><p><tt>(define&nbsp;size&nbsp;2)<br>\n</tt><p><p>\ncauses the interpreter to associate the value 2 with the\nname <tt>size</tt>.<a name="call_footnote_Temp_14" href="#footnote_Temp_14"><sup><small>8</small></sup></a>\nOnce the name <tt>size</tt> has been associated with the number 2, we can \nrefer to the value 2 by name:<p>\n\n<p><p><tt>size<br>\n<i>2</i><br>\n(*&nbsp;5&nbsp;size)<br>\n<i>10</i><br>\n</tt><p><p><p>\n\nHere are further examples of the use of <tt>define</tt>:<p>\n\n<p><p><tt>(define&nbsp;pi&nbsp;3.14159)<br>\n(define&nbsp;radius&nbsp;10)<br>\n(*&nbsp;pi&nbsp;(*&nbsp;radius&nbsp;radius))<br>\n<i>314.159</i><br>\n(define&nbsp;circumference&nbsp;(*&nbsp;2&nbsp;pi&nbsp;radius))<br>\ncircumference<br>\n<i>62.8318</i><br>\n</tt><p><p><p>\n\n<a name="%_idx_232"></a><tt>Define</tt> is our language\'s\nsimplest means of abstraction, for it allows us to use simple names to\nrefer to the results of compound operations, such as the\n<tt>circumference</tt> computed above.\nIn general, computational objects may have very complex\nstructures, and it would be extremely inconvenient to have to remember\nand repeat their details each time we want to use them.  Indeed,\ncomplex programs are constructed by building, step by step,\ncomputational objects of increasing complexity. The\ninterpreter makes this step-by-step program construction particularly\nconvenient because name-object associations can be created\nincrementally in successive interactions.  This feature encourages the\n<a name="%_idx_234"></a><a name="%_idx_236"></a>incremental development and testing of programs and is largely\nresponsible for the fact that <a name="%_idx_238"></a>a Lisp program usually consists of a large\nnumber of relatively simple procedures.<p>\n\nIt should be clear that the possibility of associating values with\nsymbols and later retrieving them means that the interpreter must\nmaintain some sort of memory that keeps track of the name-object\npairs.  This memory is called the <a name="%_idx_240"></a><em>environment</em> (more precisely\nthe <a name="%_idx_242"></a><em>global environment</em>, since we will see later that a\ncomputation may involve a number of different\nenvironments).<a name="call_footnote_Temp_15" href="#footnote_Temp_15"><sup><small>9</small></sup></a><p>\n\n<a name="%_sec_1.1.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.3">1.1.3&nbsp;&nbsp;Evaluating Combinations</a></h3><p>\n\n\n<a name="%_idx_244"></a><a name="%_idx_246"></a>\nOne of our goals in this chapter is to isolate issues about thinking\nprocedurally.  As a case in point, let us consider that, in evaluating\ncombinations, the interpreter is itself following a procedure.<p>\n\n<p><ul>\n<li>To evaluate a combination, do the following:\n</ul><p><p>\n\n<blockquote>\n<p>1.&nbsp;&nbsp;Evaluate the subexpressions of the combination.<p>\n\n<p>2.&nbsp;&nbsp;Apply the procedure that is the value of the leftmost \nsubexpression (the operator) to the arguments that are the values of\nthe other subexpressions (the operands).\n</blockquote><p>\n\nEven this simple rule illustrates some important points about\nprocesses in general.  First, observe that the first step dictates\nthat in order to accomplish the evaluation process for a combination\nwe must first perform the evaluation process on each element of the\ncombination.  Thus, the evaluation rule is <a name="%_idx_248"></a><em>recursive</em> in nature;\nthat is, it includes, as one of its steps, the need to invoke the rule\nitself.<a name="call_footnote_Temp_16" href="#footnote_Temp_16"><sup><small>10</small></sup></a><p>\n\n<a name="%_idx_250"></a>Notice how succinctly the idea of recursion can be used to express\nwhat, in the case of a deeply nested combination, would otherwise be\nviewed as a rather complicated process.  For example, evaluating<p>\n\n<p><p><tt>(*&nbsp;(+&nbsp;2&nbsp;(*&nbsp;4&nbsp;6))<br>\n&nbsp;&nbsp;&nbsp;(+&nbsp;3&nbsp;5&nbsp;7))<br>\n</tt><p><p>\nrequires that the evaluation rule be applied to four different\ncombinations.  We can obtain a picture of this process by <a name="%_idx_252"></a>representing\nthe combination in the form of a <a name="%_idx_254"></a>tree, as shown in\nfigure&nbsp;<a href="#%_fig_1.1">1.1</a>.  Each combination is represented by a\n<a name="%_idx_256"></a>node with <a name="%_idx_258"></a>branches corresponding to the operator and the\noperands of the combination stemming from it.\nThe <a name="%_idx_260"></a>terminal nodes (that is, nodes with\nno branches stemming from them) represent either operators or numbers.\nViewing evaluation in terms of the tree, we can imagine that the\nvalues of the operands percolate upward, starting from the terminal\nnodes and then combining at higher and higher levels.  In general, we\nshall see that recursion is a very powerful technique for dealing with\nhierarchical, treelike objects.  In fact, the ``percolate values\nupward\'\' form of the evaluation rule is an example of a general kind\nof process known as <a name="%_idx_262"></a><em>tree accumulation</em>.<p>\n\n<a name="%_fig_1.1"></a><p><div align=left><table width=100%><tr><td><img src="ch1-Z-G-1.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 1.1:</b>&nbsp;&nbsp;Tree representation, showing the value of each subcombination.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nNext, observe that the repeated application of the first step brings\nus to the point where we need to evaluate, not combinations, but\nprimitive expressions such as numerals, built-in operators, or other\nnames.  We take care of the primitive cases by stipulating that<p>\n\n<a name="%_idx_264"></a><a name="%_idx_266"></a><p><ul>\n<li>the values of numerals are the numbers that they name,<p>\n\n<li>the values of built-in operators are the machine\ninstruction sequences that carry out the corresponding operations, and<p>\n\n<li>the values of other names are the objects associated \nwith those names in the environment.\n</ul><p><p>\n\nWe may regard the second rule as a special case of the third one by\nstipulating that symbols such as <tt>+</tt> and <tt>*</tt> are also included\nin the global environment, and are associated with the sequences of\nmachine instructions that are their ``values.\'\'  The key point to\nnotice is the role of the <a name="%_idx_268"></a>environment in determining the meaning of\nthe symbols in expressions.  In an interactive language such as\nLisp, it is meaningless to speak of the value of an expression such as\n<tt>(+ x 1)</tt> without specifying any information about the environment\nthat would provide a meaning for the symbol&nbsp;<tt>x</tt> (or even for the\nsymbol <tt>+</tt>).  As we shall see in chapter&nbsp;3, the general notion of\nthe environment as providing a context in which evaluation takes place\nwill play an important role in our understanding of program execution.<p>\n\n<a name="%_idx_270"></a>Notice that the\nevaluation rule given above does not handle definitions.\nFor instance, evaluating\n<tt>(define x 3)</tt> does not apply <tt>define</tt> to two arguments, one\nof which is the value of the symbol <tt>x</tt> and the other of which is\n3, since the purpose of the <tt>define</tt> is precisely to associate\n<tt>x</tt> with a value.\n(That is, <tt>(define x 3)</tt> is not a combination.)<p>\n\n<a name="%_idx_272"></a>Such exceptions to the general evaluation rule are called <em>special\nforms</em>.  <tt>Define</tt> is the only example of a special form that we\nhave seen so far, but we will meet others shortly.  <a name="%_idx_274"></a>Each special form\nhas its own evaluation rule. The various kinds of expressions (each\nwith its associated evaluation rule) constitute the <a name="%_idx_276"></a>syntax of the\nprogramming language.  In comparison with most other programming\nlanguages, Lisp has a very simple syntax; that is, the evaluation rule\nfor expressions can be described by a simple general rule together\nwith specialized rules for a small number of special\nforms.<a name="call_footnote_Temp_17" href="#footnote_Temp_17"><sup><small>11</small></sup></a><p>\n\n<a name="%_sec_1.1.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.4">1.1.4&nbsp;&nbsp;Compound Procedures</a></h3><p>\n\n<p>\n\nWe have identified in Lisp some of the elements that must appear in\nany powerful programming language:<p>\n\n\n<p><ul>\n<li>Numbers and arithmetic operations are \nprimitive data and procedures.<p>\n\n<li>Nesting of combinations provides a means of \ncombining operations.<p>\n\n<li>Definitions that associate names with values provide a\nlimited means of abstraction.\n</ul><p><p>\n\nNow we will learn about\n<a name="%_idx_292"></a><em>procedure definitions</em>, a much more powerful abstraction\ntechnique by which a compound operation can be given a name and then\nreferred to as a unit.<p>\n\nWe begin by examining how to express the idea of ``squaring.\'\'  We\nmight say, ``To square something, multiply it by itself.\'\'  This is\nexpressed in our language as <p>\n\n<p><p><tt><a name="%_idx_294"></a>(define&nbsp;(square&nbsp;x)&nbsp;(*&nbsp;x&nbsp;x))<br>\n</tt><p><p><p>\n\nWe can understand this in the following way:<p>\n\n\n\n<p><p><tt>(define&nbsp;(square&nbsp;&nbsp;x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0"><br>\n&nbsp;To&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;square&nbsp;something,&nbsp;multiply&nbsp;&nbsp;&nbsp;it&nbsp;by&nbsp;itself.<br>\n</tt><p><p>\n<a name="%_idx_296"></a><a name="%_idx_298"></a>We have here a <em>compound procedure</em>, which has been given the name\n<tt>square</tt>.  The procedure represents the operation of multiplying\nsomething by itself.  The thing to be multiplied is given a local\nname, <tt>x</tt>, which plays the same role that a pronoun plays in\nnatural language.  <a name="%_idx_300"></a><a name="%_idx_302"></a><a name="%_idx_304"></a>Evaluating the definition creates this\ncompound procedure and associates it with the name <tt>square</tt>.<a name="call_footnote_Temp_18" href="#footnote_Temp_18"><sup><small>12</small></sup></a><p>\n\n<a name="%_idx_306"></a><a name="%_idx_308"></a>The general form of a procedure definition is<p>\n\n<p><p><tt>(define&nbsp;(&lt;<em>name</em>&gt;&nbsp;&lt;<em>formal&nbsp;parameters</em>&gt;)&nbsp;&lt;<em>body</em>&gt;)<br>\n</tt><p><p>\n<a name="%_idx_310"></a><a name="%_idx_312"></a>The &lt;<em>name</em>&gt; is a symbol to be associated with the procedure\ndefinition in the environment.<a name="call_footnote_Temp_19" href="#footnote_Temp_19"><sup><small>13</small></sup></a>\nThe <a name="%_idx_318"></a><a name="%_idx_320"></a>&lt;<em>formal parameters</em>&gt; are\nthe names used within the body of the procedure to refer to the\ncorresponding arguments of the procedure.  The\n<a name="%_idx_322"></a><a name="%_idx_324"></a>&lt;<em>body</em>&gt; is an expression that will yield the value of\nthe procedure application when the formal parameters are replaced by\nthe actual arguments to which the procedure is applied.<a name="call_footnote_Temp_20" href="#footnote_Temp_20"><sup><small>14</small></sup></a>\nThe &lt;<em>name</em>&gt;\nand the &lt;<em>formal parameters</em>&gt;\nare grouped within <a name="%_idx_328"></a>parentheses, just as they\nwould be in an actual call to the procedure being defined.<p>\n\nHaving defined <tt>square</tt>, we can now use it:<p>\n\n<p><p><tt>(square&nbsp;21)<br>\n<i>441</i><br>\n<br>\n(square&nbsp;(+&nbsp;2&nbsp;5))<br>\n<i>49</i><br>\n<br>\n(square&nbsp;(square&nbsp;3))<br>\n<i>81</i><br>\n</tt><p><p><p>\n\nWe can also use <tt>square</tt> as a building block in defining other\nprocedures.  For example, <em>x</em><sup>2</sup>  + <em>y</em><sup>2</sup> can be expressed as<p>\n\n<p><p><tt>(+&nbsp;(square&nbsp;x)&nbsp;(square&nbsp;y))<br>\n</tt><p><p>\nWe can easily define a procedure\n<tt>sum-of-squares</tt> that, given any two numbers as arguments, produces the\nsum of their squares:<p>\n\n<p><p><tt><a name="%_idx_330"></a>(define&nbsp;(sum-of-squares&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(+&nbsp;(square&nbsp;x)&nbsp;(square&nbsp;y)))<br>\n<br>\n(sum-of-squares&nbsp;3&nbsp;4)<br>\n<i>25</i><br>\n</tt><p><p>\nNow we can use <tt>sum-of-squares</tt> as a building block in constructing\nfurther procedures:<p>\n\n<p><p><tt>(define&nbsp;(f&nbsp;a)<br>\n&nbsp;&nbsp;(sum-of-squares&nbsp;(+&nbsp;a&nbsp;1)&nbsp;(*&nbsp;a&nbsp;2)))<br>\n<br>\n(f&nbsp;5)<br>\n<i>136</i><br>\n</tt><p><p>\n<a name="%_idx_332"></a>Compound procedures are used in exactly the same way as primitive\nprocedures.  Indeed, one could not tell by looking at the definition\nof <tt>sum-of-squares</tt> given above whether <tt>square</tt> was built into\nthe interpreter, like <tt>+</tt> and <tt>*</tt>, or defined as a compound procedure.<p>\n\n<a name="%_sec_1.1.5"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.5">1.1.5&nbsp;&nbsp;The Substitution Model for Procedure Application</a></h3><p>\n\n\n<a name="%_idx_334"></a>\nTo evaluate a combination whose operator names a compound procedure, the\ninterpreter follows much the same process as for combinations whose\noperators name primitive procedures, which we described in\nsection&nbsp;<a href="#%_sec_1.1.3">1.1.3</a>.  That is, the interpreter\nevaluates the elements of the combination and applies the procedure\n(which is the value of the operator of the combination) to the\narguments (which are the values of the operands of the combination).<p>\n\nWe can assume that the mechanism for applying primitive procedures to\narguments is built into the interpreter.  For compound procedures, the\napplication process is as follows:<p>\n\n<p><ul>\n<li>To apply a compound procedure to arguments, evaluate the body of the\nprocedure with each formal parameter replaced by the corresponding\nargument.\n</ul><p><p>\n\nTo illustrate this process, let\'s evaluate the combination<p>\n\n<p><p><tt>(f&nbsp;5)<br>\n</tt><p><p>\nwhere <tt>f</tt> is the procedure defined in\nsection&nbsp;<a href="#%_sec_1.1.4">1.1.4</a>.  We begin by retrieving the\nbody of <tt>f</tt>:<p>\n\n<p><p><tt>(sum-of-squares&nbsp;(+&nbsp;a&nbsp;1)&nbsp;(*&nbsp;a&nbsp;2))<br>\n</tt><p><p>\nThen we replace the formal parameter <tt>a</tt> by the argument 5:<p>\n\n<p><p><tt>(sum-of-squares&nbsp;(+&nbsp;5&nbsp;1)&nbsp;(*&nbsp;5&nbsp;2))<br>\n</tt><p><p>\nThus the problem reduces to the evaluation of a combination with two\noperands and an operator <tt>sum-of-squares</tt>.  Evaluating this\ncombination involves three subproblems.  We must evaluate the\noperator to get the procedure to be applied, and we must evaluate the\noperands to get the arguments.  Now <tt>(+ 5 1)</tt> produces 6 and\n<tt>(* 5 2)</tt> produces 10, so we must apply the\n<tt>sum-of-squares</tt> procedure to 6 and 10.  These values are substituted\nfor the formal parameters <tt>x</tt> and <tt>y</tt> in the body of <tt>sum-of-squares</tt>,\nreducing the expression to<p>\n\n<p><p><tt>(+&nbsp;(square&nbsp;6)&nbsp;(square&nbsp;10))<br>\n</tt><p><p>\nIf we use the definition of <tt>square</tt>, this reduces to<p>\n\n<p><p><tt>(+&nbsp;(*&nbsp;6&nbsp;6)&nbsp;(*&nbsp;10&nbsp;10))<br>\n</tt><p><p>\nwhich reduces by multiplication to<p>\n\n<p><p><tt>(+&nbsp;36&nbsp;100)<br>\n</tt><p><p>\nand finally to<p>\n\n<p><p><tt>136<br>\n</tt><p><p>\n<p>\n\nThe process we have just described is called the <em>substitution\nmodel</em> for procedure application.  It can be taken as a model that\ndetermines the ``meaning\'\' of procedure application, insofar as the\nprocedures in this chapter are concerned.  However, there are two\npoints that should be stressed:<p>\n\n<p><ul>\n<li>The purpose of the substitution is to help us think about\nprocedure application, not to provide a description of how\nthe interpreter really works.  Typical interpreters do not evaluate\nprocedure applications by manipulating the text of a procedure to\nsubstitute values for the formal parameters.  In practice, the\n``substitution\'\' is accomplished by using a local environment for the\nformal parameters.  We will discuss this more fully in chapters 3 and\n4 when we examine the implementation of an interpreter in detail.<p>\n\n<li>Over the course of this book, we will present a sequence of\nincreasingly elaborate models of how interpreters work, culminating\nwith a complete implementation of an interpreter and compiler in\nchapter&nbsp;5.  The substitution model is only the first of these\nmodels -- a way to get started thinking formally about the evaluation\nprocess.  In general, when <a name="%_idx_336"></a>modeling phenomena in science and\nengineering, we begin with simplified, incomplete models.  As we\nexamine things in greater detail, these simple models become\ninadequate and must be replaced by more refined models.  The\nsubstitution model is no exception.  In particular, when we address in\nchapter&nbsp;3 the use of procedures with ``mutable data,\'\' we will see that\nthe substitution model breaks down and must be replaced by a more\ncomplicated model of procedure application.<a name="call_footnote_Temp_21" href="#footnote_Temp_21"><sup><small>15</small></sup></a>\n</ul><p><p>\n\n<a name="%_sec_Temp_22"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_22">Applicative order versus normal order</a></h4><p>\n\nAccording to the description of evaluation given in\nsection&nbsp;<a href="#%_sec_1.1.3">1.1.3</a>, the interpreter first\nevaluates the operator and operands and then applies the resulting procedure\nto the resulting arguments.  This is not the only way to perform\nevaluation.  An alternative evaluation model would not evaluate the\noperands until their values were needed.  Instead it would first substitute\noperand expressions for parameters until\nit obtained an expression involving only primitive operators, and\nwould then perform the evaluation.  If we used this method, the\nevaluation of<p>\n\n<p><p><tt>(f&nbsp;5)<br>\n</tt><p><p>\nwould proceed according to the sequence of expansions<p>\n\n<p><p><tt>(sum-of-squares&nbsp;(+&nbsp;5&nbsp;1)&nbsp;(*&nbsp;5&nbsp;2))<br>\n<br>\n(+&nbsp;&nbsp;&nbsp;&nbsp;(square&nbsp;(+&nbsp;5&nbsp;1))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(square&nbsp;(*&nbsp;5&nbsp;2))&nbsp;&nbsp;)<br>\n<br>\n(+&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(+&nbsp;5&nbsp;1)&nbsp;(+&nbsp;5&nbsp;1))&nbsp;&nbsp;&nbsp;(*&nbsp;(*&nbsp;5&nbsp;2)&nbsp;(*&nbsp;5&nbsp;2)))<br>\n</tt><p><p>\nfollowed by the reductions<p>\n\n<p><p><tt>(+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;6&nbsp;6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;10&nbsp;10))<br>\n<br>\n(+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100)<br>\n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;136<br>\n</tt><p><p>\nThis gives the same answer as our previous evaluation model, but the\nprocess is different.  In particular, the evaluations\nof <tt>(+ 5 1)</tt> and <tt>(*&nbsp;5&nbsp;2)</tt> are each performed twice here,\ncorresponding to the reduction of the expression<p>\n\n<p><p><tt>(*&nbsp;x&nbsp;x)<br>\n</tt><p><p>\nwith <tt>x</tt> replaced respectively by <tt>(+ 5 1)</tt> and <tt>(* 5 2)</tt>.<p>\n\nThis alternative ``fully expand and then reduce\'\' evaluation method is\nknown as <a name="%_idx_340"></a><em>normal-order evaluation</em>, in contrast to the ``evaluate\nthe arguments and then apply\'\' method that the interpreter actually\nuses, which is called <a name="%_idx_342"></a><em>applicative-order evaluation</em>.  It can be\nshown that, for procedure applications that can be modeled using\nsubstitution (including all the procedures in the first two chapters\nof this book) and that yield legitimate values, normal-order and\napplicative-order evaluation produce the same value.  (See\nexercise&nbsp;<a href="#%_thm_1.5">1.5</a> for an instance of\nan ``illegitimate\'\' value where normal-order and applicative-order\nevaluation do not give the same result.)<p>\n\n<a name="%_idx_344"></a><a name="%_idx_346"></a>Lisp uses applicative-order evaluation, partly because of the\nadditional efficiency obtained from avoiding multiple evaluations of\nexpressions such as those illustrated with <tt>(+ 5 1)</tt> and <tt>(* 5\n2)</tt> above and, more significantly, because normal-order evaluation\nbecomes much more complicated to deal with when we leave the realm of\nprocedures that can be modeled by substitution.  On the other hand,\nnormal-order evaluation can be an extremely valuable tool, and we will\ninvestigate some of its implications in chapters 3 and 4.<a name="call_footnote_Temp_23" href="#footnote_Temp_23"><sup><small>16</small></sup></a><p>\n\n<a name="%_sec_1.1.6"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.6">1.1.6&nbsp;&nbsp;Conditional Expressions and Predicates</a></h3><p>\n\n<p>\n\nThe expressive power of the class of procedures that we can define at\nthis point is very limited, because we have no way to make tests and\nto perform different operations depending on the result of a test.\nFor instance, we cannot define a procedure that computes the <a name="%_idx_348"></a>absolute\nvalue of a number by testing whether the number is positive, negative,\nor zero and taking different actions in the different cases according\nto the rule<p>\n\n<p><div align=left><img src="ch1-Z-G-2.gif" border="0"></div><p><p>\n\n<a name="%_idx_350"></a>This construct is called a <em>case analysis</em>, and\nthere is a special form in Lisp for notating such a case\nanalysis.  It is called <a name="%_idx_352"></a><a name="%_idx_354"></a><a name="%_idx_356"></a><tt>cond</tt> (which stands for\n``conditional\'\'), and it is used as follows:<p>\n\n<p><p><tt><a name="%_idx_358"></a>(define&nbsp;(abs&nbsp;x)<br>\n&nbsp;&nbsp;(cond&nbsp;((&gt;&nbsp;x&nbsp;0)&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;x&nbsp;0)&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;x&nbsp;0)&nbsp;(-&nbsp;x))))<br>\n</tt><p><p>\nThe general form of a conditional expression is<p>\n\n<p><p><tt>(cond&nbsp;(&lt;<em>p<sub>1</sub></em>&gt;&nbsp;&lt;<em>e<sub>1</sub></em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;<em>p<sub>2</sub></em>&gt;&nbsp;&lt;<em>e<sub>2</sub></em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-18.gif" border="0"><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;<em>p<sub><em>n</em></sub></em>&gt;&nbsp;&lt;<em>e<sub><em>n</em></sub></em>&gt;))<br>\n</tt><p><p>\nconsisting of the symbol <tt>cond</tt> followed by\n<a name="%_idx_360"></a>parenthesized pairs of expressions <tt>(&lt;<em>p</em>&gt;&nbsp;&lt;<em>e</em>&gt;)</tt>\ncalled <a name="%_idx_362"></a><a name="%_idx_364"></a><em>clauses</em>. The first expression in each pair is a <a name="%_idx_366"></a><em>predicate</em> -- that is, an expression whose value is interpreted as\neither true or false.<a name="call_footnote_Temp_24" href="#footnote_Temp_24"><sup><small>17</small></sup></a><p>\n\n<a name="%_idx_384"></a><a name="%_idx_386"></a>Conditional expressions are evaluated as follows.  The predicate\n&lt;<em>p<sub>1</sub></em>&gt; is evaluated first.  If its value is false, then\n&lt;<em>p<sub>2</sub></em>&gt; is evaluated.  If &lt;<em>p<sub>2</sub></em>&gt;\'s value is also false, then\n&lt;<em>p<sub>3</sub></em>&gt; is evaluated.  This process continues until a predicate is\nfound whose value is true, in which case the interpreter returns the\nvalue of the corresponding <a name="%_idx_388"></a><em>consequent expression</em> &lt;<em>e</em>&gt; of the\nclause as the value of the conditional expression.  If none of the\n&lt;<em>p</em>&gt;\'s is found to be true, the value of the <tt>cond</tt> is\nundefined.<p>\n\n<a name="%_idx_390"></a>The word <em>predicate</em> is used for procedures that return true\nor false, as well as for expressions that evaluate to true or false.\nThe absolute-value procedure <tt>abs</tt> makes use of the <a name="%_idx_392"></a><a name="%_idx_394"></a><a name="%_idx_396"></a><a name="%_idx_398"></a><a name="%_idx_400"></a><a name="%_idx_402"></a><a name="%_idx_404"></a><a name="%_idx_406"></a><a name="%_idx_408"></a>primitive\npredicates <tt>&gt;</tt>, <tt>&lt;</tt>, and <tt>=</tt>.<a name="call_footnote_Temp_25" href="#footnote_Temp_25"><sup><small>18</small></sup></a> These take two\nnumbers as arguments and test whether the first number is,\nrespectively, greater than, less than, or equal to the second number,\nreturning true or false accordingly.<p>\n\nAnother way to write the absolute-value procedure is<p>\n\n<p><p><tt><a name="%_idx_414"></a>(define&nbsp;(abs&nbsp;x)<br>\n&nbsp;&nbsp;(cond&nbsp;((&lt;&nbsp;x&nbsp;0)&nbsp;(-&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;x)))<br>\n</tt><p><p>\nwhich could be expressed in English as ``If <em>x</em> is less than zero\nreturn  - <em>x</em>; otherwise return <em>x</em>.\'\'  <a name="%_idx_416"></a><tt>Else</tt> is a special symbol\nthat can be used in place of the &lt;<em>p</em>&gt; in the final clause of a <tt>cond</tt>.  This causes the <tt>cond</tt> to return as its value the value of\nthe corresponding &lt;<em>e</em>&gt; whenever all previous clauses have been\nbypassed.  In fact, any expression that always evaluates to a true\nvalue could be used as the &lt;<em>p</em>&gt; here.<p>\n\nHere is yet another way to write the absolute-value procedure:<p>\n\n<p><p><tt><a name="%_idx_418"></a>(define&nbsp;(abs&nbsp;x)<br>\n&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;x&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x))<br>\n</tt><p><p>\n<a name="%_idx_420"></a><a name="%_idx_422"></a><a name="%_idx_424"></a>This uses the special form <tt>if</tt>, a restricted type of conditional\nthat can be used when there are precisely <a name="%_idx_426"></a>two cases in the case\nanalysis.  The general form of an <tt>if</tt> expression is<p>\n\n<p><p><tt>(if&nbsp;&lt;<em>predicate</em>&gt;&nbsp;&lt;<em>consequent</em>&gt;&nbsp;&lt;<em>alternative</em>&gt;)<br>\n</tt><p><p>\n<a name="%_idx_428"></a><a name="%_idx_430"></a><a name="%_idx_432"></a>To evaluate an <tt>if</tt> expression, the interpreter starts by evaluating\nthe <a name="%_idx_434"></a>&lt;<em>predicate</em>&gt; part of the expression.  If the &lt;<em>predicate</em>&gt;\nevaluates to a true value, the interpreter then evaluates\nthe <a name="%_idx_436"></a>&lt;<em>consequent</em>&gt; and returns its value.  Otherwise it evaluates\nthe <a name="%_idx_438"></a>&lt;<em>alternative</em>&gt; and returns its value.<a name="call_footnote_Temp_26" href="#footnote_Temp_26"><sup><small>19</small></sup></a><p>\n\nIn addition to primitive\npredicates such as <tt>&lt;</tt>, <tt>=</tt>, and <tt>&gt;</tt>, there are logical\ncomposition operations, which enable us to construct compound\npredicates.  The three most frequently used are these:<p>\n\n<p><ul>\n<a name="%_idx_446"></a><a name="%_idx_448"></a><a name="%_idx_450"></a><a name="%_idx_452"></a><li><tt>(and &lt;<em>e<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>e<sub><em>n</em></sub></em>&gt;)</tt><p>\n\nThe interpreter\nevaluates the expressions &lt;<em>e</em>&gt; one at a time, in left-to-right order.  If\nany &lt;<em>e</em>&gt; evaluates to false, the value of the <tt>and</tt>\nexpression is false, and the rest of the &lt;<em>e</em>&gt;\'s are not evaluated.\nIf all &lt;<em>e</em>&gt;\'s evaluate to true values, the value of the <tt>and</tt>\nexpression is the value of the last one.<p>\n\n<a name="%_idx_454"></a><a name="%_idx_456"></a><a name="%_idx_458"></a><a name="%_idx_460"></a><li><tt>(or &lt;<em>e<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>e<sub><em>n</em></sub></em>&gt;)</tt><p>\n\nThe interpreter\nevaluates the expressions &lt;<em>e</em>&gt; one at a time, in left-to-right order.  If\nany &lt;<em>e</em>&gt; evaluates to a true value, that value is\nreturned as the value of the <tt>or</tt> expression,\nand the rest of the &lt;<em>e</em>&gt;\'s are not evaluated.\nIf all &lt;<em>e</em>&gt;\'s evaluate to false,\nthe value of the <tt>or</tt> expression is false.<p>\n\n<a name="%_idx_462"></a><a name="%_idx_464"></a><li><tt>(not &lt;<em>e</em>&gt;)</tt><p>\n\nThe value of a <tt>not</tt> expression is true\nwhen the expression &lt;<em>e</em>&gt; evaluates to false, and false otherwise.\n</ul><p><p>\n\n<a name="%_idx_466"></a><a name="%_idx_468"></a>Notice that <tt>and</tt> and <tt>or</tt> are special forms, not procedures,\nbecause the subexpressions are not necessarily all evaluated.\n<tt>Not</tt> is an ordinary procedure.<p>\n\nAs an example of how these are used, the condition that a number <em>x</em>\nbe in the range 5 &lt; <em>x</em> &lt; 10 may be expressed as<p>\n\n<p><p><tt>(and&nbsp;(&gt;&nbsp;x&nbsp;5)&nbsp;(&lt;&nbsp;x&nbsp;10))<br>\n</tt><p><p>\nAs another example, we can define a predicate to test whether one\nnumber is greater than or equal to another as<p>\n\n<p><p><tt><a name="%_idx_470"></a>(define&nbsp;(&gt;=&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(or&nbsp;(&gt;&nbsp;x&nbsp;y)&nbsp;(=&nbsp;x&nbsp;y)))<br>\n</tt><p><p>\nor alternatively as<p>\n\n<p><p><tt><a name="%_idx_472"></a>(define&nbsp;(&gt;=&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(not&nbsp;(&lt;&nbsp;x&nbsp;y)))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_1.1"></a>\n<b>Exercise 1.1.</b>&nbsp;&nbsp;Below is a sequence of expressions.  \nWhat is the result printed by the interpreter in response to each\nexpression?  Assume that the sequence is to be evaluated in the order\nin which it is presented.<p>\n\n<p><p><tt>10<br>\n(+&nbsp;5&nbsp;3&nbsp;4)<br>\n(-&nbsp;9&nbsp;1)<br>\n(/&nbsp;6&nbsp;2)<br>\n(+&nbsp;(*&nbsp;2&nbsp;4)&nbsp;(-&nbsp;4&nbsp;6))<br>\n(define&nbsp;a&nbsp;3)<br>\n(define&nbsp;b&nbsp;(+&nbsp;a&nbsp;1))<br>\n(+&nbsp;a&nbsp;b&nbsp;(*&nbsp;a&nbsp;b))<br>\n(=&nbsp;a&nbsp;b)<br>\n(if&nbsp;(and&nbsp;(&gt;&nbsp;b&nbsp;a)&nbsp;(&lt;&nbsp;b&nbsp;(*&nbsp;a&nbsp;b)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;b<br>\n&nbsp;&nbsp;&nbsp;&nbsp;a)<br>\n(cond&nbsp;((=&nbsp;a&nbsp;4)&nbsp;6)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;b&nbsp;4)&nbsp;(+&nbsp;6&nbsp;7&nbsp;a))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;25))<br>\n(+&nbsp;2&nbsp;(if&nbsp;(&gt;&nbsp;b&nbsp;a)&nbsp;b&nbsp;a))<br>\n(*&nbsp;(cond&nbsp;((&gt;&nbsp;a&nbsp;b)&nbsp;a)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;a&nbsp;b)&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;-1))<br>\n&nbsp;&nbsp;&nbsp;(+&nbsp;a&nbsp;1))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_1.2"></a>\n<b>Exercise 1.2.</b>&nbsp;&nbsp;Translate the following expression into prefix form\n<p><div align=left><img src="ch1-Z-G-3.gif" border="0"></div><p>\n<p><p>\n\n<p><a name="%_thm_1.3"></a>\n<b>Exercise 1.3.</b>&nbsp;&nbsp;Define a procedure that takes three numbers as arguments and returns\nthe sum of the squares of the two larger numbers.\n<p><p>\n\n<p><a name="%_thm_1.4"></a>\n<b>Exercise 1.4.</b>&nbsp;&nbsp;<a name="%_idx_474"></a><a name="%_idx_476"></a><a name="%_idx_478"></a>Observe that our model of evaluation allows for combinations whose\noperators are compound expressions.  Use this observation to\ndescribe the behavior of the following procedure:\n<p><p><tt>(define&nbsp;(a-plus-abs-b&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;((if&nbsp;(&gt;&nbsp;b&nbsp;0)&nbsp;+&nbsp;-)&nbsp;a&nbsp;b))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_1.5"></a>\n<b>Exercise 1.5.</b>&nbsp;&nbsp;<a name="%_idx_480"></a><a name="%_idx_482"></a>Ben Bitdiddle has invented a test to determine whether the interpreter\nhe is faced with is using applicative-order evaluation or normal-order\nevaluation.  He defines the following two procedures:\n<p><p><tt>(define&nbsp;(p)&nbsp;(p))<br>\n<br>\n(define&nbsp;(test&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;x&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y))<br>\n</tt><p><p>\nThen he evaluates the expression\n<p><p><tt>(test&nbsp;0&nbsp;(p))<br>\n</tt><p><p>\nWhat behavior will Ben observe with an interpreter that uses\napplicative-order evaluation?  What behavior will he observe with an\ninterpreter that uses normal-order evaluation?  Explain your answer.\n<a name="%_idx_484"></a><a name="%_idx_486"></a>(Assume that the evaluation rule for the special form <tt>if</tt> is the\nsame whether the interpreter is using normal or applicative order:\nThe predicate expression is evaluated first, and the result\ndetermines whether to evaluate\nthe consequent or the alternative expression.)\n\n<p><p>\n\n\n<a name="%_sec_1.1.7"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.7">1.1.7&nbsp;&nbsp;Example: Square Roots by Newton\'s Method</a></h3><p>\n\n<p>\n\n<a name="%_idx_488"></a><a name="%_idx_490"></a>Procedures, as introduced above, are much like ordinary mathematical\nfunctions.  They specify a value that is determined by one or more\nparameters.  But there is an important difference between\nmathematical functions and computer procedures.  Procedures must be\neffective.<p>\n\nAs a case in point, consider the problem of computing square\nroots.  We can define the square-root function as\n<p><div align=left><img src="ch1-Z-G-4.gif" border="0"></div><p><p>\n\nThis describes a perfectly legitimate mathematical function.  We could\nuse it to recognize whether one number is the square root of another, or\nto derive facts about square roots in general.  On the other hand, the\ndefinition does not describe a procedure.  Indeed, it tells us almost\nnothing about how to actually find the square root of a given number.  It\nwill not help matters to rephrase this definition in pseudo-Lisp:<p>\n\n<p><p><tt>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(the&nbsp;y&nbsp;(and&nbsp;(&gt;=&nbsp;y&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(=&nbsp;(square&nbsp;y)&nbsp;x))))<br>\n</tt><p><p>\nThis only begs the question.<p>\n\nThe contrast between function and procedure is a reflection of the\ngeneral distinction between describing properties of things and\ndescribing how to do things, or, as it is sometimes referred to, the\ndistinction between <a name="%_idx_492"></a><a name="%_idx_494"></a>declarative knowledge and imperative knowledge.\nIn <a name="%_idx_496"></a><a name="%_idx_498"></a>mathematics we are usually concerned with declarative (what is)\ndescriptions, whereas in computer science we are usually concerned\nwith imperative (how to) descriptions.<a name="call_footnote_Temp_32" href="#footnote_Temp_32"><sup><small>20</small></sup></a><p>\n\n<a name="%_idx_508"></a><a name="%_idx_510"></a>How does one compute square roots?  The most common way is to use\nNewton\'s method of successive approximations, which says that whenever\nwe have a guess <em>y</em> for the value of the square root of a number <em>x</em>,\nwe can perform a simple manipulation to get a better guess (one closer\nto the actual square root) by averaging <em>y</em> with\n<em>x</em>/<em>y</em>.<a name="call_footnote_Temp_33" href="#footnote_Temp_33"><sup><small>21</small></sup></a> For example, we can compute\nthe square root of 2 as follows.  Suppose our initial guess is&nbsp;1:<p>\n\n<table border=0><tr><td valign=top >Guess </td><td valign=top >Quotient </td><td valign=top >Average</td></tr>\n<tr><td valign=top >&nbsp;&nbsp;</td></tr>\n<tr><td valign=top >1      </td><td valign=top > (2/1)  =  2        </td><td valign=top >\n((2 + 1)/2)  =  1.5 </td></tr>\n<tr><td valign=top >&nbsp;&nbsp;</td></tr>\n<tr><td valign=top >1.5    </td><td valign=top > (2/1.5)  =  1.3333 </td><td valign=top >\n((1.3333 + 1.5)/2)  =  1.4167 </td></tr>\n<tr><td valign=top >&nbsp;&nbsp;</td></tr>\n<tr><td valign=top >1.4167 </td><td valign=top > (2/1.4167)  =  1.4118 </td><td valign=top >\n((1.4167 + 1.4118)/2)  =  1.4142 </td></tr>\n<tr><td valign=top >&nbsp;&nbsp;</td></tr>\n<tr><td valign=top >1.4142 </td><td valign=top ><tt>...</tt></td><td valign=top ><tt>...</tt></td></tr>\n<tr><td valign=top ></td></tr></table><p>\n\nContinuing this process, we obtain better and better\napproximations to the square root.<p>\n\nNow let\'s formalize the process in terms of procedures.  We start with\na value for the <a name="%_idx_514"></a>radicand (the number whose square root we are trying\nto compute) and a value for the guess.  If the guess is good enough\nfor our purposes, we are done; if not, we must repeat the process with an\nimproved guess.  We write this basic strategy as a procedure:<p>\n\n<p><p><tt>(define&nbsp;(sqrt-iter&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;(if&nbsp;(good-enough?&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guess<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt-iter&nbsp;(improve&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)))<br>\n</tt><p><p>\nA guess is improved by averaging\nit with the quotient of the radicand and the old guess:<p>\n\n<p><p><tt>(define&nbsp;(improve&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;(average&nbsp;guess&nbsp;(/&nbsp;x&nbsp;guess)))<br>\n</tt><p><p>\nwhere<p>\n\n<p><p><tt><a name="%_idx_516"></a>(define&nbsp;(average&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(/&nbsp;(+&nbsp;x&nbsp;y)&nbsp;2))<br>\n</tt><p><p>\nWe also have to say what we mean by ``good enough.\'\'  The\nfollowing will do for illustration, but it is not really a very good\ntest.  (See exercise&nbsp;<a href="#%_thm_1.7">1.7</a>.)\nThe idea is to improve the answer until it is close enough so that its\nsquare differs from the radicand by less than a predetermined\ntolerance (here 0.001):<a name="call_footnote_Temp_34" href="#footnote_Temp_34"><sup><small>22</small></sup></a><p>\n\n<p><p><tt>(define&nbsp;(good-enough?&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;(&lt;&nbsp;(abs&nbsp;(-&nbsp;(square&nbsp;guess)&nbsp;x))&nbsp;0.001))<br>\n</tt><p><p>\nFinally, we need a way to get started.  For instance, we can\nalways guess that the square root of any number is 1:<a name="call_footnote_Temp_35" href="#footnote_Temp_35"><sup><small>23</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_550"></a>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(sqrt-iter&nbsp;1.0&nbsp;x))<br>\n</tt><p><p>\nIf we type these definitions to the interpreter, we can use <tt>sqrt</tt>\njust as we can use any procedure:<p>\n\n<p><p><tt>(sqrt&nbsp;9)<br>\n<i>3.00009155413138</i><br>\n(sqrt&nbsp;(+&nbsp;100&nbsp;37))<br>\n<i>11.704699917758145</i><br>\n(sqrt&nbsp;(+&nbsp;(sqrt&nbsp;2)&nbsp;(sqrt&nbsp;3)))<br>\n<i>1.7739279023207892</i><br>\n(square&nbsp;(sqrt&nbsp;1000))<br>\n<i>1000.000369924366</i><br>\n</tt><p><p>\n<p>\n\n<a name="%_idx_552"></a>The <tt>sqrt</tt> program also illustrates that the simple procedural\nlanguage we have introduced so far is sufficient for writing any\npurely numerical program that one could write in, say, C or\nPascal.  This might seem surprising, since we have not included in\nour language any iterative <a name="%_idx_554"></a>(looping) constructs that direct the\ncomputer to do something over and over again.  <tt>Sqrt-iter</tt>, on the\nother hand, demonstrates how iteration can be accomplished using no\nspecial construct other than the ordinary ability to call a\nprocedure.<a name="call_footnote_Temp_36" href="#footnote_Temp_36"><sup><small>24</small></sup></a>\n\n<p><a name="%_thm_1.6"></a>\n<b>Exercise 1.6.</b>&nbsp;&nbsp;<a name="%_idx_556"></a><a name="%_idx_558"></a>Alyssa P. Hacker doesn\'t see why <tt>if</tt> needs\nto be provided as a special form.  ``Why can\'t I just define it as an\nordinary procedure in terms of <tt>cond</tt>?\'\' she asks.\nAlyssa\'s friend Eva Lu Ator claims this can indeed be done, and\nshe defines a new version of <tt>if</tt>:<p>\n\n<p><p><tt>(define&nbsp;(new-if&nbsp;predicate&nbsp;then-clause&nbsp;else-clause)<br>\n&nbsp;&nbsp;(cond&nbsp;(predicate&nbsp;then-clause)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;else-clause)))<br>\n</tt><p><p>\nEva demonstrates the program for Alyssa:<p>\n\n<p><p><tt>(new-if&nbsp;(=&nbsp;2&nbsp;3)&nbsp;0&nbsp;5)<br>\n<i>5</i><br>\n<br>\n(new-if&nbsp;(=&nbsp;1&nbsp;1)&nbsp;0&nbsp;5)<br>\n<i>0</i><br>\n</tt><p><p>\nDelighted, Alyssa uses <tt>new-if</tt> to rewrite the square-root\nprogram:<p>\n\n<p><p><tt>(define&nbsp;(sqrt-iter&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;(new-if&nbsp;(good-enough?&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guess<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt-iter&nbsp;(improve&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)))<br>\n</tt><p><p>\nWhat happens when Alyssa attempts to use this to compute square roots?\nExplain.\n\n<p><p>\n\n<p><a name="%_thm_1.7"></a>\n<b>Exercise 1.7.</b>&nbsp;&nbsp;The <tt>good-enough?</tt> test used in computing square roots will not be\nvery effective for finding the square roots of very small numbers.\nAlso, in real computers, arithmetic operations are almost always\nperformed with limited precision.  This makes our test inadequate for\nvery large numbers.  Explain these statements, with examples showing\nhow the test fails for small and large numbers.  An alternative\nstrategy for implementing <tt>good-enough?</tt> is to watch how <tt>guess</tt> changes from one iteration to the next and to stop when the\nchange is a very small fraction of the guess.  Design a square-root\nprocedure that uses this kind of end test.  Does this work better for\nsmall and large numbers?\n<p><p>\n\n<p><a name="%_thm_1.8"></a>\n<b>Exercise 1.8.</b>&nbsp;&nbsp;<a name="%_idx_560"></a><a name="%_idx_562"></a>Newton\'s method for cube roots is based on the fact that if <em>y</em> is an\napproximation to the cube root of <em>x</em>, then a better approximation is\ngiven by the value\n<p><div align=left><img src="ch1-Z-G-5.gif" border="0"></div><p>\nUse this formula to implement a cube-root procedure analogous to the\nsquare-root procedure.  (In section&nbsp;<a href="book-Z-H-12.html#%_sec_1.3.4">1.3.4</a> we\nwill see how to implement Newton\'s method in general as an abstraction\nof these square-root and cube-root procedures.)\n<p><p>\n\n<a name="%_sec_1.1.8"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.8">1.1.8&nbsp;&nbsp;Procedures as Black-Box Abstractions</a></h3><p>\n\n<p>\n\n<tt>Sqrt</tt> is our first example of a process defined by a set of\nmutually defined procedures.  Notice that the definition of <tt>sqrt-iter</tt> is <a name="%_idx_564"></a><em>recursive</em>; that is, the procedure is defined in\nterms of itself.  The idea of being able to define a procedure in\nterms of itself may be disturbing; it may seem unclear how such a\n``circular\'\' definition could make sense at all, much less specify a\nwell-defined process to be carried out by a computer.  This will be\naddressed more carefully in\nsection&nbsp;<a href="book-Z-H-11.html#%_sec_1.2">1.2</a>.  But first let\'s consider\nsome other important points illustrated by the <tt>sqrt</tt> example.<p>\n\n<a name="%_idx_566"></a>Observe that the problem of computing square roots breaks up naturally\ninto a number of subproblems: how to tell whether a guess is good\nenough, how to improve a guess, and so on.  Each of these tasks is\naccomplished by a separate procedure.  The entire <tt>sqrt</tt> program\ncan be viewed as a cluster of procedures (shown in\nfigure&nbsp;<a href="#%_fig_1.2">1.2</a>) that mirrors the decomposition of\nthe problem into subproblems.<p>\n\n<a name="%_fig_1.2"></a><p><div align=left><table width=100%><tr><td><img src="ch1-Z-G-6.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 1.2:</b>&nbsp;&nbsp;Procedural decomposition of the <tt>sqrt</tt> program.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_idx_568"></a>The importance of this decomposition strategy is not simply that one\nis dividing the program into parts.  After all, we could take any\nlarge program and divide it into parts -- the first ten lines, the next\nten lines, the next ten lines, and so on.  Rather, it is crucial that\neach procedure accomplishes an identifiable task that can be used as a\nmodule in defining other procedures.  <a name="%_idx_570"></a>For example, when we define the\n<tt>good-enough?</tt> procedure in terms of <tt>square</tt>, we are able to\nregard the <tt>square</tt> procedure as a <a name="%_idx_572"></a>``black box.\'\'  We are not at\nthat moment concerned with <em>how</em> the procedure computes its\nresult, only with the fact that it computes the square.  The details\nof how the square is computed can be suppressed, to be considered at a\nlater time.  Indeed, as far as the <tt>good-enough?</tt> procedure is\nconcerned, <tt>square</tt> is not quite a procedure but rather an\nabstraction of a procedure, a so-called <a name="%_idx_574"></a><a name="%_idx_576"></a><em>procedural abstraction</em>.\nAt this level of abstraction, any procedure that computes the square\nis equally good.<p>\n\nThus, considering only the values they return, the following two procedures for\nsquaring a number should be indistinguishable.  Each takes a numerical\nargument and produces the square of that number as the\nvalue.<a name="call_footnote_Temp_40" href="#footnote_Temp_40"><sup><small>25</small></sup></a><p>\n\n<p><p><tt>(define&nbsp;(square&nbsp;x)&nbsp;(*&nbsp;x&nbsp;x))<br>\n<br>\n(define&nbsp;(square&nbsp;x)&nbsp;<br>\n&nbsp;&nbsp;(exp&nbsp;(double&nbsp;(log&nbsp;x))))<br>\n<br>\n(define&nbsp;(double&nbsp;x)&nbsp;(+&nbsp;x&nbsp;x))<br>\n</tt><p><p><p>\n\nSo a procedure definition should be able to suppress detail.  The\nusers of the procedure may not have written the procedure themselves,\nbut may have obtained it from another programmer as a black box.  A\nuser should not need to know how the procedure is implemented in order\nto use it.<p>\n\n<a name="%_sec_Temp_41"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_41">Local names</a></h4><p>\n\n<a name="%_idx_578"></a>\nOne detail of a procedure\'s implementation that should not matter to\nthe user of the procedure is the implementer\'s choice of names for the\nprocedure\'s formal parameters.  Thus, the following procedures should\nnot be distinguishable:<p>\n\n<p><p><tt>(define&nbsp;(square&nbsp;x)&nbsp;(*&nbsp;x&nbsp;x))<br>\n<br>\n(define&nbsp;(square&nbsp;y)&nbsp;(*&nbsp;y&nbsp;y))<br>\n</tt><p><p>\nThis principle -- that the meaning of a procedure should be independent\nof the parameter names used by its author -- seems on the surface to be\nself-evident, but its consequences are profound.  The simplest\nconsequence is that the parameter names of a procedure must be local\nto the body of the procedure.  For example, we used <tt>square</tt> in\nthe definition of <tt>good-enough?</tt> in our square-root procedure:<p>\n\n<p><p><tt>(define&nbsp;(good-enough?&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;(&lt;&nbsp;(abs&nbsp;(-&nbsp;(square&nbsp;guess)&nbsp;x))&nbsp;0.001))<br>\n</tt><p><p>\nThe intention of the author of <tt>good-enough?</tt> is to determine if\nthe square of the first argument is within a given tolerance of the\nsecond argument.  We see that the author of <tt>good-enough?</tt> used\nthe name <tt>guess</tt> to refer to the first argument and <tt>x</tt> to\nrefer to the second argument.  The argument of <tt>square</tt> is <tt>guess</tt>.  If the author of <tt>square</tt> used <tt>x</tt> (as above)\nto refer to that argument, we see that the <tt>x</tt> in <tt>good-enough?</tt> must be a different <tt>x</tt> than the one in <tt>square</tt>.  Running the procedure <tt>square</tt> must not affect the value\nof <tt>x</tt> that is used by <tt>good-enough?</tt>, because that value of\n<tt>x</tt> may be needed by <tt>good-enough?</tt> after <tt>square</tt> is done\ncomputing.<p>\n\nIf the parameters were not local to the bodies of their respective\nprocedures, then the parameter <tt>x</tt> in <tt>square</tt> could be\nconfused with the parameter <tt>x</tt> in <tt>good-enough?</tt>, and the\nbehavior of <tt>good-enough?</tt> would depend upon which version of\n<tt>square</tt> we used.  Thus, <tt>square</tt> would not be the black box\nwe desired.<p>\n\n<a name="%_idx_580"></a><a name="%_idx_582"></a>A formal parameter of a procedure has a very special role in the\nprocedure definition, in that it doesn\'t matter what name the formal\nparameter has.  Such a name is called a <a name="%_idx_584"></a><a name="%_idx_586"></a><em>bound variable</em>, and we\nsay that the procedure definition <a name="%_idx_588"></a><em>binds</em> its formal parameters.\nThe meaning of a procedure definition is unchanged if a bound variable\nis consistently renamed throughout the definition.<a name="call_footnote_Temp_42" href="#footnote_Temp_42"><sup><small>26</small></sup></a>  If a variable is not bound, we say that it is <a name="%_idx_590"></a><a name="%_idx_592"></a><em>free</em>.  The\nset of expressions for which a binding defines a name is called the\n<a name="%_idx_594"></a><a name="%_idx_596"></a><em>scope</em> of that name.\nIn a procedure definition, the bound variables\ndeclared as the <a name="%_idx_598"></a><a name="%_idx_600"></a><a name="%_idx_602"></a>formal parameters of the procedure have the body of\nthe procedure as their scope.<p>\n\nIn the definition of <tt>good-enough?</tt> above, <tt>guess</tt> and <tt>x</tt> are\nbound variables but <tt>&lt;</tt>, <tt>-</tt>, <tt>abs</tt>, and <tt>square</tt> are free.\nThe meaning of <tt>good-enough?</tt> should be independent of the names we\nchoose for <tt>guess</tt> and <tt>x</tt> so long as they are distinct and\ndifferent from <tt>&lt;</tt>, <tt>-</tt>, <tt>abs</tt>, and <tt>square</tt>.  (If we renamed\n<tt>guess</tt> to <tt>abs</tt> we would have introduced a bug by <a name="%_idx_604"></a><a name="%_idx_606"></a><a name="%_idx_608"></a><em>capturing</em>\nthe variable <tt>abs</tt>.  It would have changed from free to bound.)  The\nmeaning of <tt>good-enough?</tt> is not independent of the names of its\nfree variables, however.  It surely depends upon the fact (external to\nthis definition) that the symbol <tt>abs</tt> names a procedure for\ncomputing the absolute value of a number.  <tt>Good-enough?</tt> will\ncompute a different function if we substitute <tt>cos</tt> for <tt>abs</tt> in\nits definition.<p>\n\n<a name="%_sec_Temp_43"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_43">Internal definitions and block structure</a></h4><p>\n\n<p>\n\nWe have one kind of name isolation available to us so far: The formal\nparameters of a procedure are local to the body of the procedure.  The\nsquare-root program illustrates another way in which we would like to\ncontrol the use of names.  <a name="%_idx_610"></a>The existing program consists of\nseparate procedures:<p>\n\n<p><p><tt>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(sqrt-iter&nbsp;1.0&nbsp;x))<br>\n(define&nbsp;(sqrt-iter&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;(if&nbsp;(good-enough?&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guess<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt-iter&nbsp;(improve&nbsp;guess&nbsp;x)&nbsp;x)))<br>\n(define&nbsp;(good-enough?&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;(&lt;&nbsp;(abs&nbsp;(-&nbsp;(square&nbsp;guess)&nbsp;x))&nbsp;0.001))<br>\n(define&nbsp;(improve&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;(average&nbsp;guess&nbsp;(/&nbsp;x&nbsp;guess)))<br>\n</tt><p><p><p>\n\nThe problem with this program is that the only procedure that is\nimportant to users of <tt>sqrt</tt> is <tt>sqrt</tt>.  The other\nprocedures (<tt>sqrt-iter</tt>, <tt>good-enough?</tt>, and <tt>improve</tt>)\nonly clutter up their minds.  They may not define any other procedure\ncalled <tt>good-enough?</tt> as part of another program to work together\nwith the square-root program, because <tt>sqrt</tt> needs it.  The\nproblem is especially severe in the construction of large systems by\nmany separate programmers.  For example, in the construction of a\nlarge library of numerical procedures, many numerical functions are\ncomputed as successive approximations and thus might have procedures\nnamed <tt>good-enough?</tt> and <tt>improve</tt> as auxiliary procedures.\nWe would like to localize the subprocedures, hiding them inside <tt>sqrt</tt> so that <tt>sqrt</tt> could coexist with other successive\napproximations, each having its own private\n<tt>good-enough?</tt> procedure.  To make this possible, we allow a\nprocedure to have\n<a name="%_idx_612"></a><a name="%_idx_614"></a>internal definitions that are local to that procedure.  For example,\nin the square-root problem we can write<p>\n\n<p><p><tt>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(define&nbsp;(good-enough?&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&nbsp;(abs&nbsp;(-&nbsp;(square&nbsp;guess)&nbsp;x))&nbsp;0.001))<br>\n&nbsp;&nbsp;(define&nbsp;(improve&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(average&nbsp;guess&nbsp;(/&nbsp;x&nbsp;guess)))<br>\n&nbsp;&nbsp;(define&nbsp;(sqrt-iter&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(good-enough?&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guess<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt-iter&nbsp;(improve&nbsp;guess&nbsp;x)&nbsp;x)))<br>\n&nbsp;&nbsp;(sqrt-iter&nbsp;1.0&nbsp;x))<br>\n</tt><p><p><p>\n\nSuch nesting of definitions, called <em>block structure</em>,\nis basically the right solution to the simplest \nname-packaging problem.  But there is a better idea lurking here.  In\naddition to internalizing the definitions of the auxiliary procedures,\nwe can simplify them.  Since <tt>x</tt> is bound in the definition of\n<tt>sqrt</tt>, the procedures <tt>good-enough?</tt>, <tt>improve</tt>, and\n<tt>sqrt-iter</tt>, which are defined internally to <tt>sqrt</tt>, are in the\nscope of <tt>x</tt>.  Thus, it is not necessary to pass <tt>x</tt> explicitly to\neach of these procedures.  Instead, we allow <tt>x</tt> to be a <a name="%_idx_616"></a><a name="%_idx_618"></a>free\nvariable in the internal definitions, as shown below. Then <tt>x</tt>\ngets its value from the argument with which the enclosing\nprocedure <tt>sqrt</tt> is called.  This discipline is called <a name="%_idx_620"></a><em>lexical\nscoping</em>.<a name="call_footnote_Temp_44" href="#footnote_Temp_44"><sup><small>27</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_624"></a>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(define&nbsp;(good-enough?&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&nbsp;(abs&nbsp;(-&nbsp;(square&nbsp;guess)&nbsp;x))&nbsp;0.001))<br>\n&nbsp;&nbsp;(define&nbsp;(improve&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(average&nbsp;guess&nbsp;(/&nbsp;x&nbsp;guess)))<br>\n&nbsp;&nbsp;(define&nbsp;(sqrt-iter&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(good-enough?&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guess<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt-iter&nbsp;(improve&nbsp;guess))))<br>\n&nbsp;&nbsp;(sqrt-iter&nbsp;1.0))<br>\n</tt><p><p><p>\n\nWe will use block structure extensively to help us break\nup large programs into tractable pieces.<a name="call_footnote_Temp_45" href="#footnote_Temp_45"><sup><small>28</small></sup></a>\nThe idea of block structure originated with the\nprogramming language <a name="%_idx_628"></a>Algol 60.  It appears in most advanced\nprogramming languages and is an important tool for helping to organize\nthe construction of large programs.<p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_10" href="#call_footnote_Temp_10"><sup><small>4</small></sup></a> The\ncharacterization of numbers as ``simple data\'\' is a barefaced bluff.\nIn fact, the treatment of numbers is one of the trickiest and most\nconfusing aspects of any programming language.  Some typical issues\ninvolved are these:\n<a name="%_idx_136"></a><a name="%_idx_138"></a><a name="%_idx_140"></a>Some computer systems distinguish <em>integers</em>, such as 2, from\n<em>real numbers</em>, such as 2.71.  Is the real number 2.00 different\nfrom the integer 2?\nAre the arithmetic operations used\nfor integers the same as the operations used for real numbers?  Does 6\ndivided by 2 produce 3, or 3.0?  How large a number can we represent?\nHow many decimal places of accuracy can we represent?  Is the range of\nintegers the same as the range of real numbers?  <a name="%_idx_142"></a><a name="%_idx_144"></a><a name="%_idx_146"></a>Above and beyond\nthese questions, of course, lies a collection of issues concerning\nroundoff and truncation errors -- the entire science of numerical\nanalysis.  Since our focus in this book is on large-scale program\ndesign rather than on numerical techniques, we are going to ignore\nthese problems.  The numerical examples in this chapter will exhibit\nthe usual roundoff behavior that one observes when using arithmetic\noperations that preserve a limited number of decimal places of\naccuracy in noninteger operations.\n\n<p><a name="footnote_Temp_11" href="#call_footnote_Temp_11"><sup><small>5</small></sup></a> Throughout this book,\n<a name="%_idx_152"></a>when we wish to emphasize the distinction between the input typed by\nthe user and the response printed by the interpreter, we will show the\nlatter in slanted characters.\n\n<p><a name="footnote_Temp_12" href="#call_footnote_Temp_12"><sup><small>6</small></sup></a> <a name="%_idx_200"></a><a name="%_idx_202"></a>Lisp systems typically provide\nfeatures to aid the user in formatting expressions.  Two especially\nuseful features are one that automatically indents to the proper\npretty-print position whenever a new line is started and one that\nhighlights the matching left parenthesis whenever a right parenthesis\nis typed.\n\n<p><a name="footnote_Temp_13" href="#call_footnote_Temp_13"><sup><small>7</small></sup></a> <a name="%_idx_208"></a><a name="%_idx_210"></a><a name="%_idx_212"></a><a name="%_idx_214"></a>Lisp obeys the convention that every\nexpression has a value. This convention, together with the old\nreputation of Lisp as an inefficient language, is the source of the\nquip by Alan Perlis (paraphrasing Oscar Wilde)\nthat ``Lisp programmers know the value of\neverything but the cost of nothing.\'\'\n\n<p><a name="footnote_Temp_14" href="#call_footnote_Temp_14"><sup><small>8</small></sup></a> <a name="%_idx_228"></a><a name="%_idx_230"></a>In this book, we do not show the interpreter\'s response to\nevaluating definitions, since this is highly\nimplementation-dependent.\n\n<p><a name="footnote_Temp_15" href="#call_footnote_Temp_15"><sup><small>9</small></sup></a> Chapter&nbsp;3 will show that this notion of\nenvironment is crucial, both for understanding how the interpreter\nworks and for implementing interpreters.\n\n<p><a name="footnote_Temp_16" href="#call_footnote_Temp_16"><sup><small>10</small></sup></a> It may seem strange that the evaluation rule says, as\npart of the first step, that we should evaluate the leftmost element\nof a combination, since at this point that can only be an operator\nsuch as <tt>+</tt> or <tt>*</tt>\nrepresenting a built-in primitive procedure such as addition or\nmultiplication.  We will see later that it is useful to be able to work with\ncombinations whose operators are themselves compound expressions.\n\n<p><a name="footnote_Temp_17" href="#call_footnote_Temp_17"><sup><small>11</small></sup></a> <a name="%_idx_278"></a><a name="%_idx_280"></a><a name="%_idx_282"></a><a name="%_idx_284"></a><a name="%_idx_286"></a><a name="%_idx_288"></a><a name="%_idx_290"></a>Special syntactic forms that are simply convenient\nalternative surface structures for things that can be written in more\nuniform ways are sometimes called <em>syntactic sugar</em>, to use a\nphrase coined by Peter Landin.  In comparison with users of other\nlanguages, Lisp programmers, as a rule, are less concerned with\nmatters of syntax.  (By contrast, examine any Pascal manual and notice\nhow much of it is devoted to descriptions of syntax.)  This disdain\nfor syntax is due partly to the flexibility of Lisp, which makes it\neasy to change surface syntax, and partly to the observation that many\n``convenient\'\' syntactic constructs, which make the language less\nuniform, end up causing more trouble than they are worth when programs\nbecome large and complex.  In the words of Alan Perlis, ``Syntactic\nsugar causes cancer of the semicolon.\'\'\n\n<p><a name="footnote_Temp_18" href="#call_footnote_Temp_18"><sup><small>12</small></sup></a> Observe that there are two different operations\nbeing combined here: we are creating the procedure, and we are giving\nit the name <tt>square</tt>.  It is possible, indeed important, to be\nable to separate these two notions -- to create procedures without\nnaming them, and to give names to procedures that have already been\ncreated.  We will see how to do this in section&nbsp;<a href="book-Z-H-12.html#%_sec_1.3.2">1.3.2</a>.\n\n<p><a name="footnote_Temp_19" href="#call_footnote_Temp_19"><sup><small>13</small></sup></a> Throughout this book, we will\n<a name="%_idx_314"></a><a name="%_idx_316"></a>describe the general syntax of expressions by using italic symbols\ndelimited by angle brackets -- e.g., &lt;<em>name</em>&gt; -- to denote the\n``slots\'\' in the expression to be filled in when such an expression is\nactually used.\n\n<p><a name="footnote_Temp_20" href="#call_footnote_Temp_20"><sup><small>14</small></sup></a> More\n<a name="%_idx_326"></a>generally, the body of the procedure can be a sequence of expressions.\nIn this case, the interpreter evaluates each expression in the\nsequence in turn and returns the value of the final expression as the\nvalue of the procedure application.\n\n<p><a name="footnote_Temp_21" href="#call_footnote_Temp_21"><sup><small>15</small></sup></a> Despite the\nsimplicity of the substitution idea, it turns out to be surprisingly\ncomplicated to give a rigorous mathematical definition of the\nsubstitution process.  The problem arises from the possibility of\nconfusion between the names used for the formal parameters of a\nprocedure and the (possibly identical) names used in the expressions\nto which the procedure may be applied.  Indeed, there is a long\nhistory of erroneous definitions of <em>substitution</em> in the\nliterature of logic and programming semantics.  <a name="%_idx_338"></a>See Stoy 1977 for a\ncareful discussion of substitution.\n\n<p><a name="footnote_Temp_23" href="#call_footnote_Temp_23"><sup><small>16</small></sup></a> In\nchapter&nbsp;3 we will introduce <em>stream processing</em>, which is a way of\nhandling apparently ``infinite\'\' data structures by incorporating a\nlimited form of normal-order evaluation.  In\nsection&nbsp;<a href="book-Z-H-27.html#%_sec_4.2">4.2</a> we will modify the Scheme\ninterpreter to produce a normal-order variant of Scheme.\n\n<p><a name="footnote_Temp_24" href="#call_footnote_Temp_24"><sup><small>17</small></sup></a> <a name="%_idx_368"></a><a name="%_idx_370"></a><a name="%_idx_372"></a><a name="%_idx_374"></a><a name="%_idx_376"></a><a name="%_idx_378"></a><a name="%_idx_380"></a><a name="%_idx_382"></a>``Interpreted as either true or false\'\'\nmeans this: In Scheme, there are two distinguished values that are\ndenoted by the constants <tt>#t</tt> and <tt>#f</tt>.  When the interpreter\nchecks a predicate\'s value, it interprets <tt>#f</tt> as false.  Any other value\nis treated as true.  (Thus, providing <tt>#t</tt> is logically\nunnecessary, but it is convenient.)  In this book we will use\nnames <tt>true</tt> and <tt>false</tt>, which are associated\nwith the values <tt>#t</tt> and <tt>#f</tt> respectively.\n\n<p><a name="footnote_Temp_25" href="#call_footnote_Temp_25"><sup><small>18</small></sup></a> <tt>Abs</tt> also uses\n<a name="%_idx_410"></a><a name="%_idx_412"></a>the ``minus\'\' operator <tt>-</tt>, which, when used with a single\noperand, as in <tt>(-&nbsp;x)</tt>, indicates negation.\n\n<p><a name="footnote_Temp_26" href="#call_footnote_Temp_26"><sup><small>19</small></sup></a> A minor difference\n<a name="%_idx_440"></a><a name="%_idx_442"></a><a name="%_idx_444"></a>between <tt>if</tt> and <tt>cond</tt> is that the\n&lt;<em>e</em>&gt; part of each <tt>cond</tt> clause may be a sequence of expressions.\nIf the corresponding &lt;<em>p</em>&gt; is found to be true, the expressions\n&lt;<em>e</em>&gt; are evaluated in sequence and the value of the final\nexpression in the sequence is returned as the value of the <tt>cond</tt>.\nIn an <tt>if</tt> expression, however, the &lt;<em>consequent</em>&gt; and\n&lt;<em>alternative</em>&gt; must be single expressions.\n\n<p><a name="footnote_Temp_32" href="#call_footnote_Temp_32"><sup><small>20</small></sup></a> Declarative and\nimperative descriptions are intimately related, as indeed are\nmathematics and computer science.  For instance, to say that the\nanswer produced by a program is <a name="%_idx_500"></a>``correct\'\' is to make a declarative\nstatement about the program.  There is a large amount of research\naimed at establishing techniques for <a name="%_idx_502"></a>proving that programs are\ncorrect, and much of the technical difficulty of this subject has to\ndo with negotiating the transition between imperative statements (from\nwhich programs are constructed) and declarative statements (which can\nbe used to deduce things).  In a related vein, an important current\narea in programming-language design is the exploration of so-called\n<a name="%_idx_504"></a><a name="%_idx_506"></a>very high-level languages, in which one actually programs in terms of\ndeclarative statements.  The idea is to make interpreters\nsophisticated enough so that, given ``what is\'\' knowledge specified by\nthe programmer, they can generate ``how to\'\' knowledge automatically.\nThis cannot be done in general, but there are important areas where\nprogress has been made.  We shall revisit this idea in chapter&nbsp;4.\n\n<p><a name="footnote_Temp_33" href="#call_footnote_Temp_33"><sup><small>21</small></sup></a> This square-root algorithm is actually a special case\nof Newton\'s method, which is a general technique for finding roots of\nequations.  The square-root algorithm itself was developed by Heron of\n<a name="%_idx_512"></a>Alexandria in the first century <font size=-2>A</font>.<font size=-2>D</font>.  We will see how to express\nthe general Newton\'s method as a Lisp procedure in\nsection&nbsp;<a href="book-Z-H-12.html#%_sec_1.3.4">1.3.4</a>.\n\n<p><a name="footnote_Temp_34" href="#call_footnote_Temp_34"><sup><small>22</small></sup></a> We will usually give\n<a name="%_idx_518"></a><a name="%_idx_520"></a><a name="%_idx_522"></a><a name="%_idx_524"></a>predicates names ending with question marks, to help us\nremember that they are predicates.  This\nis just a stylistic convention.  As far as the interpreter is\nconcerned, the question mark is just an ordinary character.\n\n<p><a name="footnote_Temp_35" href="#call_footnote_Temp_35"><sup><small>23</small></sup></a> Observe that we express our initial guess as 1.0 rather than\n1.  This would not make any difference in many Lisp implementations.\n<a name="%_idx_526"></a><a name="%_idx_528"></a><a name="%_idx_530"></a><a name="%_idx_532"></a><a name="%_idx_534"></a><a name="%_idx_536"></a><a name="%_idx_538"></a><a name="%_idx_540"></a><a name="%_idx_542"></a><a name="%_idx_544"></a><a name="%_idx_546"></a><a name="%_idx_548"></a>MIT Scheme, however, distinguishes between exact integers and decimal\nvalues, and dividing two integers produces a rational number rather\nthan a decimal.  For example, dividing 10 by 6 yields 5/3, while\ndividing 10.0 by 6.0 yields 1.6666666666666667.  (We will learn how to\nimplement arithmetic on rational numbers in\nsection&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a>.)  If we start with an initial guess of 1\nin our square-root program, and <em>x</em> is an exact integer, all\nsubsequent values produced in the square-root computation will be\nrational numbers rather than decimals.  Mixed operations on rational\nnumbers and decimals always yield decimals, so starting with an\ninitial guess of 1.0 forces all subsequent values to be decimals.\n\n<p><a name="footnote_Temp_36" href="#call_footnote_Temp_36"><sup><small>24</small></sup></a> Readers who are worried about the efficiency\nissues involved in using procedure calls to implement iteration should\nnote the remarks on ``tail recursion\'\' in\nsection&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a>.\n\n<p><a name="footnote_Temp_40" href="#call_footnote_Temp_40"><sup><small>25</small></sup></a> It is not even clear which of these procedures is a\nmore efficient implementation.  This depends upon the hardware\navailable.  There are machines for which the ``obvious\'\'\nimplementation is the less efficient one.  Consider a machine that has\nextensive tables of logarithms and antilogarithms stored in a very\nefficient manner.\n\n<p><a name="footnote_Temp_42" href="#call_footnote_Temp_42"><sup><small>26</small></sup></a> The\nconcept of consistent renaming is actually subtle and difficult to\ndefine formally.  Famous logicians have made embarrassing errors\nhere.\n\n<p><a name="footnote_Temp_44" href="#call_footnote_Temp_44"><sup><small>27</small></sup></a> Lexical\nscoping dictates that free variables in a procedure are taken to refer to\nbindings made by enclosing procedure definitions;\nthat is, they are looked up in\n<a name="%_idx_622"></a>the environment in which the procedure was defined.  We will see how\nthis works in detail in chapter&nbsp;3 when we study environments and the\ndetailed behavior of the interpreter.\n\n<p><a name="footnote_Temp_45" href="#call_footnote_Temp_45"><sup><small>28</small></sup></a> Embedded definitions\n<a name="%_idx_626"></a>must come first in a procedure body.  The management is not responsible\nfor the consequences of running programs that intertwine definition\nand use.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_1.2"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_1.2">1.2&nbsp;&nbsp;Procedures and the Processes They Generate</a></h2><p>\n\n<p>\n\n\nWe have now considered the elements of programming: We have used\nprimitive arithmetic operations, we have combined these operations, and\nwe have abstracted these composite operations by defining them as compound\nprocedures.  But that is not enough to enable us to say that we know\nhow to program.  Our situation is analogous to that of someone who has\nlearned the rules for how the pieces move in chess but knows nothing\nof typical openings, tactics, or strategy.  Like the novice chess\nplayer, we don\'t yet know the common patterns of usage in the domain.\nWe lack the knowledge of which moves are worth making (which\nprocedures are worth defining).  We lack the experience to predict the\nconsequences of making a move (executing a procedure).<p>\n\nThe ability to visualize the consequences of the actions under\nconsideration is crucial to becoming an expert programmer, just as it\nis in any synthetic, creative activity.  In becoming an expert\nphotographer, for example, one must learn how to look at a scene and\nknow how dark each region will appear on a print for each possible\nchoice of exposure and development conditions.  Only then can one\nreason backward, planning framing, lighting, exposure, and development\nto obtain the desired effects.  So it is with programming, where we\nare planning the course of action to be taken by a process and where\nwe control the process by means of a program.  To become experts, we\nmust learn to visualize the processes generated by various types of\nprocedures.  Only after we have developed such a skill can we learn\nto reliably construct programs that exhibit the desired behavior.<p>\n\n<a name="%_idx_630"></a><a name="%_idx_632"></a><a name="%_idx_634"></a>A procedure is a pattern for the <em>local evolution</em> of a\ncomputational process.  It specifies how each stage of the process is\nbuilt upon the previous stage.  We would like to be able to make\nstatements about the overall, or <em>global</em>, behavior of a\nprocess whose local evolution has been specified by a procedure.  This\nis very difficult to do in general, but we can at least try to\ndescribe some typical patterns of process evolution.<p>\n\nIn this section we will examine some common ``shapes\'\' for processes\ngenerated by simple procedures.  We will also investigate the\nrates at which these processes consume the important computational\nresources of time and space.  The procedures we will consider\nare very simple.  Their role is like that played by test patterns in\nphotography: as oversimplified prototypical patterns, rather than\npractical examples in their own right.<p>\n\n<a name="%_sec_1.2.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.2.1">1.2.1&nbsp;&nbsp;Linear Recursion and Iteration</a></h3><p>\n\n\n<a name="%_idx_636"></a><a name="%_idx_638"></a>\n<a name="%_fig_1.3"></a><p><div align=left><table width=100%><tr><td><img src="ch1-Z-G-7.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 1.3:</b>&nbsp;&nbsp;A linear recursive process for computing 6!.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_idx_640"></a>We begin by considering the factorial function, defined by<p>\n\n<p><div align=left><img src="ch1-Z-G-8.gif" border="0"></div><p><p>\n\nThere are many ways to compute factorials.  One way is to make use of\nthe observation that <em>n</em>! is equal to <em>n</em> times (<em>n</em> - 1)! for\nany positive integer&nbsp;<em>n</em>:<p>\n\n<p><div align=left><img src="ch1-Z-G-9.gif" border="0"></div><p><p>\n\nThus, we can compute <em>n</em>! by computing (<em>n</em> - 1)! and multiplying the\nresult by <em>n</em>.  If we add the stipulation that 1! is equal to 1,\nthis observation translates directly into a procedure:<p>\n\n<p><p><tt><a name="%_idx_642"></a>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;n&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1)))))<br>\n</tt><p><p>\n<a name="%_idx_644"></a>We can use the substitution model of\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a> to watch this procedure in action\ncomputing 6!, as shown in figure&nbsp;<a href="#%_fig_1.3">1.3</a>.<p>\n\n\nNow let\'s take a different perspective on computing factorials.  We\ncould describe a rule for computing <em>n</em>! by specifying that we\nfirst multiply 1 by 2, then multiply the result by 3, then by 4,\nand so on until we reach <em>n</em>.\nMore formally, we maintain a running product, together with a counter\nthat counts from 1 up to <em>n</em>.  We can describe the computation by\nsaying that the counter and the product simultaneously change from one\nstep to the next according to the rule<p>\n\n<p><p>product  <img src="book-Z-G-D-14.gif" border="0">  counter  &middot;  product <p>\n\n<p><p>counter  <img src="book-Z-G-D-14.gif" border="0">  counter  +  1<p>\n\n<p><p><p>\n\nand stipulating that <em>n</em>! is the value of the product when\nthe counter exceeds <em>n</em>.<p>\n\n<a name="%_fig_1.4"></a><p><div align=left><table width=100%><tr><td><img src="ch1-Z-G-10.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 1.4:</b>&nbsp;&nbsp;A linear iterative process for computing 6!.</div></caption><tr><td> \n\n</td></tr></table></div><p><p>\n\nOnce again, we can recast our description as a procedure for computing\nfactorials:<a name="call_footnote_Temp_46" href="#footnote_Temp_46"><sup><small>29</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_646"></a>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(fact-iter&nbsp;1&nbsp;1&nbsp;n))<br>\n<br>\n(define&nbsp;(fact-iter&nbsp;product&nbsp;counter&nbsp;max-count)<br>\n&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;counter&nbsp;max-count)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fact-iter&nbsp;(*&nbsp;counter&nbsp;product)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;counter&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max-count)))<br>\n</tt><p><p><p>\n\n\nAs before, we can use the substitution model to visualize the process\nof computing 6!, as shown in figure&nbsp;<a href="#%_fig_1.4">1.4</a>.<p>\n\nCompare the two processes.  From one point of view, they seem hardly\ndifferent at all.  Both compute the same mathematical function on the\nsame domain, and each requires a number of steps proportional to <em>n</em>\nto compute <em>n</em>!.  Indeed, both processes even carry out the same\nsequence of multiplications, obtaining the same sequence of partial\nproducts.  On the other hand, when we consider the <a name="%_idx_648"></a><a name="%_idx_650"></a>``shapes\'\' of the\ntwo processes, we find that they evolve quite differently.<p>\n\nConsider the first process.  The substitution model reveals a shape of\nexpansion followed by contraction, indicated by the arrow in\nfigure&nbsp;<a href="#%_fig_1.3">1.3</a>.  The expansion occurs as the\nprocess builds up a chain of <a name="%_idx_652"></a><em>deferred operations</em> (in this case,\na chain of multiplications).  The contraction occurs as \nthe operations are\nactually performed.  This type of process, characterized by a chain of\ndeferred operations, is called a <a name="%_idx_654"></a><a name="%_idx_656"></a><em>recursive process</em>.  Carrying\nout this process requires that the interpreter keep track of the\noperations to be performed later on.  In the computation of <em>n</em>!,\nthe length of the chain of deferred multiplications, and hence the amount\nof information needed to keep track of it, <a name="%_idx_658"></a>grows linearly with <em>n</em>\n(is proportional to <em>n</em>), just like the number of steps.\n<a name="%_idx_660"></a><a name="%_idx_662"></a><a name="%_idx_664"></a>Such a process is called a <em>linear recursive process</em>.<p>\n\nBy contrast, the second process does not grow and shrink.  At each\nstep, all we need to keep track of, for any <em>n</em>, are the current\nvalues of the variables <tt>product</tt>, <tt>counter</tt>, and <tt>max-count</tt>.  We call this an <a name="%_idx_666"></a><a name="%_idx_668"></a><em>iterative process</em>.  In general, an\niterative process is one whose state can be summarized by a fixed\nnumber of <a name="%_idx_670"></a><em>state variables</em>, together with a fixed rule that\ndescribes how the state variables should be updated as the process\nmoves from state to state and an (optional) end test that specifies\nconditions under which the process should terminate.  In computing\n<em>n</em>!, the number of steps required grows linearly with <em>n</em>.  Such a process is\ncalled a <a name="%_idx_672"></a><a name="%_idx_674"></a><a name="%_idx_676"></a><em>linear iterative process</em>.<p>\n\nThe contrast between the two processes can be seen in another way.  In\nthe iterative case, the program variables provide a complete\ndescription of the state of the process at any point.  If we stopped\nthe computation between steps, all we would need to do to resume the\ncomputation is to supply the interpreter with the values of the three\nprogram variables.  Not so with the recursive process.  In this case\nthere is some additional ``hidden\'\' information, maintained by the\ninterpreter and not contained in the program variables, which\nindicates ``where the process is\'\' in negotiating the chain of\ndeferred operations.  The longer the chain, the more information must\nbe maintained.<a name="call_footnote_Temp_47" href="#footnote_Temp_47"><sup><small>30</small></sup></a><p>\n\nIn contrasting iteration and recursion, we must be careful not to\nconfuse the notion of a <a name="%_idx_680"></a><a name="%_idx_682"></a>recursive <em>process</em> with the notion of a\nrecursive <em>procedure</em>.  When we describe a procedure as recursive,\nwe are referring to the syntactic fact that the procedure definition\nrefers (either directly or indirectly) to the procedure itself.  But\nwhen we describe a process as following a pattern that is, say,\nlinearly recursive, we are speaking about how the process evolves, not\nabout the syntax of how a procedure is written.  It may seem\ndisturbing that we refer to a recursive procedure such as <tt>fact-iter</tt> as generating an iterative process.  However, the process\nreally is iterative: Its state is captured completely by its three\nstate variables, and an interpreter need keep track of only three\nvariables in order to execute the process.<p>\n\nOne reason that the distinction between process and procedure may be\nconfusing is that most implementations of common languages (including\n<a name="%_idx_684"></a><a name="%_idx_686"></a><a name="%_idx_688"></a>Ada, Pascal, and C) are designed in such a way that the\ninterpretation of any recursive procedure consumes an amount of memory\nthat grows with the number of procedure calls, even when the process\ndescribed is, in principle, iterative.  As a consequence, these\nlanguages can describe iterative processes only by resorting to\nspecial-purpose <a name="%_idx_690"></a>``looping constructs\'\' such as <tt>do</tt>, <tt>repeat</tt>,\n<tt>until</tt>, <tt>for</tt>, and <tt>while</tt>.  The implementation of Scheme\nwe shall consider in chapter&nbsp;5 does not share this defect.  It will\nexecute an iterative process in constant space, even if the iterative\nprocess is described by a recursive procedure.  An implementation with\nthis property is called <a name="%_idx_692"></a><em>tail-recursive</em>.  With a tail-recursive\nimplementation, <a name="%_idx_694"></a>iteration can be expressed using the ordinary\nprocedure call mechanism, so that special iteration constructs are\nuseful only as <a name="%_idx_696"></a>syntactic sugar.<a name="call_footnote_Temp_48" href="#footnote_Temp_48"><sup><small>31</small></sup></a><p>\n\n<p><a name="%_thm_1.9"></a>\n<b>Exercise 1.9.</b>&nbsp;&nbsp;Each of the following two procedures defines a method for adding two\npositive integers in terms of the procedures <tt>inc</tt>,\nwhich increments its argument by 1, and <tt>dec</tt>, which decrements\nits argument by 1.<p>\n\n<p><p><tt>(define&nbsp;(+&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;a&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(inc&nbsp;(+&nbsp;(dec&nbsp;a)&nbsp;b))))<br>\n<br>\n(define&nbsp;(+&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;a&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(dec&nbsp;a)&nbsp;(inc&nbsp;b))))<br>\n</tt><p><p>\nUsing the substitution model, illustrate the process generated by each\nprocedure in evaluating <tt>(+ 4 5)</tt>.  Are these processes\niterative or recursive?\n<p><p>\n\n<p><a name="%_thm_1.10"></a>\n<b>Exercise 1.10.</b>&nbsp;&nbsp;<a name="%_idx_708"></a><a name="%_idx_710"></a>The following procedure computes a mathematical function called\nAckermann\'s function.<p>\n\n<p><p><tt>(define&nbsp;(A&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;y&nbsp;0)&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;x&nbsp;0)&nbsp;(*&nbsp;2&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;y&nbsp;1)&nbsp;2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(A&nbsp;(-&nbsp;x&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A&nbsp;x&nbsp;(-&nbsp;y&nbsp;1))))))<br>\n</tt><p><p>\nWhat are the values of the following expressions?<p>\n\n<p><p><tt>(A&nbsp;1&nbsp;10)<br>\n<br>\n(A&nbsp;2&nbsp;4)<br>\n<br>\n(A&nbsp;3&nbsp;3)<br>\n</tt><p><p>\nConsider the following procedures, where <tt>A</tt> is the procedure  \ndefined above:\n<p><p><tt>(define&nbsp;(f&nbsp;n)&nbsp;(A&nbsp;0&nbsp;n))<br>\n<br>\n(define&nbsp;(g&nbsp;n)&nbsp;(A&nbsp;1&nbsp;n))<br>\n<br>\n(define&nbsp;(h&nbsp;n)&nbsp;(A&nbsp;2&nbsp;n))<br>\n<br>\n(define&nbsp;(k&nbsp;n)&nbsp;(*&nbsp;5&nbsp;n&nbsp;n))<br>\n</tt><p><p>\nGive concise mathematical definitions for the functions computed by\nthe procedures <tt>f</tt>, <tt>g</tt>, and <tt>h</tt> for positive integer\nvalues of <em>n</em>.  For example, <tt>(k n)</tt> computes 5<em>n</em><sup>2</sup>.\n<p><p>\n\n<a name="%_sec_1.2.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.2.2">1.2.2&nbsp;&nbsp;Tree Recursion</a></h3><p>\n\n\n<a name="%_idx_712"></a><a name="%_idx_714"></a><a name="%_idx_716"></a>\nAnother common pattern of computation is called <em>tree recursion</em>.\nAs an example, consider computing the sequence of <a name="%_idx_718"></a>Fibonacci numbers,\nin which each number is the sum of the preceding two:<p>\n\n<p><div align=left><img src="ch1-Z-G-11.gif" border="0"></div><p><p>\n\nIn general, the Fibonacci numbers can be defined by the rule\n<p><div align=left><img src="ch1-Z-G-12.gif" border="0"></div><p>\nWe can immediately translate this definition into a recursive\nprocedure for computing Fibonacci numbers:<p>\n\n<p><p><tt><a name="%_idx_720"></a>(define&nbsp;(fib&nbsp;n)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;n&nbsp;0)&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;n&nbsp;1)&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(+&nbsp;(fib&nbsp;(-&nbsp;n&nbsp;1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fib&nbsp;(-&nbsp;n&nbsp;2))))))<br>\n</tt><p><p><p>\n\n<a name="%_fig_1.5"></a><p><div align=left><table width=100%><tr><td><img src="ch1-Z-G-13.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 1.5:</b>&nbsp;&nbsp;The tree-recursive process generated in computing <tt>(fib 5)</tt>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nConsider the pattern of this computation.  To compute <tt>(fib 5)</tt>,\nwe compute <tt>(fib 4)</tt> and <tt>(fib 3)</tt>.  To compute <tt>(fib 4)</tt>,\nwe compute <tt>(fib 3)</tt> and <tt>(fib 2)</tt>.  In general, the evolved\nprocess looks like a tree, as shown in figure&nbsp;<a href="#%_fig_1.5">1.5</a>.\nNotice that the branches split into two at each level (except at the\nbottom); this reflects the fact that the <tt>fib</tt> procedure calls\nitself twice each time it is invoked.<p>\n\n\nThis procedure is instructive as a prototypical tree recursion, but it\nis a terrible way to compute Fibonacci numbers because it does so much\nredundant computation.  Notice in figure&nbsp;<a href="#%_fig_1.5">1.5</a> that\nthe entire computation of <tt>(fib 3)</tt> -- almost half the work -- is\nduplicated.  In fact, it is not hard to show that the number of times\nthe procedure will compute <tt>(fib 1)</tt> or <tt>(fib 0)</tt> (the number\nof leaves in the above tree, in general) is precisely \n<em>F</em><em>i</em><em>b</em>(<em>n</em> + 1).  To get an idea of how bad this is, one can show that the\nvalue of  <em>F</em><em>i</em><em>b</em>(<em>n</em>) <a name="%_idx_722"></a>grows exponentially with <em>n</em>.  More precisely\n(see exercise&nbsp;<a href="#%_thm_1.13">1.13</a>),  <em>F</em><em>i</em><em>b</em>(<em>n</em>) is the closest\ninteger to <img src="book-Z-G-D-11.gif" border="0"><sup><em>n</em></sup> /<img src="book-Z-G-D-13.gif" border="0">5, where<p>\n\n<p><div align=left><img src="ch1-Z-G-14.gif" border="0"></div><p>\nis the <a name="%_idx_724"></a><em>golden ratio</em>, which satisfies the equation<p>\n\n<p><div align=left><img src="ch1-Z-G-15.gif" border="0"></div><p>\n\nThus, the process uses a number of steps that grows exponentially\nwith the input.  On the other hand, the space required grows only\nlinearly with the input, because we need keep track only of which\nnodes are above us in the tree at any point in the computation.  In\ngeneral, the number of steps required by a tree-recursive process will be\nproportional to the number of nodes in the tree, while the space\nrequired will be proportional to the maximum depth of the tree.<p>\n\nWe can also formulate an iterative process for computing the\nFibonacci numbers.  The idea is to use a pair of integers <em>a</em> and\n<em>b</em>, initialized to  <em>F</em><em>i</em><em>b</em>(1) = 1 and  <em>F</em><em>i</em><em>b</em>(0) = 0,\nand to repeatedly apply the simultaneous\ntransformations\n<p><div align=left><img src="ch1-Z-G-16.gif" border="0"></div><p>\nIt is not hard to show that, after applying this transformation <em>n</em>\ntimes, <em>a</em> and <em>b</em> will be equal, respectively, to  <em>F</em><em>i</em><em>b</em>(<em>n</em> + 1) and\n <em>F</em><em>i</em><em>b</em>(<em>n</em>).  Thus, we can compute Fibonacci numbers iteratively using\nthe procedure<p>\n\n<p><p><tt><a name="%_idx_726"></a>(define&nbsp;(fib&nbsp;n)<br>\n&nbsp;&nbsp;(fib-iter&nbsp;1&nbsp;0&nbsp;n))<br>\n<br>\n(define&nbsp;(fib-iter&nbsp;a&nbsp;b&nbsp;count)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;count&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fib-iter&nbsp;(+&nbsp;a&nbsp;b)&nbsp;a&nbsp;(-&nbsp;count&nbsp;1))))<br>\n</tt><p><p>\nThis second method for computing  <em>F</em><em>i</em><em>b</em>(<em>n</em>) is a linear iteration.  The\ndifference in number of steps required by the two methods -- one linear in <em>n</em>,\none growing as fast as  <em>F</em><em>i</em><em>b</em>(<em>n</em>) itself -- is enormous, even for\nsmall inputs.<p>\n\nOne should not conclude from this that tree-recursive processes are\nuseless.  When we consider processes that operate on hierarchically\nstructured data rather than numbers, we will find that tree recursion\nis a natural and powerful tool.<a name="call_footnote_Temp_51" href="#footnote_Temp_51"><sup><small>32</small></sup></a> But even in numerical operations,\ntree-recursive processes can be useful in helping us to understand and\ndesign programs.  For instance, although the first <tt>fib</tt> procedure\nis much less efficient than the second one, it is more\nstraightforward, being little more than a translation into Lisp of the\ndefinition of the Fibonacci sequence.  To formulate the iterative\nalgorithm required noticing that the computation could be recast as an\niteration with three state variables.<p>\n\n<a name="%_sec_Temp_52"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_52">Example: Counting change</a></h4><p>\n\n<a name="%_idx_728"></a>\nIt takes only a bit of cleverness to come up with the iterative\nFibonacci algorithm.  In contrast, consider the\nfollowing problem: How many different ways can we make change of $ 1.00,\ngiven half-dollars, quarters, dimes, nickels, and pennies?  More\ngenerally, can we write a procedure to compute the number of ways to\nchange any given amount of money?<p>\n\nThis problem has a simple solution as a recursive procedure.  Suppose\nwe think of the types of coins available as arranged in some order.\nThen the following relation holds:<p>\n\n<p><p>The number of ways to change amount <em>a</em> using <em>n</em> kinds of coins equals<p>\n\n<p><ul>\n<li>the number of ways to change amount <em>a</em> using all but the first\nkind of coin, plus<p>\n\n<li>the number of ways to change amount <em>a</em> - <em>d</em> using all <em>n</em> kinds of\ncoins, where <em>d</em> is the denomination of the first kind of coin.\n</ul><p><p>\n\nTo see why this is true, observe that the ways to make change can be\ndivided into two groups: those that do not use any of the first kind\nof coin, and those that do.  Therefore, the total number of ways to\nmake change for some amount is equal to the number of ways to make\nchange for the amount without using any of the first kind of coin,\nplus the number of ways to make change assuming that we do use the\nfirst kind of coin.  But the latter number is equal to the number of\nways to make change for the amount that remains after using a coin of\nthe first kind.<p>\n\nThus, we can recursively reduce the problem of changing a given amount\nto the problem of changing smaller amounts using fewer kinds of coins.\nConsider this reduction rule carefully, and convince yourself that we\ncan use it to describe an algorithm if we specify the following\ndegenerate cases:<a name="call_footnote_Temp_53" href="#footnote_Temp_53"><sup><small>33</small></sup></a><p>\n\n<p><ul>\n<li>If <em>a</em> is exactly 0, we should count that as 1 way to make change.<p>\n\n<li>If <em>a</em> is less than 0, we should count that as 0 ways to make change.<p>\n\n<li>If <em>n</em> is 0, we should count that as 0 ways to make change.\n</ul><p><p>\n\nWe can easily translate this description into a recursive\nprocedure:<p>\n\n<p><p><tt><a name="%_idx_730"></a>(define&nbsp;(count-change&nbsp;amount)<br>\n&nbsp;&nbsp;(cc&nbsp;amount&nbsp;5))<br>\n(define&nbsp;(cc&nbsp;amount&nbsp;kinds-of-coins)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;amount&nbsp;0)&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((or&nbsp;(&lt;&nbsp;amount&nbsp;0)&nbsp;(=&nbsp;kinds-of-coins&nbsp;0))&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(+&nbsp;(cc&nbsp;amount<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;kinds-of-coins&nbsp;1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cc&nbsp;(-&nbsp;amount<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(first-denomination&nbsp;kinds-of-coins))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kinds-of-coins)))))<br>\n(define&nbsp;(first-denomination&nbsp;kinds-of-coins)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;kinds-of-coins&nbsp;1)&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;kinds-of-coins&nbsp;2)&nbsp;5)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;kinds-of-coins&nbsp;3)&nbsp;10)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;kinds-of-coins&nbsp;4)&nbsp;25)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;kinds-of-coins&nbsp;5)&nbsp;50)))<br>\n</tt><p><p>\n(The <tt>first-denomination</tt> procedure takes as input the number of\nkinds of coins available and returns the denomination of the first\nkind.  Here we are thinking of the coins as arranged in order from\nlargest to smallest, but any order would do as well.)  We can now\nanswer our original question about changing a dollar:<p>\n\n<p><p><tt>(count-change&nbsp;100)<br>\n<i>292</i><br>\n</tt><p><p><p>\n\n<tt>Count-change</tt> generates a tree-recursive process with\nredundancies similar to those in our first implementation of <tt>fib</tt>.  (It will take quite a while for that 292 to be computed.)  On\nthe other hand, it is not obvious how to design a better algorithm\nfor computing the result, and we leave this problem as a challenge.\nThe observation that a <a name="%_idx_732"></a>tree-recursive process may be highly\ninefficient but often easy to specify and understand has led people to\npropose that one could get the best of both worlds by designing a\n``smart compiler\'\' that could transform tree-recursive procedures into\nmore efficient procedures that compute the same result.<a name="call_footnote_Temp_54" href="#footnote_Temp_54"><sup><small>34</small></sup></a><p>\n\n<p><a name="%_thm_1.11"></a>\n<b>Exercise 1.11.</b>&nbsp;&nbsp;A function <em>f</em> is defined by the rule that <em>f</em>(<em>n</em>) = <em>n</em> if <em>n</em>&lt;3 and\n<em>f</em>(<em>n</em>) = <em>f</em>(<em>n</em> - 1) + 2<em>f</em>(<em>n</em> - 2) + 3<em>f</em>(<em>n</em> - 3) if <em>n</em><u>&gt;</u> 3.  Write a procedure that\ncomputes <em>f</em> by means of a recursive process.  Write a procedure that\ncomputes <em>f</em> by means of an iterative process.\n<p><p>\n\n<p><a name="%_thm_1.12"></a>\n<b>Exercise 1.12.</b>&nbsp;&nbsp;<a name="%_idx_738"></a>The following pattern of numbers is called\n<em>Pascal\'s triangle</em>.<p>\n\n<p><div align=left><img src="ch1-Z-G-17.gif" border="0"></div><p>\nThe numbers at the edge of the triangle are all 1, and\neach number inside the triangle is the sum of the two numbers above it.<a name="call_footnote_Temp_57" href="#footnote_Temp_57"><sup><small>35</small></sup></a>\nWrite a procedure that computes elements of Pascal\'s triangle by means\nof a recursive process.\n<p><p>\n\n<p><a name="%_thm_1.13"></a>\n<b>Exercise 1.13.</b>&nbsp;&nbsp;Prove that  <em>F</em><em>i</em><em>b</em>(<em>n</em>) is the closest integer to <img src="book-Z-G-D-11.gif" border="0"><sup><em>n</em></sup>/<img src="book-Z-G-D-13.gif" border="0">5,\nwhere <img src="book-Z-G-D-11.gif" border="0"> =  (1 + <img src="book-Z-G-D-13.gif" border="0">5)/2.  Hint: Let <img src="book-Z-G-D-12.gif" border="0"> =  (1 - <img src="book-Z-G-D-13.gif" border="0">5)/2.  Use\ninduction and the definition of the Fibonacci numbers (see\nsection&nbsp;<a href="#%_sec_1.2.2">1.2.2</a>) to prove that  <em>F</em><em>i</em><em>b</em>(<em>n</em>) = (<img src="book-Z-G-D-11.gif" border="0"><sup><em>n</em></sup>\n - <img src="book-Z-G-D-12.gif" border="0"><sup><em>n</em></sup>)/<img src="book-Z-G-D-13.gif" border="0">5.\n\n<p><p>\n\n<a name="%_sec_1.2.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.2.3">1.2.3&nbsp;&nbsp;Orders of Growth</a></h3><p>\n\n\n<a name="%_idx_752"></a>\nThe previous examples illustrate that processes can differ\nconsiderably in the rates at which they consume computational\nresources.  One convenient way to describe this difference is to use\nthe notion of <a name="%_idx_754"></a><em>order of growth</em> to obtain a gross measure of the\n<a name="%_idx_756"></a>resources required by a process as the inputs become larger.<p>\n\n\nLet <em>n</em> be a parameter that measures the size of the problem, and let\n<em>R</em>(<em>n</em>) be the amount of resources the process requires for a problem\nof size <em>n</em>.  In our previous examples we took <em>n</em> to be the number\nfor which a given function is to be computed, but there are other\npossibilities.  For instance, if our goal is to compute an\napproximation to the square root of a number, we might take <em>n</em> to be\nthe number of digits accuracy required.  For matrix multiplication we\nmight take <em>n</em> to be the number of rows in the matrices.  In general\nthere are a number of properties of the problem with respect to which\nit will be desirable to analyze a given process.  Similarly, <em>R</em>(<em>n</em>)\nmight measure the number of internal storage registers used, the\nnumber of elementary machine operations performed, and so on.  In\ncomputers that do only a fixed number of operations at a time, the\ntime required will be proportional to the number of elementary machine\noperations performed.<p>\n\n<a name="%_idx_758"></a><a name="%_idx_760"></a>We say that <em>R</em>(<em>n</em>) has order of growth <img src="book-Z-G-D-3.gif" border="0">(<em>f</em>(<em>n</em>)), written\n<em>R</em>(<em>n</em>) = <img src="book-Z-G-D-3.gif" border="0">(<em>f</em>(<em>n</em>)) (pronounced ``theta of <em>f</em>(<em>n</em>)\'\'), if there are\npositive constants <em>k</em><sub>1</sub> and <em>k</em><sub>2</sub> independent of <em>n</em> such that\n<p><div align=left><img src="ch1-Z-G-18.gif" border="0"></div><p>\nfor any sufficiently large value of <em>n</em>.  (In other\nwords, for large <em>n</em>, the value <em>R</em>(<em>n</em>) is sandwiched between <em>k</em><sub>1</sub><em>f</em>(<em>n</em>)\nand <em>k</em><sub>2</sub><em>f</em>(<em>n</em>).)<p>\n\n<a name="%_idx_762"></a><a name="%_idx_764"></a><a name="%_idx_766"></a>For instance, with the linear recursive process for computing\nfactorial described in section&nbsp;<a href="#%_sec_1.2.1">1.2.1</a> the\nnumber of steps grows proportionally to the input <em>n</em>.  Thus, the\nsteps required for this process grows as <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>).  We also saw\nthat the space required grows as <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>).  For the <a name="%_idx_768"></a><a name="%_idx_770"></a><a name="%_idx_772"></a>iterative\nfactorial, the number of steps is still <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) but the space is\n<img src="book-Z-G-D-3.gif" border="0">(1) -- that is, constant.<a name="call_footnote_Temp_59" href="#footnote_Temp_59"><sup><small>36</small></sup></a> The <a name="%_idx_774"></a><a name="%_idx_776"></a><a name="%_idx_778"></a>tree-recursive Fibonacci computation requires\n<img src="book-Z-G-D-3.gif" border="0">(<img src="book-Z-G-D-11.gif" border="0"><sup><em>n</em></sup>) steps and space <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>), where <img src="book-Z-G-D-11.gif" border="0"> is the\ngolden ratio described in section&nbsp;<a href="#%_sec_1.2.2">1.2.2</a>.<p>\n\n\nOrders of growth provide only a crude description of the behavior of a\nprocess.  For example, a process requiring <em>n</em><sup>2</sup> steps and a process\nrequiring 1000<em>n</em><sup>2</sup> steps and a process requiring 3<em>n</em><sup>2</sup> + 10<em>n</em> + 17 steps\nall have <img src="book-Z-G-D-3.gif" border="0">(<em>n</em><sup>2</sup>) order of growth.  On the other hand, order of\ngrowth provides a useful indication of how we may expect the behavior\nof the process to change as we change the size of the problem.  For a\n<a name="%_idx_780"></a><img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) (linear) process, doubling the size will roughly double the amount\nof resources used.  For an <a name="%_idx_782"></a>exponential process, each increment in\nproblem size will multiply the resource utilization by a constant\nfactor.  In the remainder of section&nbsp;<a href="#%_sec_1.2">1.2</a>\nwe will examine two\nalgorithms whose order of growth is <a name="%_idx_784"></a>logarithmic, so that doubling the\nproblem size increases the resource requirement by a constant amount.<p>\n\n<p><a name="%_thm_1.14"></a>\n<b>Exercise 1.14.</b>&nbsp;&nbsp;Draw the tree illustrating the process generated by the <tt>count-change</tt> procedure of section&nbsp;<a href="#%_sec_1.2.2">1.2.2</a> in making\nchange for 11 cents.  What are the orders of growth of the space and\nnumber of steps used by this process as the amount to be changed\nincreases?\n<p><p>\n\n<p><a name="%_thm_1.15"></a>\n<b>Exercise 1.15.</b>&nbsp;&nbsp;<a name="%_idx_786"></a>The sine of an angle (specified in\nradians) can be computed by making use of the approximation\n<tt>sin</tt> <em>x</em> <img src="book-Z-G-D-20.gif" border="0">  <em>x</em>\nif <em>x</em> is\nsufficiently small, and the trigonometric identity \n<p><div align=left><img src="ch1-Z-G-19.gif" border="0"></div><p> \nto reduce the size of the argument of <tt>sin</tt>.  (For\npurposes of this exercise an angle is considered ``sufficiently\nsmall\'\' if its magnitude is not greater than 0.1 radians.) These\nideas are incorporated in the following procedures:<p>\n\n<p><p><tt><a name="%_idx_788"></a>(define&nbsp;(cube&nbsp;x)&nbsp;(*&nbsp;x&nbsp;x&nbsp;x))<br>\n(define&nbsp;(p&nbsp;x)&nbsp;(-&nbsp;(*&nbsp;3&nbsp;x)&nbsp;(*&nbsp;4&nbsp;(cube&nbsp;x))))<br>\n(define&nbsp;(sine&nbsp;angle)<br>\n&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;(&gt;&nbsp;(abs&nbsp;angle)&nbsp;0.1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angle<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p&nbsp;(sine&nbsp;(/&nbsp;angle&nbsp;3.0)))))<br>\n</tt><p><p><p>\n\na.&nbsp;&nbsp;How many times is the procedure <tt>p</tt> \napplied when <tt>(sine 12.15)</tt> is evaluated?<p>\n\nb.&nbsp;&nbsp;What is the order of growth in space and number of steps (as a\nfunction of&nbsp;<em>a</em>) used by the process generated by the <tt>sine</tt>\nprocedure when <tt>(sine a)</tt> is evaluated?\n<p><p>\n\n<a name="%_sec_1.2.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.2.4">1.2.4&nbsp;&nbsp;Exponentiation</a></h3><p>\n\n\n<a name="%_idx_790"></a>\n\nConsider the problem of computing the exponential of a given number.\nWe would like a procedure that takes as arguments a base <em>b</em> and a\npositive integer exponent <em>n</em> and computes <em>b</em><sup><em>n</em></sup>.  One way to do this\nis via the recursive definition\n<p><div align=left><img src="ch1-Z-G-20.gif" border="0"></div><p>\nwhich translates readily into the procedure <p>\n\n<p><p><tt><a name="%_idx_792"></a>(define&nbsp;(expt&nbsp;b&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;b&nbsp;(expt&nbsp;b&nbsp;(-&nbsp;n&nbsp;1)))))<br>\n</tt><p><p>\nThis is a linear recursive process, which requires <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) steps\nand <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) space.  Just as with factorial, we can readily\nformulate an equivalent linear iteration:<p>\n\n\n<p><p><tt><a name="%_idx_794"></a>(define&nbsp;(expt&nbsp;b&nbsp;n)<br>\n&nbsp;&nbsp;(expt-iter&nbsp;b&nbsp;n&nbsp;1))<br>\n<br>\n(define&nbsp;(expt-iter&nbsp;b&nbsp;counter&nbsp;product)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;counter&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(expt-iter&nbsp;b<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;counter&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;b&nbsp;product))))&nbsp;<br>\n</tt><p><p>\nThis version requires <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) steps and <img src="book-Z-G-D-3.gif" border="0">(1) space.<p>\n\n<a name="%_idx_796"></a>We can compute exponentials in fewer steps by using successive\nsquaring.  For instance, rather than computing <em>b</em><sup>8</sup> as\n<p><div align=left><img src="ch1-Z-G-21.gif" border="0"></div><p>\nwe can compute it using three multiplications:\n<p><div align=left><img src="ch1-Z-G-22.gif" border="0"></div><p><p>\n\nThis method works fine for exponents that are powers of 2.  We can\nalso take advantage of successive squaring in computing exponentials\nin general if we use the rule<p>\n\n<p><div align=left><img src="ch1-Z-G-23.gif" border="0"></div><p>\nWe can express this method as a procedure:<p>\n\n\n<p><p><tt><a name="%_idx_798"></a>(define&nbsp;(fast-expt&nbsp;b&nbsp;n)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;n&nbsp;0)&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((even?&nbsp;n)&nbsp;(square&nbsp;(fast-expt&nbsp;b&nbsp;(/&nbsp;n&nbsp;2))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(*&nbsp;b&nbsp;(fast-expt&nbsp;b&nbsp;(-&nbsp;n&nbsp;1))))))<br>\n</tt><p><p>\nwhere the predicate to test whether an integer is even is defined in terms of\nthe <a name="%_idx_800"></a><a name="%_idx_802"></a>primitive procedure <tt>remainder</tt> by\n<p>\n\n\n<p><p><tt><a name="%_idx_804"></a>(define&nbsp;(even?&nbsp;n)<br>\n&nbsp;&nbsp;(=&nbsp;(remainder&nbsp;n&nbsp;2)&nbsp;0))<br>\n</tt><p><p>\n<a name="%_idx_806"></a><a name="%_idx_808"></a>The process evolved by <tt>fast-expt</tt> grows logarithmically with <em>n</em>\nin both space and number of steps.  To see this, observe that\ncomputing <em>b</em><sup>2<em>n</em></sup> using <tt>fast-expt</tt> requires only one more\nmultiplication than computing <em>b</em><sup><em>n</em></sup>.  The size of the exponent we can\ncompute therefore doubles (approximately) with every new\nmultiplication we are allowed.  Thus, the number of multiplications\nrequired for an exponent of <em>n</em> grows about as fast as the logarithm\nof <em>n</em> to the base 2.  The process has <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>)\ngrowth.<a name="call_footnote_Temp_62" href="#footnote_Temp_62"><sup><small>37</small></sup></a><p>\n\nThe difference between <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>) growth and <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) growth\nbecomes striking as <em>n</em> becomes large.  For example, <tt>fast-expt</tt>\nfor <em>n</em> = 1000 requires only 14 multiplications.<a name="call_footnote_Temp_63" href="#footnote_Temp_63"><sup><small>38</small></sup></a> It is also possible to use the idea of\nsuccessive squaring to devise an iterative algorithm that computes\nexponentials with a logarithmic number of steps\n(see exercise&nbsp;<a href="#%_thm_1.16">1.16</a>), although, as is often\nthe case with iterative algorithms, this is not written down so\nstraightforwardly as the recursive algorithm.<a name="call_footnote_Temp_64" href="#footnote_Temp_64"><sup><small>39</small></sup></a>\n\n<p>\n\n<p><a name="%_thm_1.16"></a>\n<b>Exercise 1.16.</b>&nbsp;&nbsp;Design a procedure that evolves an iterative exponentiation process\nthat uses successive squaring and uses a logarithmic number of steps,\nas does <tt>fast-expt</tt>.  (Hint: Using the observation that\n(<em>b</em><sup><em>n</em>/2</sup>)<sup>2</sup>  = (<em>b</em><sup>2</sup>)<sup><em>n</em>/2</sup>, keep, along with the exponent <em>n</em> and the\nbase <em>b</em>, an additional state variable <em>a</em>, and define the state\ntransformation in such a way that the product <em>a</em> <em>b</em><sup><em>n</em></sup> is unchanged\nfrom state to state.  At the beginning of the process <em>a</em> is taken to\nbe 1, and the answer is given by the value of <em>a</em> at the end of the\nprocess.  In general, the technique of defining an <a name="%_idx_816"></a><em>invariant\nquantity</em> that remains unchanged from state to state is a powerful way\nto think about the <a name="%_idx_818"></a>design of iterative algorithms.)\n\n<p><p>\n\n<p><a name="%_thm_1.17"></a>\n<b>Exercise 1.17.</b>&nbsp;&nbsp;The exponentiation algorithms in this section are based on performing\nexponentiation by means of repeated multiplication.  In a similar way,\none can perform integer multiplication by means of repeated addition.\nThe following multiplication procedure (in which it is assumed that\nour language can only add, not multiply) is analogous to the <tt>expt</tt> procedure:<p>\n\n<p><p><tt>(define&nbsp;(*&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;b&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;a&nbsp;(*&nbsp;a&nbsp;(-&nbsp;b&nbsp;1)))))<br>\n</tt><p><p>\n\nThis algorithm takes a number of steps that is linear in <tt>b</tt>.\nNow suppose we include, together with addition, operations <tt>double</tt>,\nwhich doubles an integer, and <tt>halve</tt>, which divides an (even)\ninteger by 2.  Using these, design a multiplication procedure analogous\nto <tt>fast-expt</tt> that uses a logarithmic number of steps. \n<p><p>\n\n<p><a name="%_thm_1.18"></a>\n<b>Exercise 1.18.</b>&nbsp;&nbsp;Using the results of exercises&nbsp;<a href="#%_thm_1.16">1.16</a>\nand&nbsp;<a href="#%_thm_1.17">1.17</a>, devise a procedure that generates an iterative\nprocess for multiplying two integers in terms of adding, doubling, and\nhalving and uses a logarithmic number of steps.<a name="call_footnote_Temp_68" href="#footnote_Temp_68"><sup><small>40</small></sup></a>\n\n<p><p>\n\n<p><a name="%_thm_1.19"></a>\n<b>Exercise 1.19.</b>&nbsp;&nbsp;\n<a name="%_idx_828"></a>There is a clever algorithm for computing the Fibonacci numbers in\na logarithmic number of steps.\nRecall the transformation of the state variables\n<em>a</em> and <em>b</em> in the <tt>fib-iter</tt> process of\nsection&nbsp;<a href="#%_sec_1.2.2">1.2.2</a>: <em>a</em> <img src="book-Z-G-D-14.gif" border="0">  <em>a</em> + <em>b</em> and <em>b</em> <img src="book-Z-G-D-14.gif" border="0"> \n<em>a</em>.  Call this transformation <em>T</em>, and observe that applying <em>T</em> over\nand over again <em>n</em> times, starting with 1 and 0, produces the pair\n <em>F</em><em>i</em><em>b</em>(<em>n</em> + 1) and  <em>F</em><em>i</em><em>b</em>(<em>n</em>).  In other words, the Fibonacci\nnumbers are produced by applying <em>T</em><sup><em>n</em></sup>, the <em>n</em>th power of the\ntransformation <em>T</em>, starting with the pair (1,0).  Now consider <em>T</em>\nto be the special case of <em>p</em> = 0 and <em>q</em> = 1 in a family of\ntransformations <em>T</em><sub><em>p</em><em>q</em></sub>, where <em>T</em><sub><em>p</em><em>q</em></sub> transforms the pair (<em>a</em>,<em>b</em>)\naccording to <em>a</em> <img src="book-Z-G-D-14.gif" border="0">  <em>b</em><em>q</em> + <em>a</em><em>q</em> + <em>a</em><em>p</em> and <em>b</em> <img src="book-Z-G-D-14.gif" border="0">  <em>b</em><em>p</em> + <em>a</em><em>q</em>.  Show\nthat if we apply such a transformation <em>T</em><sub><em>p</em><em>q</em></sub> twice, the effect is\nthe same as using a single transformation <em>T</em><sub><em>p</em>\'<em>q</em>\'</sub> of the same form,\nand compute <em>p</em>\' and <em>q</em>\' in terms of <em>p</em> and&nbsp;<em>q</em>.  This gives us an\nexplicit way to square these transformations, and thus we can compute\n<em>T</em><sup><em>n</em></sup> using successive squaring, as in the <tt>fast-expt</tt>\nprocedure.  Put this all together to complete the following procedure,\nwhich runs in a logarithmic number of steps:<a name="call_footnote_Temp_70" href="#footnote_Temp_70"><sup><small>41</small></sup></a><p>\n\n<p><p><tt>(define&nbsp;(fib&nbsp;n)<br>\n&nbsp;&nbsp;(fib-iter&nbsp;1&nbsp;0&nbsp;0&nbsp;1&nbsp;n))<br>\n(define&nbsp;(fib-iter&nbsp;a&nbsp;b&nbsp;p&nbsp;q&nbsp;count)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;count&nbsp;0)&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((even?&nbsp;count)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fib-iter&nbsp;a<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>??</em>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;compute&nbsp;<em>p</em>\'</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>??</em>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;compute&nbsp;<em>q</em>\'</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;count&nbsp;2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(fib-iter&nbsp;(+&nbsp;(*&nbsp;b&nbsp;q)&nbsp;(*&nbsp;a&nbsp;q)&nbsp;(*&nbsp;a&nbsp;p))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(*&nbsp;b&nbsp;p)&nbsp;(*&nbsp;a&nbsp;q))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;count&nbsp;1)))))<br>\n</tt><p><p>\n<p><p>\n\n<a name="%_sec_1.2.5"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.2.5">1.2.5&nbsp;&nbsp;Greatest Common Divisors</a></h3><p>\n\n\n<a name="%_idx_834"></a>\nThe greatest common divisor (GCD) of two integers <em>a</em> and <em>b</em> is\ndefined to be the largest integer that divides both <em>a</em> and\n<em>b</em> with no remainder.  For example, the GCD of 16 and 28 is 4.  In chapter&nbsp;2,\nwhen we investigate how to implement rational-number arithmetic, we\nwill need to be able to compute GCDs in order to reduce\nrational numbers to lowest terms.  (To reduce a rational number to\nlowest terms, we must divide both the numerator and the denominator by their\nGCD.  For example, 16/28 reduces to 4/7.)  One way to find the\nGCD of two integers is to factor them and search for common\nfactors, but there is a famous algorithm that is much more efficient.<p>\n\n<a name="%_idx_836"></a>The idea of the algorithm is based on the observation that, if <em>r</em> is\nthe remainder when <em>a</em> is divided by <em>b</em>, then the common divisors of\n<em>a</em> and <em>b</em> are precisely the same as the common divisors of <em>b</em> and\n<em>r</em>.  Thus, we can use the equation\n<p><div align=left><img src="ch1-Z-G-24.gif" border="0"></div><p>\nto successively reduce the problem of computing a GCD to the\nproblem of computing the GCD of smaller and smaller pairs of\nintegers.  For example,\n<p><div align=left><img src="ch1-Z-G-25.gif" border="0"></div><p>\nreduces GCD(206,40) to GCD(2,0), which is 2.  It is\npossible to show that starting with any two positive integers and\nperforming repeated reductions will always eventually produce a pair\nwhere the second number is 0.  Then the GCD is the other\nnumber in the pair.  This method for computing the GCD is\nknown as <em>Euclid\'s Algorithm</em>.<a name="call_footnote_Temp_71" href="#footnote_Temp_71"><sup><small>42</small></sup></a><p>\n\nIt is easy to express Euclid\'s Algorithm as a procedure:\n<p><p><tt><a name="%_idx_842"></a>(define&nbsp;(gcd&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;b&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gcd&nbsp;b&nbsp;(remainder&nbsp;a&nbsp;b))))<br>\n</tt><p><p>\nThis generates an iterative process, whose number of steps grows as\nthe logarithm of the numbers involved.<p>\n\n<a name="%_idx_844"></a>The fact that the number of steps required by Euclid\'s Algorithm has\nlogarithmic growth bears an interesting relation to the Fibonacci\nnumbers:<p>\n\n<p><p><a name="%_idx_846"></a><a name="%_idx_848"></a><strong>Lam&eacute;\'s Theorem:</strong> If Euclid\'s Algorithm requires <em>k</em> steps to\ncompute the GCD of some pair, then the smaller number in the pair\nmust be greater than or equal to the <em>k</em>th Fibonacci\nnumber.<a name="call_footnote_Temp_72" href="#footnote_Temp_72"><sup><small>43</small></sup></a><p>\n\n<p><p><p>\n\nWe can use this theorem to get an order-of-growth estimate for Euclid\'s\nAlgorithm.  Let <em>n</em> be the smaller of the two inputs to the\nprocedure.  If the process takes <em>k</em> steps, then we must have \n<em>n</em><u>&gt;</u>  <em>F</em><em>i</em><em>b</em> (<em>k</em>) <img src="book-Z-G-D-20.gif" border="0"> <img src="book-Z-G-D-11.gif" border="0"><sup><em>k</em></sup>/<img src="book-Z-G-D-13.gif" border="0">5.  Therefore\nthe number of steps <em>k</em> grows as the logarithm (to the base\n<img src="book-Z-G-D-11.gif" border="0">) of <em>n</em>.  Hence, the order of growth is <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>).<p>\n\n<p><a name="%_thm_1.20"></a>\n<b>Exercise 1.20.</b>&nbsp;&nbsp;<a name="%_idx_852"></a><a name="%_idx_854"></a>The process that a procedure generates is of course dependent on the\nrules used by the interpreter.  As an example, consider the iterative\n<tt>gcd</tt> procedure given above.\nSuppose we were to interpret this procedure using normal-order\nevaluation, as discussed in section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a>.\n(The normal-order-evaluation rule for <tt>if</tt> is described in\nexercise&nbsp;<a href="book-Z-H-10.html#%_thm_1.5">1.5</a>.)  Using the\nsubstitution method (for normal order), illustrate the process\ngenerated in evaluating <tt>(gcd 206 40)</tt> and indicate the\n<tt>remainder</tt> operations that are actually performed.\nHow many <tt>remainder</tt> operations are actually performed\nin the normal-order evaluation of <tt>(gcd 206&nbsp;40)</tt>?\nIn the applicative-order evaluation?\n<p><p>\n\n<a name="%_sec_1.2.6"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.2.6">1.2.6&nbsp;&nbsp;Example: Testing for Primality</a></h3><p>\n\n\n<a name="%_idx_856"></a><a name="%_idx_858"></a>\nThis section describes two methods for checking the primality of an\ninteger <em>n</em>, one with order of growth <img src="book-Z-G-D-3.gif" border="0">(<img src="book-Z-G-D-13.gif" border="0"><em>n</em>), and a\n``probabilistic\'\' algorithm with order of growth <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>).  The\nexercises at the end of this section suggest programming\nprojects based on these algorithms.<p>\n\n<a name="%_sec_Temp_74"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_74">Searching for divisors</a></h4><p>\n\nSince ancient times, mathematicians have been fascinated by problems\nconcerning prime numbers, and many people have worked on the problem\nof determining ways to test if numbers are prime.  One way\nto test if a number is prime is to find the number\'s divisors.  The\nfollowing program finds the smallest integral divisor (greater than 1)\nof a given number&nbsp;<em>n</em>.  It does this in a straightforward way, by\ntesting <em>n</em> for divisibility by successive integers starting with 2.<p>\n\n<p><p><tt><a name="%_idx_860"></a>(define&nbsp;(smallest-divisor&nbsp;n)<br>\n&nbsp;&nbsp;(find-divisor&nbsp;n&nbsp;2))<br>\n<a name="%_idx_862"></a>(define&nbsp;(find-divisor&nbsp;n&nbsp;test-divisor)<br>\n&nbsp;&nbsp;(cond&nbsp;((&gt;&nbsp;(square&nbsp;test-divisor)&nbsp;n)&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((divides?&nbsp;test-divisor&nbsp;n)&nbsp;test-divisor)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(find-divisor&nbsp;n&nbsp;(+&nbsp;test-divisor&nbsp;1)))))<br>\n<a name="%_idx_864"></a>(define&nbsp;(divides?&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(=&nbsp;(remainder&nbsp;b&nbsp;a)&nbsp;0))<br>\n</tt><p><p><p>\n\nWe can test whether a number is prime as follows: <em>n</em> is prime if\nand only if <em>n</em> is its own smallest divisor.<p>\n\n<p><p><tt><a name="%_idx_866"></a>(define&nbsp;(prime?&nbsp;n)<br>\n&nbsp;&nbsp;(=&nbsp;n&nbsp;(smallest-divisor&nbsp;n)))<br>\n</tt><p><p><p>\n\nThe end test for <tt>find-divisor</tt> is based on the fact that if <em>n</em>\nis not prime it must have a divisor less than or equal to\n<img src="book-Z-G-D-13.gif" border="0"><em>n</em>.<a name="call_footnote_Temp_75" href="#footnote_Temp_75"><sup><small>44</small></sup></a>  This\nmeans that the algorithm need only test divisors between 1 and\n<img src="book-Z-G-D-13.gif" border="0"><em>n</em>.  Consequently, the number of steps required to identify\n<em>n</em> as prime will have order of growth <img src="book-Z-G-D-3.gif" border="0">(<img src="book-Z-G-D-13.gif" border="0"><em>n</em>).<p>\n\n<a name="%_sec_Temp_76"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_76">The Fermat test</a></h4><p>\n\n<a name="%_idx_868"></a><a name="%_idx_870"></a>The <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>) primality test is based on a result from number\ntheory known as Fermat\'s Little Theorem.<a name="call_footnote_Temp_77" href="#footnote_Temp_77"><sup><small>45</small></sup></a><p>\n\n<p><p><a name="%_idx_886"></a><strong>Fermat\'s Little Theorem:</strong> If <em>n</em> is a prime number and \n<em>a</em> is any positive integer less than <em>n</em>, then <em>a</em> raised to the\n<em>n</em>th power is congruent to <em>a</em> modulo <em>n</em>.<p>\n\n<p><p><a name="%_idx_888"></a>(Two numbers are said to be <em>congruent modulo</em> <em>n</em> if\nthey both have the same remainder when divided by <em>n</em>.  The\nremainder of a number <em>a</em> when divided by <em>n</em> is also referred to as\nthe <a name="%_idx_890"></a><a name="%_idx_892"></a><em>remainder of</em> <em>a</em> <em>modulo</em> <em>n</em>, or simply as <em>a</em> \n<em>modulo</em> <em>n</em>.)<p>\n\nIf <em>n</em> is not prime, then, in general, most of the numbers <em>a</em>&lt; <em>n</em> will not\nsatisfy the above relation.  This leads to the following algorithm for\ntesting primality: Given a number <em>n</em>, pick a <a name="%_idx_894"></a>random number <em>a</em> &lt; <em>n</em> and\ncompute the remainder of <em>a</em><sup><em>n</em></sup> modulo <em>n</em>.  If the result is not equal to\n<em>a</em>, then <em>n</em> is certainly not prime.  If it is <em>a</em>, then chances are good\nthat <em>n</em> is prime.  Now pick another random number <em>a</em> and test it with the\nsame method.  If it also satisfies the equation, then we can be even more\nconfident that <em>n</em> is prime.  By trying more and more values of <em>a</em>, we can\nincrease our confidence in the result.  This algorithm is known as the\nFermat test.<p>\n\n<a name="%_idx_896"></a>To implement the Fermat test, we need a procedure that computes the\nexponential of a number modulo another number:<p>\n\n<p><p><tt><a name="%_idx_898"></a>(define&nbsp;(expmod&nbsp;base&nbsp;exp&nbsp;m)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;exp&nbsp;0)&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((even?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(remainder&nbsp;(square&nbsp;(expmod&nbsp;base&nbsp;(/&nbsp;exp&nbsp;2)&nbsp;m))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(remainder&nbsp;(*&nbsp;base&nbsp;(expmod&nbsp;base&nbsp;(-&nbsp;exp&nbsp;1)&nbsp;m))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m))))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>\n</tt><p><p>\nThis is very similar to the <tt>fast-expt</tt> procedure of\nsection&nbsp;<a href="#%_sec_1.2.4">1.2.4</a>.  It uses successive squaring, so\nthat the number of steps grows logarithmically with the\nexponent.<a name="call_footnote_Temp_78" href="#footnote_Temp_78"><sup><small>46</small></sup></a><p>\n\nThe Fermat test is performed by choosing at random a number <em>a</em>\nbetween 1 and <em>n</em> - 1 inclusive and checking whether the remainder\nmodulo <em>n</em> of the <em>n</em>th power of <em>a</em> is equal to <em>a</em>.  The random\nnumber <em>a</em> is chosen using the procedure <a name="%_idx_900"></a><a name="%_idx_902"></a><tt>random</tt>, which we assume is\nincluded as a primitive in Scheme. <tt>Random</tt> returns a\nnonnegative integer less than its integer input.  Hence, to obtain a random\nnumber between 1 and <em>n</em> - 1, we call <tt>random</tt> with an input of\n<em>n</em> - 1 and add 1 to the result:<p>\n\n<p><p><tt><a name="%_idx_904"></a>(define&nbsp;(fermat-test&nbsp;n)<br>\n&nbsp;&nbsp;(define&nbsp;(try-it&nbsp;a)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(=&nbsp;(expmod&nbsp;a&nbsp;n&nbsp;n)&nbsp;a))<br>\n&nbsp;&nbsp;(try-it&nbsp;(+&nbsp;1&nbsp;(random&nbsp;(-&nbsp;n&nbsp;1)))))<br>\n</tt><p><p><p>\n\nThe following procedure runs the test a given number of times, as\nspecified by a parameter.  Its value is true if the test succeeds\nevery time, and false otherwise.<p>\n\n<p><p><tt><a name="%_idx_906"></a>(define&nbsp;(fast-prime?&nbsp;n&nbsp;times)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;times&nbsp;0)&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((fermat-test&nbsp;n)&nbsp;(fast-prime?&nbsp;n&nbsp;(-&nbsp;times&nbsp;1)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;false)))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_79"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_79">Probabilistic methods</a></h4><p>\n\n<a name="%_idx_908"></a><a name="%_idx_910"></a>\nThe Fermat test differs in character from most familiar algorithms, in\nwhich one computes an answer that is guaranteed to be correct.  Here,\nthe answer obtained is only probably correct.  More precisely, if <em>n</em>\never fails the Fermat test, we can be certain that <em>n</em> is not prime.\nBut the fact that <em>n</em> passes the test, while an extremely strong\nindication, is still not a guarantee that <em>n</em> is prime.  What we would\nlike to say is that for any number <em>n</em>, if we perform the test enough\ntimes and find that <em>n</em> always passes the test, then the probability\nof error in our primality test can be made as small as we like.<p>\n\n\nUnfortunately, this assertion is not quite correct.  There do exist\nnumbers that fool the Fermat test: numbers <em>n</em> that are not prime and\nyet have the property that <em>a</em><sup><em>n</em></sup> is congruent to <em>a</em> modulo <em>n</em> for\nall integers <em>a</em> &lt; <em>n</em>.  Such numbers are extremely rare, so the Fermat\ntest is quite reliable in practice.<a name="call_footnote_Temp_80" href="#footnote_Temp_80"><sup><small>47</small></sup></a>\nThere are variations of the Fermat test that cannot be fooled.  In\nthese tests, as with the Fermat method, one tests the primality of an\ninteger <em>n</em> by choosing a random integer <em>a</em>&lt;<em>n</em> and checking some\ncondition that depends upon <em>n</em> and <em>a</em>.  (See\nexercise&nbsp;<a href="#%_thm_1.28">1.28</a> for an example of such a test.)  On the\nother hand, in contrast to the Fermat test, one can prove that, for\nany <em>n</em>, the condition does not hold for most of the integers <em>a</em>&lt;<em>n</em>\nunless <em>n</em> is prime.  Thus, if <em>n</em> passes the test for some random\nchoice of&nbsp;<em>a</em>, the chances are better than even that <em>n</em> is prime.  If\n<em>n</em> passes the test for two random choices of <em>a</em>, the chances are better\nthan 3 out of 4 that <em>n</em> is prime. By running the test with more and\nmore randomly chosen values of <em>a</em> we can make the probability of\nerror as small as we like.<p>\n\nThe existence of tests for which one can prove that the chance of\nerror becomes arbitrarily small has sparked interest in algorithms of\nthis type, which have come to be known as <em>probabilistic\nalgorithms</em>.  There is a great deal of research activity in this area,\nand probabilistic algorithms have been fruitfully applied to many\nfields.<a name="call_footnote_Temp_81" href="#footnote_Temp_81"><sup><small>48</small></sup></a><p>\n\n<p><a name="%_thm_1.21"></a>\n<b>Exercise 1.21.</b>&nbsp;&nbsp;Use the <tt>smallest-divisor</tt> procedure to find the smallest divisor\nof each of the following numbers: 199, 1999, 19999.\n<p><p>\n\n<p><a name="%_thm_1.22"></a>\n<b>Exercise 1.22.</b>&nbsp;&nbsp;<a name="%_idx_932"></a><a name="%_idx_934"></a>Most Lisp implementations include a primitive called <tt>runtime</tt>\nthat returns an integer that specifies the amount of time the system\nhas been running (measured, for example, in microseconds).  The\nfollowing <tt>timed-prime-test</tt> procedure, when called with an\ninteger <em>n</em>, prints <em>n</em> and checks to see if <em>n</em> is prime.  If <em>n</em> is\nprime, the procedure prints three asterisks followed by the amount of time\nused in performing the test.<p>\n\n<p><p><tt><a name="%_idx_936"></a><a name="%_idx_938"></a><a name="%_idx_940"></a>(define&nbsp;(timed-prime-test&nbsp;n)<br>\n&nbsp;&nbsp;(newline)<br>\n&nbsp;&nbsp;(display&nbsp;n)<br>\n&nbsp;&nbsp;(start-prime-test&nbsp;n&nbsp;(runtime)))<br>\n(define&nbsp;(start-prime-test&nbsp;n&nbsp;start-time)<br>\n&nbsp;&nbsp;(if&nbsp;(prime?&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(report-prime&nbsp;(-&nbsp;(runtime)&nbsp;start-time))))<br>\n(define&nbsp;(report-prime&nbsp;elapsed-time)<br>\n&nbsp;&nbsp;(display&nbsp;&quot;&nbsp;***&nbsp;&quot;)<br>\n&nbsp;&nbsp;(display&nbsp;elapsed-time))<br>\n</tt><p><p>\nUsing this procedure, write a procedure <tt>search-for-primes</tt> that\nchecks the primality of consecutive odd integers in a specified range.\nUse your procedure to find the three smallest primes larger than 1000;\nlarger than 10,000; larger than 100,000; larger than 1,000,000.  Note\nthe time needed to test each prime.  Since the testing algorithm has\norder of growth of <img src="book-Z-G-D-3.gif" border="0">(<img src="book-Z-G-D-13.gif" border="0"><em>n</em>), you should expect that testing\nfor primes around 10,000 should take about <img src="book-Z-G-D-13.gif" border="0">10 times as long\nas testing for primes around 1000.  Do your timing data bear this out?\nHow well do the data for 100,000 and 1,000,000 support the <img src="book-Z-G-D-13.gif" border="0"><em>n</em>\nprediction?  Is your result compatible with the notion that programs\non your machine run in time proportional to the number of steps\nrequired for the computation?\n\n<p><p>\n\n<p><a name="%_thm_1.23"></a>\n<b>Exercise 1.23.</b>&nbsp;&nbsp;<a name="%_idx_942"></a>The <tt>smallest-divisor</tt> procedure shown at the start of this section\ndoes lots of needless testing: After it checks to see if the\nnumber is divisible by 2 there is no point in checking to see if\nit is divisible by any larger even numbers.  This suggests that the\nvalues used for <tt>test-divisor</tt> should not be 2, 3, 4, 5, 6,\n<tt>...</tt>, but rather 2, 3, 5, 7, 9, <tt>...</tt>.  To implement this\nchange, define a procedure <tt>next</tt> that returns 3 if its input is\nequal to 2 and otherwise returns its input plus&nbsp;2.  Modify the <tt>smallest-divisor</tt> procedure to use <tt>(next test-divisor)</tt> instead\nof <tt>(+ test-divisor 1)</tt>.  With <tt>timed-prime-test</tt>\nincorporating this modified version of <tt>smallest-divisor</tt>, run the\ntest for each of the 12 primes found in\nexercise&nbsp;<a href="#%_thm_1.22">1.22</a>.  Since this modification halves the\nnumber of test steps, you should expect it to run about twice as fast.\nIs this expectation confirmed?  If not, what is the observed ratio of\nthe speeds of the two algorithms, and how do you explain the fact that\nit is different from 2?\n<p><p>\n\n<p><a name="%_thm_1.24"></a>\n<b>Exercise 1.24.</b>&nbsp;&nbsp;Modify the <tt>timed-prime-test</tt> procedure of\nexercise&nbsp;<a href="#%_thm_1.22">1.22</a> to use <tt>fast-prime?</tt> (the\nFermat method), and test each of the 12 primes you found in that\nexercise.  Since the Fermat test has <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>) growth, how\nwould you expect the time to test primes near 1,000,000 to compare\nwith the time needed to test primes near 1000?  Do your data bear this\nout?  Can you explain any discrepancy you find?\n\n<p><p>\n\n<p><a name="%_thm_1.25"></a>\n<b>Exercise 1.25.</b>&nbsp;&nbsp;Alyssa P. Hacker complains that we went to a lot of extra work in\nwriting <tt>expmod</tt>.  After all, she says, since we already know how\nto compute exponentials, we could have simply written<p>\n\n<p><p><tt><a name="%_idx_944"></a>(define&nbsp;(expmod&nbsp;base&nbsp;exp&nbsp;m)<br>\n&nbsp;&nbsp;(remainder&nbsp;(fast-expt&nbsp;base&nbsp;exp)&nbsp;m))<br>\n</tt><p><p>\nIs she correct?  Would this procedure serve as well for our fast prime\ntester?  Explain.\n\n<p><p>\n\n<p><a name="%_thm_1.26"></a>\n<b>Exercise 1.26.</b>&nbsp;&nbsp;Louis Reasoner is having great difficulty doing\nexercise&nbsp;<a href="#%_thm_1.24">1.24</a>.  His <tt>fast-prime?</tt> test\nseems to run more slowly than his <tt>prime?</tt> test.  Louis calls his\nfriend Eva Lu Ator over to help.  When they examine Louis\'s code, they\nfind that he has rewritten the <tt>expmod</tt> procedure to use an\nexplicit multiplication, rather than calling <tt>square</tt>:<p>\n\n<p><p><tt><a name="%_idx_946"></a>(define&nbsp;(expmod&nbsp;base&nbsp;exp&nbsp;m)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;exp&nbsp;0)&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((even?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(remainder&nbsp;(*&nbsp;(expmod&nbsp;base&nbsp;(/&nbsp;exp&nbsp;2)&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(expmod&nbsp;base&nbsp;(/&nbsp;exp&nbsp;2)&nbsp;m))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(remainder&nbsp;(*&nbsp;base&nbsp;(expmod&nbsp;base&nbsp;(-&nbsp;exp&nbsp;1)&nbsp;m))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m))))<br>\n</tt><p><p>\n``I don\'t see what difference that could make,\'\' says Louis.  ``I\ndo.\'\'  says Eva.  ``By writing the procedure like that, you have\ntransformed the <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>) process into a <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) process.\'\'\nExplain.\n<p><p>\n\n<p><a name="%_thm_1.27"></a>\n<b>Exercise 1.27.</b>&nbsp;&nbsp;<a name="%_idx_948"></a>Demonstrate that the Carmichael numbers listed in\nfootnote&nbsp;<a href="#footnote_Temp_80">47</a> really do fool\nthe Fermat test.  That is, write a procedure that takes an integer <em>n</em>\nand tests whether <em>a</em><sup><em>n</em></sup> is congruent to <em>a</em> modulo <em>n</em> for every\n<em>a</em>&lt;<em>n</em>, and try your procedure on the given Carmichael numbers.\n<p><p>\n\n\n<p><a name="%_thm_1.28"></a>\n<b>Exercise 1.28.</b>&nbsp;&nbsp;<a name="%_idx_950"></a><a name="%_idx_952"></a><a name="%_idx_954"></a><a name="%_idx_956"></a><a name="%_idx_958"></a>One variant of the Fermat test that cannot be fooled is called the\n<em>Miller-Rabin test</em> (Miller 1976; Rabin 1980).  This starts from\n<a name="%_idx_960"></a>an alternate form of Fermat\'s Little Theorem, which states that if <em>n</em>\nis a prime number and <em>a</em> is any positive integer less than <em>n</em>, then\n<em>a</em> raised to the (<em>n</em> - 1)st power is congruent to 1 modulo&nbsp;<em>n</em>.  To test\nthe primality of a number <em>n</em> by the Miller-Rabin test, we pick a\nrandom number <em>a</em>&lt;<em>n</em> and raise <em>a</em> to the (<em>n</em> - 1)st power modulo&nbsp;<em>n</em>\nusing the <tt>expmod</tt> procedure.  However, whenever we perform the\nsquaring step in <tt>expmod</tt>, we check to see if we have discovered a\n``nontrivial square root of 1 modulo&nbsp;<em>n</em>,\'\' that is, a number not\nequal to 1 or <em>n</em> - 1 whose square is equal to 1 modulo&nbsp;<em>n</em>.  It is\npossible to prove that if such a nontrivial square root of 1 exists,\nthen <em>n</em> is not prime.  It is also possible to prove that if <em>n</em> is an\nodd number that is not prime, then, for at least half the numbers\n<em>a</em>&lt;<em>n</em>, computing <em>a</em><sup><em>n</em>-1</sup> in this way will reveal a nontrivial\nsquare root of 1 modulo&nbsp;<em>n</em>.  (This is why the Miller-Rabin test\ncannot be fooled.)  Modify the <tt>expmod</tt> procedure to signal if it\ndiscovers a nontrivial square root of 1, and use this to implement\nthe Miller-Rabin test with a procedure analogous to <tt>fermat-test</tt>.\nCheck your procedure by testing various known primes and non-primes.\nHint: One convenient way to make <tt>expmod</tt> signal is to have it\nreturn 0.\n\n<p><p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_46" href="#call_footnote_Temp_46"><sup><small>29</small></sup></a> In a real program we would probably use the\nblock structure introduced in the last section to hide the definition\nof <tt>fact-iter</tt>:\n<p><p><tt>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;product&nbsp;counter)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;counter&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;(*&nbsp;counter&nbsp;product)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;counter&nbsp;1))))<br>\n&nbsp;&nbsp;(iter&nbsp;1&nbsp;1))<br>\n</tt><p><p>\nWe avoided doing this here so as to minimize the number of things to\nthink about at once.\n\n<p><a name="footnote_Temp_47" href="#call_footnote_Temp_47"><sup><small>30</small></sup></a> When we discuss the implementation of\nprocedures on register machines in chapter&nbsp;5, we will see that any\niterative process can be realized ``in hardware\'\' as a machine that\nhas a fixed set of registers and no auxiliary memory.  In contrast,\nrealizing a recursive process requires a machine that uses an\n<a name="%_idx_678"></a>auxiliary data structure known as a <em>stack</em>.\n\n<p><a name="footnote_Temp_48" href="#call_footnote_Temp_48"><sup><small>31</small></sup></a> Tail recursion has long been\n<a name="%_idx_698"></a><a name="%_idx_700"></a><a name="%_idx_702"></a>known as a compiler optimization trick.  A coherent semantic basis for\ntail recursion was provided by Carl Hewitt (1977), who explained it in\n<a name="%_idx_704"></a>terms of the ``message-passing\'\' model of computation that we shall\ndiscuss in chapter&nbsp;3. Inspired by this, Gerald Jay Sussman and Guy\nLewis Steele Jr. (see Steele 1975) constructed a tail-recursive\ninterpreter for Scheme.  Steele later showed how tail recursion is a\nconsequence of the natural way to compile procedure calls (Steele\n1977).  The IEEE standard for Scheme requires that Scheme implementations\n<a name="%_idx_706"></a>be tail-recursive.\n\n<p><a name="footnote_Temp_51" href="#call_footnote_Temp_51"><sup><small>32</small></sup></a> An example of this was hinted\nat in section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.3">1.1.3</a>:\nThe interpreter itself evaluates expressions\nusing a tree-recursive process.\n\n<p><a name="footnote_Temp_53" href="#call_footnote_Temp_53"><sup><small>33</small></sup></a> For example, work through in detail how the\nreduction rule applies to the problem of making change for 10 cents\nusing pennies and nickels.\n\n<p><a name="footnote_Temp_54" href="#call_footnote_Temp_54"><sup><small>34</small></sup></a> One\napproach to coping with redundant computations is to arrange matters\nso that we automatically construct a table of values as they\nare computed.  Each time we are asked to apply the procedure to some\nargument, we first look to see if the value is already stored in the\ntable, in which case we avoid performing the redundant computation.\nThis strategy, known as <a name="%_idx_734"></a><a name="%_idx_736"></a><em>tabulation</em> or <em>memoization</em>, can be\nimplemented in a straightforward way.  Tabulation can sometimes be\nused to transform processes that require an exponential number of\nsteps (such as <tt>count-change</tt>) into processes whose space and time\nrequirements grow linearly with the input.  See\nexercise&nbsp;<a href="book-Z-H-22.html#%_thm_3.27">3.27</a>.\n\n<p><a name="footnote_Temp_57" href="#call_footnote_Temp_57"><sup><small>35</small></sup></a> The elements of Pascal\'s triangle are called the <em>binomial\ncoefficients</em>, because the <em>n</em>th row consists of\n<a name="%_idx_740"></a>the coefficients of the terms in the\nexpansion of (<em>x</em> + <em>y</em>)<sup><em>n</em></sup>.  This pattern for computing the coefficients\n<a name="%_idx_742"></a>appeared in Blaise Pascal\'s 1653 seminal work on probability theory, <em>Trait&eacute; du triangle arithm&eacute;tique</em>.  According to\n<a name="%_idx_744"></a>Knuth (1973), the same pattern appears in the <em>Szu-yuen\nY&uuml;-chien</em> (``The Precious Mirror of the Four Elements\'\'), published\n<a name="%_idx_746"></a><a name="%_idx_748"></a><a name="%_idx_750"></a>by the Chinese mathematician Chu Shih-chieh in 1303, in the\nworks of the twelfth-century Persian poet and mathematician Omar\nKhayyam, and in the works of the twelfth-century Hindu mathematician\nBh&aacute;scara &Aacute;ch&aacute;rya.\n\n<p><a name="footnote_Temp_59" href="#call_footnote_Temp_59"><sup><small>36</small></sup></a> These statements mask a\ngreat deal of oversimplification.  For instance, if we count process\nsteps as ``machine operations\'\' we are making the assumption that the\nnumber of machine operations needed to perform, say, a multiplication\nis independent of the size of the numbers to be multiplied, which is\nfalse if the numbers are sufficiently large.  Similar remarks hold for\nthe estimates of space.  Like the design and description of a process,\nthe analysis of a process can be carried out at various levels of\nabstraction.\n\n<p><a name="footnote_Temp_62" href="#call_footnote_Temp_62"><sup><small>37</small></sup></a> More precisely, the number of multiplications\nrequired is equal to 1 less than the log base 2 of <em>n</em> plus the number\nof ones in the binary representation of <em>n</em>.  This total is always\nless than twice the log base 2 of <em>n</em>.  The arbitrary constants\n<em>k</em><sub>1</sub> and <em>k</em><sub>2</sub> in\nthe definition of order notation imply that, for a logarithmic\nprocess, the base to which logarithms are taken does not matter, so\nall such processes are described as <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>).\n\n<p><a name="footnote_Temp_63" href="#call_footnote_Temp_63"><sup><small>38</small></sup></a> You may wonder\nwhy anyone would care about raising numbers to the 1000th power.  See\nsection&nbsp;<a href="#%_sec_1.2.6">1.2.6</a>.\n\n<p><a name="footnote_Temp_64" href="#call_footnote_Temp_64"><sup><small>39</small></sup></a> This iterative\nalgorithm is ancient.  It appears in the <em>Chandah-sutra</em> by\n<a name="%_idx_810"></a><a name="%_idx_812"></a><a name="%_idx_814"></a>&Aacute;ch&aacute;rya Pingala, written before 200 <font size=-2>B</font>.<font size=-2>C</font>. See Knuth 1981, section\n4.6.3, for a full discussion and analysis of this and other methods of\nexponentiation.\n\n<p><a name="footnote_Temp_68" href="#call_footnote_Temp_68"><sup><small>40</small></sup></a> This\n<a name="%_idx_820"></a><a name="%_idx_822"></a>algorithm, which is sometimes known as the ``Russian peasant method\'\'\nof multiplication, is ancient.  Examples of its use are found in the\n<a name="%_idx_824"></a>Rhind Papyrus, one of the two oldest mathematical documents in\nexistence, written about 1700 <font size=-2>B</font>.<font size=-2>C</font>. (and copied from an even\n<a name="%_idx_826"></a>older document) by an Egyptian scribe named A\'h-mose.\n\n<p><a name="footnote_Temp_70" href="#call_footnote_Temp_70"><sup><small>41</small></sup></a> This exercise was\n<a name="%_idx_830"></a><a name="%_idx_832"></a>suggested to us by Joe Stoy, based on an example in Kaldewaij 1990.\n\n<p><a name="footnote_Temp_71" href="#call_footnote_Temp_71"><sup><small>42</small></sup></a> Euclid\'s Algorithm is so\n<a name="%_idx_838"></a>called because it appears in Euclid\'s <em>Elements</em> (Book 7, ca. 300\n<font size=-2>B</font>.<font size=-2>C</font>.).  According to Knuth (1973), it can be considered the\n<a name="%_idx_840"></a>oldest known nontrivial algorithm.  The ancient Egyptian method of\nmultiplication (exercise&nbsp;<a href="#%_thm_1.18">1.18</a>) is surely older,\nbut, as Knuth explains, Euclid\'s algorithm is the oldest known to have\nbeen presented as a general algorithm, rather than as a set of\nillustrative examples.\n\n<p><a name="footnote_Temp_72" href="#call_footnote_Temp_72"><sup><small>43</small></sup></a> This theorem was proved in 1845 by Gabriel Lam&eacute;, a\n<a name="%_idx_850"></a>French mathematician and engineer known chiefly for his contributions\nto mathematical physics.  To prove the theorem, we consider pairs\n(<em>a</em><sub><em>k</em></sub> ,<em>b</em><sub><em>k</em></sub>), where <em>a</em><sub><em>k</em></sub><u>&gt;</u> <em>b</em><sub><em>k</em></sub>, for which Euclid\'s Algorithm\nterminates in <em>k</em> steps.  The proof is based on the claim that, if\n(<em>a</em><sub><em>k</em>+1</sub>, <em>b</em><sub><em>k</em>+1</sub>)  <img src="book-Z-G-D-15.gif" border="0">  (<em>a</em><sub><em>k</em></sub>, <em>b</em><sub><em>k</em></sub>)\n <img src="book-Z-G-D-15.gif" border="0">  (<em>a</em><sub><em>k</em>-1</sub>, <em>b</em><sub><em>k</em>-1</sub>) are three successive pairs in the\nreduction process, then we must have <em>b</em><sub><em>k</em>+1</sub><u>&gt;</u> <em>b</em><sub><em>k</em></sub>  +  <em>b</em><sub><em>k</em>-1</sub>.\nTo verify the claim, consider that a reduction step is defined by\napplying the transformation <em>a</em><sub><em>k</em>-1</sub>  =  <em>b</em><sub><em>k</em></sub>, <em>b</em><sub><em>k</em>-1</sub>  = \n remainder of  <em>a</em><sub><em>k</em></sub> divided by <em>b</em><sub><em>k</em></sub>.  \nThe second equation means that <em>a</em><sub><em>k</em></sub>  =  <em>q</em><em>b</em><sub><em>k</em></sub>  +  <em>b</em><sub><em>k</em>-1</sub> for some\npositive integer <em>q</em>.  And since <em>q</em> must be at least 1 we have <em>a</em><sub><em>k</em></sub>\n =  <em>q</em><em>b</em><sub><em>k</em></sub>  +  <em>b</em><sub><em>k</em>-1</sub> <u>&gt;</u> <em>b</em><sub><em>k</em></sub>  +  <em>b</em><sub><em>k</em>-1</sub>.  But in the previous\nreduction step we have <em>b</em><sub><em>k</em>+1</sub> =  <em>a</em><sub><em>k</em></sub>.  Therefore, <em>b</em><sub><em>k</em>+1</sub>  = \n<em>a</em><sub><em>k</em></sub><u>&gt;</u> <em>b</em><sub><em>k</em></sub>  +  <em>b</em><sub><em>k</em>-1</sub>.  This verifies the claim.  Now we can\nprove the theorem by induction on <em>k</em>, the number of steps that the\nalgorithm requires to terminate.  The result is true for <em>k</em> = 1, since\nthis merely requires that <em>b</em> be at least as large as \n<em>F</em><em>i</em><em>b</em>(1) = 1.  Now, assume that the result is true for all integers less\nthan or equal to <em>k</em> and establish the result for <em>k</em> + 1.  Let\n(<em>a</em><sub><em>k</em>+1</sub>, <em>b</em><sub><em>k</em>+1</sub>) <img src="book-Z-G-D-15.gif" border="0"> (<em>a</em><sub><em>k</em></sub>, <em>b</em><sub><em>k</em></sub>)\n <img src="book-Z-G-D-15.gif" border="0"> (<em>a</em><sub><em>k</em>-1</sub>, <em>b</em><sub><em>k</em>-1</sub>) be successive pairs in the\nreduction process.  By our induction hypotheses, we have <em>b</em><sub><em>k</em>-1</sub><u>&gt;</u>\n <em>F</em><em>i</em><em>b</em>(<em>k</em> - 1) and <em>b</em><sub><em>k</em></sub><u>&gt;</u>  <em>F</em><em>i</em><em>b</em>(<em>k</em>).  Thus, applying the claim we just\nproved together with the definition of the Fibonacci numbers gives\n<em>b</em><sub><em>k</em>+1</sub> <u>&gt;</u> <em>b</em><sub><em>k</em></sub>  +  <em>b</em><sub><em>k</em>-1</sub><u>&gt;</u>  <em>F</em><em>i</em><em>b</em>(<em>k</em>)  +   <em>F</em><em>i</em><em>b</em>(<em>k</em> - 1)  =  <em>F</em><em>i</em><em>b</em>(<em>k</em> + 1), which\ncompletes the proof of Lam&eacute;\'s Theorem.\n\n<p><a name="footnote_Temp_75" href="#call_footnote_Temp_75"><sup><small>44</small></sup></a> If <em>d</em> is a divisor of <em>n</em>, then so is <em>n</em>/<em>d</em>.\nBut <em>d</em> and <em>n</em>/<em>d</em> cannot both be greater than <img src="book-Z-G-D-13.gif" border="0"><em>n</em>.\n\n<p><a name="footnote_Temp_77" href="#call_footnote_Temp_77"><sup><small>45</small></sup></a> Pierre de Fermat (1601-1665) is considered to be the founder of\n<a name="%_idx_872"></a><a name="%_idx_874"></a>modern number theory.  He obtained many important number-theoretic\nresults, but he usually announced just the results, without providing\nhis proofs.  <a name="%_idx_876"></a>Fermat\'s Little Theorem was stated in a letter he wrote in\n1640.  The first published proof was given by <a name="%_idx_878"></a>Euler in 1736 (and an\n<a name="%_idx_880"></a>earlier, identical proof was discovered in the unpublished manuscripts\nof Leibniz).  The most famous of Fermat\'s results -- known as Fermat\'s\nLast Theorem -- was jotted down in 1637 in his copy of the book <em>Arithmetic</em> (by the third-century Greek mathematician <a name="%_idx_882"></a>Diophantus) with the\nremark ``I have discovered a truly remarkable proof, but this margin is\ntoo small to contain it.\'\'  Finding a proof of Fermat\'s Last Theorem\nbecame one of the most famous challenges in number theory.  A complete\n<a name="%_idx_884"></a>solution was finally given in 1995 by Andrew Wiles of Princeton University.\n\n<p><a name="footnote_Temp_78" href="#call_footnote_Temp_78"><sup><small>46</small></sup></a> The reduction steps in the cases where the exponent\n<em>e</em> is greater than 1 are based on the fact that, for any integers\n<em>x</em>, <em>y</em>, and <em>m</em>, we can find the remainder of <em>x</em> times <em>y</em> modulo\n<em>m</em> by computing separately the remainders of <em>x</em> modulo <em>m</em> and <em>y</em>\nmodulo <em>m</em>, multiplying these, and then taking the remainder of the\nresult modulo <em>m</em>.  For instance, in the case where <em>e</em> is even, we\ncompute the remainder of <em>b</em><sup><em>e</em>/2</sup> modulo <em>m</em>, square this, and take\nthe remainder modulo <em>m</em>.  This technique is useful because it means\nwe can perform our computation without ever having to deal with\nnumbers much larger than <em>m</em>.  (Compare\nexercise&nbsp;<a href="#%_thm_1.25">1.25</a>.)\n\n<p><a name="footnote_Temp_80" href="#call_footnote_Temp_80"><sup><small>47</small></sup></a> Numbers that fool the\n<a name="%_idx_912"></a>Fermat test are called <em>Carmichael numbers</em>, and little is known\nabout them other than that they are extremely rare.  There are 255\nCarmichael numbers below 100,000,000.  The smallest few are 561, 1105,\n1729, 2465, 2821, and 6601.  In testing primality of very large\nnumbers chosen at random, the chance of stumbling upon a value that\nfools the Fermat test is less than the chance that <a name="%_idx_914"></a>cosmic radiation\nwill cause the computer to make an error in carrying out a ``correct\'\'\nalgorithm.  Considering an algorithm to be inadequate for the first\nreason but not for the second illustrates the difference between\n<a name="%_idx_916"></a><a name="%_idx_918"></a>mathematics and engineering.\n\n<p><a name="footnote_Temp_81" href="#call_footnote_Temp_81"><sup><small>48</small></sup></a> One of the most striking applications of\n<a name="%_idx_920"></a>probabilistic prime testing has been to the field of cryptography.\nAlthough it is now computationally infeasible to factor an arbitrary\n200-digit number, the primality of such a number can be checked in a\nfew seconds with the Fermat test.  This fact forms the basis of a\ntechnique for constructing ``unbreakable codes\'\' suggested by <a name="%_idx_922"></a>Rivest,\n<a name="%_idx_924"></a>Shamir, and <a name="%_idx_926"></a>Adleman (1977).  The resulting <a name="%_idx_928"></a><em>RSA algorithm</em> has\nbecome a widely used technique for enhancing the security of\nelectronic communications.  Because of this and related developments,\nthe study of <a name="%_idx_930"></a>prime numbers, once considered the epitome of a topic in\n``pure\'\' mathematics to be studied only for its own sake, now turns\nout to have important practical applications to cryptography,\nelectronic funds transfer, and information retrieval.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_1.3"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_1.3">1.3&nbsp;&nbsp;Formulating Abstractions with Higher-Order Procedures</a></h2><p>\n\n<p>\n\n\nWe have seen that procedures are, in effect, abstractions that describe\ncompound operations on numbers independent of the particular numbers.\nFor example, when we<p>\n\n\n<p><p><tt><a name="%_idx_962"></a>(define&nbsp;(cube&nbsp;x)&nbsp;(*&nbsp;x&nbsp;x&nbsp;x))<br>\n</tt><p><p>\nwe are not talking about the cube of a particular number, but rather\nabout a method for obtaining the cube of any number.  Of course we\ncould get along without ever defining this procedure, by\nalways writing expressions such as<p>\n\n<p><p><tt>(*&nbsp;3&nbsp;3&nbsp;3)<br>\n(*&nbsp;x&nbsp;x&nbsp;x)<br>\n(*&nbsp;y&nbsp;y&nbsp;y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>\n</tt><p><p>\nand never mentioning <tt>cube</tt> explicitly.  This would place us at a\nserious disadvantage, forcing us to work always at the level of the\nparticular operations that happen to be primitives in the language\n(multiplication, in this case) rather than in terms of higher-level\noperations.  Our programs would be able to compute cubes, but our\nlanguage would lack the ability to express the concept of cubing.  One\nof the things we should demand from a powerful programming language is\nthe ability to build abstractions by assigning names to common\npatterns and then to work in terms of the abstractions directly.\nProcedures provide this ability.  This is why all but the most\nprimitive programming languages include mechanisms for defining\nprocedures.<p>\n\nYet even in numerical processing we will be severely limited in our\nability to create abstractions if we are restricted to procedures\nwhose parameters must be numbers.  Often the same programming pattern\nwill be used with a number of different procedures.  To express such\npatterns as concepts, we will need to construct procedures that can\naccept procedures as arguments or return procedures as values.\nProcedures that manipulate procedures are called <a name="%_idx_964"></a><em>higher-order\nprocedures</em>.  This section shows how higher-order procedures can serve\nas powerful abstraction mechanisms, vastly increasing the expressive\npower of our language.<p>\n\n<a name="%_sec_1.3.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.3.1">1.3.1&nbsp;&nbsp;Procedures as Arguments</a></h3><p>\n\n\n<a name="%_idx_966"></a><a name="%_idx_968"></a>\n\nConsider the following three procedures.  The first computes the sum\nof the integers from <tt>a</tt> through <tt>b</tt>:<p>\n\n<p><p><tt><a name="%_idx_970"></a>(define&nbsp;(sum-integers&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;a&nbsp;(sum-integers&nbsp;(+&nbsp;a&nbsp;1)&nbsp;b))))<br>\n</tt><p><p>\nThe second computes the sum of the cubes of the integers in the given range:<p>\n\n<p><p><tt><a name="%_idx_972"></a>(define&nbsp;(sum-cubes&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(cube&nbsp;a)&nbsp;(sum-cubes&nbsp;(+&nbsp;a&nbsp;1)&nbsp;b))))<br>\n</tt><p><p>\nThe third computes the sum of a sequence of terms in the\nseries\n<p><div align=left><img src="ch1-Z-G-26.gif" border="0"></div><p>\nwhich converges to <img src="book-Z-G-D-9.gif" border="0">/8 (very slowly):<a name="call_footnote_Temp_90" href="#footnote_Temp_90"><sup><small>49</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_978"></a>(define&nbsp;(pi-sum&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(/&nbsp;1.0&nbsp;(*&nbsp;a&nbsp;(+&nbsp;a&nbsp;2)))&nbsp;(pi-sum&nbsp;(+&nbsp;a&nbsp;4)&nbsp;b))))<br>\n</tt><p><p><p>\n\nThese three procedures clearly share a common underlying pattern.\nThey are for the most part identical, differing only in the name of\nthe procedure, the function of <tt>a</tt> used to compute the term to be added,\nand the function that provides the next value of <tt>a</tt>.  We could generate\neach of the procedures by filling in slots in the same template:<p>\n\n<p><p><tt>(define&nbsp;(&lt;<em>name</em>&gt;&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(&lt;<em>term</em>&gt;&nbsp;a)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;<em>name</em>&gt;&nbsp;(&lt;<em>next</em>&gt;&nbsp;a)&nbsp;b))))<br>\n</tt><p><p><p>\n\n<a name="%_idx_980"></a>The presence of such a common pattern is strong evidence that there is\na useful abstraction waiting to be brought to the surface.  Indeed,\nmathematicians long ago identified the abstraction of\n<a name="%_idx_982"></a><a name="%_idx_984"></a><em>summation of a series</em> and invented ``sigma\n<a name="%_idx_986"></a><a name="%_idx_988"></a>notation,\'\' for example<p>\n\n<p><div align=left><img src="ch1-Z-G-27.gif" border="0"></div><p><p>\n\nto express this concept.  The power of sigma notation is that it\nallows mathematicians to deal with the concept of summation\nitself rather than only with particular sums -- for example, to\nformulate general results about sums that are independent of the\nparticular series being summed.<p>\n\nSimilarly, as program designers, we would like our language to\nbe powerful enough so that we can write a procedure that expresses the\nconcept of summation itself rather than only procedures\nthat compute particular sums.  We can do so readily in our\nprocedural language by taking the common template shown above and\ntransforming the ``slots\'\' into formal parameters:<p>\n\n<p><p><tt><a name="%_idx_990"></a>(define&nbsp;(sum&nbsp;term&nbsp;a&nbsp;next&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(term&nbsp;a)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sum&nbsp;term&nbsp;(next&nbsp;a)&nbsp;next&nbsp;b))))<br>\n</tt><p><p>\nNotice that <tt>sum</tt> takes as its arguments the lower and upper bounds\n<tt>a</tt>&nbsp;and&nbsp;<tt>b</tt> together with the procedures <tt>term</tt> and <tt>next</tt>.\nWe can use <tt>sum</tt> just as we would any procedure.  For example, we can\nuse it (along with a procedure <tt>inc</tt> that increments its argument by 1)\nto define <tt>sum-cubes</tt>:<p>\n\n<p><p><tt><a name="%_idx_992"></a>(define&nbsp;(inc&nbsp;n)&nbsp;(+&nbsp;n&nbsp;1))<br>\n<a name="%_idx_994"></a>(define&nbsp;(sum-cubes&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(sum&nbsp;cube&nbsp;a&nbsp;inc&nbsp;b))<br>\n</tt><p><p>\nUsing this, we can compute the sum of the cubes of the integers from 1\nto 10:<p>\n\n\n<p><p><tt>(sum-cubes&nbsp;1&nbsp;10)<br>\n<i>3025</i><br>\n</tt><p><p>\nWith the aid of an identity procedure to compute the term, we can define\n<tt>sum-integers</tt> in terms of <tt>sum</tt>:<p>\n\n\n<p><p><tt><a name="%_idx_996"></a>(define&nbsp;(identity&nbsp;x)&nbsp;x)<br>\n<br>\n<a name="%_idx_998"></a>(define&nbsp;(sum-integers&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(sum&nbsp;identity&nbsp;a&nbsp;inc&nbsp;b))<br>\n</tt><p><p>\nThen we can add up the integers from 1 to 10:<p>\n\n\n<p><p><tt>(sum-integers&nbsp;1&nbsp;10)<br>\n<i>55</i><br>\n</tt><p><p>\nWe can also define <tt>pi-sum</tt> in the same way:<a name="call_footnote_Temp_91" href="#footnote_Temp_91"><sup><small>50</small></sup></a><p>\n\n\n<p><p><tt><a name="%_idx_1000"></a>(define&nbsp;(pi-sum&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(define&nbsp;(pi-term&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1.0&nbsp;(*&nbsp;x&nbsp;(+&nbsp;x&nbsp;2))))<br>\n&nbsp;&nbsp;(define&nbsp;(pi-next&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;4))<br>\n&nbsp;&nbsp;(sum&nbsp;pi-term&nbsp;a&nbsp;pi-next&nbsp;b))<br>\n</tt><p><p>\nUsing these procedures, we can compute an approximation to \n<img src="book-Z-G-D-9.gif" border="0">:<p>\n\n\n<p><p><tt>(*&nbsp;8&nbsp;(pi-sum&nbsp;1&nbsp;1000))<br>\n<i>3.139592655589783</i><br>\n</tt><p><p><p>\n\n\nOnce we have <tt>sum</tt>, we can use it as a building block in\nformulating further concepts.  For instance, the <a name="%_idx_1002"></a>definite integral of a\nfunction <em>f</em> between the limits <em>a</em> and <em>b</em> can be approximated\nnumerically using the formula\n<p><p><div align=left><img src="ch1-Z-G-28.gif" border="0"></div><p>\nfor small values of <em>d</em><em>x</em>.  We can express this directly as a\nprocedure:<p>\n\n<p><p><tt><a name="%_idx_1004"></a>(define&nbsp;(integral&nbsp;f&nbsp;a&nbsp;b&nbsp;dx)<br>\n&nbsp;&nbsp;(define&nbsp;(add-dx&nbsp;x)&nbsp;(+&nbsp;x&nbsp;dx))<br>\n&nbsp;&nbsp;(*&nbsp;(sum&nbsp;f&nbsp;(+&nbsp;a&nbsp;(/&nbsp;dx&nbsp;2.0))&nbsp;add-dx&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx))<br>\n(integral&nbsp;cube&nbsp;0&nbsp;1&nbsp;0.01)<br>\n<i>.24998750000000042</i><br>\n(integral&nbsp;cube&nbsp;0&nbsp;1&nbsp;0.001)<br>\n<i>.249999875000001</i><br>\n</tt><p><p>\n(The exact value of the integral of <tt>cube</tt> between 0 and 1 is 1/4.)<p>\n\n<p><a name="%_thm_1.29"></a>\n<b>Exercise 1.29.</b>&nbsp;&nbsp;<a name="%_idx_1006"></a>Simpson\'s Rule is a more accurate method of numerical integration than\nthe method illustrated above.  Using Simpson\'s Rule, the integral of a\nfunction <em>f</em> between <em>a</em> and <em>b</em> is approximated as\n<p><div align=left><img src="ch1-Z-G-29.gif" border="0"></div><p><p>\n\nwhere <em>h</em> = (<em>b</em> - <em>a</em>)/<em>n</em>, for some even integer <em>n</em>, and <em>y</em><sub><em>k</em></sub>  = <em>f</em>(<em>a</em> + <em>k</em><em>h</em>).\n(Increasing <em>n</em> increases the accuracy of the approximation.)  Define\na procedure that takes as arguments <em>f</em>, <em>a</em>, <em>b</em>, and <em>n</em> and returns\nthe value of the integral, computed using Simpson\'s Rule.\nUse your procedure to integrate <tt>cube</tt> between 0 and 1\n(with <em>n</em> = 100 and <em>n</em> = 1000), and compare the results to those of the\n<tt>integral</tt> procedure shown above.\n<p><p>\n\n<p><a name="%_thm_1.30"></a>\n<b>Exercise 1.30.</b>&nbsp;&nbsp;<a name="%_idx_1008"></a>The <tt>sum</tt> procedure above generates a linear recursion.  The\nprocedure can be rewritten so that the sum is performed iteratively.\nShow how to do this by filling in the missing expressions in the\nfollowing definition:<p>\n\n<p><p><tt>(define&nbsp;(sum&nbsp;term&nbsp;a&nbsp;next&nbsp;b)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;a&nbsp;result)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;&lt;<em>??</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>??</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;&lt;<em>??</em>&gt;&nbsp;&lt;<em>??</em>&gt;)))<br>\n&nbsp;&nbsp;(iter&nbsp;&lt;<em>??</em>&gt;&nbsp;&lt;<em>??</em>&gt;))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_1.31"></a>\n<b>Exercise 1.31.</b>&nbsp;&nbsp;\n<a name="%_idx_1010"></a><br>a.&nbsp;&nbsp;The <tt>sum</tt> procedure is only the simplest of a vast number of\nsimilar abstractions that can be captured as higher-order procedures.<a name="call_footnote_Temp_95" href="#footnote_Temp_95"><sup><small>51</small></sup></a>  Write an analogous procedure\ncalled <tt>product</tt> that returns the product of the values of a\nfunction at points over a given range.\nShow how to define <a name="%_idx_1012"></a><tt>factorial</tt> in terms of\n<tt>product</tt>.  Also use <tt>product</tt> to compute approximations to\n<a name="%_idx_1014"></a><img src="book-Z-G-D-9.gif" border="0"> using the formula<a name="call_footnote_Temp_96" href="#footnote_Temp_96"><sup><small>52</small></sup></a>\n<p><div align=left><img src="ch1-Z-G-30.gif" border="0"></div><p><p>\n\nb.&nbsp;&nbsp;If your <tt>product</tt>\nprocedure generates a recursive process, write one that generates\nan iterative process.\nIf it generates an iterative process, write one that generates\na recursive process.\n\n<p><p>\n\n<p><a name="%_thm_1.32"></a>\n<b>Exercise 1.32.</b>&nbsp;&nbsp;<a name="%_idx_1018"></a><a name="%_idx_1020"></a><a name="%_idx_1022"></a>a. Show that <tt>sum</tt> and <tt>product</tt>\n(exercise&nbsp;<a href="#%_thm_1.31">1.31</a>) are both special cases of a still more\ngeneral notion called <tt>accumulate</tt> that combines a collection of\nterms, using some general accumulation function:<p>\n\n<p><p><tt>(accumulate&nbsp;combiner&nbsp;null-value&nbsp;term&nbsp;a&nbsp;next&nbsp;b)<br>\n</tt><p><p>\n<tt>Accumulate</tt> takes as arguments the same term and range\nspecifications as <tt>sum</tt> and <tt>product</tt>, together with a <tt>combiner</tt>\nprocedure (of two arguments) that specifies how the current\nterm is to be combined with the accumulation of the preceding terms\nand a <tt>null-value</tt> that specifies what base value to use\nwhen the terms run out.  Write <tt>accumulate</tt>\nand show how <tt>sum</tt> and <tt>product</tt> can both\nbe defined as simple calls to <tt>accumulate</tt>.<p>\n\n<p><p>b. If your <tt>accumulate</tt>\nprocedure generates a recursive process, write one that generates\nan iterative process.\nIf it generates an iterative process, write one that generates\na recursive process.\n\n<p><p>\n\n<p><a name="%_thm_1.33"></a>\n<b>Exercise 1.33.</b>&nbsp;&nbsp;<a name="%_idx_1024"></a>You can obtain an even more general version of <tt>accumulate</tt>\n(exercise&nbsp;<a href="#%_thm_1.32">1.32</a>) by introducing the notion of a <a name="%_idx_1026"></a><em>filter</em> on the terms to be combined.  That is, combine only those\nterms derived from values in the range that satisfy a specified\ncondition.  The resulting <tt>filtered-accumulate</tt> abstraction takes\nthe same arguments as accumulate, together with an additional\npredicate of one argument that specifies the filter.  Write <tt>filtered-accumulate</tt> as a procedure.  Show how to express the\nfollowing using <tt>filtered-accumulate</tt>:<p>\n\n<p><p>a. the sum of the squares of the prime numbers in the interval <em>a</em> to\n<em>b</em> (assuming that you have a <tt>prime?</tt> predicate already written)<p>\n\n<p><p>b. the product of all the positive integers less than <em>n</em>\n<a name="%_idx_1028"></a>that are relatively prime to&nbsp;<em>n</em> (i.e., all positive integers\n<em>i</em> &lt; <em>n</em> such that  <em>G</em><em>C</em><em>D</em>(<em>i</em>,<em>n</em>) = 1).\n\n<p><p>\n\n<a name="%_sec_1.3.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.3.2">1.3.2&nbsp;&nbsp;Constructing Procedures Using <tt>Lambda</tt></a></h3><p>\n\n\n<p>\n\nIn using <tt>sum</tt> as in section&nbsp;<a href="#%_sec_1.3.1">1.3.1</a>,\nit seems terribly awkward to have to define trivial procedures such as\n<tt>pi-term</tt> and <tt>pi-next</tt> just so we can use them as arguments to\nour higher-order procedure.  Rather than define <tt>pi-next</tt> and <tt>pi-term</tt>, it would be more convenient\nto have a way to directly specify ``the procedure that returns its\ninput incremented by 4\'\' and ``the procedure that returns the\nreciprocal of its input times its input plus 2.\'\'  We can do this by\nintroducing the special form <tt>lambda</tt>, which creates procedures.\nUsing <tt>lambda</tt> we can describe what we want as<p>\n\n<p><p><tt>(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;4))<br>\n</tt><p><p>\nand <p>\n\n<p><p><tt>(lambda&nbsp;(x)&nbsp;(/&nbsp;1.0&nbsp;(*&nbsp;x&nbsp;(+&nbsp;x&nbsp;2))))<br>\n</tt><p><p>\nThen our <tt>pi-sum</tt> procedure can be expressed without defining any\nauxiliary procedures as<p>\n\n<p><p><tt><a name="%_idx_1030"></a>(define&nbsp;(pi-sum&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(sum&nbsp;(lambda&nbsp;(x)&nbsp;(/&nbsp;1.0&nbsp;(*&nbsp;x&nbsp;(+&nbsp;x&nbsp;2))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;4))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b))<br>\n</tt><p><p><p>\n\nAgain using <tt>lambda</tt>, we can write the <tt>integral</tt> procedure\nwithout having to define the auxiliary procedure <tt>add-dx</tt>:<p>\n\n<p><p><tt><a name="%_idx_1032"></a>(define&nbsp;(integral&nbsp;f&nbsp;a&nbsp;b&nbsp;dx)<br>\n&nbsp;&nbsp;(*&nbsp;(sum&nbsp;f<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;a&nbsp;(/&nbsp;dx&nbsp;2.0))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;dx))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx))<br>\n</tt><p><p><p>\n\n<a name="%_idx_1034"></a><a name="%_idx_1036"></a><a name="%_idx_1038"></a><a name="%_idx_1040"></a><a name="%_idx_1042"></a>In general, <tt>lambda</tt> is used to create procedures in the same way as\n<tt>define</tt>, except that <a name="%_idx_1044"></a>no name is specified for the procedure:<p>\n\n<p><p><tt>(lambda&nbsp;(&lt;<em>formal-parameters</em>&gt;)&nbsp;&lt;<em>body</em>&gt;)<br>\n</tt><p><p>\nThe resulting procedure is just as much a procedure as one that is\ncreated using <tt>define</tt>.  The only difference is that it has not\nbeen associated with any name in the environment.  In fact,<p>\n\n<a name="%_idx_1046"></a><p><p><tt>(define&nbsp;(plus4&nbsp;x)&nbsp;(+&nbsp;x&nbsp;4))<br>\n</tt><p><p>\nis equivalent to<p>\n\n<p><p><tt>(define&nbsp;plus4&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;4)))<br>\n</tt><p><p>\nWe can read a <tt>lambda</tt> expression as follows:\n<p><p><tt>&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0">&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-16.gif" border="0"><br>\n&nbsp;the&nbsp;procedure&nbsp;&nbsp;&nbsp;of&nbsp;an&nbsp;argument&nbsp;<tt>x</tt>&nbsp;&nbsp;that&nbsp;adds&nbsp;&nbsp;<tt>x</tt>&nbsp;and&nbsp;4<br>\n</tt><p><p>\n\n<a name="%_idx_1048"></a><a name="%_idx_1050"></a><a name="%_idx_1052"></a>Like any expression that has a procedure as its value, a\n<tt>lambda</tt> expression can be used as the operator in a combination such as<p>\n\n<p><p><tt>((lambda&nbsp;(x&nbsp;y&nbsp;z)&nbsp;(+&nbsp;x&nbsp;y&nbsp;(square&nbsp;z)))&nbsp;1&nbsp;2&nbsp;3)<br>\n<i>12</i><br>\n</tt><p><p>\nor, more generally, in any context where we would normally use a\nprocedure name.<a name="call_footnote_Temp_99" href="#footnote_Temp_99"><sup><small>53</small></sup></a><p>\n\n<a name="%_sec_Temp_100"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_100">Using <tt>let</tt> to create local variables</a></h4><p>\n\n<a name="%_idx_1058"></a><a name="%_idx_1060"></a>\n\nAnother use of <tt>lambda</tt> is in creating local variables.\nWe often need local variables in our procedures other than those that have\nbeen bound as formal parameters.  For example, suppose we wish to\ncompute the function<p>\n\n<p><div align=left><img src="ch1-Z-G-31.gif" border="0"></div><p><p>\n\nwhich we could also express as\n<p><div align=left><img src="ch1-Z-G-32.gif" border="0"></div><p>\nIn writing a procedure to compute <em>f</em>, we would like to include as\nlocal variables not only <em>x</em> and <em>y</em>  but also the names of\nintermediate quantities like <em>a</em> and <em>b</em>.  One way to\naccomplish this is to\nuse an auxiliary procedure to bind the local variables:<p>\n\n\n<p><p><tt>(define&nbsp;(f&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(define&nbsp;(f-helper&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(*&nbsp;x&nbsp;(square&nbsp;a))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;y&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;a&nbsp;b)))<br>\n&nbsp;&nbsp;(f-helper&nbsp;(+&nbsp;1&nbsp;(*&nbsp;x&nbsp;y))&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;1&nbsp;y)))<br>\n</tt><p><p><p>\n\nOf course, we could use a <tt>lambda</tt> expression to specify an\nanonymous procedure for binding our local variables.  The body of\n<tt>f</tt> then becomes a single call to that procedure:<p>\n\n\n<p><p><tt>(define&nbsp;(f&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;((lambda&nbsp;(a&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(*&nbsp;x&nbsp;(square&nbsp;a))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;y&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;a&nbsp;b)))<br>\n&nbsp;&nbsp;&nbsp;(+&nbsp;1&nbsp;(*&nbsp;x&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;(-&nbsp;1&nbsp;y)))<br>\n</tt><p><p>\nThis construct is so useful that there is a special form called\n<tt>let</tt> to make its use more convenient.  Using <tt>let</tt>, the <tt>f</tt>\nprocedure could be written as<p>\n\n\n<p><p><tt>(define&nbsp;(f&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(let&nbsp;((a&nbsp;(+&nbsp;1&nbsp;(*&nbsp;x&nbsp;y)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b&nbsp;(-&nbsp;1&nbsp;y)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(*&nbsp;x&nbsp;(square&nbsp;a))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;y&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;a&nbsp;b))))<br>\n</tt><p><p>\n<a name="%_idx_1062"></a><a name="%_idx_1064"></a>The general form of a <tt>let</tt> expression is<p>\n\n\n<p><p><tt>(let&nbsp;((&lt;<em>var<sub>1</sub></em>&gt;&nbsp;&lt;<em>exp<sub>1</sub></em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;<em>var<sub>2</sub></em>&gt;&nbsp;&lt;<em>exp<sub>2</sub></em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-18.gif" border="0"><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;<em>var<sub><em>n</em></sub></em>&gt;&nbsp;&lt;<em>exp<sub><em>n</em></sub></em>&gt;))<br>\n&nbsp;&nbsp;&nbsp;&lt;<em>body</em>&gt;)<br>\n</tt><p><p>\nwhich can be thought of as saying<p>\n\n<table border=0><tr><td valign=top >let </td><td valign=top >&lt;<em>var<sub>1</sub></em>&gt; have the value &lt;<em>exp<sub>1</sub></em>&gt; and</td></tr>\n<tr><td valign=top ></td><td valign=top >&lt;<em>var<sub>2</sub></em>&gt; have the value &lt;<em>exp<sub>2</sub></em>&gt; and</td></tr>\n<tr><td valign=top ></td><td valign=top ><img src="book-Z-G-D-18.gif" border="0"></td></tr>\n<tr><td valign=top ></td><td valign=top >&lt;<em>var<sub><em>n</em></sub></em>&gt; have the value &lt;<em>exp<sub><em>n</em></sub></em>&gt;</td></tr>\n<tr><td valign=top >in  </td><td valign=top >&lt;<em>body</em>&gt;\n</td></tr></table><p>\n\nThe first part of the <tt>let</tt> expression is a list of\nname-expression pairs.  When the <tt>let</tt> is evaluated, each name is\nassociated with the value of the corresponding expression.  The body\nof the <tt>let</tt> is evaluated with\nthese names bound as local variables.  The way this happens is that the <tt>let</tt> expression is interpreted as an alternate syntax for<p>\n\n<p><p><tt>((lambda&nbsp;(&lt;<em>var<sub>1</sub></em>&gt;&nbsp;<tt>...</tt>&lt;<em>var<sub><em>n</em></sub></em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>body</em>&gt;)<br>\n&nbsp;&lt;<em>exp<sub>1</sub></em>&gt;<br>\n&nbsp;<img src="book-Z-G-D-18.gif" border="0"><br>\n&nbsp;&lt;<em>exp<sub><em>n</em></sub></em>&gt;)<br>\n</tt><p><p>\nNo new mechanism is required in the interpreter in order to\nprovide local variables.  A <a name="%_idx_1066"></a><a name="%_idx_1068"></a><tt>let</tt> expression is simply syntactic sugar for\nthe underlying <tt>lambda</tt> application.<p>\n\n<a name="%_idx_1070"></a><a name="%_idx_1072"></a>We can see from this equivalence that\nthe scope of a variable specified by a <tt>let</tt> expression is the body of\nthe <tt>let</tt>.\nThis implies that:<p>\n\n<p><ul>\n<li><tt>Let</tt> allows one to\nbind variables as locally as possible to where they\nare to be used.  For example, if the value of <tt>x</tt> is 5,\nthe value of the expression<p>\n\n<p><p><tt>(+&nbsp;(let&nbsp;((x&nbsp;3))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;(*&nbsp;x&nbsp;10)))<br>\n&nbsp;&nbsp;&nbsp;x)<br>\n</tt><p><p><p>\n\nis 38.  Here, the <tt>x</tt> in the body of the <tt>let</tt> is 3,\nso the value of the <tt>let</tt> expression is 33.  On the other hand, the\n<tt>x</tt> that is the second argument to the outermost <tt>+</tt> is still&nbsp;5.<p>\n\n<li>The variables\' values are computed outside the <tt>let</tt>.\nThis matters when the expressions that\nprovide the values for the local variables depend upon\nvariables having the same names as the local variables themselves.\nFor example, if the value of <tt>x</tt> is 2, the expression<p>\n\n<p><p><tt>(let&nbsp;((x&nbsp;3)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(y&nbsp;(+&nbsp;x&nbsp;2)))<br>\n&nbsp;&nbsp;(*&nbsp;x&nbsp;y))<br>\n</tt><p><p>\nwill have the value 12 because, inside the body of the <tt>let</tt>,\n<tt>x</tt> will be 3 and <tt>y</tt> will be 4 (which is the\nouter <tt>x</tt> plus 2).\n</ul><p><p>\n\n\n<a name="%_idx_1074"></a><a name="%_idx_1076"></a>Sometimes we can use internal definitions to get the same effect as\nwith <tt>let</tt>.  For example, we could have defined the procedure <tt>f</tt> above as\n<p><p><tt>(define&nbsp;(f&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(define&nbsp;a&nbsp;(+&nbsp;1&nbsp;(*&nbsp;x&nbsp;y)))<br>\n&nbsp;&nbsp;(define&nbsp;b&nbsp;(-&nbsp;1&nbsp;y))<br>\n&nbsp;&nbsp;(+&nbsp;(*&nbsp;x&nbsp;(square&nbsp;a))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;y&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;a&nbsp;b)))<br>\n</tt><p><p>\nWe prefer, however, to use <tt>let</tt> in situations like this\nand to use internal <tt>define</tt> only for internal procedures.<a name="call_footnote_Temp_101" href="#footnote_Temp_101"><sup><small>54</small></sup></a><p>\n\n<p><a name="%_thm_1.34"></a>\n<b>Exercise 1.34.</b>&nbsp;&nbsp;Suppose we define the procedure<p>\n\n<p><p><tt>(define&nbsp;(f&nbsp;g)<br>\n&nbsp;&nbsp;(g&nbsp;2))<br>\n</tt><p><p>\nThen we have<p>\n\n<p><p><tt>(f&nbsp;square)<br>\n<i>4</i><br>\n<br>\n(f&nbsp;(lambda&nbsp;(z)&nbsp;(*&nbsp;z&nbsp;(+&nbsp;z&nbsp;1))))<br>\n<i>6</i><br>\n</tt><p><p>\nWhat happens if we (perversely) ask the interpreter to evaluate the\ncombination <tt>(f f)</tt>?  Explain.\n<p><p>\n\n<a name="%_sec_1.3.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.3.3">1.3.3&nbsp;&nbsp;Procedures as General Methods</a></h3><p>\n\n\n<a name="%_idx_1078"></a><a name="%_idx_1080"></a>\nWe introduced compound procedures in\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.4">1.1.4</a> as a mechanism for abstracting\npatterns of numerical operations so as to make them independent of the\nparticular numbers involved.  With higher-order procedures, such as\nthe <tt>integral</tt> procedure of\nsection&nbsp;<a href="#%_sec_1.3.1">1.3.1</a>, we began to see a more\npowerful kind of abstraction: procedures used to express general\nmethods of computation, independent of the particular functions\ninvolved.  In this section we discuss two more elaborate\nexamples -- general methods for finding zeros and fixed points of\nfunctions -- and show how these methods can be expressed directly as\nprocedures.<p>\n\n<a name="%_sec_Temp_103"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_103">Finding roots of equations by the half-interval method</a></h4><p>\n\n<a name="%_idx_1082"></a>\nThe <em>half-interval method</em> is a simple but powerful technique for\nfinding roots of an equation <em>f</em>(<em>x</em>) = 0, where <em>f</em> is a continuous\nfunction.  The idea is that, if we are given points <em>a</em> and <em>b</em> such\nthat <em>f</em>(<em>a</em>) &lt; 0 &lt; <em>f</em>(<em>b</em>), then <em>f</em> must have at least one zero between\n<em>a</em> and <em>b</em>.  To locate a zero, let <em>x</em> be the average of <em>a</em> and <em>b</em>\nand compute <em>f</em>(<em>x</em>).  If <em>f</em>(<em>x</em>) &gt; 0, then <em>f</em> must have a zero between\n<em>a</em> and <em>x</em>.  If <em>f</em>(<em>x</em>) &lt; 0, then <em>f</em> must have a zero between <em>x</em> and\n<em>b</em>.  Continuing in this way, we can identify smaller and smaller\nintervals on which <em>f</em> must have a zero.  When we reach a point where\nthe interval is small enough, the process stops.  Since the interval\nof uncertainty is reduced by half at each step of the process, the\nnumber of steps required grows as <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt>( <em>L</em>/<em>T</em>)), where <em>L</em> is the\nlength of the original interval and <em>T</em> is the error tolerance\n(that is, the size of the interval we will consider ``small enough\'\').\nHere is a procedure that implements this strategy:<p>\n\n\n<p><p><tt><a name="%_idx_1084"></a>(define&nbsp;(search&nbsp;f&nbsp;neg-point&nbsp;pos-point)<br>\n&nbsp;&nbsp;(let&nbsp;((midpoint&nbsp;(average&nbsp;neg-point&nbsp;pos-point)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(close-enough?&nbsp;neg-point&nbsp;pos-point)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midpoint<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((test-value&nbsp;(f&nbsp;midpoint)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((positive?&nbsp;test-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(search&nbsp;f&nbsp;neg-point&nbsp;midpoint))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((negative?&nbsp;test-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(search&nbsp;f&nbsp;midpoint&nbsp;pos-point))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;midpoint))))))<br>\n</tt><p><p><p>\n\nWe assume that we are initially given the function <em>f</em> together with\npoints at which its values are negative and positive.  We first\ncompute the midpoint of the two given points.  Next we check to see if\nthe given interval is small enough, and if so we simply return the\nmidpoint as our answer.  Otherwise, we compute as a test value the\nvalue of <em>f</em> at the midpoint.  If the test value is positive, then\nwe continue the process with a new interval running from the original\nnegative point to the midpoint.  If the test value is negative, we\ncontinue with the interval from the midpoint to the positive point.\nFinally, there is the possibility that the test value is&nbsp;0, in which\ncase the midpoint is itself the root we are searching for.<p>\n\n\nTo test whether the endpoints are ``close enough\'\' we can use a\nprocedure similar to the one used in section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a> for\ncomputing square roots:<a name="call_footnote_Temp_104" href="#footnote_Temp_104"><sup><small>55</small></sup></a><p>\n\n<p><p><tt>(define&nbsp;(close-enough?&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(&lt;&nbsp;(abs&nbsp;(-&nbsp;x&nbsp;y))&nbsp;0.001))<br>\n</tt><p><p><p>\n\n<tt>Search</tt> is awkward to use directly, because\nwe can accidentally give it points at which <em>f</em>\'s\nvalues do not have the required sign, in which case we get a wrong answer.\nInstead we will use <tt>search</tt> via the following procedure, which\nchecks to see which of the endpoints has a negative function value and\nwhich has a positive value, and calls the <tt>search</tt> procedure\naccordingly.  If the function has the same sign on the two given\npoints, the half-interval method cannot be used, in which case the\nprocedure signals an error.<a name="call_footnote_Temp_105" href="#footnote_Temp_105"><sup><small>56</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_1092"></a>(define&nbsp;(half-interval-method&nbsp;f&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(let&nbsp;((a-value&nbsp;(f&nbsp;a))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b-value&nbsp;(f&nbsp;b)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((and&nbsp;(negative?&nbsp;a-value)&nbsp;(positive?&nbsp;b-value))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(search&nbsp;f&nbsp;a&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(negative?&nbsp;b-value)&nbsp;(positive?&nbsp;a-value))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(search&nbsp;f&nbsp;b&nbsp;a))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Values&nbsp;are&nbsp;not&nbsp;of&nbsp;opposite&nbsp;sign&quot;&nbsp;a&nbsp;b)))))<br>\n</tt><p><p><p>\n\n<a name="%_idx_1094"></a>The following example uses the half-interval method to approximate <img src="book-Z-G-D-9.gif" border="0">\nas the root between 2 and 4 of <tt>sin</tt>  <em>x</em>  =  0:<p>\n\n<p><p><tt>(half-interval-method&nbsp;sin&nbsp;2.0&nbsp;4.0)<br>\n<i>3.14111328125</i><br>\n</tt><p><p><p>\n\nHere is another example, using the half-interval method\nto search for a root of the equation <em>x</em><sup>3</sup>  -  2<em>x</em>  -  3  =  0\nbetween 1 and 2:<p>\n\n<p><p><tt>(half-interval-method&nbsp;(lambda&nbsp;(x)&nbsp;(-&nbsp;(*&nbsp;x&nbsp;x&nbsp;x)&nbsp;(*&nbsp;2&nbsp;x)&nbsp;3))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0)<br>\n<i>1.89306640625</i><br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_106"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_106">Finding fixed points of functions</a></h4><p>\n\n<a name="%_idx_1096"></a><a name="%_idx_1098"></a>\nA number <em>x</em> is called a <em>fixed point</em> of a function <em>f</em> if <em>x</em>\nsatisfies the equation <em>f</em>(<em>x</em>) = <em>x</em>.  For some functions <em>f</em> we can locate\na fixed point by beginning with an initial guess and applying <em>f</em>\nrepeatedly,<p>\n\n<p><div align=left><img src="ch1-Z-G-33.gif" border="0"></div><p><p>\n\nuntil the value does not change very much.  Using this idea, we can\ndevise a procedure <tt>fixed-point</tt> that takes as inputs a function\nand an initial guess and produces an approximation to a fixed point of\nthe function.  We apply the function repeatedly until we find two\nsuccessive values whose difference is less than some prescribed\ntolerance:<p>\n\n\n<p><p><tt>(define&nbsp;tolerance&nbsp;0.00001)<br>\n<a name="%_idx_1100"></a>(define&nbsp;(fixed-point&nbsp;f&nbsp;first-guess)<br>\n&nbsp;&nbsp;(define&nbsp;(close-enough?&nbsp;v1&nbsp;v2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&nbsp;(abs&nbsp;(-&nbsp;v1&nbsp;v2))&nbsp;tolerance))<br>\n&nbsp;&nbsp;(define&nbsp;(try&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((next&nbsp;(f&nbsp;guess)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(close-enough?&nbsp;guess&nbsp;next)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(try&nbsp;next))))<br>\n&nbsp;&nbsp;(try&nbsp;first-guess))<br>\n</tt><p><p>\n<a name="%_idx_1102"></a><a name="%_idx_1104"></a>For example, we can use this method to approximate the fixed point of\nthe cosine function, starting with 1 as an initial approximation:<a name="call_footnote_Temp_107" href="#footnote_Temp_107"><sup><small>57</small></sup></a><p>\n\n\n<p><p><tt><a name="%_idx_1112"></a><a name="%_idx_1114"></a>(fixed-point&nbsp;cos&nbsp;1.0)<br>\n<i>.7390822985224023</i><br>\n</tt><p><p>\nSimilarly, we can find a solution to the equation\n<em>y</em> = <tt>sin</tt> <em>y</em>  +  <tt>cos</tt> <em>y</em>:<p>\n\n\n<p><p><tt><a name="%_idx_1116"></a><a name="%_idx_1118"></a>(fixed-point&nbsp;(lambda&nbsp;(y)&nbsp;(+&nbsp;(sin&nbsp;y)&nbsp;(cos&nbsp;y)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0)<br>\n<i>1.2587315962971173</i><br>\n</tt><p><p><p>\n\n\nThe fixed-point process is reminiscent of the process we used for\nfinding square roots in section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>.  Both are based on the\nidea of repeatedly improving a guess until the result satisfies some\ncriterion.  In fact, we can readily formulate the <a name="%_idx_1120"></a>square-root\ncomputation as a fixed-point search.  Computing the square root of\nsome number <em>x</em> requires finding a <em>y</em> such that <em>y</em><sup>2</sup>  =  <em>x</em>.  Putting\nthis equation into the equivalent form <em>y</em>  =  <em>x</em>/<em>y</em>, we recognize that we\nare looking for a fixed point of the function<a name="call_footnote_Temp_108" href="#footnote_Temp_108"><sup><small>58</small></sup></a> <em>y</em>  <img src="book-Z-G-D-17.gif" border="0">  <em>x</em>/<em>y</em>, and we\ncan therefore try to compute square roots as<p>\n\n\n<p><p><tt>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(fixed-point&nbsp;(lambda&nbsp;(y)&nbsp;(/&nbsp;x&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0))<br>\n</tt><p><p><p>\n\nUnfortunately, this fixed-point search does not converge.  Consider an\ninitial guess <em>y</em><sub>1</sub>.  The next guess is <em>y</em><sub>2</sub>  =  <em>x</em>/<em>y</em><sub>1</sub> and the next\nguess is <em>y</em><sub>3</sub>  =  <em>x</em>/<em>y</em><sub>2</sub>  =  <em>x</em>/(<em>x</em>/<em>y</em><sub>1</sub>)  =  <em>y</em><sub>1</sub>.  This results in an infinite\nloop in which the two guesses <em>y</em><sub>1</sub> and <em>y</em><sub>2</sub> repeat over and over,\noscillating about the answer.<p>\n\nOne way to control such oscillations is to prevent the guesses from\nchanging so much.\nSince the answer is always between our guess <em>y</em>\nand <em>x</em>/<em>y</em>, we can make a new guess that is not as far from <em>y</em> as <em>x</em>/<em>y</em>\nby averaging <em>y</em> with <em>x</em>/<em>y</em>, so that the next guess after\n<em>y</em> is (1/2)(<em>y</em> + <em>x</em>/<em>y</em>) instead of <em>x</em>/<em>y</em>.\nThe process of making such a sequence of guesses is simply the process\nof looking for a fixed point of <em>y</em>  <img src="book-Z-G-D-17.gif" border="0">  (1/2)(<em>y</em> + <em>x</em>/<em>y</em>):<p>\n\n<p><p><tt><a name="%_idx_1126"></a>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(fixed-point&nbsp;(lambda&nbsp;(y)&nbsp;(average&nbsp;y&nbsp;(/&nbsp;x&nbsp;y)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0))<br>\n</tt><p><p>\n(Note that <em>y</em> = (1/2)(<em>y</em> + <em>x</em>/<em>y</em>) is a simple transformation of the\nequation <em>y</em> = <em>x</em>/<em>y</em>; to derive it, add <em>y</em> to both sides of the equation\nand divide by&nbsp;2.)<p>\n\nWith this modification, the square-root procedure works.  In fact, if\nwe unravel the definitions, we can see that the sequence of\napproximations to the square root generated here is precisely the\nsame as the one generated by our original square-root procedure of\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>.  This approach of averaging\nsuccessive approximations to a solution, a technique we that we call\n<a name="%_idx_1128"></a><em>average damping</em>, often aids the convergence of fixed-point\nsearches.<p>\n\n<p><a name="%_thm_1.35"></a>\n<b>Exercise 1.35.</b>&nbsp;&nbsp;<a name="%_idx_1130"></a><a name="%_idx_1132"></a>Show that the golden ratio <img src="book-Z-G-D-11.gif" border="0"> (section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a>)\nis a fixed point of the transformation <em>x</em>  <img src="book-Z-G-D-17.gif" border="0">  1  +  1/<em>x</em>, and use\nthis fact to compute <img src="book-Z-G-D-11.gif" border="0"> by means of the <tt>fixed-point</tt>\nprocedure.\n<p><p>\n\n<p><a name="%_thm_1.36"></a>\n<b>Exercise 1.36.</b>&nbsp;&nbsp;Modify <tt>fixed-point</tt> so that it prints the sequence of\napproximations it generates, using\nthe <tt>newline</tt> and <tt>display</tt> primitives shown in\nexercise&nbsp;<a href="book-Z-H-11.html#%_thm_1.22">1.22</a>.  Then find a solution to <em>x</em><sup><em>x</em></sup>  = \n1000 by finding a fixed point of <em>x</em>  <img src="book-Z-G-D-17.gif" border="0">  <tt>log</tt>(1000)/<tt>log</tt>(<em>x</em>).  (Use\nScheme\'s <a name="%_idx_1134"></a><a name="%_idx_1136"></a>primitive <tt>log</tt> procedure, which computes natural\nlogarithms.)  Compare the number of steps this takes with and without\naverage damping.  (Note that you cannot start <tt>fixed-point</tt> with a\nguess of 1, as this would cause division by <tt>log</tt>(1) = 0.)\n\n<p><p>\n\n<p><a name="%_thm_1.37"></a>\n<b>Exercise 1.37.</b>&nbsp;&nbsp;<a name="%_idx_1138"></a>a. An infinite <em>continued fraction</em> is an expression of the form\n<p><div align=left><img src="ch1-Z-G-34.gif" border="0"></div><p> \n<a name="%_idx_1140"></a><a name="%_idx_1142"></a>As an example, one can show that the infinite continued fraction\nexpansion with the <em>N</em><sub><em>i</em></sub> and the <em>D</em><sub><em>i</em></sub> all equal to 1 produces\n1/<img src="book-Z-G-D-11.gif" border="0">, where <img src="book-Z-G-D-11.gif" border="0"> is the golden ratio (described in\nsection&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a>).\nOne way to approximate an\ninfinite continued fraction is to truncate the expansion after a given\nnumber of terms.  Such a truncation -- a so-called <em><em>k</em>-term finite\ncontinued fraction</em> -- has the form\n<p><div align=left><img src="ch1-Z-G-35.gif" border="0"></div><p> \nSuppose that <tt>n</tt> and <tt>d</tt> are procedures of one argument (the\nterm index <em>i</em>) that return the <em>N</em><sub><em>i</em></sub> and <em>D</em><sub><em>i</em></sub> of the terms of the\ncontinued fraction.  Define a procedure <tt>cont-frac</tt>\nsuch that evaluating <tt>(cont-frac n d k)</tt>\ncomputes the value of the <em>k</em>-term finite\ncontinued fraction.  Check your procedure by approximating 1/<img src="book-Z-G-D-11.gif" border="0"> using\n<p><p><tt>(cont-frac&nbsp;(lambda&nbsp;(i)&nbsp;1.0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(i)&nbsp;1.0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k)<br>\n</tt><p><p>\nfor successive values of <tt>k</tt>.  How large must you make <tt>k</tt>\nin order to get an approximation that is accurate to 4 decimal places?<p>\n\n<p><p>b. If your <tt>cont-frac</tt>\nprocedure generates a recursive process, write one that generates\nan iterative process.\nIf it generates an iterative process, write one that generates\na recursive process.\n\n<p><p>\n\n<p><a name="%_thm_1.38"></a>\n<b>Exercise 1.38.</b>&nbsp;&nbsp;<a name="%_idx_1144"></a>In 1737, the Swiss mathematician Leonhard Euler published a memoir\n<em>De Fractionibus Continuis</em>, which included a <a name="%_idx_1146"></a><a name="%_idx_1148"></a>continued fraction\nexpansion for <em>e</em> - 2, where <em>e</em> is the base of the natural logarithms.\nIn this fraction, the <em>N</em><sub><em>i</em></sub> are all 1, and the <em>D</em><sub><em>i</em></sub> are successively\n1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, <tt>...</tt>.  Write a program that uses\nyour <tt>cont-frac</tt> procedure from\nexercise&nbsp;<a href="#%_thm_1.37">1.37</a> to approximate <em>e</em>, based on\nEuler\'s expansion.\n<p><p>\n\n<p><a name="%_thm_1.39"></a>\n<b>Exercise 1.39.</b>&nbsp;&nbsp;<a name="%_idx_1150"></a><a name="%_idx_1152"></a><a name="%_idx_1154"></a>A continued fraction representation of the tangent function was\npublished in 1770 by the German mathematician J.H. Lambert:\n<p><div align=left><img src="ch1-Z-G-36.gif" border="0"></div><p> \nwhere <em>x</em> is in radians.\nDefine a procedure <tt>(tan-cf x k)</tt> that computes an approximation\nto the tangent function based on Lambert\'s\nformula.  <tt>K</tt> specifies the number of terms to compute, as in\nexercise&nbsp;<a href="#%_thm_1.37">1.37</a>.\n<p><p>\n\n<a name="%_sec_1.3.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.3.4">1.3.4&nbsp;&nbsp;Procedures as Returned Values</a></h3><p>\n\n\n<a name="%_idx_1156"></a><a name="%_idx_1158"></a>\nThe above examples demonstrate how\nthe ability to pass procedures as arguments significantly enhances\nthe expressive power of our programming language.  We can achieve even\nmore expressive power by creating procedures whose returned values are\nthemselves procedures.<p>\n\nWe can illustrate this idea by looking again at the fixed-point\nexample described at the end of\nsection&nbsp;<a href="#%_sec_1.3.3">1.3.3</a>.  We formulated a new version\nof the square-root procedure as a fixed-point search, starting with\nthe observation that <img src="book-Z-G-D-13.gif" border="0"><em>x</em> is a fixed-point of the function\n<em>y</em> <img src="book-Z-G-D-17.gif" border="0">  <em>x</em>/<em>y</em>.  Then we used average damping to make the\napproximations converge.  Average damping is a useful general\ntechnique in itself.  Namely, given a function&nbsp;<em>f</em>, we consider the\nfunction whose value at <em>x</em> is equal to the average of <em>x</em> and <em>f</em>(<em>x</em>).<p>\n\n\nWe can express the idea of average damping by means of the\nfollowing procedure:<p>\n\n<p><p><tt><a name="%_idx_1160"></a>(define&nbsp;(average-damp&nbsp;f)<br>\n&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(average&nbsp;x&nbsp;(f&nbsp;x))))<br>\n</tt><p><p>\n<tt>Average-damp</tt> is a procedure that takes as its argument a\nprocedure <tt>f</tt> and returns as its value a procedure (produced by\nthe <tt>lambda</tt>) that, when applied to a number <tt>x</tt>, produces the\naverage of <tt>x</tt> and <tt>(f x)</tt>.  For example, applying <tt>average-damp</tt> to the <tt>square</tt> procedure produces a procedure whose\nvalue at some number <em>x</em> is the average of <em>x</em> and <em>x</em><sup>2</sup>.  Applying\nthis resulting procedure to 10 returns the average of 10 and 100, or\n55:<a name="call_footnote_Temp_114" href="#footnote_Temp_114"><sup><small>59</small></sup></a><p>\n\n\n<p><p><tt>((average-damp&nbsp;square)&nbsp;10)<br>\n<i>55</i><br>\n</tt><p><p><p>\n\n<a name="%_idx_1168"></a>Using <tt>average-damp</tt>, we can reformulate the square-root procedure\nas follows:<p>\n\n\n<p><p><tt><a name="%_idx_1170"></a>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(fixed-point&nbsp;(average-damp&nbsp;(lambda&nbsp;(y)&nbsp;(/&nbsp;x&nbsp;y)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0))<br>\n</tt><p><p>\nNotice how this formulation makes explicit the three ideas in the\nmethod: fixed-point search, average damping, and the function\n<em>y</em> <img src="book-Z-G-D-17.gif" border="0">  <em>x</em>/<em>y</em>.  It is instructive to compare this formulation of the\nsquare-root method with the original version given in\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>.  Bear in mind that these procedures express\nthe same process, and notice how much clearer the idea becomes when we\nexpress the process in terms of these abstractions.  In general, there\nare many ways to formulate a process as a procedure.  Experienced\nprogrammers know how to choose procedural formulations that are\nparticularly perspicuous, and where useful elements of the process are\nexposed as separate entities that can be reused in other applications.\nAs a simple example of reuse, notice that the cube root of <em>x</em> is a\nfixed point of the function <em>y</em> <img src="book-Z-G-D-17.gif" border="0">  <em>x</em>/<em>y</em><sup>2</sup>, so we can immediately\ngeneralize our square-root procedure to one that extracts <a name="%_idx_1172"></a><a name="%_idx_1174"></a>cube\nroots:<a name="call_footnote_Temp_115" href="#footnote_Temp_115"><sup><small>60</small></sup></a><p>\n\n\n<p><p><tt><a name="%_idx_1176"></a>(define&nbsp;(cube-root&nbsp;x)<br>\n&nbsp;&nbsp;(fixed-point&nbsp;(average-damp&nbsp;(lambda&nbsp;(y)&nbsp;(/&nbsp;x&nbsp;(square&nbsp;y))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0))<br>\n</tt><p><p><p>\n\n\n<a name="%_sec_Temp_116"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_116">Newton\'s method</a></h4><p>\n\n<a name="%_idx_1178"></a>\nWhen we first introduced the square-root procedure, in\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>, we mentioned that this was a special case of\n<em>Newton\'s method</em>.  \nIf <em>x</em> <img src="book-Z-G-D-17.gif" border="0">  <em>g</em>(<em>x</em>) is a differentiable function, then a solution of\nthe equation <em>g</em>(<em>x</em>) = 0 is a fixed point of the function <em>x</em> <img src="book-Z-G-D-17.gif" border="0">  <em>f</em>(<em>x</em>)\nwhere\n<p><div align=left><img src="ch1-Z-G-37.gif" border="0"></div><p>\nand\n<em>D</em><em>g</em>(<em>x</em>) is the derivative of <em>g</em> evaluated at <em>x</em>.  <a name="%_idx_1180"></a>Newton\'s\nmethod is the use of the fixed-point method we saw above to\napproximate a solution of the equation by finding a fixed point of\nthe function <em>f</em>.<a name="call_footnote_Temp_117" href="#footnote_Temp_117"><sup><small>61</small></sup></a>\nFor many functions <em>g</em> and for sufficiently good initial guesses for\n<em>x</em>, Newton\'s method converges very rapidly to a solution of\n<em>g</em>(<em>x</em>) = 0.<a name="call_footnote_Temp_118" href="#footnote_Temp_118"><sup><small>62</small></sup></a><p>\n\n<a name="%_idx_1186"></a><a name="%_idx_1188"></a><a name="%_idx_1190"></a>In order to implement Newton\'s method as a procedure, we must first\nexpress the idea of derivative.  Note that ``derivative,\'\' like\naverage damping, is something that transforms a function into another\nfunction.  For instance, the derivative of the function <em>x</em> <img src="book-Z-G-D-17.gif" border="0"> \n<em>x</em><sup>3</sup> is the function <em>x</em>  <img src="book-Z-G-D-17.gif" border="0">  3<em>x</em><sup>2</sup>.  In general, if <em>g</em> is a\nfunction and <em>d</em><em>x</em> is a small number, then the derivative <em>D</em><em>g</em> of <em>g</em> is\nthe function whose value at any number <em>x</em> is given (in the limit of\nsmall <em>d</em><em>x</em>) by\n<p><div align=left><img src="ch1-Z-G-38.gif" border="0"></div><p>\nThus, we can express the idea of derivative (taking <em>d</em><em>x</em> to be, say,\n0.00001) as the procedure<p>\n\n<p><p><tt><a name="%_idx_1192"></a>(define&nbsp;(deriv&nbsp;g)<br>\n&nbsp;&nbsp;(lambda&nbsp;(x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;(-&nbsp;(g&nbsp;(+&nbsp;x&nbsp;dx))&nbsp;(g&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dx)))<br>\n</tt><p><p>\nalong with the definition<p>\n\n<p><p><tt>(define&nbsp;dx&nbsp;0.00001)<br>\n</tt><p><p><p>\n\nLike <tt>average-damp</tt>, <tt>deriv</tt> is a procedure that takes a\nprocedure as argument and returns a procedure as value.  For example,\nto approximate the derivative of <em>x</em>  <img src="book-Z-G-D-17.gif" border="0">  <em>x</em><sup>3</sup> at 5 (whose exact\nvalue is 75) we can evaluate<p>\n\n<p><p><tt><a name="%_idx_1194"></a>(define&nbsp;(cube&nbsp;x)&nbsp;(*&nbsp;x&nbsp;x&nbsp;x))<br>\n((deriv&nbsp;cube)&nbsp;5)<br>\n<i>75.00014999664018</i><br>\n</tt><p><p><p>\n\nWith the aid of <tt>deriv</tt>, we can express Newton\'s method as a\nfixed-point process:<p>\n\n<p><p><tt><a name="%_idx_1196"></a>(define&nbsp;(newton-transform&nbsp;g)<br>\n&nbsp;&nbsp;(lambda&nbsp;(x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;x&nbsp;(/&nbsp;(g&nbsp;x)&nbsp;((deriv&nbsp;g)&nbsp;x)))))<br>\n<a name="%_idx_1198"></a>(define&nbsp;(newtons-method&nbsp;g&nbsp;guess)<br>\n&nbsp;&nbsp;(fixed-point&nbsp;(newton-transform&nbsp;g)&nbsp;guess))<br>\n</tt><p><p>\nThe <tt>newton-transform</tt> procedure expresses the formula at the\nbeginning of this section, and <tt>newtons-method</tt> is readily defined\nin terms of this.  It takes as arguments a procedure that computes the\nfunction for which we want to find a zero, together with an initial\nguess.  For instance, to find the <a name="%_idx_1200"></a>square root of <em>x</em>, we can use\nNewton\'s method to find a zero of the function <em>y</em> <img src="book-Z-G-D-17.gif" border="0">  <em>y</em><sup>2</sup> - <em>x</em> starting with\nan initial guess of 1.<a name="call_footnote_Temp_119" href="#footnote_Temp_119"><sup><small>63</small></sup></a>\nThis provides yet another form of the square-root\nprocedure:<p>\n\n<p><p><tt><a name="%_idx_1202"></a>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(newtons-method&nbsp;(lambda&nbsp;(y)&nbsp;(-&nbsp;(square&nbsp;y)&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_120"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_120">Abstractions and first-class procedures</a></h4><p>\n\nWe\'ve seen two ways to express the square-root\ncomputation as an instance of a more general method, once as a fixed-point\nsearch and once using Newton\'s method.  Since Newton\'s method\nwas itself expressed as a fixed-point process,\nwe actually saw two ways to compute square roots as fixed points.\nEach method begins with a function and finds a <a name="%_idx_1204"></a>fixed\npoint of some transformation of the function.  We can express this\ngeneral idea itself as a procedure:<p>\n\n<p><p><tt><a name="%_idx_1206"></a>(define&nbsp;(fixed-point-of-transform&nbsp;g&nbsp;transform&nbsp;guess)<br>\n&nbsp;&nbsp;(fixed-point&nbsp;(transform&nbsp;g)&nbsp;guess))<br>\n</tt><p><p>\nThis very general procedure takes as its arguments a procedure <tt>g</tt>\nthat computes some function, a procedure that transforms <tt>g</tt>, and\nan initial guess.  The returned result is a fixed point of the\ntransformed function.<p>\n\n<a name="%_idx_1208"></a>Using this abstraction, we can recast the first square-root\ncomputation from this section (where we look for\na fixed point of the average-damped version of <em>y</em>  <img src="book-Z-G-D-17.gif" border="0">  <em>x</em>/<em>y</em>)\nas an instance of this general method:<p>\n\n<p><p><tt><a name="%_idx_1210"></a>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(fixed-point-of-transform&nbsp;(lambda&nbsp;(y)&nbsp;(/&nbsp;x&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;average-damp<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0))<br>\n</tt><p><p>\n<a name="%_idx_1212"></a>Similarly, we can express the second square-root computation from this section\n(an instance\nof Newton\'s method that finds a fixed point of the\nNewton transform of <em>y</em> <img src="book-Z-G-D-17.gif" border="0">  <em>y</em><sup>2</sup> - <em>x</em>) as<p>\n\n<p><p><tt><a name="%_idx_1214"></a><a name="%_idx_1216"></a>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(fixed-point-of-transform&nbsp;(lambda&nbsp;(y)&nbsp;(-&nbsp;(square&nbsp;y)&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newton-transform<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0))<br>\n</tt><p><p><p>\n\nWe began section&nbsp;<a href="#%_sec_1.3">1.3</a> with the observation\nthat compound procedures\nare a crucial abstraction mechanism, because they permit us to\nexpress general methods of computing as explicit elements in our\nprogramming language.  Now we\'ve seen how higher-order\nprocedures permit us to manipulate these general methods\nto create further abstractions.<p>\n\nAs programmers, we should be alert to opportunities to identify the\nunderlying abstractions in our programs and to build upon them and\ngeneralize them to create more powerful abstractions.  This is not to\nsay that one should always write programs in the most abstract way\npossible; expert programmers know how to choose the level of\nabstraction appropriate to their task.  But it is important to be able\nto think in terms of these abstractions, so that we can be ready to\napply them in new contexts.  The significance of higher-order\nprocedures is that they enable us to represent these abstractions\nexplicitly as elements in our programming language, so that they can\nbe handled just like other computational elements.<p>\n\nIn general, programming languages impose restrictions on the ways in\nwhich computational elements can be manipulated.  Elements with the\nfewest restrictions are said to have <a name="%_idx_1218"></a><em>first-class</em> status.  Some\nof the ``rights and privileges\'\' of first-class elements are:<a name="call_footnote_Temp_121" href="#footnote_Temp_121"><sup><small>64</small></sup></a>\n<p><ul>\n<li>They may be named by variables.\n<li>They may be passed as arguments to procedures.\n<li>They may be returned as the results of procedures.\n<li>They may be included in data structures.<a name="call_footnote_Temp_122" href="#footnote_Temp_122"><sup><small>65</small></sup></a>\n</ul><p>\n<a name="%_idx_1222"></a><a name="%_idx_1224"></a>Lisp, unlike other common programming languages, awards procedures\nfull first-class status.  This poses challenges for efficient\nimplementation, but the resulting gain in expressive power is\nenormous.<a name="call_footnote_Temp_123" href="#footnote_Temp_123"><sup><small>66</small></sup></a><p>\n\n<p><a name="%_thm_1.40"></a>\n<b>Exercise 1.40.</b>&nbsp;&nbsp;Define a procedure <tt>cubic</tt> that can be used together with the <tt>newtons-method</tt> procedure in expressions of the form<p>\n\n\n<p><p><tt>(newtons-method&nbsp;(cubic&nbsp;a&nbsp;b&nbsp;c)&nbsp;1)<br>\n</tt><p><p>\nto approximate zeros of the cubic <em>x</em><sup>3</sup>  + <em>a</em><em>x</em><sup>2</sup>  + <em>b</em><em>x</em>  + <em>c</em>.\n<p><p>\n\n<p><a name="%_thm_1.41"></a>\n<b>Exercise 1.41.</b>&nbsp;&nbsp;Define a procedure <tt>double</tt> that takes a procedure of one\nargument as argument and\nreturns a procedure that applies the original procedure twice.  For\nexample, if <tt>inc</tt> is a procedure that adds 1 to its argument,\nthen <tt>(double inc)</tt> should be a procedure that adds 2.  What\nvalue is returned by<p>\n\n\n<p><p><tt>(((double&nbsp;(double&nbsp;double))&nbsp;inc)&nbsp;5)<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_1.42"></a>\n<b>Exercise 1.42.</b>&nbsp;&nbsp;<a name="%_idx_1226"></a><a name="%_idx_1228"></a>Let <em>f</em> and <em>g</em> be two one-argument functions.  The <em>composition</em>\n<em>f</em> after <em>g</em> is defined to be the function <em>x</em> <img src="book-Z-G-D-17.gif" border="0">  <em>f</em>(<em>g</em>(<em>x</em>)).\nDefine a procedure <tt>compose</tt> that implements composition.  For\nexample, if <tt>inc</tt> is a procedure that adds 1 to its argument,\n\n<p><p><tt>((compose&nbsp;square&nbsp;inc)&nbsp;6)<br>\n<i>49</i><br>\n</tt><p><p>\n<p><p>\n\n\n<p><a name="%_thm_1.43"></a>\n<b>Exercise 1.43.</b>&nbsp;&nbsp;<a name="%_idx_1230"></a>If <em>f</em> is a numerical function and <em>n</em> is a positive integer, then we\ncan form the <em>n</em>th repeated application of <em>f</em>, which is defined to be\nthe function whose value at <em>x</em> is <em>f</em>(<em>f</em>(<tt>...</tt>(<em>f</em>(<em>x</em>))<tt>...</tt>)).  For\nexample, if <em>f</em> is the function <em>x</em>  <img src="book-Z-G-D-17.gif" border="0">  <em>x</em> + 1,\nthen the <em>n</em>th repeated application of <em>f</em> is\nthe function <em>x</em>  <img src="book-Z-G-D-17.gif" border="0">  <em>x</em> + <em>n</em>.  If <em>f</em> is the operation of\nsquaring a number, then the <em>n</em>th repeated application of <em>f</em> is the\nfunction that raises its argument to the 2<sup><em>n</em></sup>th power.  Write a\nprocedure that takes as inputs a procedure that computes <em>f</em> and a\npositive integer <em>n</em> and returns the procedure that computes the <em>n</em>th\nrepeated application of <em>f</em>.  Your procedure should be able to be used\nas follows:<p>\n\n\n<p><p><tt>((repeated&nbsp;square&nbsp;2)&nbsp;5)<br>\n<i>625</i><br>\n</tt><p><p>\nHint: You may find it convenient to use <tt>compose</tt> from\nexercise&nbsp;<a href="#%_thm_1.42">1.42</a>.\n\n<p><p>\n\n<p><a name="%_thm_1.44"></a>\n<b>Exercise 1.44.</b>&nbsp;&nbsp;<a name="%_idx_1232"></a><a name="%_idx_1234"></a><a name="%_idx_1236"></a>The idea of <em>smoothing</em> a function is an important concept in\nsignal processing.  If <em>f</em> is a function and <em>d</em><em>x</em> is some small number,\nthen the smoothed version of <em>f</em> is the function whose value at a\npoint <em>x</em> is the average of <em>f</em>(<em>x</em> - <em>d</em><em>x</em>), <em>f</em>(<em>x</em>), and <em>f</em>(<em>x</em> + <em>d</em><em>x</em>).  Write a\nprocedure <tt>smooth</tt> that takes as input a procedure that computes\n<em>f</em> and returns a procedure that computes the smoothed <em>f</em>.  It is\nsometimes valuable to repeatedly smooth a function (that is, smooth\nthe smoothed function, and so on) to obtained the <em><em>n</em>-fold\nsmoothed function</em>.  Show how to generate the <em>n</em>-fold smoothed\nfunction of any given function using <tt>smooth</tt> and <tt>repeated</tt>\nfrom exercise&nbsp;<a href="#%_thm_1.43">1.43</a>.\n<p><p>\n\n<p><a name="%_thm_1.45"></a>\n<b>Exercise 1.45.</b>&nbsp;&nbsp;We saw in section&nbsp;<a href="#%_sec_1.3.3">1.3.3</a>\nthat attempting to compute square roots by naively finding a\nfixed point of <em>y</em> <img src="book-Z-G-D-17.gif" border="0">  <em>x</em>/<em>y</em> does not converge, and that this can be\nfixed by average damping.  The same method works for finding cube\nroots as fixed points of the average-damped <em>y</em> <img src="book-Z-G-D-17.gif" border="0">  <em>x</em>/<em>y</em><sup>2</sup>.\nUnfortunately, the process does not work for <a name="%_idx_1238"></a><a name="%_idx_1240"></a>fourth roots -- a single\naverage damp is not enough to make a fixed-point search for <em>y</em> <img src="book-Z-G-D-17.gif" border="0"> \n<em>x</em>/<em>y</em><sup>3</sup> converge.  On the other hand, if we average damp twice (i.e.,\nuse the average damp of the average damp of <em>y</em> <img src="book-Z-G-D-17.gif" border="0">  <em>x</em>/<em>y</em><sup>3</sup>) the\nfixed-point search does converge.  Do some experiments to determine\nhow many average damps are required to compute <a name="%_idx_1242"></a><a name="%_idx_1244"></a><em>n</em>th roots as a\nfixed-point search based upon repeated average damping of <em>y</em> <img src="book-Z-G-D-17.gif" border="0"> \n<em>x</em>/<em>y</em><sup><em>n</em>-1</sup>.  Use this to implement a simple procedure for computing\n<em>n</em>th roots using <tt>fixed-point</tt>, <tt>average-damp</tt>, and the <tt>repeated</tt> procedure of exercise&nbsp;<a href="#%_thm_1.43">1.43</a>.\nAssume that any arithmetic operations you need are available as primitives.\n\n<p><p>\n\n<p><a name="%_thm_1.46"></a>\n<b>Exercise 1.46.</b>&nbsp;&nbsp;<a name="%_idx_1246"></a><a name="%_idx_1248"></a><a name="%_idx_1250"></a><a name="%_idx_1252"></a>Several of the numerical methods described in this chapter are instances\nof an extremely general computational strategy known as <em>iterative\nimprovement</em>.  Iterative improvement says that, to compute something,\nwe start with an initial guess for the answer, test if the guess is\ngood enough, and otherwise improve the guess and continue the process\nusing the improved guess as the new guess.  Write a procedure <tt>iterative-improve</tt> that takes two procedures as arguments: a method\nfor telling whether a guess is good enough and a method for improving\na guess.  <tt>Iterative-improve</tt> should return as its value a\nprocedure that takes a guess as argument and keeps improving the guess\nuntil it is good enough.  Rewrite the <tt>sqrt</tt> procedure of\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a> and the <tt>fixed-point</tt> procedure of\nsection&nbsp;<a href="#%_sec_1.3.3">1.3.3</a> in terms of <tt>iterative-improve</tt>.\n<p>\n<p>\n\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_90" href="#call_footnote_Temp_90"><sup><small>49</small></sup></a> This series,\n<a name="%_idx_974"></a><a name="%_idx_976"></a>usually written in the equivalent form (<img src="book-Z-G-D-9.gif" border="0">/4)  =  1 - (1/3) + (1/5) - (1/7) + <tt>&middot;&middot;&middot;</tt>, is due to Leibniz.  We\'ll see how\nto use this as the basis for some fancy numerical tricks in\nsection&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.3">3.5.3</a>.\n\n<p><a name="footnote_Temp_91" href="#call_footnote_Temp_91"><sup><small>50</small></sup></a> Notice\nthat we have used block structure (section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.8">1.1.8</a>) to\nembed the definitions of <tt>pi-next</tt> and <tt>pi-term</tt> within <tt>pi-sum</tt>, since these procedures are unlikely to be useful for any\nother purpose.  We will see how to get rid of them altogether in\nsection&nbsp;<a href="#%_sec_1.3.2">1.3.2</a>.\n\n<p><a name="footnote_Temp_95" href="#call_footnote_Temp_95"><sup><small>51</small></sup></a> The intent of\nexercises&nbsp;<a href="#%_thm_1.31">1.31</a>-<a href="#%_thm_1.33">1.33</a> is to\ndemonstrate the expressive power that is attained by using an\nappropriate abstraction to consolidate many seemingly disparate\noperations.  However, though accumulation and filtering are elegant\nideas, our hands are somewhat tied in using them at this point since\nwe do not yet have data structures to provide suitable means of\ncombination for these abstractions.  We will return to these ideas in\nsection&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a> when we show how\nto use <em>sequences</em> as interfaces for combining filters and\naccumulators to build even more powerful abstractions.  We will see\nthere how these methods really come into their own as a powerful and\nelegant approach to designing programs.\n\n<p><a name="footnote_Temp_96" href="#call_footnote_Temp_96"><sup><small>52</small></sup></a> This formula was discovered by the seventeenth-century\n<a name="%_idx_1016"></a>English mathematician John Wallis.\n\n<p><a name="footnote_Temp_99" href="#call_footnote_Temp_99"><sup><small>53</small></sup></a> It would be clearer and less intimidating to\npeople learning Lisp if a name more obvious than <tt>lambda</tt>, such as\n<tt>make-procedure</tt>, were used.  But the convention is firmly\nentrenched.  The notation is adopted from the <a name="%_idx_1054"></a><img src="book-Z-G-D-6.gif" border="0"> calculus, a\n<a name="%_idx_1056"></a>mathematical formalism introduced by the mathematical logician Alonzo\nChurch (1941).  Church developed the <img src="book-Z-G-D-6.gif" border="0"> calculus to provide a\nrigorous foundation for studying the notions of function and function\napplication.  The <img src="book-Z-G-D-6.gif" border="0"> calculus has become a basic tool for\nmathematical investigations of the semantics of programming\nlanguages.\n\n<p><a name="footnote_Temp_101" href="#call_footnote_Temp_101"><sup><small>54</small></sup></a> Understanding internal definitions well enough to be sure a\nprogram means what we intend it to mean requires a more elaborate\nmodel of the evaluation process than we have presented in this\nchapter.  The subtleties do not arise with internal definitions of\nprocedures, however.  We will return to this issue in\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.6">4.1.6</a>, after we learn more about\nevaluation.\n\n<p><a name="footnote_Temp_104" href="#call_footnote_Temp_104"><sup><small>55</small></sup></a> We have used 0.001 as a representative ``small\'\' number to indicate a\ntolerance for the acceptable error in a calculation.  The appropriate\ntolerance for a real calculation depends upon the problem to be solved\nand the limitations of the computer and the algorithm.  This is often\n<a name="%_idx_1086"></a>a very subtle consideration, requiring help from a numerical analyst\nor some other kind of magician.\n\n<p><a name="footnote_Temp_105" href="#call_footnote_Temp_105"><sup><small>56</small></sup></a> This\n<a name="%_idx_1088"></a><a name="%_idx_1090"></a>can be accomplished using <tt>error</tt>, which takes as\narguments a number of items that are printed as error\nmessages.\n\n<p><a name="footnote_Temp_107" href="#call_footnote_Temp_107"><sup><small>57</small></sup></a> Try this during a boring lecture: Set your calculator to\n<a name="%_idx_1106"></a><a name="%_idx_1108"></a><a name="%_idx_1110"></a>radians mode and then repeatedly press the <tt>cos</tt> button until you\nobtain the fixed point.\n\n<p><a name="footnote_Temp_108" href="#call_footnote_Temp_108"><sup><small>58</small></sup></a>  <img src="book-Z-G-D-17.gif" border="0"> \n<a name="%_idx_1122"></a><a name="%_idx_1124"></a>(pronounced ``maps to\'\') is\nthe mathematician\'s way of writing <tt>lambda</tt>.\n<em>y</em>  <img src="book-Z-G-D-17.gif" border="0">  <em>x</em>/<em>y</em> means <tt>(lambda(y) (/ x y))</tt>, that is, the\nfunction whose value at <em>y</em> is <em>x</em>/<em>y</em>.\n\n<p><a name="footnote_Temp_114" href="#call_footnote_Temp_114"><sup><small>59</small></sup></a> Observe that this is a combination whose operator is itself\n<a name="%_idx_1162"></a><a name="%_idx_1164"></a><a name="%_idx_1166"></a>a combination.  Exercise&nbsp;<a href="book-Z-H-10.html#%_thm_1.4">1.4</a> already demonstrated\nthe ability to form such combinations, but that was only a toy\nexample.  Here we begin to see the real need for such\ncombinations -- when applying a procedure that is obtained as the value\nreturned by a higher-order procedure.\n\n<p><a name="footnote_Temp_115" href="#call_footnote_Temp_115"><sup><small>60</small></sup></a> See exercise&nbsp;<a href="#%_thm_1.45">1.45</a> for a further\ngeneralization.\n\n<p><a name="footnote_Temp_117" href="#call_footnote_Temp_117"><sup><small>61</small></sup></a> Elementary calculus books usually describe Newton\'s\nmethod in terms of the sequence of approximations\n<em>x</em><sub><em>n</em>+1</sub> = <em>x</em><sub><em>n</em></sub> - <em>g</em>(<em>x</em><sub><em>n</em></sub>)/<em>D</em><em>g</em>(<em>x</em><sub><em>n</em></sub>).  Having language for talking about\nprocesses and using the idea of fixed points simplifies the description\nof the method.\n\n<p><a name="footnote_Temp_118" href="#call_footnote_Temp_118"><sup><small>62</small></sup></a> Newton\'s method does not always converge to an answer, but\nit can be shown that in favorable cases each iteration doubles the\nnumber-of-digits accuracy of the approximation to the solution.\nIn such cases, <a name="%_idx_1182"></a><a name="%_idx_1184"></a>Newton\'s method will converge much more\nrapidly than the half-interval method.\n\n<p><a name="footnote_Temp_119" href="#call_footnote_Temp_119"><sup><small>63</small></sup></a> For finding square roots, Newton\'s method converges rapidly to the\ncorrect solution from any starting point.\n\n<p><a name="footnote_Temp_121" href="#call_footnote_Temp_121"><sup><small>64</small></sup></a> The notion of first-class status of programming-language\n<a name="%_idx_1220"></a>elements is due to the British computer scientist Christopher\nStrachey (1916-1975).\n\n<p><a name="footnote_Temp_122" href="#call_footnote_Temp_122"><sup><small>65</small></sup></a> We\'ll see\nexamples of this after we introduce data structures in chapter&nbsp;2.\n\n<p><a name="footnote_Temp_123" href="#call_footnote_Temp_123"><sup><small>66</small></sup></a> The major implementation cost of first-class\nprocedures is that allowing procedures to be returned as values\nrequires reserving storage for a procedure\'s free variables even while\nthe procedure is not executing.  In the Scheme implementation we will\nstudy in section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1">4.1</a>, these variables are stored in the\nprocedure\'s environment.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_chap_2"></a>\n<h1 class=chapter>\n<div class=chapterheading><a href="book-Z-H-4.html#%_toc_%_chap_2">Chapter 2</a></div><p>\n<a href="book-Z-H-4.html#%_toc_%_chap_2">Building Abstractions with Data</a></h1><p>\n\n<p>\n<div align=right> \n<table width=60%><tr><td>\n<span class=epigraph>\n<p>\n\nWe now come to the decisive step of mathematical abstraction: we\nforget about what the symbols stand for. <tt>...</tt></div><p>\n\n<a name="%_sec_2.1"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_2.1">2.1&nbsp;&nbsp;Introduction to Data Abstraction</a></h2><p>\n\nIn section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.8">1.1.8</a>, we noted\nthat a procedure used as an element in creating a more complex\nprocedure could be regarded not only as a collection of particular\noperations but also as a procedural abstraction.  That is, the details\nof how the procedure was implemented could be suppressed, and the\nparticular procedure itself could be replaced by any other procedure\nwith the same overall behavior.  In other words, we could make an\nabstraction that would separate the way the procedure would be used\nfrom the details of how the procedure would be implemented in terms of\nmore primitive procedures.  The analogous notion for compound data is\ncalled <a name="%_idx_1280"></a><em>data abstraction</em>.  Data abstraction is a methodology that\nenables us to isolate how a compound data object is used from the\ndetails of how it is constructed from more primitive data objects.<p>\n\nThe basic idea of data abstraction is to structure the programs that\nare to use compound data objects so that they operate on <a name="%_idx_1282"></a><a name="%_idx_1284"></a>``abstract\ndata.\'\' That is, our programs should use data in such a way as to make\nno assumptions about the data that are not strictly necessary for\nperforming the task at hand.  At the same time, a <a name="%_idx_1286"></a><a name="%_idx_1288"></a>``concrete\'\' data\nrepresentation is defined independent of the programs that use\nthe data.  The interface between these two parts of our system will be\na set of procedures, called <a name="%_idx_1290"></a><em>selectors</em> and <a name="%_idx_1292"></a><em>constructors</em>,\nthat implement the abstract data in terms of the concrete\nrepresentation.  To illustrate this technique, we will consider how to\ndesign a set of procedures for manipulating rational numbers.<p>\n\n<a name="%_sec_2.1.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.1.1">2.1.1&nbsp;&nbsp;Example: Arithmetic Operations for Rational Numbers</a></h3><p>\n\n<p>\n\n<a name="%_idx_1294"></a><a name="%_idx_1296"></a><a name="%_idx_1298"></a>Suppose we want to do arithmetic with rational numbers.  We want to be\nable to add, subtract, multiply, and divide them and to test whether\ntwo rational numbers are equal.<p>\n\nLet us begin by assuming that we already have a way of constructing a\nrational number from a numerator and a denominator.  We also assume\nthat, given a rational number, we have a way of extracting (or\nselecting) its numerator and its denominator.  Let us further assume\nthat the constructor and selectors are available as procedures:<p>\n\n<p><ul>\n<a name="%_idx_1300"></a><li><tt>(make-rat &lt;<em>n</em>&gt; &lt;<em>d</em>&gt;)</tt> returns the\nrational number whose  numerator is the integer <tt>&lt;<em>n</em>&gt;</tt>\nand whose denominator is the integer <tt>&lt;<em>d</em>&gt;</tt>. <p>\n\n<a name="%_idx_1302"></a><li><tt>(numer &lt;<em>x</em>&gt;)</tt> returns the numerator of the rational \nnumber <tt>&lt;<em>x</em>&gt;</tt>.<p>\n\n<a name="%_idx_1304"></a><li><tt>(denom &lt;<em>x</em>&gt;)</tt> returns the denominator of the \nrational number <tt>&lt;<em>x</em>&gt;</tt>.\n</ul><p><p>\n\nWe are using here a powerful strategy of synthesis: <a name="%_idx_1306"></a><em>wishful thinking</em>.\nWe haven\'t yet said how a rational number is represented, or how the\nprocedures <tt>numer</tt>, <tt>denom</tt>, and <tt>make-rat</tt> should be\nimplemented.  Even so, if we did have these three procedures, we could\nthen add, subtract, multiply, divide, and test equality by using the\nfollowing relations:<p>\n\n<p><div align=left><img src="ch2-Z-G-1.gif" border="0"></div><p><p>\n\n<p><div align=left><img src="ch2-Z-G-2.gif" border="0"></div><p><p>\n\n<p><div align=left><img src="ch2-Z-G-3.gif" border="0"></div><p><p>\n\n<p><div align=left><img src="ch2-Z-G-4.gif" border="0"></div><p><p>\n\n<p><div align=left><img src="ch2-Z-G-5.gif" border="0"></div><p><p>\n\nWe can express these rules as procedures:<p>\n\n<p><p><tt><a name="%_idx_1308"></a>(define&nbsp;(add-rat&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(make-rat&nbsp;(+&nbsp;(*&nbsp;(numer&nbsp;x)&nbsp;(denom&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(numer&nbsp;y)&nbsp;(denom&nbsp;x)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(denom&nbsp;x)&nbsp;(denom&nbsp;y))))<br>\n<a name="%_idx_1310"></a>(define&nbsp;(sub-rat&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(make-rat&nbsp;(-&nbsp;(*&nbsp;(numer&nbsp;x)&nbsp;(denom&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(numer&nbsp;y)&nbsp;(denom&nbsp;x)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(denom&nbsp;x)&nbsp;(denom&nbsp;y))))<br>\n<a name="%_idx_1312"></a>(define&nbsp;(mul-rat&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(make-rat&nbsp;(*&nbsp;(numer&nbsp;x)&nbsp;(numer&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(denom&nbsp;x)&nbsp;(denom&nbsp;y))))<br>\n<a name="%_idx_1314"></a>(define&nbsp;(div-rat&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(make-rat&nbsp;(*&nbsp;(numer&nbsp;x)&nbsp;(denom&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(denom&nbsp;x)&nbsp;(numer&nbsp;y))))<br>\n<a name="%_idx_1316"></a>(define&nbsp;(equal-rat?&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(=&nbsp;(*&nbsp;(numer&nbsp;x)&nbsp;(denom&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(numer&nbsp;y)&nbsp;(denom&nbsp;x))))<br>\n</tt><p><p><p>\n\nNow we have the operations on rational numbers defined in terms of the\nselector and constructor procedures\n<tt>numer</tt>, <tt>denom</tt>, and <tt>make-rat</tt>.\nBut we haven\'t yet defined these.\nWhat we need is some way to glue together a numerator and a\ndenominator to form a rational\nnumber.<p>\n\n<a name="%_sec_Temp_132"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_132">Pairs</a></h4><p>\n\nTo enable us to implement the concrete level of our data\nabstraction, our language provides a compound structure called a <a name="%_idx_1318"></a><em>pair</em>, which can be constructed with the primitive procedure <a name="%_idx_1320"></a><a name="%_idx_1322"></a><tt>cons</tt>.  This procedure takes two arguments and returns a compound data\nobject that contains the two arguments as parts.  Given a pair, we can\nextract the parts using the primitive procedures <a name="%_idx_1324"></a><a name="%_idx_1326"></a><tt>car</tt> and <a name="%_idx_1328"></a><a name="%_idx_1330"></a><tt>cdr</tt>.<a name="call_footnote_Temp_133" href="#footnote_Temp_133"><sup><small>2</small></sup></a> Thus, we can use <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> as follows:<p>\n\n\n\n<p><p><tt>(define&nbsp;x&nbsp;(cons&nbsp;1&nbsp;2))<br>\n<br>\n(car&nbsp;x)<br>\n<i>1</i><br>\n<br>\n(cdr&nbsp;x)<br>\n<i>2</i><br>\n</tt><p><p>\nNotice that a pair is a data object that can be given a name and\nmanipulated, just like a primitive data object.  Moreover, <tt>cons</tt>\ncan be used to form pairs whose elements are pairs, and so on:<p>\n\n\n<p><p><tt>(define&nbsp;x&nbsp;(cons&nbsp;1&nbsp;2))<br>\n<br>\n(define&nbsp;y&nbsp;(cons&nbsp;3&nbsp;4))<br>\n<br>\n(define&nbsp;z&nbsp;(cons&nbsp;x&nbsp;y))<br>\n<br>\n(car&nbsp;(car&nbsp;z))<br>\n<i>1</i><br>\n<br>\n(car&nbsp;(cdr&nbsp;z))<br>\n<i>3</i><br>\n</tt><p><p>\nIn section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2">2.2</a> we will see how this ability to\ncombine pairs means that pairs can be used as general-purpose building\nblocks to create all sorts of complex data structures.  The single\ncompound-data primitive <em>pair</em>, implemented by the procedures <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>, is the only glue we need.  Data\nobjects constructed from pairs are called <a name="%_idx_1342"></a><a name="%_idx_1344"></a><em>list-structured</em> data.<p>\n\n<a name="%_sec_Temp_134"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_134">Representing rational numbers</a></h4><p>\n\n<a name="%_idx_1346"></a>Pairs offer a natural way to complete the rational-number system.\nSimply represent a rational number as a pair of two integers: a\nnumerator and a denominator.  Then <tt>make-rat</tt>, <tt>numer</tt>, and\n<tt>denom</tt> are readily implemented as follows:<a name="call_footnote_Temp_135" href="#footnote_Temp_135"><sup><small>3</small></sup></a><p>\n\n\n<p><p><tt><a name="%_idx_1348"></a>(define&nbsp;(make-rat&nbsp;n&nbsp;d)&nbsp;(cons&nbsp;n&nbsp;d))<br>\n<br>\n<a name="%_idx_1350"></a>(define&nbsp;(numer&nbsp;x)&nbsp;(car&nbsp;x))<br>\n<br>\n<a name="%_idx_1352"></a>(define&nbsp;(denom&nbsp;x)&nbsp;(cdr&nbsp;x))<br>\n</tt><p><p>\nAlso, in order to display the results of our computations,\nwe can <a name="%_idx_1354"></a>print rational numbers by printing the numerator, a\nslash, and the denominator:<a name="call_footnote_Temp_136" href="#footnote_Temp_136"><sup><small>4</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_1370"></a>(define&nbsp;(print-rat&nbsp;x)<br>\n&nbsp;&nbsp;(newline)<br>\n&nbsp;&nbsp;(display&nbsp;(numer&nbsp;x))<br>\n&nbsp;&nbsp;(display&nbsp;&quot;/&quot;)<br>\n&nbsp;&nbsp;(display&nbsp;(denom&nbsp;x)))<br>\n</tt><p><p>\nNow we can try our rational-number procedures:<p>\n\n<p><p><tt>(define&nbsp;one-half&nbsp;(make-rat&nbsp;1&nbsp;2))<br>\n<br>\n(print-rat&nbsp;one-half)<br>\n<i>1/2</i><br>\n<br>\n(define&nbsp;one-third&nbsp;(make-rat&nbsp;1&nbsp;3))<br>\n(print-rat&nbsp;(add-rat&nbsp;one-half&nbsp;one-third))<br>\n<i>5/6</i><br>\n<br>\n(print-rat&nbsp;(mul-rat&nbsp;one-half&nbsp;one-third))<br>\n<i>1/6</i><br>\n<br>\n(print-rat&nbsp;(add-rat&nbsp;one-third&nbsp;one-third))<br>\n<i>6/9</i><br>\n</tt><p><p><p>\n\n<a name="%_idx_1372"></a><a name="%_idx_1374"></a>As the final example shows, our rational-number implementation does\nnot reduce rational numbers to lowest terms.  We can remedy this by\nchanging <tt>make-rat</tt>. If we have a <a name="%_idx_1376"></a><tt>gcd</tt> procedure like the one\nin section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.5">1.2.5</a> that produces the greatest common divisor of two\nintegers, we can use <tt>gcd</tt> to reduce the numerator and the\ndenominator to lowest terms before constructing the pair:<p>\n\n<p><p><tt><a name="%_idx_1378"></a>(define&nbsp;(make-rat&nbsp;n&nbsp;d)<br>\n&nbsp;&nbsp;(let&nbsp;((g&nbsp;(gcd&nbsp;n&nbsp;d)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(/&nbsp;n&nbsp;g)&nbsp;(/&nbsp;d&nbsp;g))))<br>\n</tt><p><p>\nNow we have<p>\n\n<p><p><tt>(print-rat&nbsp;(add-rat&nbsp;one-third&nbsp;one-third))<br>\n<i>2/3</i><br>\n</tt><p><p>\nas desired.  This modification was accomplished by changing the\nconstructor <tt>make-rat</tt> without changing any of the procedures\n(such as <tt>add-rat</tt> and <tt>mul-rat</tt>)\nthat implement the actual operations.<p>\n\n<p><a name="%_thm_2.1"></a>\n<b>Exercise 2.1.</b>&nbsp;&nbsp;Define a better version of <tt>make-rat</tt> that\nhandles both positive and negative arguments.  <tt>Make-rat</tt> should\nnormalize the sign so that if the rational number is positive, both\nthe numerator and denominator are positive, and if the rational number\nis negative, only the numerator is negative.\n<p>\n\n<a name="%_sec_2.1.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.1.2">2.1.2&nbsp;&nbsp;Abstraction Barriers</a></h3><p>\n\n<p>\n\n<a name="%_idx_1380"></a>Before continuing with more examples of compound data and data\nabstraction, let us consider some of the issues raised by the\nrational-number example.  We defined the rational-number operations in\nterms of a constructor <tt>make-rat</tt> and selectors <tt>numer</tt> and\n<tt>denom</tt>.  In general, the underlying idea of data abstraction is\nto identify for each type of data object a basic set of operations in\nterms of which all manipulations of data objects of that type will be\nexpressed, and then to use only those operations in manipulating the\ndata.<p>\n\nWe can envision the structure of the rational-number system as\nshown in figure&nbsp;<a href="#%_fig_2.1">2.1</a>.  The\nhorizontal lines represent <em>abstraction barriers</em> that isolate\ndifferent ``levels\'\' of the system.  At each level, the barrier\nseparates the programs (above) that use the data abstraction from the\nprograms (below) that implement the data abstraction.  Programs that\nuse rational numbers manipulate them solely in terms of the procedures\nsupplied ``for public use\'\' by the rational-number package: <tt>add-rat</tt>, <tt>sub-rat</tt>, <tt>mul-rat</tt>, <tt>div-rat</tt>, and <tt>equal-rat?</tt>. These, in turn, are implemented solely in terms of the\n<a name="%_idx_1382"></a><a name="%_idx_1384"></a>constructor and selectors <tt>make-rat</tt>, <tt>numer</tt>, and <tt>denom</tt>, which themselves are implemented in terms of pairs.  The\ndetails of how pairs are implemented are irrelevant to the rest of the\nrational-number package so long as pairs can be manipulated by the use\nof <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>.  In effect, procedures at\neach level are the interfaces that define the abstraction barriers and\nconnect the different levels.<p>\n\n<a name="%_fig_2.1"></a><p><div align=left><table width=100%><tr><td><div align=left><img src="ch2-Z-G-6.gif" border="0">&nbsp;</div>\n\n</td></tr><caption align=bottom><div align=left><b>Figure 2.1:</b>&nbsp;&nbsp;Data-abstraction barriers in the rational-number package.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nThis simple idea has many advantages.  One advantage is that it makes\nprograms much easier to maintain and to modify.  Any complex data\nstructure can be represented in a variety of ways with the primitive\ndata structures provided by a programming language.  Of course, the\nchoice of representation influences the programs that operate on it;\nthus, if the representation were to be changed at some later time, all\nsuch programs might have to be modified accordingly.  This task could\nbe time-consuming and expensive in the case of large programs unless\nthe dependence on the representation were to be confined by design to\na very few program modules.<p>\n\n<a name="%_idx_1386"></a><a name="%_idx_1388"></a>For example, an alternate way to address the problem of reducing rational\nnumbers to lowest terms is to perform the reduction whenever we\naccess the parts of a rational number, rather than when we construct\nit.  This leads to different constructor and selector procedures:<p>\n\n<p><p><tt><a name="%_idx_1390"></a>(define&nbsp;(make-rat&nbsp;n&nbsp;d)<br>\n&nbsp;&nbsp;(cons&nbsp;n&nbsp;d))<br>\n<a name="%_idx_1392"></a>(define&nbsp;(numer&nbsp;x)<br>\n&nbsp;&nbsp;(let&nbsp;((g&nbsp;(gcd&nbsp;(car&nbsp;x)&nbsp;(cdr&nbsp;x))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;(car&nbsp;x)&nbsp;g)))<br>\n<a name="%_idx_1394"></a>(define&nbsp;(denom&nbsp;x)<br>\n&nbsp;&nbsp;(let&nbsp;((g&nbsp;(gcd&nbsp;(car&nbsp;x)&nbsp;(cdr&nbsp;x))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;(cdr&nbsp;x)&nbsp;g)))<br>\n</tt><p><p>\nThe difference between this implementation and the previous one lies\nin when we compute the <tt>gcd</tt>.\nIf in our typical use of rational numbers we access the\nnumerators and denominators of the same rational numbers many\ntimes, it would be preferable\nto compute the <tt>gcd</tt> when the rational numbers are constructed.\nIf not, we may be better off waiting until access\ntime to compute the <tt>gcd</tt>.  In any case, when\nwe change from one representation to the other, the procedures <tt>add-rat</tt>, <tt>sub-rat</tt>, and so on do not have to be modified at all.<p>\n\n\nConstraining the dependence on the representation to a few interface\nprocedures helps us design programs as well as modify them,\nbecause it allows us to maintain the flexibility to consider alternate\nimplementations.  To continue with our simple example, suppose we are\ndesigning a rational-number package and we can\'t decide initially\nwhether to perform the <tt>gcd</tt> at construction time or at selection\ntime.  The data-abstraction methodology gives us a way to defer that\ndecision without losing the ability to make progress on the rest of\nthe system.<p>\n\n<p><a name="%_thm_2.2"></a>\n<b>Exercise 2.2.</b>&nbsp;&nbsp;Consider the problem of representing \n<a name="%_idx_1396"></a>line segments in a plane.  Each segment is\nrepresented as a pair of points: a starting point and an ending point.\nDefine a constructor <a name="%_idx_1398"></a><tt>make-segment</tt> and selectors <a name="%_idx_1400"></a><tt>start-segment</tt>\nand <a name="%_idx_1402"></a><tt>end-segment</tt> that define the representation of segments in\nterms of points.  Furthermore, a point <a name="%_idx_1404"></a>can be represented as a pair\nof numbers: the <em>x</em> coordinate and the <em>y</em> coordinate.  Accordingly,\nspecify a constructor <a name="%_idx_1406"></a><tt>make-point</tt> and selectors <tt>x-point</tt> and\n<tt>y-point</tt> that define this representation.  Finally, using your\nselectors and constructors, define a procedure <a name="%_idx_1408"></a><tt>midpoint-segment</tt>\nthat takes a line segment as argument and returns its midpoint (the\npoint whose coordinates are the average of the coordinates of the\nendpoints).\nTo try your procedures, you\'ll need a way to print points:<p>\n\n<p><p><tt><a name="%_idx_1410"></a>(define&nbsp;(print-point&nbsp;p)<br>\n&nbsp;&nbsp;(newline)<br>\n&nbsp;&nbsp;(display&nbsp;&quot;(&quot;)<br>\n&nbsp;&nbsp;(display&nbsp;(x-point&nbsp;p))<br>\n&nbsp;&nbsp;(display&nbsp;&quot;,&quot;)<br>\n&nbsp;&nbsp;(display&nbsp;(y-point&nbsp;p))<br>\n&nbsp;&nbsp;(display&nbsp;&quot;)&quot;))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_2.3"></a>\n<b>Exercise 2.3.</b>&nbsp;&nbsp;<a name="%_idx_1412"></a>Implement a representation for rectangles in a plane.\n(Hint: You may want to make use of exercise&nbsp;<a href="#%_thm_2.2">2.2</a>.)\nIn terms of\nyour constructors and selectors, create procedures that compute the\nperimeter and the area of a given rectangle.  Now implement a\ndifferent representation for rectangles.  Can you design your system\nwith suitable abstraction barriers, so that the same perimeter and\narea procedures will work using either representation?\n\n<p>\n<p>\n\n<a name="%_sec_2.1.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.1.3">2.1.3&nbsp;&nbsp;What Is Meant by Data?</a></h3><p>\n\n\n<a name="%_idx_1414"></a>\nWe began the rational-number implementation in\nsection&nbsp;<a href="#%_sec_2.1.1">2.1.1</a> by implementing the rational-number\noperations <tt>add-rat</tt>, <tt>sub-rat</tt>, and so on in terms of three\nunspecified procedures: <tt>make-rat</tt>, <tt>numer</tt>, and <tt>denom</tt>.\nAt that point, we could think of the operations as being defined in\nterms of data objects -- numerators, denominators, and rational\nnumbers -- whose behavior was specified by the latter three procedures.<p>\n\nBut exactly what is meant by <em>data</em>?  It is not enough to say\n``whatever is implemented by the given selectors and constructors.\'\'\nClearly, not every arbitrary set of three procedures can serve as an\nappropriate basis for the rational-number implementation.  We need to\nguarantee that, <a name="%_idx_1416"></a><a name="%_idx_1418"></a><a name="%_idx_1420"></a>if we construct a rational number <tt>x</tt> from a pair\nof integers <tt>n</tt> and <tt>d</tt>, then extracting the <tt>numer</tt> and the\n<tt>denom</tt> of <tt>x</tt> and dividing them should yield the same result\nas dividing <tt>n</tt> by <tt>d</tt>.  In other words, <tt>make-rat</tt>,\n<tt>numer</tt>, and <tt>denom</tt> must satisfy the condition that, for any\ninteger <tt>n</tt> and any non-zero integer <tt>d</tt>, if <tt>x</tt> is\n(<tt>make-rat n d</tt>), then<p>\n\n<p><div align=left><img src="ch2-Z-G-7.gif" border="0"></div><p><p>\n\nIn fact, this is the only condition <tt>make-rat</tt>, <tt>numer</tt>, and\n<tt>denom</tt> must fulfill in order to form a suitable basis for a\nrational-number representation.  In general, we can think of data as\ndefined by some collection of selectors and constructors, together\nwith specified conditions that these procedures must fulfill in order\nto be a valid representation.<a name="call_footnote_Temp_140" href="#footnote_Temp_140"><sup><small>5</small></sup></a><p>\n\n\n<a name="%_idx_1446"></a><a name="%_idx_1448"></a>This point of view can serve to define not only ``high-level\'\' data\nobjects, such as rational numbers, but lower-level objects as well.\n<a name="%_idx_1450"></a>Consider the notion of a pair, which we used in order to define our\nrational numbers.  We never actually said what a pair was, only that\nthe language supplied procedures <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>\nfor operating on pairs.  But the only thing we need to know about\nthese three operations <a name="%_idx_1452"></a><a name="%_idx_1454"></a><a name="%_idx_1456"></a><a name="%_idx_1458"></a>is that if we glue two objects together using\n<tt>cons</tt> we can retrieve the objects using <tt>car</tt> and <tt>cdr</tt>.\nThat is, the operations satisfy the condition that, for any objects\n<tt>x</tt> and <tt>y</tt>, if <tt>z</tt> is <tt>(cons x y)</tt> then <tt>(car z)</tt>\nis <tt>x</tt> and <tt>(cdr z)</tt> is <tt>y</tt>.  Indeed, we mentioned that\nthese three procedures are included as primitives in our language.\nHowever, any triple of procedures that satisfies the above condition\ncan be used as the basis for implementing pairs.  This point is\nillustrated strikingly by the fact that we could implement <tt>cons</tt>,\n<tt>car</tt>, and <tt>cdr</tt> without using any data structures at all but\nonly using procedures.  Here are the definitions:<p>\n\n<p><p><tt><a name="%_idx_1460"></a>(define&nbsp;(cons&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((=&nbsp;m&nbsp;0)&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;m&nbsp;1)&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Argument&nbsp;not&nbsp;0&nbsp;or&nbsp;1&nbsp;--&nbsp;CONS&quot;&nbsp;m))))<br>\n&nbsp;&nbsp;dispatch)<br>\n<br>\n<a name="%_idx_1462"></a>(define&nbsp;(car&nbsp;z)&nbsp;(z&nbsp;0))<br>\n<br>\n<a name="%_idx_1464"></a>(define&nbsp;(cdr&nbsp;z)&nbsp;(z&nbsp;1))<br>\n</tt><p><p>\nThis use of procedures corresponds to nothing like our intuitive\nnotion of what data should be.  Nevertheless, all we need to do to\nshow that this is a valid way to represent pairs is to verify that\nthese procedures satisfy the condition given above.<p>\n\nThe subtle point to notice is that the value returned by <tt>(cons x\ny)</tt> is a procedure -- namely the internally defined procedure <tt>dispatch</tt>, which takes one argument and returns either <tt>x</tt> or <tt>y</tt> depending on whether the argument is 0 or 1.  Correspondingly, <tt>(car z)</tt> is defined to apply <tt>z</tt> to 0.  Hence, if <tt>z</tt> is the\nprocedure formed by <tt>(cons x y)</tt>, then <tt>z</tt> applied to 0 will\nyield <tt>x</tt>. Thus, we have shown that <tt>(car (cons x y))</tt> yields\n<tt>x</tt>, as desired.  Similarly, <tt>(cdr (cons x y))</tt> applies the\nprocedure returned by <tt>(cons x y)</tt> to 1, which returns <tt>y</tt>.\nTherefore, this procedural implementation of pairs is a valid\nimplementation, and if we access pairs using only <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> we cannot distinguish this implementation from one\nthat uses ``real\'\' data structures.<p>\n\nThe point of exhibiting the procedural representation of pairs is not\nthat our language works this way (Scheme, and Lisp systems in general,\nimplement pairs directly, for efficiency reasons) but that it could\nwork this way.  The procedural representation, although obscure, is a\nperfectly adequate way to represent pairs, since it fulfills the only\nconditions that pairs need to fulfill.  This example also demonstrates\nthat the ability to manipulate procedures as objects automatically\nprovides the ability to represent compound data.  This may seem a\ncuriosity now, but procedural representations of data will play a\ncentral role in our programming repertoire.  This style of programming\nis often called <a name="%_idx_1466"></a><em>message passing</em>, and we will be using it as a\nbasic tool in chapter&nbsp;3 when we address the issues of modeling and\nsimulation.<p>\n\n<p><a name="%_thm_2.4"></a>\n<b>Exercise 2.4.</b>&nbsp;&nbsp;Here is an alternative procedural representation of pairs.  For this\nrepresentation, verify that <tt>(car (cons x y))</tt> yields <tt>x</tt> for\nany objects <tt>x</tt> and <tt>y</tt>.<p>\n\n<p><p><tt><a name="%_idx_1468"></a>(define&nbsp;(cons&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(lambda&nbsp;(m)&nbsp;(m&nbsp;x&nbsp;y)))<br>\n<br>\n<a name="%_idx_1470"></a>(define&nbsp;(car&nbsp;z)<br>\n&nbsp;&nbsp;(z&nbsp;(lambda&nbsp;(p&nbsp;q)&nbsp;p)))<br>\n</tt><p><p>\n<a name="%_idx_1472"></a>What is the corresponding definition of <tt>cdr</tt>? (Hint: To verify\nthat this works, make use of the substitution model of\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a>.)\n\n<p><p>\n\n<p><a name="%_thm_2.5"></a>\n<b>Exercise 2.5.</b>&nbsp;&nbsp;Show that we can represent pairs of nonnegative integers using only\nnumbers and arithmetic operations if we represent the pair <em>a</em> and <em>b</em>\nas the integer that is the product 2<sup><em>a</em></sup> 3<sup><em>b</em></sup>.  Give the corresponding\ndefinitions of the procedures <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>.\n<p>\n\n<p><a name="%_thm_2.6"></a>\n<b>Exercise 2.6.</b>&nbsp;&nbsp;In case representing pairs as procedures wasn\'t mind-boggling enough,\nconsider that, in a language that can manipulate procedures, we can\nget by without numbers (at least insofar as nonnegative integers are\nconcerned) by implementing 0 and the operation of adding 1 as<p>\n\n<p><p><tt>(define&nbsp;zero&nbsp;(lambda&nbsp;(f)&nbsp;(lambda&nbsp;(x)&nbsp;x)))<br>\n<br>\n(define&nbsp;(add-1&nbsp;n)<br>\n&nbsp;&nbsp;(lambda&nbsp;(f)&nbsp;(lambda&nbsp;(x)&nbsp;(f&nbsp;((n&nbsp;f)&nbsp;x)))))<br>\n</tt><p><p>\nThis representation is known as <a name="%_idx_1474"></a><em>Church numerals</em>, after its\ninventor, <a name="%_idx_1476"></a>Alonzo Church, the logician who invented the <img src="book-Z-G-D-6.gif" border="0">\ncalculus.<p>\n\nDefine <tt>one</tt> and <tt>two</tt> directly (not in terms of <tt>zero</tt>\nand <tt>add-1</tt>).  (Hint: Use substitution to evaluate <tt>(add-1 zero)</tt>).\nGive a direct definition of the addition procedure <tt>+</tt> (not in\nterms of repeated application of <tt>add-1</tt>).\n<p>\n\n<a name="%_sec_2.1.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.1.4">2.1.4&nbsp;&nbsp;Extended Exercise: Interval Arithmetic</a></h3><p>\n\n<a name="%_idx_1478"></a><a name="%_idx_1480"></a>\nAlyssa P. Hacker is designing a system to help people solve\nengineering problems.  One feature she wants to provide in her system\nis the ability to manipulate inexact quantities (such as measured\nparameters of physical devices) with known precision, so that when\ncomputations are done with such approximate quantities the results\nwill be numbers of known precision.<p>\n\nElectrical engineers will be using Alyssa\'s system to compute\nelectrical quantities.  It is sometimes necessary for them to compute\nthe value of a parallel equivalent resistance <em>R</em><sub><em>p</em></sub> of two\nresistors <em>R</em><sub>1</sub> and <em>R</em><sub>2</sub> using the formula\n<a name="%_idx_1482"></a>\n<p><div align=left><img src="ch2-Z-G-8.gif" border="0"></div><p><p>\n\nResistance values are usually known only up to some <a name="%_idx_1484"></a>tolerance\nguaranteed by the manufacturer of the resistor.  For example, if you\nbuy a resistor labeled ``6.8 ohms with 10% tolerance\'\' you can only\nbe sure that the resistor has a resistance between 6.8 - 0.68 = 6.12 and\n6.8 + 0.68 = 7.48 ohms.  Thus, if you have a 6.8-ohm 10% resistor in\nparallel with a 4.7-ohm 5% resistor, the resistance of the\ncombination can range from about 2.58 ohms (if the two resistors are\nat the lower bounds) to about 2.97 ohms (if the two resistors are at\nthe upper bounds).<p>\n\nAlyssa\'s idea is to implement ``interval arithmetic\'\' as a set of\narithmetic operations for combining ``intervals\'\' (objects\nthat represent the range of possible values of an inexact quantity).\nThe result of adding, subtracting, multiplying, or dividing two\nintervals is itself an interval, representing the range of the\nresult.<p>\n\nAlyssa postulates the existence of an abstract object called an\n``interval\'\' that has two endpoints: a lower bound and an upper bound.\nShe also presumes that, given the endpoints of an interval, she can\nconstruct the interval using the data constructor <a name="%_idx_1486"></a><tt>make-interval</tt>.\nAlyssa first writes a procedure for adding two intervals.  She\nreasons that the minimum value the sum could be is the sum of the two\nlower bounds and the maximum value it could be is the sum of the two\nupper bounds:<p>\n\n<p><p><tt><a name="%_idx_1488"></a>(define&nbsp;(add-interval&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(make-interval&nbsp;(+&nbsp;(lower-bound&nbsp;x)&nbsp;(lower-bound&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(upper-bound&nbsp;x)&nbsp;(upper-bound&nbsp;y))))<br>\n</tt><p><p>\nAlyssa also works out the product of two intervals by finding the\nminimum and the maximum of the products of the bounds and using them\nas the bounds of the resulting interval.  (<tt>Min</tt> and <tt>max</tt> are\n<a name="%_idx_1490"></a><a name="%_idx_1492"></a><a name="%_idx_1494"></a><a name="%_idx_1496"></a>primitives that find the minimum or maximum of any number of\narguments.)<p>\n\n<p><p><tt><a name="%_idx_1498"></a>(define&nbsp;(mul-interval&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(let&nbsp;((p1&nbsp;(*&nbsp;(lower-bound&nbsp;x)&nbsp;(lower-bound&nbsp;y)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p2&nbsp;(*&nbsp;(lower-bound&nbsp;x)&nbsp;(upper-bound&nbsp;y)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p3&nbsp;(*&nbsp;(upper-bound&nbsp;x)&nbsp;(lower-bound&nbsp;y)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p4&nbsp;(*&nbsp;(upper-bound&nbsp;x)&nbsp;(upper-bound&nbsp;y))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(make-interval&nbsp;(min&nbsp;p1&nbsp;p2&nbsp;p3&nbsp;p4)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(max&nbsp;p1&nbsp;p2&nbsp;p3&nbsp;p4))))<br>\n</tt><p><p>\nTo divide two intervals, Alyssa multiplies the first by the reciprocal of\nthe second.  Note that the bounds of the reciprocal interval are\nthe reciprocal of the upper bound and the reciprocal of the lower bound, in\nthat order.<p>\n\n<p><p><tt><a name="%_idx_1500"></a>(define&nbsp;(div-interval&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(mul-interval&nbsp;x&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-interval&nbsp;(/&nbsp;1.0&nbsp;(upper-bound&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;1.0&nbsp;(lower-bound&nbsp;y)))))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_2.7"></a>\n<b>Exercise 2.7.</b>&nbsp;&nbsp;Alyssa\'s program is incomplete because she has not specified the\nimplementation of the interval abstraction.  Here is a definition of\nthe interval constructor:<p>\n\n<p><p><tt><a name="%_idx_1502"></a>(define&nbsp;(make-interval&nbsp;a&nbsp;b)&nbsp;(cons&nbsp;a&nbsp;b))<br>\n</tt><p><p>\nDefine selectors <a name="%_idx_1504"></a><tt>upper-bound</tt> and <a name="%_idx_1506"></a><tt>lower-bound</tt> to complete\nthe implementation.\n<p><p>\n\n<p><a name="%_thm_2.8"></a>\n<b>Exercise 2.8.</b>&nbsp;&nbsp;Using reasoning analogous to Alyssa\'s, describe how the difference\nof two intervals may be computed.  Define a corresponding subtraction\nprocedure, called <a name="%_idx_1508"></a><tt>sub-interval</tt>.\n<p><p>\n\n<p><a name="%_thm_2.9"></a>\n<b>Exercise 2.9.</b>&nbsp;&nbsp;<a name="%_idx_1510"></a>The <em>width</em> of an interval is half of the difference between its\nupper and lower bounds.  The width is a measure of the uncertainty of\nthe number specified by the interval.  For some arithmetic operations\nthe width of the result of combining two intervals is a function only\nof the widths of the argument intervals, whereas for others the width\nof the combination is not a function of the widths of the argument\nintervals.  Show that the width of the sum (or difference) of two\nintervals is a function only of the widths of the intervals being\nadded (or subtracted).  Give examples to show that this is not true\nfor multiplication or division.\n<p><p>\n\n<p><a name="%_thm_2.10"></a>\n<b>Exercise 2.10.</b>&nbsp;&nbsp;<a name="%_idx_1512"></a>Ben Bitdiddle, an expert systems programmer, looks over Alyssa\'s\nshoulder and comments that it is not clear what it means to\ndivide by an interval that spans zero.  Modify Alyssa\'s code to\ncheck for this condition and to signal an error if it occurs.\n<p><p>\n\n<p><a name="%_thm_2.11"></a>\n<b>Exercise 2.11.</b>&nbsp;&nbsp;<a name="%_idx_1514"></a>In passing, Ben also cryptically comments: ``By testing the signs of\nthe endpoints of the intervals, it is possible to break <tt>mul-interval</tt> into nine cases, only one of which requires more than\ntwo multiplications.\'\'  Rewrite this procedure using Ben\'s\nsuggestion.\n<p><p>\n\n<p><p>\nAfter debugging her program, Alyssa shows it to a potential user,\nwho complains that her program solves the wrong problem.  He\nwants a program that can deal with numbers represented as a center\nvalue and an additive tolerance; for example, he wants to work with\nintervals such as 3.5&plusmn; 0.15 rather than </div><p>\n\n<a name="%_sec_2.2"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_2.2">2.2&nbsp;&nbsp;Hierarchical Data and the Closure Property</a></h2><p>\n\n<p>\n\nAs we have seen, pairs provide a primitive ``glue\'\' that we can use to\nconstruct compound data objects.\nFigure&nbsp;<a href="#%_fig_2.2">2.2</a> shows a standard way to\nvisualize a <a name="%_idx_1526"></a>pair -- in this case, the pair formed by <tt>(cons 1 2)</tt>.\nIn this representation, which is called <a name="%_idx_1528"></a><em>box-and-pointer\nnotation</em>, each object is shown as a <a name="%_idx_1530"></a><em>pointer</em> to a box.  The box\nfor a primitive object contains a representation of the object.  For\nexample, the box for a number contains a numeral.  The box for a pair\nis actually a double box, the left part containing (a pointer to) the\n<tt>car</tt> of the pair and the right part containing the <tt>cdr</tt>.<p>\n\n\nWe have already seen that <tt>cons</tt> can be used to combine not\nonly numbers but pairs as well.  (You made use of this fact, or\nshould have, in doing exercises&nbsp;<a href="book-Z-H-14.html#%_thm_2.2">2.2</a>\nand&nbsp;<a href="book-Z-H-14.html#%_thm_2.3">2.3</a>.)  As a consequence, pairs provide a universal\nbuilding block from which we can construct all sorts of data\nstructures.  Figure&nbsp;<a href="#%_fig_2.3">2.3</a> shows two ways\nto use pairs to combine the numbers 1, 2, 3, and 4.<p>\n\n<a name="%_fig_2.2"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-11.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.2:</b>&nbsp;&nbsp;Box-and-pointer representation of <tt>(cons 1 2)</tt>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_fig_2.3"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-12.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.3:</b>&nbsp;&nbsp;Two ways to combine 1, 2, 3, and 4 using pairs.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nThe ability to create pairs whose elements are pairs is the essence of\nlist structure\'s importance as a representational tool.  We refer to\nthis ability as the <a name="%_idx_1532"></a><a name="%_idx_1534"></a><em>closure property</em> of <tt>cons</tt>.  In general,\nan operation for combining data objects satisfies the closure property\nif the results of combining things with that operation can themselves\nbe combined using the same operation.<a name="call_footnote_Temp_154" href="#footnote_Temp_154"><sup><small>6</small></sup></a>\nClosure is the key to power in\nany means of combination because it permits us to create <a name="%_idx_1538"></a><a name="%_idx_1540"></a><em>hierarchical</em> structures -- structures made up of parts, which\nthemselves are made up of parts, and so on.<p>\n\nFrom the outset of chapter&nbsp;1, we\'ve made essential use of closure in\ndealing with procedures, because all but the very simplest programs\nrely on the fact that the elements of a combination can themselves be\ncombinations.  In this section, we take up the consequences of closure\nfor compound data.  We describe some conventional techniques for using\npairs to represent sequences and trees, and we exhibit a graphics\nlanguage that illustrates closure in a vivid way.<a name="call_footnote_Temp_155" href="#footnote_Temp_155"><sup><small>7</small></sup></a><p>\n\n<a name="%_sec_2.2.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.2.1">2.2.1&nbsp;&nbsp;Representing Sequences</a></h3><p>\n\n<p>\n\n<a name="%_fig_2.4"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-13.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.4:</b>&nbsp;&nbsp;The sequence 1, 2, 3, 4 represented as a chain of pairs.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nOne of the useful structures we can build with pairs is a <a name="%_idx_1554"></a><a name="%_idx_1556"></a><a name="%_idx_1558"></a><em>sequence</em> -- an ordered collection of data objects.  There are, of\ncourse, many ways to represent sequences in terms of pairs.  One\nparticularly straightforward representation is illustrated in\nfigure&nbsp;<a href="#%_fig_2.4">2.4</a>, where the sequence 1, 2, 3, 4 is\nrepresented as a chain of pairs.  The <tt>car</tt> of each pair is the\ncorresponding item in the chain, and the <tt>cdr</tt> of the pair is\nthe next pair in the chain.  The <tt>cdr</tt> of the final pair\nsignals the end of the sequence by pointing to a distinguished\nvalue that is not a pair,\nrepresented in box-and-pointer diagrams as a diagonal line\n<a name="%_idx_1560"></a>and in programs as the value of the variable <a name="%_idx_1562"></a><a name="%_idx_1564"></a><tt>nil</tt>.\nThe entire sequence is constructed by nested <tt>cons</tt> operations:<p>\n\n<p><p><tt>(cons&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;2<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;3<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;4&nbsp;nil))))<br>\n</tt><p><p><p>\n\n\nSuch a sequence of pairs, formed by nested <tt>cons</tt>es, is called a\n<a name="%_idx_1566"></a><em>list</em>, and Scheme provides a\nprimitive called <a name="%_idx_1568"></a><a name="%_idx_1570"></a><tt>list</tt> to help in constructing lists.<a name="call_footnote_Temp_156" href="#footnote_Temp_156"><sup><small>8</small></sup></a>\nThe above sequence could be produced by <tt>(list 1 2 3 4)</tt>.  In\ngeneral,<p>\n\n\n<p><p><tt>(list&nbsp;&lt;<em>a<sub>1</sub></em>&gt;&nbsp;&lt;<em>a<sub>2</sub></em>&gt;&nbsp;<tt>...</tt> &lt;<em>a<sub><em>n</em></sub></em>&gt;)<br>\n</tt><p><p>\nis equivalent to<p>\n\n\n<p><p><tt>(cons&nbsp;&lt;<em>a<sub>1</sub></em>&gt;&nbsp;(cons&nbsp;&lt;<em>a<sub>2</sub></em>&gt;&nbsp;(cons&nbsp;<tt>...</tt> (cons&nbsp;&lt;<em>a<sub><em>n</em></sub></em>&gt;&nbsp;nil)&nbsp;<tt>...</tt>)))<br>\n</tt><p><p>\nLisp systems conventionally print lists by printing the sequence of\n<a name="%_idx_1576"></a>elements, enclosed in parentheses.  Thus, the data object in\nfigure&nbsp;<a href="#%_fig_2.4">2.4</a> is printed as <tt>(1 2 3 4)</tt>:<p>\n\n\n<p><p><tt>(define&nbsp;one-through-four&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4))<br>\n<br>\none-through-four<br>\n<i>(1&nbsp;2&nbsp;3&nbsp;4)</i><br>\n</tt><p><p>\nBe careful not to confuse the expression <tt>(list 1 2 3 4)</tt> with the\nlist <tt>(1 2 3 4)</tt>, which is the result obtained when the expression\nis evaluated.  Attempting to evaluate the expression <tt>(1 2 3 4)</tt> will\nsignal an error when the interpreter tries to apply the procedure <tt>1</tt> to arguments <tt>2</tt>, <tt>3</tt>, and <tt>4</tt>.<p>\n\n\nWe can think of <a name="%_idx_1578"></a><a name="%_idx_1580"></a><tt>car</tt> as selecting the first item in the list, and\nof <a name="%_idx_1582"></a><tt>cdr</tt> as selecting the sublist consisting of all but the first\nitem.  Nested applications of <tt>car</tt> and <tt>cdr</tt> can be used to\nextract the second, third, and subsequent items in the\nlist.<a name="call_footnote_Temp_157" href="#footnote_Temp_157"><sup><small>9</small></sup></a>\nThe constructor <a name="%_idx_1592"></a><tt>cons</tt> makes a list like the original one,\nbut with an additional item at the beginning.<p>\n\n\n<p><p><tt>(car&nbsp;one-through-four)<br>\n<i>1</i><br>\n<br>\n(cdr&nbsp;one-through-four)<br>\n<i>(2&nbsp;3&nbsp;4)</i><br>\n(car&nbsp;(cdr&nbsp;one-through-four))<br>\n<i>2</i><br>\n<br>\n(cons&nbsp;10&nbsp;one-through-four)<br>\n<i>(10&nbsp;1&nbsp;2&nbsp;3&nbsp;4)</i><br>\n<br>\n(cons&nbsp;5&nbsp;one-through-four)<br>\n<i>(5&nbsp;1&nbsp;2&nbsp;3&nbsp;4)</i><br>\n</tt><p><p>\nThe value of <tt>nil</tt>, used to terminate the chain of pairs, can be\nthought of as a sequence of no elements, the <a name="%_idx_1594"></a><a name="%_idx_1596"></a><em>empty list</em>.  The\nword <em>nil</em> is a contraction of the Latin word <em>nihil</em>, which\nmeans ``nothing.\'\'<a name="call_footnote_Temp_158" href="#footnote_Temp_158"><sup><small>10</small></sup></a><p>\n\n<a name="%_sec_Temp_159"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_159">List operations</a></h4><p>\n\n<a name="%_idx_1602"></a><a name="%_idx_1604"></a>\nThe use of pairs to represent sequences of elements as lists is\naccompanied by conventional programming techniques for manipulating\nlists by successively <a name="%_idx_1606"></a><a name="%_idx_1608"></a>``<tt>cdr</tt>ing down\'\' the lists.  For example,\nthe procedure <a name="%_idx_1610"></a><tt>list-ref</tt> takes as arguments a list and a number\n<em>n</em> and returns the <em>n</em>th item of the list.  It is customary to\nnumber the elements of the list beginning with 0.  The method for\ncomputing <tt>list-ref</tt> is the following:<p>\n\n<p><ul>\n<li>For <em>n</em> = 0, <tt>list-ref</tt> should return the <tt>car</tt> of the list.<p>\n\n<li>Otherwise, <tt>list-ref</tt> should return  the (<em>n</em> - 1)st item of the\n<tt>cdr</tt> of the list.\n</ul><p><p>\n\n<p><p><tt><a name="%_idx_1612"></a>(define&nbsp;(list-ref&nbsp;items&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;items)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-ref&nbsp;(cdr&nbsp;items)&nbsp;(-&nbsp;n&nbsp;1))))<br>\n(define&nbsp;squares&nbsp;(list&nbsp;1&nbsp;4&nbsp;9&nbsp;16&nbsp;25))<br>\n<br>\n(list-ref&nbsp;squares&nbsp;3)<br>\n<i>16</i><br>\n</tt><p><p><p>\n\nOften we <tt>cdr</tt> down the whole list.  To aid in this, Scheme includes\na primitive predicate <a name="%_idx_1614"></a><a name="%_idx_1616"></a><a name="%_idx_1618"></a><tt>null?</tt>, which tests whether its argument is\nthe empty list.  The procedure <a name="%_idx_1620"></a><a name="%_idx_1622"></a><tt>length</tt>, which\nreturns the number of items in a list, illustrates this typical\npattern of use:<p>\n\n<p><p><tt><a name="%_idx_1624"></a>(define&nbsp;(length&nbsp;items)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;items)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;1&nbsp;(length&nbsp;(cdr&nbsp;items)))))<br>\n(define&nbsp;odds&nbsp;(list&nbsp;1&nbsp;3&nbsp;5&nbsp;7))<br>\n<br>\n(length&nbsp;odds)<br>\n<i>4</i><br>\n</tt><p><p>\nThe <tt>length</tt> procedure implements a simple recursive plan. The\nreduction step is:<p>\n\n<p><ul>\n<li>The <tt>length</tt> of any list is 1 plus the <tt>length</tt> of the\n<tt>cdr</tt> of the list.\n</ul><p><p>\n\nThis is applied successively until we reach the base case:<p>\n\n<p><ul>\n<li>The <tt>length</tt> of the empty list is 0.\n</ul><p><p>\n\nWe could also compute <tt>length</tt> in an iterative style:<p>\n\n<p><p><tt><a name="%_idx_1626"></a>(define&nbsp;(length&nbsp;items)<br>\n&nbsp;&nbsp;(define&nbsp;(length-iter&nbsp;a&nbsp;count)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;a)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(length-iter&nbsp;(cdr&nbsp;a)&nbsp;(+&nbsp;1&nbsp;count))))<br>\n&nbsp;&nbsp;(length-iter&nbsp;items&nbsp;0))<br>\n</tt><p><p><p>\n\nAnother conventional programming technique is to <a name="%_idx_1628"></a><a name="%_idx_1630"></a>``<tt>cons</tt> up\'\' an\nanswer list while <tt>cdr</tt>ing down a list, as in the procedure <a name="%_idx_1632"></a><a name="%_idx_1634"></a><tt>append</tt>, which takes two lists as arguments and combines their\nelements to make a new list:<p>\n\n<p><p><tt>(append&nbsp;squares&nbsp;odds)<br>\n<i>(1&nbsp;4&nbsp;9&nbsp;16&nbsp;25&nbsp;1&nbsp;3&nbsp;5&nbsp;7)</i><br>\n<br>\n(append&nbsp;odds&nbsp;squares)<br>\n<i>(1&nbsp;3&nbsp;5&nbsp;7&nbsp;1&nbsp;4&nbsp;9&nbsp;16&nbsp;25)</i><br>\n</tt><p><p>\n<tt>Append</tt> is also implemented using a recursive plan.  To <tt>append</tt>\nlists <tt>list1</tt> and <tt>list2</tt>, do the following:<p>\n\n<p><ul>\n<li>If <tt>list1</tt> is the empty list, then the result is just <tt>list2</tt>.<p>\n\n<li>Otherwise, <tt>append</tt> the <tt>cdr</tt> of <tt>list1</tt> and \n<tt>list2</tt>, and <tt>cons</tt> the <tt>car</tt> of <tt>list1</tt> onto the result:\n</ul><p><p>\n\n<p><p><tt><a name="%_idx_1636"></a>(define&nbsp;(append&nbsp;list1&nbsp;list2)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;list1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list2<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;list1)&nbsp;(append&nbsp;(cdr&nbsp;list1)&nbsp;list2))))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_2.17"></a>\n<b>Exercise 2.17.</b>&nbsp;&nbsp;Define a procedure <a name="%_idx_1638"></a><a name="%_idx_1640"></a><tt>last-pair</tt> that returns the list that contains only\nthe last element of a given (nonempty) list:<p>\n\n<p><p><tt>(last-pair&nbsp;(list&nbsp;23&nbsp;72&nbsp;149&nbsp;34))<br>\n<i>(34)</i><br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_2.18"></a>\n<b>Exercise 2.18.</b>&nbsp;&nbsp;Define a procedure <a name="%_idx_1642"></a><a name="%_idx_1644"></a><tt>reverse</tt> that takes a list as argument and\nreturns a list of the same elements in reverse order:<p>\n\n<p><p><tt>(reverse&nbsp;(list&nbsp;1&nbsp;4&nbsp;9&nbsp;16&nbsp;25))<br>\n<i>(25&nbsp;16&nbsp;9&nbsp;4&nbsp;1)</i><br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_2.19"></a>\n<b>Exercise 2.19.</b>&nbsp;&nbsp;Consider the <a name="%_idx_1646"></a>change-counting program of\nsection&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a>.  It would be nice to be able to\neasily change the currency used by the program, so that we could\ncompute the number of ways to change a British pound, for example.  As\nthe program is written, the knowledge of the currency is distributed\npartly into the procedure <tt>first-denomination</tt> and partly into the\nprocedure <tt>count-change</tt> (which knows that there are five\nkinds of U.S. coins).  It would be nicer to be able to\nsupply a list of coins to be used for making change.<p>\n\nWe want to rewrite the procedure <tt>cc</tt> so that its\nsecond argument is a list of the values of the\ncoins to use rather than an integer specifying which coins to use.  We\ncould then have lists that defined each kind of currency:<p>\n\n<p><p><tt>(define&nbsp;us-coins&nbsp;(list&nbsp;50&nbsp;25&nbsp;10&nbsp;5&nbsp;1))<br>\n(define&nbsp;uk-coins&nbsp;(list&nbsp;100&nbsp;50&nbsp;20&nbsp;10&nbsp;5&nbsp;2&nbsp;1&nbsp;0.5))<br>\n</tt><p><p>\nWe could then call <tt>cc</tt> as follows:<p>\n\n<p><p><tt>(cc&nbsp;100&nbsp;us-coins)<br>\n<i>292</i><br>\n</tt><p><p>\nTo do this will require changing the program <tt>cc</tt> somewhat.  It will\nstill have the same form, but it will access its second argument\ndifferently, as follows:<p>\n\n<p><p><tt>(define&nbsp;(cc&nbsp;amount&nbsp;coin-values)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;amount&nbsp;0)&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((or&nbsp;(&lt;&nbsp;amount&nbsp;0)&nbsp;(no-more?&nbsp;coin-values))&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(cc&nbsp;amount<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(except-first-denomination&nbsp;coin-values))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cc&nbsp;(-&nbsp;amount<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(first-denomination&nbsp;coin-values))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coin-values)))))<br>\n</tt><p><p>\nDefine the procedures <tt>first-denomination</tt>, <tt>except-first-denomination</tt>, and <tt>no-more?</tt> in terms of primitive\noperations on list structures.  Does the order of the list <tt>coin-values</tt> affect the answer produced by <tt>cc</tt>?  Why or why not?\n<p><p>\n\n\n<p><a name="%_thm_2.20"></a>\n<b>Exercise 2.20.</b>&nbsp;&nbsp;<a name="%_idx_1648"></a><a name="%_idx_1650"></a><a name="%_idx_1652"></a><a name="%_idx_1654"></a>The procedures <tt>+</tt>, <tt>*</tt>, and <tt>list</tt> take arbitrary numbers\nof arguments. One way to define such procedures is to use <tt>define</tt>\nwith <em>dotted-tail notation</em>.  In a procedure definition, a parameter\nlist that has a dot before the last parameter name indicates that, when the\nprocedure is called, the initial parameters (if any) will have as values\nthe initial arguments,\nas usual, but the final parameter\'s value will be a <em>list</em> of\nany remaining arguments.\nFor instance, given the definition\n\n<p><p><tt>(define&nbsp;(f&nbsp;x&nbsp;y&nbsp;.&nbsp;z)&nbsp;<em>&lt;body&gt;</em>)<br>\n</tt><p><p>\nthe procedure <tt>f</tt> can be called with two or more arguments.\nIf we evaluate\n\n<p><p><tt>(f&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)<br>\n</tt><p><p>\nthen in the body of <tt>f</tt>, <tt>x</tt> will be 1, <tt>y</tt> will be\n2, and <tt>z</tt> will be the list <tt>(3 4 5 6)</tt>.\nGiven the definition\n\n<p><p><tt>(define&nbsp;(g&nbsp;.&nbsp;w)&nbsp;<em>&lt;body&gt;</em>)<br>\n</tt><p><p>\nthe procedure <tt>g</tt> can be called with zero or more arguments.\nIf we evaluate\n\n<p><p><tt>(g&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)<br>\n</tt><p><p>\nthen in the body of <tt>g</tt>, <tt>w</tt> will be the\nlist <tt>(1 2 3 4 5 6)</tt>.<a name="call_footnote_Temp_164" href="#footnote_Temp_164"><sup><small>11</small></sup></a><p>\n\nUse this notation\nto write a procedure <tt>same-parity</tt> that takes one or more integers\nand returns a list of all the arguments that have the same even-odd\nparity as the first argument.  For example,\n<p><p><tt>(same-parity&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7)<br>\n<i>(1&nbsp;3&nbsp;5&nbsp;7)</i><br>\n<br>\n(same-parity&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7)<br>\n<i>(2&nbsp;4&nbsp;6)</i><br>\n</tt><p><p>\n<p>\n\n<a name="%_sec_Temp_165"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_165">Mapping over lists</a></h4><p>\n\n<a name="%_idx_1658"></a><a name="%_idx_1660"></a>\nOne extremely useful operation is to apply some transformation\nto each element in a list and generate the list of results.\nFor instance, the following procedure scales each number in a list by\na given factor:<p>\n\n<p><p><tt><a name="%_idx_1662"></a>(define&nbsp;(scale-list&nbsp;items&nbsp;factor)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;items)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(*&nbsp;(car&nbsp;items)&nbsp;factor)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(scale-list&nbsp;(cdr&nbsp;items)&nbsp;factor))))<br>\n(scale-list&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)&nbsp;10)<br>\n<i>(10&nbsp;20&nbsp;30&nbsp;40&nbsp;50)</i><br>\n</tt><p><p><p>\n\nWe can abstract this general idea and capture it as a common pattern\nexpressed as a higher-order procedure, just as in\nsection&nbsp;<a href="book-Z-H-12.html#%_sec_1.3">1.3</a>.  The higher-order procedure\nhere is called <tt>map</tt>.  <tt>Map</tt> takes as arguments a procedure\nof one argument\nand a list, and returns a list of the results produced by\napplying the procedure to each element in the list:<a name="call_footnote_Temp_166" href="#footnote_Temp_166"><sup><small>12</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_1666"></a>(define&nbsp;(map&nbsp;proc&nbsp;items)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;items)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(proc&nbsp;(car&nbsp;items))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;proc&nbsp;(cdr&nbsp;items)))))<br>\n(map&nbsp;abs&nbsp;(list&nbsp;-10&nbsp;2.5&nbsp;-11.6&nbsp;17))<br>\n<i>(10&nbsp;2.5&nbsp;11.6&nbsp;17)</i><br>\n(map&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4))<br>\n<i>(1&nbsp;4&nbsp;9&nbsp;16)</i><br>\n</tt><p><p>\nNow we can give a new definition of <tt>scale-list</tt> in terms of <tt>map</tt>:\n<p><p><tt><a name="%_idx_1668"></a>(define&nbsp;(scale-list&nbsp;items&nbsp;factor)<br>\n&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;factor))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items))<br>\n</tt><p><p>\n<p>\n\n<tt>Map</tt> is an important construct, not only because it captures a\ncommon pattern, but because it establishes a higher level of\nabstraction in dealing with lists.  In the original definition of <tt>scale-list</tt>, the recursive structure of the program draws attention to\nthe element-by-element processing of the list.  Defining <tt>scale-list</tt> in terms of <tt>map</tt> suppresses that level of detail and\nemphasizes that scaling transforms a list of elements to a list of\nresults.  The difference between the two definitions is not that the\ncomputer is performing a different process (it isn\'t) but that we\nthink about the process differently.  In effect, <tt>map</tt> helps\nestablish an abstraction barrier that isolates the implementation of\nprocedures that transform lists from the details of how the\nelements of the list are extracted and combined.  Like the barriers\nshown in figure&nbsp;<a href="book-Z-H-14.html#%_fig_2.1">2.1</a>, this abstraction gives\nus the flexibility to change the low-level details of how sequences\nare implemented, while preserving the conceptual framework of\noperations that transform sequences to sequences.\nSection&nbsp;<a href="#%_sec_2.2.3">2.2.3</a> expands on this use\nof sequences as a framework for organizing programs.<p>\n\n<p><a name="%_thm_2.21"></a>\n<b>Exercise 2.21.</b>&nbsp;&nbsp;The procedure <tt>square-list</tt> takes a list of\nnumbers as argument and returns a list of the squares of those\nnumbers.<p>\n\n<p><p><tt>(square-list&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4))<br>\n<i>(1&nbsp;4&nbsp;9&nbsp;16)</i><br>\n</tt><p><p>\nHere are two different definitions of <tt>square-list</tt>.  Complete\nboth of them by filling in the missing expressions:<p>\n\n<p><p><tt>(define&nbsp;(square-list&nbsp;items)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;items)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;&lt;<em>??</em>&gt;&nbsp;&lt;<em>??</em>&gt;)))<br>\n(define&nbsp;(square-list&nbsp;items)<br>\n&nbsp;&nbsp;(map&nbsp;&lt;<em>??</em>&gt;&nbsp;&lt;<em>??</em>&gt;))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_2.22"></a>\n<b>Exercise 2.22.</b>&nbsp;&nbsp;Louis Reasoner tries to rewrite the first <tt>square-list</tt> procedure of\nexercise&nbsp;<a href="#%_thm_2.21">2.21</a> so that it evolves an iterative\nprocess:<p>\n\n<p><p><tt>(define&nbsp;(square-list&nbsp;items)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;things&nbsp;answer)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;things)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;answer<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;(cdr&nbsp;things)&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(square&nbsp;(car&nbsp;things))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;answer))))<br>\n&nbsp;&nbsp;(iter&nbsp;items&nbsp;nil))<br>\n</tt><p><p>\nUnfortunately, defining <tt>square-list</tt> this way produces the answer\nlist in the reverse order of the one desired.  Why?<p>\n\nLouis then tries to fix his bug by interchanging the arguments to\n<tt>cons</tt>:<p>\n\n<p><p><tt>(define&nbsp;(square-list&nbsp;items)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;things&nbsp;answer)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;things)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;answer<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;(cdr&nbsp;things)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;answer<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(square&nbsp;(car&nbsp;things))))))<br>\n&nbsp;&nbsp;(iter&nbsp;items&nbsp;nil))<br>\n</tt><p><p>\nThis doesn\'t work either.  Explain.\n\n<p><p>\n\n<p><a name="%_thm_2.23"></a>\n<b>Exercise 2.23.</b>&nbsp;&nbsp;The procedure <a name="%_idx_1670"></a><tt>for-each</tt> is similar to <tt>map</tt>.  It takes as\narguments a procedure and a list of elements.  However, rather than\nforming a list of the  results, <tt>for-each</tt> just applies the procedure\nto each of the elements in turn, from left to right.  The values\nreturned by applying the procedure to the elements are not used at\nall -- <tt>for-each</tt> is used with procedures that perform an action,\nsuch as printing.  For example,\n<p><p><tt>(for-each&nbsp;(lambda&nbsp;(x)&nbsp;(newline)&nbsp;(display&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;57&nbsp;321&nbsp;88))<br>\n<i>57</i><br>\n<i>321</i><br>\n<i>88</i><br>\n</tt><p><p>\nThe value returned by the call to <tt>for-each</tt> (not illustrated above)\ncan be something arbitrary, such as true.  Give an\nimplementation of <tt>for-each</tt>.\n\n<p>\n<p>\n\n<a name="%_sec_2.2.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.2.2">2.2.2&nbsp;&nbsp;Hierarchical Structures</a></h3><p>\n\n\n<a name="%_idx_1672"></a><a name="%_idx_1674"></a><a name="%_idx_1676"></a><a name="%_idx_1678"></a>\nThe representation of sequences in terms of lists generalizes\nnaturally to represent sequences whose elements may\nthemselves be sequences.  For example, we can regard the object\n<tt>((1 2) 3 4)</tt> constructed by<p>\n\n<p><p><tt>(cons&nbsp;(list&nbsp;1&nbsp;2)&nbsp;(list&nbsp;3&nbsp;4))<br>\n</tt><p><p>\nas a list of three items, the first of which is itself a list, <tt>(1 2)</tt>.  Indeed, this is suggested by the form in which the result is\nprinted by the interpreter.  Figure&nbsp;<a href="#%_fig_2.5">2.5</a> shows\nthe representation of this structure in terms of pairs.<p>\n\n<a name="%_fig_2.5"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-15.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.5:</b>&nbsp;&nbsp;Structure formed by <tt>(cons (list 1 2) (list 3 4))</tt>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nAnother way to think of sequences whose elements are sequences is as\n<em>trees</em>.  The elements of the sequence are the branches of the\ntree, and elements that are themselves sequences are subtrees.\nFigure&nbsp;<a href="#%_fig_2.6">2.6</a> shows the structure in\nfigure&nbsp;<a href="#%_fig_2.5">2.5</a> viewed as a tree.<p>\n\n<a name="%_fig_2.6"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-16.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.6:</b>&nbsp;&nbsp;The list structure in figure&nbsp;<a href="#%_fig_2.5">2.5</a> viewed as a tree.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n\n<a name="%_idx_1680"></a>Recursion is a natural tool for dealing with tree structures, since\nwe can often reduce operations on trees to operations on their\nbranches, which reduce in turn to operations on the branches of the\nbranches, and so on, until we reach the leaves of the tree.\nAs an example, compare the <tt>length</tt> procedure of\nsection&nbsp;<a href="#%_sec_2.2.1">2.2.1</a> with the <a name="%_idx_1682"></a><a name="%_idx_1684"></a><tt>count-leaves</tt> procedure, which\nreturns the total number of leaves of a tree:<p>\n\n\n<p><p><tt>(define&nbsp;x&nbsp;(cons&nbsp;(list&nbsp;1&nbsp;2)&nbsp;(list&nbsp;3&nbsp;4)))<br>\n<br>\n(length&nbsp;x)<br>\n<i>3</i><br>\n(count-leaves&nbsp;x)<br>\n<i>4</i><br>\n<br>\n(list&nbsp;x&nbsp;x)<br>\n<i>(((1&nbsp;2)&nbsp;3&nbsp;4)&nbsp;((1&nbsp;2)&nbsp;3&nbsp;4))</i><br>\n<br>\n(length&nbsp;(list&nbsp;x&nbsp;x))<br>\n<i>2</i><br>\n<br>\n(count-leaves&nbsp;(list&nbsp;x&nbsp;x))<br>\n<i>8</i><br>\n</tt><p><p><p>\n\n\nTo implement <tt>count-leaves</tt>, recall the recursive plan for computing\n<tt>length</tt>:<p>\n\n\n<p><ul>\n<li><tt>Length</tt> of a list <tt>x</tt> is 1 plus <tt>length</tt> of the\n<tt>cdr</tt> of <tt>x</tt>.<p>\n\n<li><tt>Length</tt> of the empty list is 0.\n</ul><p><p>\n\n<tt>Count-leaves</tt> is similar.  The value for the empty list is the same:<p>\n\n\n<p><ul>\n<li><tt>Count-leaves</tt> of the empty list is 0.\n</ul><p><p>\n\nBut in the reduction step, where we strip off the <tt>car</tt> of the\nlist, we must take into account that the <tt>car</tt> may itself be a\ntree whose leaves we need to count.  Thus, the appropriate reduction\nstep is<p>\n\n\n<p><ul>\n<li><tt>Count-leaves</tt> of a tree <tt>x</tt> is <tt>count-leaves</tt> of the <tt>car</tt> of <tt>x</tt> plus <tt>count-leaves</tt> of the\n<tt>cdr</tt> of <tt>x</tt>.\n</ul><p><p>\n\nFinally, by taking <tt>car</tt>s we reach\nactual leaves, so we need another base case:<p>\n\n\n<p><ul>\n<li><tt>Count-leaves</tt> of a leaf is 1.\n</ul><p><p>\n\nTo aid\nin writing recursive procedures on trees, Scheme provides the primitive\npredicate <a name="%_idx_1686"></a><a name="%_idx_1688"></a><tt>pair?</tt>, which tests whether its argument is a pair.\nHere is the complete procedure:<a name="call_footnote_Temp_170" href="#footnote_Temp_170"><sup><small>13</small></sup></a><p>\n\n\n<p><p><tt><a name="%_idx_1690"></a>(define&nbsp;(count-leaves&nbsp;x)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;x)&nbsp;0)&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((not&nbsp;(pair?&nbsp;x))&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(+&nbsp;(count-leaves&nbsp;(car&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(count-leaves&nbsp;(cdr&nbsp;x))))))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_2.24"></a>\n<b>Exercise 2.24.</b>&nbsp;&nbsp;Suppose we evaluate the expression <tt>(list 1 (list 2 (list 3 4)))</tt>.\nGive the result printed by the interpreter, the corresponding\nbox-and-pointer structure, and the interpretation of this as a tree\n(as in figure&nbsp;<a href="#%_fig_2.6">2.6</a>).\n<p><p>\n\n<p><a name="%_thm_2.25"></a>\n<b>Exercise 2.25.</b>&nbsp;&nbsp;Give combinations of <tt>car</tt>s and <tt>cdr</tt>s that will pick 7 from\neach of the following lists:<p>\n\n<p><p><tt>(1&nbsp;3&nbsp;(5&nbsp;7)&nbsp;9)<br>\n<br>\n((7))<br>\n<br>\n(1&nbsp;(2&nbsp;(3&nbsp;(4&nbsp;(5&nbsp;(6&nbsp;7))))))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_2.26"></a>\n<b>Exercise 2.26.</b>&nbsp;&nbsp;Suppose we define <tt>x</tt> and <tt>y</tt> to be two lists:<p>\n\n<p><p><tt>(define&nbsp;x&nbsp;(list&nbsp;1&nbsp;2&nbsp;3))<br>\n(define&nbsp;y&nbsp;(list&nbsp;4&nbsp;5&nbsp;6))<br>\n</tt><p><p>\nWhat result is printed by the interpreter in response to evaluating\neach of the following expressions:<p>\n\n<p><p><tt>(append&nbsp;x&nbsp;y)<br>\n<br>\n(cons&nbsp;x&nbsp;y)<br>\n<br>\n(list&nbsp;x&nbsp;y)<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_2.27"></a>\n<b>Exercise 2.27.</b>&nbsp;&nbsp;Modify your <tt>reverse</tt> procedure of exercise&nbsp;<a href="#%_thm_2.18">2.18</a> to\nproduce a <a name="%_idx_1692"></a><a name="%_idx_1694"></a><tt>deep-reverse</tt> procedure that takes a list as argument\nand returns as its value the list with its elements reversed and with\nall sublists deep-reversed as well.  For example,<p>\n\n<p><p><tt>(define&nbsp;x&nbsp;(list&nbsp;(list&nbsp;1&nbsp;2)&nbsp;(list&nbsp;3&nbsp;4)))<br>\n<br>\nx<br>\n<i>((1&nbsp;2)&nbsp;(3&nbsp;4))</i><br>\n<br>\n(reverse&nbsp;x)<br>\n<i>((3&nbsp;4)&nbsp;(1&nbsp;2))</i><br>\n<br>\n(deep-reverse&nbsp;x)<br>\n<i>((4&nbsp;3)&nbsp;(2&nbsp;1))</i><br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_2.28"></a>\n<b>Exercise 2.28.</b>&nbsp;&nbsp;Write a procedure <a name="%_idx_1696"></a><a name="%_idx_1698"></a><tt>fringe</tt> that takes as argument a tree\n(represented as a list) and returns a list whose elements are all the\nleaves of the tree arranged in left-to-right order.  For example,<p>\n\n<p><p><tt>(define&nbsp;x&nbsp;(list&nbsp;(list&nbsp;1&nbsp;2)&nbsp;(list&nbsp;3&nbsp;4)))<br>\n<br>\n(fringe&nbsp;x)<br>\n<i>(1&nbsp;2&nbsp;3&nbsp;4)</i><br>\n<br>\n(fringe&nbsp;(list&nbsp;x&nbsp;x))<br>\n<i>(1&nbsp;2&nbsp;3&nbsp;4&nbsp;1&nbsp;2&nbsp;3&nbsp;4)</i><br>\n</tt><p><p>\n<p><p>\n\n\n<p><a name="%_thm_2.29"></a>\n<b>Exercise 2.29.</b>&nbsp;&nbsp;<a name="%_idx_1700"></a>A binary mobile consists of two branches, a left branch and a right\nbranch.  Each branch is a rod of a certain length, from which hangs\neither a weight or another binary mobile.  We can represent a binary\nmobile using compound data by constructing it from two branches (for\nexample, using <tt>list</tt>):<p>\n\n\n<p><p><tt>(define&nbsp;(make-mobile&nbsp;left&nbsp;right)<br>\n&nbsp;&nbsp;(list&nbsp;left&nbsp;right))<br>\n</tt><p><p>\nA branch is constructed from a <tt>length</tt> (which must be a number)\ntogether with a <tt>structure</tt>, which may be either a number\n(representing a simple weight) or another mobile:<p>\n\n\n<p><p><tt>(define&nbsp;(make-branch&nbsp;length&nbsp;structure)<br>\n&nbsp;&nbsp;(list&nbsp;length&nbsp;structure))<br>\n</tt><p><p><p>\n\na.&nbsp;&nbsp;Write the corresponding selectors <tt>left-branch</tt> and\n<tt>right-branch</tt>, which return the branches of a mobile, and\n<tt>branch-length</tt> and <tt>branch-structure</tt>, which return \nthe components of a branch.<p>\n\nb.&nbsp;&nbsp;Using your selectors, define a procedure <tt>total-weight</tt> \nthat returns the total weight of a mobile.<p>\n\nc.&nbsp;&nbsp;A mobile is said to be <a name="%_idx_1702"></a><em>balanced</em> if the torque applied\nby its top-left branch is equal to that applied by its top-right\nbranch (that is, if the length of the left rod multiplied by the\nweight hanging from that rod is equal to the corresponding product for\nthe right side) and if each of the submobiles hanging off its branches\nis balanced. Design a predicate that tests whether a binary mobile is\nbalanced.<p>\n\nd.&nbsp;&nbsp;Suppose we change the representation of mobiles so that the\nconstructors are<p>\n\n\n<p><p><tt>(define&nbsp;(make-mobile&nbsp;left&nbsp;right)<br>\n&nbsp;&nbsp;(cons&nbsp;left&nbsp;right))<br>\n(define&nbsp;(make-branch&nbsp;length&nbsp;structure)<br>\n&nbsp;&nbsp;(cons&nbsp;length&nbsp;structure))<br>\n</tt><p><p>\nHow much do you need to change your programs to convert to the new\nrepresentation?\n\n<p>\n<p>\n\n<a name="%_sec_Temp_177"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_177">Mapping over trees</a></h4><p>\n\n<a name="%_idx_1704"></a><a name="%_idx_1706"></a>\nJust as <tt>map</tt> is a powerful abstraction for dealing with sequences,\n<tt>map</tt> together with recursion is a powerful abstraction for\ndealing with trees.  For instance, the <tt>scale-tree</tt>\nprocedure, analogous to <tt>scale-list</tt> of\nsection&nbsp;<a href="#%_sec_2.2.1">2.2.1</a>, takes as arguments a numeric factor and a\ntree whose leaves are numbers.  It returns a tree of the same shape,\nwhere each number is multiplied by the factor.\nThe recursive plan for <tt>scale-tree</tt> is similar to the one for\n<tt>count-leaves</tt>:<p>\n\n<p><p><tt><a name="%_idx_1708"></a>(define&nbsp;(scale-tree&nbsp;tree&nbsp;factor)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;tree)&nbsp;nil)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((not&nbsp;(pair?&nbsp;tree))&nbsp;(*&nbsp;tree&nbsp;factor))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(cons&nbsp;(scale-tree&nbsp;(car&nbsp;tree)&nbsp;factor)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(scale-tree&nbsp;(cdr&nbsp;tree)&nbsp;factor)))))<br>\n(scale-tree&nbsp;(list&nbsp;1&nbsp;(list&nbsp;2&nbsp;(list&nbsp;3&nbsp;4)&nbsp;5)&nbsp;(list&nbsp;6&nbsp;7))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10)<br>\n<i>(10&nbsp;(20&nbsp;(30&nbsp;40)&nbsp;50)&nbsp;(60&nbsp;70))</i><br>\n</tt><p><p><p>\n\nAnother way to implement <tt>scale-tree</tt> is to regard the\ntree as a sequence of sub-trees and use <tt>map</tt>.  We map\nover the sequence, scaling each sub-tree in turn, and return the list\nof results.  In the base case, where the tree is a leaf, we simply\nmultiply by the factor:<p>\n\n<p><p><tt><a name="%_idx_1710"></a>(define&nbsp;(scale-tree&nbsp;tree&nbsp;factor)<br>\n&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(sub-tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;sub-tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(scale-tree&nbsp;sub-tree&nbsp;factor)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;sub-tree&nbsp;factor)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree))<br>\n</tt><p><p>\nMany tree operations can be implemented by similar combinations of\nsequence operations and recursion.<p>\n\n<p><a name="%_thm_2.30"></a>\n<b>Exercise 2.30.</b>&nbsp;&nbsp;Define a procedure <tt>square-tree</tt> analogous to the <tt>square-list</tt>\nprocedure of exercise&nbsp;<a href="#%_thm_2.21">2.21</a>.  That is, <tt>square-list</tt> should behave as follows:<p>\n\n<p><p><tt>(square-tree<br>\n&nbsp;(list&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;2&nbsp;(list&nbsp;3&nbsp;4)&nbsp;5)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;6&nbsp;7)))<br>\n<i>(1&nbsp;(4&nbsp;(9&nbsp;16)&nbsp;25)&nbsp;(36&nbsp;49))</i><br>\n</tt><p><p>\nDefine <tt>square-tree</tt> both directly (i.e., without using any\nhigher-order procedures) and also by using <tt>map</tt> and recursion.\n\n<p><p>\n\n<p><a name="%_thm_2.31"></a>\n<b>Exercise 2.31.</b>&nbsp;&nbsp;Abstract your answer to exercise&nbsp;<a href="#%_thm_2.30">2.30</a> to produce a\nprocedure <a name="%_idx_1712"></a><tt>tree-map</tt> with the property that <tt>square-tree</tt>\ncould be defined as<p>\n\n<p><p><tt>(define&nbsp;(square-tree&nbsp;tree)&nbsp;(tree-map&nbsp;square&nbsp;tree))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_2.32"></a>\n<b>Exercise 2.32.</b>&nbsp;&nbsp;We can represent a <a name="%_idx_1714"></a>set as a list of distinct elements, and we can\nrepresent the set of all subsets of the set as a list of lists.  For\nexample, if the set is <tt>(1&nbsp;2&nbsp;3)</tt>, then the set of all subsets is\n<tt>(() (3) (2) (2&nbsp;3) (1) (1&nbsp;3) (1&nbsp;2) (1&nbsp;2&nbsp;3))</tt>.  Complete the\nfollowing definition of a procedure that generates the set of subsets\nof a set and give a clear explanation of why it works:\n<p><p><tt><a name="%_idx_1716"></a>(define&nbsp;(subsets&nbsp;s)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;s)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;nil)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((rest&nbsp;(subsets&nbsp;(cdr&nbsp;s))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append&nbsp;rest&nbsp;(map&nbsp;&lt;<em>??</em>&gt;&nbsp;rest)))))<br>\n</tt><p><p>\n<p>\n<p>\n\n<a name="%_sec_2.2.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.2.3">2.2.3&nbsp;&nbsp;Sequences as Conventional Interfaces</a></h3><p>\n\n\n<a name="%_idx_1718"></a><a name="%_idx_1720"></a>\nIn working with compound data, we\'ve stressed how data abstraction\npermits us to design programs without becoming enmeshed in the details\nof data representations, and how abstraction preserves for us the\nflexibility to experiment with alternative representations.  In this\nsection, we introduce another powerful design principle for working\nwith data structures -- the use of <em>conventional interfaces</em>.<p>\n\nIn section&nbsp;<a href="book-Z-H-12.html#%_sec_1.3">1.3</a> we saw how program\nabstractions, implemented as higher-order procedures, can capture\ncommon patterns in programs that deal with numerical data.  Our\nability to formulate analogous operations for working with compound\ndata depends crucially on the style in which we manipulate our data\nstructures.  Consider, for example, the following procedure, analogous\nto the <tt>count-leaves</tt> procedure of section&nbsp;<a href="#%_sec_2.2.2">2.2.2</a>, which\ntakes a tree as argument and computes the sum of the squares of the\nleaves that are odd:\n<p><p><tt><a name="%_idx_1722"></a>(define&nbsp;(sum-odd-squares&nbsp;tree)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;tree)&nbsp;0)&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((not&nbsp;(pair?&nbsp;tree))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(odd?&nbsp;tree)&nbsp;(square&nbsp;tree)&nbsp;0))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(+&nbsp;(sum-odd-squares&nbsp;(car&nbsp;tree))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sum-odd-squares&nbsp;(cdr&nbsp;tree))))))<br>\n</tt><p><p>\n\nOn the surface, this procedure is very different from the following\none, which constructs a list of all the even Fibonacci numbers\n <em>F</em><em>i</em><em>b</em>(<em>k</em>), where <em>k</em> is less than or equal to a given integer <em>n</em>:\n<p><p><tt><a name="%_idx_1724"></a>(define&nbsp;(even-fibs&nbsp;n)<br>\n&nbsp;&nbsp;(define&nbsp;(next&nbsp;k)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;k&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((f&nbsp;(fib&nbsp;k)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(even?&nbsp;f)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;f&nbsp;(next&nbsp;(+&nbsp;k&nbsp;1)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(next&nbsp;(+&nbsp;k&nbsp;1))))))<br>\n&nbsp;&nbsp;(next&nbsp;0))<br>\n</tt><p><p><p>\n\n\nDespite the fact that these two procedures are structurally very\ndifferent, a more abstract description of the two computations reveals\na great deal of similarity.  The first program\n<p><ul>\n<li>enumerates the leaves of a tree;\n<li>filters them, selecting the odd ones;\n<li>squares each of the selected ones; and\n<li>accumulates the results using <tt>+</tt>, starting with 0.\n</ul><p>\nThe second program\n<p><ul>\n<li>enumerates the integers from 0 to <em>n</em>;\n<li>computes the Fibonacci number for each integer;\n<li>filters them, selecting the even ones; and\n<li>accumulates the results using <tt>cons</tt>,  starting with the\nempty list.\n</ul><p><p>\n\n<a name="%_idx_1726"></a><a name="%_idx_1728"></a>A signal-processing engineer would find it natural to conceptualize\nthese processes in terms of signals flowing through a cascade of\nstages, each of which implements part of the program plan, as shown in\nfigure&nbsp;<a href="#%_fig_2.7">2.7</a>.  In <tt>sum-odd-squares</tt>, we\nbegin with an <a name="%_idx_1730"></a><em>enumerator</em>, which generates a ``signal\'\'\nconsisting of the leaves of a given tree.  This signal is passed\nthrough a <a name="%_idx_1732"></a><em>filter</em>, which eliminates all but the odd elements.\nThe resulting signal is in turn passed through a <a name="%_idx_1734"></a><em>map</em>, which is a\n``transducer\'\' that applies the <tt>square</tt> procedure to each\nelement.  The output of the map is then fed to an <a name="%_idx_1736"></a><em>accumulator</em>,\nwhich combines the elements using <tt>+</tt>, starting from an initial 0.\nThe plan for <tt>even-fibs</tt> is analogous.<p>\n\n<a name="%_fig_2.7"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-17.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.7:</b>&nbsp;&nbsp;The signal-flow plans for the procedures <tt>sum-odd-squares</tt> (top) and <tt>even-fibs</tt> (bottom) reveal the\ncommonality between the two programs.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nUnfortunately, the two procedure definitions above fail to exhibit this\nsignal-flow structure.  For instance, if we examine the <tt>sum-odd-squares</tt> procedure, we find that the enumeration is\nimplemented partly by the <tt>null?</tt> and <tt>pair?</tt> tests and partly\nby the tree-recursive structure of the procedure.  Similarly, the\naccumulation is found partly in the tests and partly in the addition used\nin the recursion.  In general, there are no distinct parts of either\nprocedure that correspond to the elements in the signal-flow\ndescription.\nOur two procedures decompose the computations in a different way,\nspreading the enumeration over the program and mingling it with the\nmap, the filter, and the accumulation.  If we could organize our\nprograms to make the signal-flow structure manifest in the procedures\nwe write, this would increase the conceptual clarity of the resulting\ncode.<p>\n\n<a name="%_sec_Temp_181"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_181">Sequence Operations</a></h4><p>\n\n\n<a name="%_idx_1738"></a>\nThe key to organizing programs so as to more clearly reflect the\nsignal-flow structure is to concentrate on the ``signals\'\' that flow\nfrom one stage in the process to the next.  If we represent these\nsignals as lists, then we can use list operations to implement the\nprocessing at each of the stages.  For instance, we can implement the\nmapping stages of the signal-flow diagrams using the <tt>map</tt>\nprocedure from section&nbsp;<a href="#%_sec_2.2.1">2.2.1</a>:\n\n<p><p><tt>(map&nbsp;square&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))<br>\n<i>(1&nbsp;4&nbsp;9&nbsp;16&nbsp;25)</i><br>\n</tt><p><p><p>\n\nFiltering a sequence to select only those elements that satisfy a\ngiven predicate is accomplished by\n\n<p><p><tt><a name="%_idx_1740"></a>(define&nbsp;(filter&nbsp;predicate&nbsp;sequence)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;sequence)&nbsp;nil)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((predicate&nbsp;(car&nbsp;sequence))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;sequence)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(filter&nbsp;predicate&nbsp;(cdr&nbsp;sequence))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(filter&nbsp;predicate&nbsp;(cdr&nbsp;sequence)))))<br>\n</tt><p><p>\nFor example,\n<p><p><tt>(filter&nbsp;odd?&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))<br>\n<i>(1&nbsp;3&nbsp;5)</i><br>\n</tt><p><p><p>\n\nAccumulations can be implemented by\n<p><p><tt><a name="%_idx_1742"></a>(define&nbsp;(accumulate&nbsp;op&nbsp;initial&nbsp;sequence)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;sequence)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initial<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;(car&nbsp;sequence)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(accumulate&nbsp;op&nbsp;initial&nbsp;(cdr&nbsp;sequence)))))<br>\n(accumulate&nbsp;+&nbsp;0&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))<br>\n<i>15</i><br>\n(accumulate&nbsp;*&nbsp;1&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))<br>\n<i>120</i><br>\n(accumulate&nbsp;cons&nbsp;nil&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))<br>\n<i>(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)</i><br>\n</tt><p><p><p>\n\n\nAll that remains to implement signal-flow diagrams is to enumerate the\nsequence of elements to be processed.  For <tt>even-fibs</tt>, we need to\ngenerate the sequence of\nintegers in a given range, which we can do as follows:\n<p><p><tt><a name="%_idx_1744"></a>(define&nbsp;(enumerate-interval&nbsp;low&nbsp;high)<br>\n&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;low&nbsp;high)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;low&nbsp;(enumerate-interval&nbsp;(+&nbsp;low&nbsp;1)&nbsp;high))))<br>\n(enumerate-interval&nbsp;2&nbsp;7)<br>\n<i>(2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7)</i><br>\n</tt><p><p>\nTo enumerate the leaves of a tree, we can use<a name="call_footnote_Temp_182" href="#footnote_Temp_182"><sup><small>14</small></sup></a>\n<p><p><tt><a name="%_idx_1748"></a><a name="%_idx_1750"></a>(define&nbsp;(enumerate-tree&nbsp;tree)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;tree)&nbsp;nil)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((not&nbsp;(pair?&nbsp;tree))&nbsp;(list&nbsp;tree))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(append&nbsp;(enumerate-tree&nbsp;(car&nbsp;tree))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(enumerate-tree&nbsp;(cdr&nbsp;tree))))))<br>\n(enumerate-tree&nbsp;(list&nbsp;1&nbsp;(list&nbsp;2&nbsp;(list&nbsp;3&nbsp;4))&nbsp;5))<br>\n<i>(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)</i><br>\n</tt><p><p><p>\n\nNow we can reformulate <tt>sum-odd-squares</tt> and <tt>even-fibs</tt> as in\nthe signal-flow diagrams.  For <tt>sum-odd-squares</tt>, we enumerate the\nsequence of leaves of the tree, filter this to keep only the odd\nnumbers in the sequence, square each element, and sum the results:\n\n<p><p><tt><a name="%_idx_1752"></a>(define&nbsp;(sum-odd-squares&nbsp;tree)<br>\n&nbsp;&nbsp;(accumulate&nbsp;+<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;square<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(filter&nbsp;odd?<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(enumerate-tree&nbsp;tree)))))<br>\n</tt><p><p>\nFor <tt>even-fibs</tt>, we enumerate the integers from 0 to <em>n</em>, generate\nthe Fibonacci number for each of these integers, filter the resulting\nsequence to keep only the even elements, and accumulate the results\ninto a list:\n\n<p><p><tt><a name="%_idx_1754"></a>(define&nbsp;(even-fibs&nbsp;n)<br>\n&nbsp;&nbsp;(accumulate&nbsp;cons<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(filter&nbsp;even?<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;fib<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(enumerate-interval&nbsp;0&nbsp;n)))))<br>\n</tt><p><p><p>\n\n\nThe value of expressing programs as sequence operations is that this\nhelps us make program designs that are modular, that is, designs that\nare constructed by combining relatively independent pieces.  We can\nencourage modular design by providing a library of standard components\ntogether with a conventional interface for connecting the components\nin flexible ways.<p>\n\n<a name="%_idx_1756"></a><a name="%_idx_1758"></a>Modular construction is a powerful strategy for\ncontrolling complexity in engineering design.  In real\nsignal-processing applications, for example, designers regularly build\nsystems by cascading elements selected from standardized families of\nfilters and transducers.  Similarly, sequence operations provide a\nlibrary of standard program elements that we can mix and match.  For\ninstance, we can reuse pieces from the <tt>sum-odd-squares</tt> and <tt>even-fibs</tt> procedures in a program that constructs a list of the\nsquares of the first <em>n</em> + 1 Fibonacci numbers:\n\n<p><p><tt>(define&nbsp;(list-fib-squares&nbsp;n)<br>\n&nbsp;&nbsp;(accumulate&nbsp;cons<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;square<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;fib<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(enumerate-interval&nbsp;0&nbsp;n)))))<br>\n(list-fib-squares&nbsp;10)<br>\n<i>(0&nbsp;1&nbsp;1&nbsp;4&nbsp;9&nbsp;25&nbsp;64&nbsp;169&nbsp;441&nbsp;1156&nbsp;3025)</i><br>\n</tt><p><p>\nWe can rearrange the pieces and use them in computing the product of\nthe odd integers in a sequence:\n<p><p><tt>(define&nbsp;(product-of-squares-of-odd-elements&nbsp;sequence)<br>\n&nbsp;&nbsp;(accumulate&nbsp;*<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;square<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(filter&nbsp;odd?&nbsp;sequence))))<br>\n(product-of-squares-of-odd-elements&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))<br>\n<i>225</i><br>\n</tt><p><p><p>\n\nWe can also formulate conventional data-processing applications in\nterms of sequence operations.  Suppose we have a sequence of personnel\nrecords and we want to find the salary of the highest-paid programmer.\nAssume that we have a selector <tt>salary</tt> that returns the salary of\na record, and a predicate <tt>programmer?</tt> that tests if a record is\nfor a programmer.  Then we can write\n<p><p><tt>(define&nbsp;(salary-of-highest-paid-programmer&nbsp;records)<br>\n&nbsp;&nbsp;(accumulate&nbsp;max<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;salary<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(filter&nbsp;programmer?&nbsp;records))))<br>\n</tt><p><p>\nThese examples give just a hint of the vast range of operations that\ncan be expressed as sequence operations.<a name="call_footnote_Temp_183" href="#footnote_Temp_183"><sup><small>15</small></sup></a><p>\n\nSequences, implemented here as lists, serve\nas a conventional interface that permits us to combine processing\nmodules.  Additionally, when we uniformly represent structures as\nsequences, we have localized the data-structure dependencies in our\nprograms to a small number of sequence operations.  By changing these,\nwe can experiment with alternative representations of sequences, while\nleaving the overall design of our programs intact.  We will exploit\nthis capability in section&nbsp;<a href="book-Z-H-24.html#%_sec_3.5">3.5</a>, when we generalize the\nsequence-processing paradigm to admit infinite sequences.<p>\n\n<p><a name="%_thm_2.33"></a>\n<b>Exercise 2.33.</b>&nbsp;&nbsp;Fill in the missing expressions to complete the following definitions\nof some basic list-manipulation operations as accumulations:\n<p><p><tt><a name="%_idx_1766"></a>(define&nbsp;(map&nbsp;p&nbsp;sequence)<br>\n&nbsp;&nbsp;(accumulate&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;&lt;<em>??</em>&gt;)&nbsp;nil&nbsp;sequence))<br>\n<a name="%_idx_1768"></a>(define&nbsp;(append&nbsp;seq1&nbsp;seq2)<br>\n&nbsp;&nbsp;(accumulate&nbsp;cons&nbsp;&lt;<em>??</em>&gt;&nbsp;&lt;<em>??</em>&gt;))<br>\n<a name="%_idx_1770"></a>(define&nbsp;(length&nbsp;sequence)<br>\n&nbsp;&nbsp;(accumulate&nbsp;&lt;<em>??</em>&gt;&nbsp;0&nbsp;sequence))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_2.34"></a>\n<b>Exercise 2.34.</b>&nbsp;&nbsp;<a name="%_idx_1772"></a>Evaluating a polynomial in <em>x</em> at a given value of <em>x</em> can be\nformulated as an accumulation.  We evaluate the polynomial\n<p><div align=left><img src="ch2-Z-G-18.gif" border="0"></div><p>\nusing a well-known algorithm called <a name="%_idx_1774"></a><em>Horner\'s rule</em>, which\nstructures the computation as\n<p><div align=left><img src="ch2-Z-G-19.gif" border="0"></div><p>\nIn other words, we start with <em>a</em><sub><em>n</em></sub>, multiply by <em>x</em>, add <em>a</em><sub><em>n</em>-1</sub>,\nmultiply by <em>x</em>, and so on, until we reach <em>a</em><sub>0</sub>.<a name="call_footnote_Temp_186" href="#footnote_Temp_186"><sup><small>16</small></sup></a>\nFill in the following template to produce a procedure that evaluates a\npolynomial using Horner\'s rule.\nAssume that the coefficients of the\npolynomial are arranged in a sequence, from <em>a</em><sub>0</sub> through <em>a</em><sub><em>n</em></sub>.\n<p><p><tt>(define&nbsp;(horner-eval&nbsp;x&nbsp;coefficient-sequence)<br>\n&nbsp;&nbsp;(accumulate&nbsp;(lambda&nbsp;(this-coeff&nbsp;higher-terms)&nbsp;&lt;<em>??</em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coefficient-sequence))<br>\n</tt><p><p>\nFor example, to compute 1 + 3<em>x</em> + 5<em>x</em><sup>3</sup> + <em>x</em><sup>5</sup> at <em>x</em> = 2 you would evaluate\n<p><p><tt>(horner-eval&nbsp;2&nbsp;(list&nbsp;1&nbsp;3&nbsp;0&nbsp;5&nbsp;0&nbsp;1))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_2.35"></a>\n<b>Exercise 2.35.</b>&nbsp;&nbsp;Redefine <tt>count-leaves</tt> from section&nbsp;<a href="#%_sec_2.2.2">2.2.2</a> as an\naccumulation:\n<p><p><tt><a name="%_idx_1792"></a>(define&nbsp;(count-leaves&nbsp;t)<br>\n&nbsp;&nbsp;(accumulate&nbsp;&lt;<em>??</em>&gt;&nbsp;&lt;<em>??</em>&gt;&nbsp;(map&nbsp;&lt;<em>??</em>&gt;&nbsp;&lt;<em>??</em>&gt;)))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_2.36"></a>\n<b>Exercise 2.36.</b>&nbsp;&nbsp;The procedure <tt>accumulate-n</tt> is similar to <tt>accumulate</tt> except\nthat it takes as its third argument a sequence of sequences, which are all\nassumed to have the same number of elements.  It applies the\ndesignated accumulation procedure to combine all the first elements of\nthe sequences, all the second elements of the sequences, and so on, and\nreturns a sequence of the results.  For instance, if <tt>s</tt> is a sequence\ncontaining four sequences, <tt>((1 2 3) (4 5 6) (7 8 9) (10 11 12)),</tt>\nthen the value of <tt>(accumulate-n + 0 s)</tt> should be the sequence <tt>(22 26 30)</tt>.  Fill in the missing expressions\nin the following definition of <tt>accumulate-n</tt>:\n<p><p><tt><a name="%_idx_1794"></a>(define&nbsp;(accumulate-n&nbsp;op&nbsp;init&nbsp;seqs)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;(car&nbsp;seqs))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(accumulate&nbsp;op&nbsp;init&nbsp;&lt;<em>??</em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(accumulate-n&nbsp;op&nbsp;init&nbsp;&lt;<em>??</em>&gt;))))<br>\n</tt><p><p>\n<p>\n<p><a name="%_thm_2.37"></a>\n<b>Exercise 2.37.</b>&nbsp;&nbsp;<a name="%_idx_1796"></a><a name="%_idx_1798"></a><a name="%_idx_1800"></a>Suppose we represent vectors <em>v</em> = (<em>v</em><sub><em>i</em></sub>) as sequences of numbers, and\nmatrices <em>m</em> = (<em>m</em><sub><em>i</em><em>j</em></sub>) as sequences of vectors (the rows of the matrix).\nFor example, the matrix\n<p><div align=left><img src="ch2-Z-G-20.gif" border="0"></div><p>\nis represented as the sequence <tt>((1 2 3 4) (4 5 6 6) (6 7 8 9))</tt>.\nWith this representation, we can use sequence operations to concisely\nexpress the basic matrix and vector operations.  These operations\n(which are described in any book on matrix algebra) are the following:<p>\n\n<p><div align=left><img src="ch2-Z-G-21.gif" border="0"></div><p><p>\n\nWe can define the dot product as<a name="call_footnote_Temp_190" href="#footnote_Temp_190"><sup><small>17</small></sup></a>\n<p><p><tt><a name="%_idx_1802"></a>(define&nbsp;(dot-product&nbsp;v&nbsp;w)<br>\n&nbsp;&nbsp;(accumulate&nbsp;+&nbsp;0&nbsp;(map&nbsp;*&nbsp;v&nbsp;w)))<br>\n</tt><p><p>\nFill in the missing expressions in the following procedures for\ncomputing the other matrix operations.  (The procedure <tt>accumulate-n</tt> is\ndefined in exercise&nbsp;<a href="#%_thm_2.36">2.36</a>.)\n<p><p><tt><a name="%_idx_1804"></a>(define&nbsp;(matrix-*-vector&nbsp;m&nbsp;v)<br>\n&nbsp;&nbsp;(map&nbsp;&lt;<em>??</em>&gt;&nbsp;m))<br>\n<a name="%_idx_1806"></a>(define&nbsp;(transpose&nbsp;mat)<br>\n&nbsp;&nbsp;(accumulate-n&nbsp;&lt;<em>??</em>&gt;&nbsp;&lt;<em>??</em>&gt;&nbsp;mat))<br>\n<a name="%_idx_1808"></a>(define&nbsp;(matrix-*-matrix&nbsp;m&nbsp;n)<br>\n&nbsp;&nbsp;(let&nbsp;((cols&nbsp;(transpose&nbsp;n)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;&lt;<em>??</em>&gt;&nbsp;m)))<br>\n</tt><p><p>\n<p>\n<p><a name="%_thm_2.38"></a>\n<b>Exercise 2.38.</b>&nbsp;&nbsp;<a name="%_idx_1810"></a><a name="%_idx_1812"></a>The <tt>accumulate</tt> procedure is also known as <tt>fold-right</tt>,\nbecause it combines the first element of the sequence with the result\nof combining all the elements to the right.  There is also a <tt>fold-left</tt>, which is \nsimilar to <tt>fold-right</tt>, except\nthat it combines elements working in the opposite direction:\n<p><p><tt><a name="%_idx_1814"></a>(define&nbsp;(fold-left&nbsp;op&nbsp;initial&nbsp;sequence)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;result&nbsp;rest)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;rest)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;(op&nbsp;result&nbsp;(car&nbsp;rest))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;rest))))<br>\n&nbsp;&nbsp;(iter&nbsp;initial&nbsp;sequence))<br>\n</tt><p><p>\nWhat are the values of\n<p><p><tt>(fold-right&nbsp;/&nbsp;1&nbsp;(list&nbsp;1&nbsp;2&nbsp;3))<br>\n(fold-left&nbsp;/&nbsp;1&nbsp;(list&nbsp;1&nbsp;2&nbsp;3))<br>\n(fold-right&nbsp;list&nbsp;nil&nbsp;(list&nbsp;1&nbsp;2&nbsp;3))<br>\n(fold-left&nbsp;list&nbsp;nil&nbsp;(list&nbsp;1&nbsp;2&nbsp;3))<br>\n</tt><p><p>\nGive a property that <tt>op</tt> should satisfy to guarantee that <tt>fold-right</tt> and <tt>fold-left</tt> will produce the same values for any\nsequence.\n\n<p><p>\n\n<p><a name="%_thm_2.39"></a>\n<b>Exercise 2.39.</b>&nbsp;&nbsp;\nComplete the following definitions of <tt>reverse</tt>\n<a name="%_idx_1816"></a>(exercise&nbsp;<a href="#%_thm_2.18">2.18</a>) in terms of <tt>fold-right</tt> and <tt>fold-left</tt> from exercise&nbsp;<a href="#%_thm_2.38">2.38</a>:\n<p><p><tt>(define&nbsp;(reverse&nbsp;sequence)<br>\n&nbsp;&nbsp;(fold-right&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;&lt;<em>??</em>&gt;)&nbsp;nil&nbsp;sequence))<br>\n(define&nbsp;(reverse&nbsp;sequence)<br>\n&nbsp;&nbsp;(fold-left&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;&lt;<em>??</em>&gt;)&nbsp;nil&nbsp;sequence))<br>\n</tt><p><p>\n<p>\n\n<a name="%_sec_Temp_193"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_193">Nested Mappings</a></h4><p>\n\n\n<a name="%_idx_1818"></a>\nWe can extend the sequence paradigm to include many\ncomputations that are commonly expressed using nested loops.<a name="call_footnote_Temp_194" href="#footnote_Temp_194"><sup><small>18</small></sup></a>\nConsider\nthis problem: Given a positive integer <em>n</em>, find all ordered pairs of\ndistinct positive integers <em>i</em> and <em>j</em>, where 1<u>&lt;</u> <em>j</em>&lt; <em>i</em><u>&lt;</u> <em>n</em>, such\nthat <em>i</em>  + <em>j</em> is prime.  For example, if <em>n</em> is 6, then the pairs are\nthe following:\n<p><div align=left><img src="ch2-Z-G-22.gif" border="0"></div><p>\nA natural way to organize this computation is to generate the sequence\nof all ordered pairs of positive integers less than or equal to <em>n</em>,\nfilter to select those pairs whose sum is prime, and\nthen, for each pair (<em>i</em>, <em>j</em>) that passes through the filter, produce the triple\n(<em>i</em>,<em>j</em>,<em>i</em> + <em>j</em>).<p>\n\nHere is a way to generate the sequence of pairs: For each integer\n<em>i</em><u>&lt;</u> <em>n</em>, enumerate the integers <em>j</em>&lt;<em>i</em>, and for each such <em>i</em> and <em>j</em>\ngenerate the pair (<em>i</em>,<em>j</em>).  In terms of sequence operations, we map\nalong the sequence <tt>(enumerate-interval 1 n)</tt>.  For each <em>i</em> in\nthis sequence, we map along the sequence <tt>(enumerate-interval 1 (-\ni 1))</tt>.  For each <em>j</em> in this latter sequence, we generate the pair\n<tt>(list i j)</tt>.  This gives us a sequence of pairs for each <em>i</em>.\nCombining all the sequences for all the <em>i</em> (by accumulating with <tt>append</tt>) produces the required sequence of pairs:<a name="call_footnote_Temp_195" href="#footnote_Temp_195"><sup><small>19</small></sup></a>\n<p><p><tt>(accumulate&nbsp;append<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(j)&nbsp;(list&nbsp;i&nbsp;j))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(enumerate-interval&nbsp;1&nbsp;(-&nbsp;i&nbsp;1))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(enumerate-interval&nbsp;1&nbsp;n)))<br>\n</tt><p><p>\nThe combination of mapping and accumulating with <tt>append</tt> is so common in this\nsort of program that we will isolate it as a separate procedure:\n<p><p><tt><a name="%_idx_1826"></a>(define&nbsp;(flatmap&nbsp;proc&nbsp;seq)<br>\n&nbsp;&nbsp;(accumulate&nbsp;append&nbsp;nil&nbsp;(map&nbsp;proc&nbsp;seq)))<br>\n</tt><p><p>\nNow filter this sequence of pairs to find those whose sum is prime. The\nfilter predicate is called for each element of the sequence; its\nargument is a pair and it must extract the integers from the pair.\nThus, the predicate to apply to each element in the sequence is\n<p><p><tt>(define&nbsp;(prime-sum?&nbsp;pair)<br>\n&nbsp;&nbsp;(prime?&nbsp;(+&nbsp;(car&nbsp;pair)&nbsp;(cadr&nbsp;pair))))<br>\n</tt><p><p>\nFinally, generate the sequence of results by mapping over the filtered\npairs using the following procedure, which constructs a triple\nconsisting of the two elements of the pair along with their sum:\n<p><p><tt>(define&nbsp;(make-pair-sum&nbsp;pair)<br>\n&nbsp;&nbsp;(list&nbsp;(car&nbsp;pair)&nbsp;(cadr&nbsp;pair)&nbsp;(+&nbsp;(car&nbsp;pair)&nbsp;(cadr&nbsp;pair))))<br>\n</tt><p><p>\nCombining all these steps yields the complete procedure:\n<p><p><tt><a name="%_idx_1828"></a>(define&nbsp;(prime-sum-pairs&nbsp;n)<br>\n&nbsp;&nbsp;(map&nbsp;make-pair-sum<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(filter&nbsp;prime-sum?<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flatmap<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(i)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(j)&nbsp;(list&nbsp;i&nbsp;j))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(enumerate-interval&nbsp;1&nbsp;(-&nbsp;i&nbsp;1))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(enumerate-interval&nbsp;1&nbsp;n)))))<br>\n</tt><p><p><p>\n\nNested mappings are also useful for sequences other than those that\nenumerate intervals.  Suppose we wish to generate all the <a name="%_idx_1830"></a><a name="%_idx_1832"></a>permutations\nof a set <em>S</em>; that is, all the ways of ordering the items in\nthe set.  For instance, the permutations of {1,2,3} are\n{1,2,3}, { 1,3,2}, {2,1,3}, { 2,3,1}, { 3,1,2}, and\n{ 3,2,1}.  Here is a plan for generating the permutations of&nbsp;<em>S</em>:\nFor each item <em>x</em> in <em>S</em>, recursively generate the sequence of\npermutations of <em>S</em> - <em>x</em>,<a name="call_footnote_Temp_196" href="#footnote_Temp_196"><sup><small>20</small></sup></a> and adjoin\n<em>x</em> to the front of each one.  This yields, for each <em>x</em> in <em>S</em>, the sequence\nof permutations of <em>S</em> that begin with&nbsp;<em>x</em>.  Combining these\nsequences for all <em>x</em> gives all the permutations of&nbsp;<em>S</em>:<a name="call_footnote_Temp_197" href="#footnote_Temp_197"><sup><small>21</small></sup></a><p>\n\n\n<p><p><tt><a name="%_idx_1840"></a>(define&nbsp;(permutations&nbsp;s)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;empty&nbsp;set?</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;nil)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;sequence&nbsp;containing&nbsp;empty&nbsp;set</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flatmap&nbsp;(lambda&nbsp;(x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(p)&nbsp;(cons&nbsp;x&nbsp;p))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(permutations&nbsp;(remove&nbsp;x&nbsp;s))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s)))<br>\n</tt><p><p>\nNotice how this strategy reduces the problem of generating\npermutations of <em>S</em> to the problem of generating the permutations of\nsets with fewer elements than <em>S</em>.  In the terminal case, we work our\nway down to the empty list, which represents a set of no elements.\nFor this, we generate <tt>(list nil)</tt>, which is a sequence with one\nitem, namely the set with no elements.  The <tt>remove</tt> procedure\nused in <tt>permutations</tt> returns all the items in a given sequence\nexcept for a given item.  This can be expressed as a simple filter:\n\n<p><p><tt><a name="%_idx_1842"></a>(define&nbsp;(remove&nbsp;item&nbsp;sequence)<br>\n&nbsp;&nbsp;(filter&nbsp;(lambda&nbsp;(x)&nbsp;(not&nbsp;(=&nbsp;x&nbsp;item)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sequence))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_2.40"></a>\n<b>Exercise 2.40.</b>&nbsp;&nbsp;Define a procedure <a name="%_idx_1844"></a><tt>unique-pairs</tt> that, given an integer <em>n</em>,\ngenerates the sequence of pairs (<em>i</em>,<em>j</em>) with 1<u>&lt;</u> <em>j</em>&lt; <em>i</em><u>&lt;</u> <em>n</em>.  Use <tt>unique-pairs</tt> to simplify the definition of <tt>prime-sum-pairs</tt>\ngiven above.\n<p><p>\n\n<p><a name="%_thm_2.41"></a>\n<b>Exercise 2.41.</b>&nbsp;&nbsp;Write a procedure to find all ordered\ntriples of distinct positive integers <em>i</em>, <em>j</em>, and&nbsp;<em>k</em> less than or\nequal to a given integer <em>n</em> that sum to a given integer <em>s</em>.\n<p><p>\n\n\n<p><a name="%_thm_2.42"></a>\n<b>Exercise 2.42.</b>&nbsp;&nbsp;<a name="%_fig_2.8"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-23.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.8:</b>&nbsp;&nbsp;A solution to the eight-queens puzzle.</div></caption><tr><td>\n\n</td></tr></table></div><p>\nThe <a name="%_idx_1846"></a><a name="%_idx_1848"></a><a name="%_idx_1850"></a>``eight-queens puzzle\'\' asks how to place eight queens on a\nchessboard so that no queen is in check from any other (i.e., no two\nqueens are in the same row, column, or diagonal).  One possible\nsolution is shown in figure&nbsp;<a href="#%_fig_2.8">2.8</a>.  One way to solve the\npuzzle is to work across the board, placing a queen in each column.\nOnce we have placed <em>k</em> - 1 queens, we must place the <em>k</em>th queen in a\nposition where it does not check any of the queens already on the\nboard.  We can formulate this approach recursively: Assume that we\nhave already generated the sequence of all possible ways to place\n<em>k</em> - 1 queens in the first <em>k</em> - 1 columns of the board.  For each of\nthese ways, generate an extended set of positions by placing a queen\nin each row of the <em>k</em>th column.  Now filter these, keeping only\nthe positions for which the queen in the <em>k</em>th column is safe with\nrespect to the other queens.  This produces the sequence of all ways\nto place <em>k</em> queens in the first <em>k</em> columns.  By continuing this\nprocess, we will produce not only one solution, but all solutions to\nthe puzzle.<p>\n\n\nWe implement this solution as a procedure <tt>queens</tt>, which returns\na sequence of all solutions to the problem of placing <em>n</em> queens on an\n<em>n</em>&times; <em>n</em> chessboard.  <tt>Queens</tt> has an internal procedure <tt>queen-cols</tt> that returns the sequence of all ways to place queens in\nthe first <em>k</em> columns of the board.\n\n<p><p><tt><a name="%_idx_1852"></a>(define&nbsp;(queens&nbsp;board-size)<br>\n&nbsp;&nbsp;(define&nbsp;(queen-cols&nbsp;k)&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;k&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;empty-board)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(filter<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(positions)&nbsp;(safe?&nbsp;k&nbsp;positions))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flatmap<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(rest-of-queens)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(new-row)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(adjoin-position&nbsp;new-row&nbsp;k&nbsp;rest-of-queens))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(enumerate-interval&nbsp;1&nbsp;board-size)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(queen-cols&nbsp;(-&nbsp;k&nbsp;1))))))<br>\n&nbsp;&nbsp;(queen-cols&nbsp;board-size))<br>\n</tt><p><p>\nIn this procedure <tt>rest-of-queens</tt> is a way to place <em>k</em> - 1 queens\nin the first <em>k</em> - 1 columns, and <tt>new-row</tt> is a proposed row in\nwhich to place the queen for the <em>k</em>th column.  Complete the program\nby implementing the representation for sets of board positions,\nincluding the procedure <tt>adjoin-position</tt>, which adjoins a new row-column\nposition to a set of positions, and <tt>empty-board</tt>, which\nrepresents an empty set of positions.  You must also write the\nprocedure <tt>safe?</tt>, which determines for a set of positions,\nwhether the queen in the <em>k</em>th column is safe with respect to the\nothers.  (Note that we need only check whether the new queen is\nsafe -- the other queens are already guaranteed safe with respect to\neach other.)\n\n<p><p>\n\n<p><a name="%_thm_2.43"></a>\n<b>Exercise 2.43.</b>&nbsp;&nbsp;Louis Reasoner is having a terrible time doing exercise&nbsp;<a href="#%_thm_2.42">2.42</a>.  His\n<tt>queens</tt> procedure seems to work, but it runs extremely slowly.\n(Louis never does manage to wait long enough for it to solve even the\n6&times; 6 case.)  When Louis asks Eva Lu Ator for help, she points\nout that he has interchanged the order of the nested mappings in the\n<tt>flatmap</tt>, writing it as\n<p><p><tt>(flatmap<br>\n&nbsp;(lambda&nbsp;(new-row)<br>\n&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(rest-of-queens)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(adjoin-position&nbsp;new-row&nbsp;k&nbsp;rest-of-queens))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(queen-cols&nbsp;(-&nbsp;k&nbsp;1))))<br>\n&nbsp;(enumerate-interval&nbsp;1&nbsp;board-size))<br>\n</tt><p><p>\nExplain why this interchange makes the program run slowly.  Estimate\nhow long it will take Louis\'s program to solve the eight-queens\npuzzle, assuming that the program in exercise&nbsp;<a href="#%_thm_2.42">2.42</a> solves\nthe puzzle in time <em>T</em>.\n<p><p>\n\n<a name="%_sec_2.2.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.2.4">2.2.4&nbsp;&nbsp;Example: A Picture Language</a></h3><p>\n\n\n<a name="%_idx_1854"></a>\nThis section presents a simple language for drawing\npictures that illustrates the\npower of data abstraction and closure,\nand also exploits higher-order procedures in\nan essential way.  The language\nis designed to make it easy to experiment with patterns\nsuch as the ones in figure&nbsp;<a href="#%_fig_2.9">2.9</a>, which are\ncomposed of repeated elements that are shifted and scaled.<a name="call_footnote_Temp_202" href="#footnote_Temp_202"><sup><small>22</small></sup></a> In this language,\nthe data objects being combined\nare represented as procedures rather than as list structure.\nJust as <tt>cons</tt>, which satisfies the <a name="%_idx_1860"></a>closure property,\nallowed us to easily build arbitrarily complicated\nlist structure, the operations in this language, which also\nsatisfy the closure property, allow us to easily build\narbitrarily complicated patterns.<p>\n\n<a name="%_fig_2.9"></a><p><div align=left><table width=100%><tr><td><div align=left><img src="ch2-Z-G-24.gif" border="0">\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<img src="ch2-Z-G-25.gif" border="0">&nbsp;</div>\n\n</td></tr><caption align=bottom><div align=left><b>Figure 2.9:</b>&nbsp;&nbsp;Designs generated with the picture language.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_sec_Temp_203"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_203">The picture language</a></h4><p>\n\nWhen we began our study of programming in\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1">1.1</a>, we emphasized the\nimportance of describing a language by focusing on the language\'s\nprimitives, its means of combination, and its means of abstraction.\nWe\'ll follow that framework here.<p>\n\nPart of the elegance of this picture language is that there is\nonly one kind of element, called a <a name="%_idx_1862"></a><em>painter</em>.  A painter\ndraws an image that is shifted and scaled to fit within a designated\n<a name="%_idx_1864"></a>parallelogram-shaped frame.  For example, there\'s a primitive painter\nwe\'ll call <tt>wave</tt> that makes a crude line drawing, as\nshown in figure&nbsp;<a href="#%_fig_2.10">2.10</a>.\nThe actual shape of the drawing depends on the frame -- all\nfour images in figure&nbsp;<a href="#%_fig_2.10">2.10</a> are produced by the same <tt>wave</tt> painter, but with respect to four different frames.  Painters\ncan be more elaborate than this:\nThe primitive\npainter called <tt>rogers</tt> paints a picture of MIT\'s founder,\nWilliam Barton Rogers, as shown in figure&nbsp;<a href="#%_fig_2.11">2.11</a>.<a name="call_footnote_Temp_204" href="#footnote_Temp_204"><sup><small>23</small></sup></a>\nThe four images in figure&nbsp;<a href="#%_fig_2.11">2.11</a>\nare drawn with respect to the same four frames\nas the <tt>wave</tt> images in figure&nbsp;<a href="#%_fig_2.10">2.10</a>.<p>\n\n\n<a name="%_idx_1876"></a>To combine images,\nwe use various operations that construct new painters\nfrom given painters.\nFor example, the <a name="%_idx_1878"></a><tt>beside</tt> operation takes two painters and produces a new,\ncompound painter that draws the first painter\'s image in the left half\nof the frame and the second painter\'s image in the right half of the frame.\nSimilarly, <a name="%_idx_1880"></a><tt>below</tt> takes two painters and produces a compound\npainter that draws the first painter\'s image below the second\npainter\'s image.\nSome operations transform a single painter to produce\na new painter.  For example, <a name="%_idx_1882"></a><tt>flip-vert</tt> takes a painter and\nproduces a painter that draws its image upside-down, and\n<a name="%_idx_1884"></a><tt>flip-horiz</tt> produces a painter that draws the original\npainter\'s image left-to-right reversed.<p>\n\n<a name="%_fig_2.10"></a><p><div align=left><table width=100%><tr><td><div align=left><img src="ch2-Z-G-26.gif" border="0">\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<img src="ch2-Z-G-27.gif" border="0">&nbsp;</div>\n\n<div align=left><img src="ch2-Z-G-28.gif" border="0">\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<img src="ch2-Z-G-29.gif" border="0">&nbsp;</div>\n\n</td></tr><caption align=bottom><div align=left><b>Figure 2.10:</b>&nbsp;&nbsp;Images produced by the <tt>wave</tt> painter, with respect\nto four different frames.  The frames, shown with dotted lines, are not\npart of the images.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_fig_2.11"></a><p><div align=left><table width=100%><tr><td><div align=left><img src="ch2-Z-G-30.gif" border="0">\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<img src="ch2-Z-G-31.gif" border="0">&nbsp;</div>\n\n<div align=left><img src="ch2-Z-G-32.gif" border="0">\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<img src="ch2-Z-G-33.gif" border="0">&nbsp;</div>\n\n</td></tr><caption align=bottom><div align=left><b>Figure 2.11:</b>&nbsp;&nbsp;Images of William Barton Rogers, founder and first\npresident of MIT, painted with respect to the same four frames as in\nfigure&nbsp;<a href="#%_fig_2.10">2.10</a> (original image reprinted with the permission\nof the MIT Museum).</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n\nFigure&nbsp;<a href="#%_fig_2.12">2.12</a> shows the drawing of a painter called\n<tt>wave4</tt> that is built up in two stages starting from <tt>wave</tt>:\n<p><p><tt>(define&nbsp;wave2&nbsp;(beside&nbsp;wave&nbsp;(flip-vert&nbsp;wave)))<br>\n(define&nbsp;wave4&nbsp;(below&nbsp;wave2&nbsp;wave2))<br>\n</tt><p><p><p>\n\n<a name="%_fig_2.12"></a><p><div align=left><table width=100%><tr><td><div align=left><img src="ch2-Z-G-34.gif" border="0">\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<img src="ch2-Z-G-35.gif" border="0">&nbsp;</div>\n\n<p><p><tt>(define&nbsp;wave2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;wave4<br>\n&nbsp;&nbsp;(beside&nbsp;wave&nbsp;(flip-vert&nbsp;wave)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(below&nbsp;wave2&nbsp;wave2))<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 2.12:</b>&nbsp;&nbsp;Creating a complex figure,\nstarting from the <tt>wave</tt> painter of figure&nbsp;<a href="#%_fig_2.10">2.10</a>.</div></caption><tr><td>\n\n</td></tr></table></div><p> <p>\n\n<a name="%_idx_1886"></a>In building up a complex image in this manner we are exploiting the\nfact that painters are closed under the language\'s means of\ncombination.  The <tt>beside</tt> or <tt>below</tt> of two painters is\nitself a painter; therefore, we can use it as an element in making\nmore complex painters.  As with building up list structure using <tt>cons</tt>, the closure of our data under the means of combination is\ncrucial to the ability to create complex structures while using only a\nfew operations.<p>\n\n\nOnce we can combine painters, we would like to be able to abstract\ntypical patterns of combining painters.\nWe will implement the painter operations as Scheme procedures.\nThis means that we don\'t need a special abstraction mechanism\nin the picture language:\nSince the means of combination\nare ordinary Scheme procedures, we automatically have the capability\nto do anything with painter operations that we can do with\nprocedures.\nFor example, we can abstract the pattern in <tt>wave4</tt> as<p>\n\n\n<p><p><tt><a name="%_idx_1888"></a>(define&nbsp;(flipped-pairs&nbsp;painter)<br>\n&nbsp;&nbsp;(let&nbsp;((painter2&nbsp;(beside&nbsp;painter&nbsp;(flip-vert&nbsp;painter))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(below&nbsp;painter2&nbsp;painter2)))<br>\n</tt><p><p>\nand define <tt>wave4</tt> as an instance of this pattern:<p>\n\n\n<p><p><tt>(define&nbsp;wave4&nbsp;(flipped-pairs&nbsp;wave))<br>\n</tt><p><p><p>\n\nWe can also define recursive operations.\nHere\'s one that makes painters split and branch\ntowards the right as shown in figures&nbsp;<a href="#%_fig_2.13">2.13</a>\nand &nbsp;<a href="#%_fig_2.14">2.14</a>:\n<p><p><tt><a name="%_idx_1890"></a>(define&nbsp;(right-split&nbsp;painter&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;painter<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((smaller&nbsp;(right-split&nbsp;painter&nbsp;(-&nbsp;n&nbsp;1))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(beside&nbsp;painter&nbsp;(below&nbsp;smaller&nbsp;smaller)))))<br>\n</tt><p><p><p>\n\n<a name="%_fig_2.13"></a><p><div align=left><table width=100%><tr><td><div align=left><img src="ch2-Z-G-36.gif" border="0">\n          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<img src="ch2-Z-G-37.gif" border="0">&nbsp;</div>\n\n<p><p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right-split&nbsp;<em>n</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;corner-split&nbsp;<em>n</em><br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 2.13:</b>&nbsp;&nbsp;Recursive plans for <tt>right-split</tt> and <tt>corner-split</tt>.</div></caption><tr><td>\n\n</td></tr></table></div><p> <p>\n\nWe can produce balanced patterns by branching upwards\nas well as towards the right (see exercise&nbsp;<a href="#%_thm_2.44">2.44</a>\nand figures&nbsp;<a href="#%_fig_2.13">2.13</a> and &nbsp;<a href="#%_fig_2.14">2.14</a>):<p>\n\n<p><p><tt><a name="%_idx_1892"></a>(define&nbsp;(corner-split&nbsp;painter&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;painter<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((up&nbsp;(up-split&nbsp;painter&nbsp;(-&nbsp;n&nbsp;1)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(right&nbsp;(right-split&nbsp;painter&nbsp;(-&nbsp;n&nbsp;1))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((top-left&nbsp;(beside&nbsp;up&nbsp;up))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bottom-right&nbsp;(below&nbsp;right&nbsp;right))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(corner&nbsp;(corner-split&nbsp;painter&nbsp;(-&nbsp;n&nbsp;1))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(beside&nbsp;(below&nbsp;painter&nbsp;top-left)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(below&nbsp;bottom-right&nbsp;corner))))))<br>\n</tt><p><p><p>\n\n<a name="%_fig_2.14"></a><p><div align=left><table width=100%><tr><td><div align=left><img src="ch2-Z-G-38.gif" border="0">\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<img src="ch2-Z-G-39.gif" border="0">&nbsp;</div>\n\n<p><p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(right-split&nbsp;wave&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(right-split&nbsp;rogers&nbsp;4)<br>\n</tt><p><p>\n<p><p><div align=left><img src="ch2-Z-G-40.gif" border="0">\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n<img src="ch2-Z-G-41.gif" border="0">&nbsp;</div>\n\n<p><p><tt>&nbsp;&nbsp;&nbsp;&nbsp;(corner-split&nbsp;wave&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(corner-split&nbsp;rogers&nbsp;4)<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 2.14:</b>&nbsp;&nbsp;The recursive operations <tt>right-split</tt> and <tt>corner-split</tt> applied to the painters <tt>wave</tt> and <tt>rogers</tt>.\nCombining four <tt>corner-split</tt> figures produces\nsymmetric <tt>square-limit</tt> designs as shown\nin figure&nbsp;<a href="#%_fig_2.9">2.9</a>.</div></caption><tr><td>\n\n</td></tr></table></div><p> <p>\n\nBy placing four copies of a <tt>corner-split</tt>\nappropriately, we obtain a pattern called <tt>square-limit</tt>, whose\napplication to <tt>wave</tt> and <tt>rogers</tt> is shown in\nfigure&nbsp;<a href="#%_fig_2.9">2.9</a>:\n<p><p><tt><a name="%_idx_1894"></a>(define&nbsp;(square-limit&nbsp;painter&nbsp;n)<br>\n&nbsp;&nbsp;(let&nbsp;((quarter&nbsp;(corner-split&nbsp;painter&nbsp;n)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((half&nbsp;(beside&nbsp;(flip-horiz&nbsp;quarter)&nbsp;quarter)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(below&nbsp;(flip-vert&nbsp;half)&nbsp;half))))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_2.44"></a>\n<b>Exercise 2.44.</b>&nbsp;&nbsp;Define the procedure <a name="%_idx_1896"></a><tt>up-split</tt> used by <tt>corner-split</tt>.\nIt is similar to <tt>right-split</tt>, except that it switches the\nroles of <tt>below</tt> and <tt>beside</tt>.\n\n<p><p>\n\n\n<a name="%_sec_Temp_206"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_206">Higher-order operations</a></h4><p>\n\n<a name="%_idx_1898"></a>\nIn addition to abstracting patterns of combining painters, we can work\nat a higher level, abstracting patterns of combining painter operations.\nThat is, we can view the painter operations as elements to manipulate\nand can write means of combination for these elements -- procedures that\ntake painter operations as arguments and create new painter operations.<p>\n\nFor example, <tt>flipped-pairs</tt> and <tt>square-limit</tt> each\narrange four copies of a painter\'s image in a square pattern; they differ\nonly in how they orient the copies.\nOne way to abstract this pattern of painter combination is with\nthe following procedure, which takes four one-argument painter operations\nand produces a painter operation that transforms a given\npainter with those four operations and arranges the results in a square.\n<tt>Tl</tt>, <tt>tr</tt>, <tt>bl</tt>, and <tt>br</tt> are the\ntransformations to apply to the top left copy, the top right copy,\nthe bottom left copy, and the bottom right copy, respectively.<p>\n\n<p><p><tt><a name="%_idx_1900"></a>(define&nbsp;(square-of-four&nbsp;tl&nbsp;tr&nbsp;bl&nbsp;br)<br>\n&nbsp;&nbsp;(lambda&nbsp;(painter)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((top&nbsp;(beside&nbsp;(tl&nbsp;painter)&nbsp;(tr&nbsp;painter)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bottom&nbsp;(beside&nbsp;(bl&nbsp;painter)&nbsp;(br&nbsp;painter))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(below&nbsp;bottom&nbsp;top))))<br>\n</tt><p><p>\nThen <tt>flipped-pairs</tt> can be defined in terms\nof <tt>square-of-four</tt> as follows:<a name="call_footnote_Temp_207" href="#footnote_Temp_207"><sup><small>24</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_1904"></a>(define&nbsp;(flipped-pairs&nbsp;painter)<br>\n&nbsp;&nbsp;(let&nbsp;((combine4&nbsp;(square-of-four&nbsp;identity&nbsp;flip-vert<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;identity&nbsp;flip-vert)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(combine4&nbsp;painter)))<br>\n</tt><p><p>\nand <tt>square-limit</tt> can be expressed as<a name="call_footnote_Temp_208" href="#footnote_Temp_208"><sup><small>25</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_1906"></a>(define&nbsp;(square-limit&nbsp;painter&nbsp;n)<br>\n&nbsp;&nbsp;(let&nbsp;((combine4&nbsp;(square-of-four&nbsp;flip-horiz&nbsp;identity<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotate180&nbsp;flip-vert)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(combine4&nbsp;(corner-split&nbsp;painter&nbsp;n))))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_2.45"></a>\n<b>Exercise 2.45.</b>&nbsp;&nbsp;<tt>Right-split</tt> and <tt>up-split</tt> can be expressed as\ninstances of a general splitting operation.\nDefine a procedure <a name="%_idx_1908"></a><tt>split</tt> with the property that evaluating\n<p><p><tt>(define&nbsp;right-split&nbsp;(split&nbsp;beside&nbsp;below))<br>\n(define&nbsp;up-split&nbsp;(split&nbsp;below&nbsp;beside))<br>\n</tt><p><p>\nproduces procedures <tt>right-split</tt> and <tt>up-split</tt> with the same\nbehaviors as the ones already defined.\n\n<p><p>\n\n<a name="%_sec_Temp_210"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_210">Frames</a></h4><p>\n\n<a name="%_idx_1910"></a>\nBefore we can show how to implement painters and their\nmeans of combination, we must first consider\n<a name="%_idx_1912"></a>frames.  A frame can be described by three vectors -- an origin vector\nand two edge vectors.  The origin vector specifies the offset of the\nframe\'s origin from some absolute origin in the plane, and the edge\nvectors specify the offsets of the frame\'s corners from its origin.\nIf the edges are perpendicular, the frame will be rectangular.\nOtherwise the frame will be a more general parallelogram.<p>\n\nFigure&nbsp;<a href="#%_fig_2.15">2.15</a> shows a frame and its associated vectors.  In\naccordance with data abstraction, we need not be\nspecific yet about how frames are represented, other than to say that\nthere is a constructor <a name="%_idx_1914"></a><tt>make-frame</tt>, which takes three vectors and\nproduces a frame, and three corresponding selectors <a name="%_idx_1916"></a><tt>origin-frame</tt>, <a name="%_idx_1918"></a><tt>edge1-frame</tt>, and <a name="%_idx_1920"></a><tt>edge2-frame</tt> (see\nexercise&nbsp;<a href="#%_thm_2.47">2.47</a>).<p>\n\n<a name="%_fig_2.15"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-42.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.15:</b>&nbsp;&nbsp;A frame is described by three vectors -- an\norigin and two edges.</div></caption><tr><td>\n\n</td></tr></table></div><p> <p>\n\n<a name="%_idx_1922"></a>We will use coordinates in the unit square (0<u>&lt;</u> <em>x</em>,<em>y</em><u>&lt;</u> 1)\nto specify images.\nWith each frame, we associate a <a name="%_idx_1924"></a><em>frame coordinate map</em>, which\nwill be used to shift and scale images to fit the frame.  The map\ntransforms the unit square into the frame by\nmapping the vector <strong><em>v</em></strong> = (<em>x</em>,<em>y</em>) to the vector sum\n<p><div align=left><img src="ch2-Z-G-43.gif" border="0"></div><p>\nFor example, (0,0) is mapped to the origin of the frame, (1,1) to\nthe vertex diagonally opposite the origin, and (0.5,0.5) to the\ncenter of the frame.  We can create a frame\'s coordinate map with the\nfollowing procedure:<a name="call_footnote_Temp_211" href="#footnote_Temp_211"><sup><small>26</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_1926"></a>(define&nbsp;(frame-coord-map&nbsp;frame)<br>\n&nbsp;&nbsp;(lambda&nbsp;(v)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(add-vect<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(origin-frame&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-vect&nbsp;(scale-vect&nbsp;(xcor-vect&nbsp;v)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(edge1-frame&nbsp;frame))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(scale-vect&nbsp;(ycor-vect&nbsp;v)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(edge2-frame&nbsp;frame))))))<br>\n</tt><p><p>\nObserve that applying <tt>frame-coord-map</tt> to a frame returns\na procedure that, given a vector, returns a vector.\nIf the argument vector is in the unit square, the result vector\nwill be in the frame.  For example,\n<p><p><tt>((frame-coord-map&nbsp;a-frame)&nbsp;(make-vect&nbsp;0&nbsp;0))<br>\n</tt><p><p>\nreturns the same vector as\n<p><p><tt>(origin-frame&nbsp;a-frame)<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_2.46"></a>\n<b>Exercise 2.46.</b>&nbsp;&nbsp;<a name="%_idx_1928"></a><a name="%_idx_1930"></a>A two-dimensional vector <strong>v</strong> running from the origin to a point\ncan be represented as a pair\nconsisting of an <em>x</em>-coordinate and a <em>y</em>-coordinate.  Implement a data\nabstraction for vectors by giving a constructor <a name="%_idx_1932"></a><tt>make-vect</tt> and\ncorresponding selectors <a name="%_idx_1934"></a><tt>xcor-vect</tt> and <a name="%_idx_1936"></a><tt>ycor-vect</tt>.  In\nterms of your selectors and constructor, implement procedures <a name="%_idx_1938"></a><tt>add-vect</tt>, <a name="%_idx_1940"></a><tt>sub-vect</tt>, and <a name="%_idx_1942"></a><tt>scale-vect</tt> that perform\nthe operations vector addition, vector subtraction, and multiplying a\nvector by a scalar:\n<p><div align=left><img src="ch2-Z-G-44.gif" border="0"></div><p>\n<p><p>\n\n<p><a name="%_thm_2.47"></a>\n<b>Exercise 2.47.</b>&nbsp;&nbsp;Here are two possible constructors for frames:\n<p><p><tt><a name="%_idx_1944"></a>(define&nbsp;(make-frame&nbsp;origin&nbsp;edge1&nbsp;edge2)<br>\n&nbsp;&nbsp;(list&nbsp;origin&nbsp;edge1&nbsp;edge2))<br>\n<br>\n(define&nbsp;(make-frame&nbsp;origin&nbsp;edge1&nbsp;edge2)<br>\n&nbsp;&nbsp;(cons&nbsp;origin&nbsp;(cons&nbsp;edge1&nbsp;edge2)))<br>\n</tt><p><p>\nFor each constructor supply the appropriate selectors to produce an\nimplementation for frames.\n\n<p><p>\n\n<a name="%_sec_Temp_214"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_214">Painters</a></h4><p>\n\n<a name="%_idx_1946"></a>\nA painter is represented as a procedure that, given a frame\nas argument, draws a particular image shifted and scaled to fit the frame.\nThat is to say, if <tt>p</tt> is a painter and <tt>f</tt> is a frame, then we\nproduce <tt>p</tt>\'s image in <tt>f</tt> by calling <tt>p</tt> with <tt>f</tt> as\nargument.<p>\n\nThe details of how primitive painters are implemented depend on the\nparticular characteristics of the graphics system and the type of\nimage to be drawn.  For instance, suppose we have a procedure <a name="%_idx_1948"></a><tt>draw-line</tt> that draws a line on the screen between two specified\npoints.  Then we can create painters for line drawings, such as the\n<tt>wave</tt> painter in figure&nbsp;<a href="#%_fig_2.10">2.10</a>, from lists of line\nsegments as follows:<a name="call_footnote_Temp_215" href="#footnote_Temp_215"><sup><small>27</small></sup></a><p><p><tt><a name="%_idx_1950"></a>(define&nbsp;(segments-&gt;painter&nbsp;segment-list)<br>\n&nbsp;&nbsp;(lambda&nbsp;(frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(for-each<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(segment)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(draw-line<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((frame-coord-map&nbsp;frame)&nbsp;(start-segment&nbsp;segment))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((frame-coord-map&nbsp;frame)&nbsp;(end-segment&nbsp;segment))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segment-list)))<br>\n</tt><p><p>\nThe segments are given using coordinates with respect to the unit\nsquare.  For each segment in the list, the painter transforms the\nsegment endpoints with the frame coordinate map and draws a line\nbetween the transformed points.<p>\n\nRepresenting painters as procedures erects a powerful abstraction\nbarrier in the picture language.  We can create and intermix\nall sorts of primitive painters, based on a variety of graphics\ncapabilities. The details of their implementation do not matter.  Any\nprocedure can serve as a painter, provided that it takes a frame as\nargument and draws something scaled to fit the frame.<a name="call_footnote_Temp_216" href="#footnote_Temp_216"><sup><small>28</small></sup></a>\n\n<p><a name="%_thm_2.48"></a>\n<b>Exercise 2.48.</b>&nbsp;&nbsp;<a name="%_idx_1952"></a>A directed line segment in the\nplane can be represented as a pair of vectors -- the\nvector running from the origin to the start-point of the segment, and\nthe vector running from the origin to the end-point of the segment.\nUse your vector representation from exercise&nbsp;<a href="#%_thm_2.46">2.46</a> to\ndefine a representation for segments with a constructor <a name="%_idx_1954"></a><tt>make-segment</tt> and selectors <a name="%_idx_1956"></a><tt>start-segment</tt> and <a name="%_idx_1958"></a><tt>end-segment</tt>.\n\n<p><p>\n\n<p><a name="%_thm_2.49"></a>\n<b>Exercise 2.49.</b>&nbsp;&nbsp;Use <tt>segments-&gt;painter</tt> to define the following primitive painters:<p>\n\na.&nbsp;&nbsp;The painter that draws the outline of the designated frame.<p>\n\nb.&nbsp;&nbsp;The painter that draws an ``X\'\' by connecting opposite corners of\nthe frame.<p>\n\nc.&nbsp;&nbsp;The painter that draws a diamond shape by connecting the midpoints of\nthe sides of the frame.<p>\n\nd.&nbsp;&nbsp;The <tt>wave</tt> painter.\n\n<p><p>\n\n<a name="%_sec_Temp_219"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_219">Transforming and combining painters</a></h4><p>\n\n<a name="%_idx_1960"></a>\nAn operation on painters (such as <tt>flip-vert</tt> or <tt>beside</tt>)\nworks by creating a painter that invokes the original painters\nwith respect to frames derived from the argument frame.\nThus, for example, <tt>flip-vert</tt> doesn\'t have to know how a painter\nworks in order to flip it -- it just has to know how to turn a frame\nupside down:\nThe flipped painter just uses the original painter,\nbut in the inverted frame.<p>\n\nPainter operations are based on\nthe procedure <tt>transform-painter</tt>, which takes as arguments a painter and\ninformation on how to transform a frame and\nproduces a new painter.  The transformed painter, when called on a frame,\ntransforms the frame and\ncalls the original painter on the transformed frame.\nThe arguments to <tt>transform-painter</tt> are points (represented as vectors)\nthat specify the corners of the new frame:\nWhen mapped into\nthe frame, the first point specifies the new frame\'s origin\nand the other two specify the ends of its edge vectors.\nThus, arguments within the\nunit square specify a frame contained within the original frame.<p>\n\n<p><p><tt><a name="%_idx_1962"></a>(define&nbsp;(transform-painter&nbsp;painter&nbsp;origin&nbsp;corner1&nbsp;corner2)<br>\n&nbsp;&nbsp;(lambda&nbsp;(frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((m&nbsp;(frame-coord-map&nbsp;frame)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((new-origin&nbsp;(m&nbsp;origin)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(painter<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-frame&nbsp;new-origin<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sub-vect&nbsp;(m&nbsp;corner1)&nbsp;new-origin)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sub-vect&nbsp;(m&nbsp;corner2)&nbsp;new-origin)))))))<br>\n</tt><p><p><p>\n\nHere\'s how to flip painter images vertically:\n<p><p><tt><a name="%_idx_1964"></a>(define&nbsp;(flip-vert&nbsp;painter)<br>\n&nbsp;&nbsp;(transform-painter&nbsp;painter<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;0.0&nbsp;1.0)&nbsp;&nbsp;&nbsp;<em>;&nbsp;new&nbsp;<tt>origin</tt></em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;1.0&nbsp;1.0)&nbsp;&nbsp;&nbsp;<em>;&nbsp;new&nbsp;end&nbsp;of&nbsp;<tt>edge1</tt></em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;0.0&nbsp;0.0)))&nbsp;<em>;&nbsp;new&nbsp;end&nbsp;of&nbsp;<tt>edge2</tt></em><br>\n</tt><p><p>\nUsing <tt>transform-painter</tt>, we can easily define new transformations.\nFor example, we can define a painter that shrinks its image to the\nupper-right quarter of the frame it is given:\n<p><p><tt><a name="%_idx_1966"></a>(define&nbsp;(shrink-to-upper-right&nbsp;painter)<br>\n&nbsp;&nbsp;(transform-painter&nbsp;painter<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;0.5&nbsp;0.5)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;1.0&nbsp;0.5)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;0.5&nbsp;1.0)))<br>\n</tt><p><p>\nOther transformations rotate images counterclockwise by 90 degrees<a name="call_footnote_Temp_220" href="#footnote_Temp_220"><sup><small>29</small></sup></a>\n<p><p><tt><a name="%_idx_1968"></a>(define&nbsp;(rotate90&nbsp;painter)<br>\n&nbsp;&nbsp;(transform-painter&nbsp;painter<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;1.0&nbsp;0.0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;1.0&nbsp;1.0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;0.0&nbsp;0.0)))<br>\n</tt><p><p>\nor squash images towards the center of the frame:<a name="call_footnote_Temp_221" href="#footnote_Temp_221"><sup><small>30</small></sup></a>\n<p><p><tt><a name="%_idx_1970"></a>(define&nbsp;(squash-inwards&nbsp;painter)<br>\n&nbsp;&nbsp;(transform-painter&nbsp;painter<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;0.0&nbsp;0.0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;0.65&nbsp;0.35)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;0.35&nbsp;0.65)))<br>\n</tt><p><p><p>\n\nFrame transformation is also the key to\ndefining means of combining two or more painters.\nThe <tt>beside</tt> procedure,\nfor example, takes two painters, transforms them\nto paint in the left and right halves of an argument frame respectively,\nand produces a new, compound painter.\nWhen the compound painter is given a frame, it\ncalls the first transformed painter to paint in the left half of\nthe frame and calls the second transformed painter to paint in the\nright half of the frame:\n<p><p><tt><a name="%_idx_1972"></a>(define&nbsp;(beside&nbsp;painter1&nbsp;painter2)<br>\n&nbsp;&nbsp;(let&nbsp;((split-point&nbsp;(make-vect&nbsp;0.5&nbsp;0.0)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((paint-left<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(transform-painter&nbsp;painter1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;0.0&nbsp;0.0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split-point<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;0.0&nbsp;1.0)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(paint-right<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(transform-painter&nbsp;painter2<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split-point<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;1.0&nbsp;0.0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vect&nbsp;0.5&nbsp;1.0))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(paint-left&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(paint-right&nbsp;frame)))))<br>\n</tt><p><p><p>\n\nObserve how the painter data abstraction, and in particular the\nrepresentation of painters as procedures, makes <tt>beside</tt> easy to\nimplement.  The <tt>beside</tt> procedure need not know anything\nabout the details of the component painters other than that each\npainter will draw something in its designated frame.<p>\n\n<p><a name="%_thm_2.50"></a>\n<b>Exercise 2.50.</b>&nbsp;&nbsp;Define the transformation <a name="%_idx_1974"></a><tt>flip-horiz</tt>, which flips\npainters horizontally, and transformations that rotate\npainters counterclockwise by 180 degrees and 270 degrees.\n\n<p><p>\n\n<p><a name="%_thm_2.51"></a>\n<b>Exercise 2.51.</b>&nbsp;&nbsp;Define the <a name="%_idx_1976"></a><tt>below</tt> operation for painters.  <tt>Below</tt> takes two\npainters as arguments.  The resulting painter, given a frame,\ndraws with the first painter in the\nbottom of the frame and with the second painter in the top.  Define <tt>below</tt> in two different ways -- first by writing a procedure that is\nanalogous to the <tt>beside</tt> procedure given above, and\nagain in terms of <tt>beside</tt> and suitable\nrotation operations (from exercise&nbsp;<a href="#%_thm_2.50">2.50</a>).\n\n<p><p>\n\n<a name="%_sec_Temp_224"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_224">Levels of language for robust design</a></h4><p>\n\nThe picture language exercises some of the critical ideas\nwe\'ve introduced about abstraction with procedures and data.  The\nfundamental data abstractions, painters, are implemented using\nprocedural representations, which enables the language to\nhandle different basic drawing capabilities in a uniform way.  The\nmeans of combination satisfy the closure property, which permits us to\neasily build up complex designs.  Finally, all the tools for\nabstracting procedures are available to us for abstracting means of\ncombination for painters.<p>\n\n\nWe have also obtained a glimpse of another crucial idea about\nlanguages and program design.  This is the approach of <a name="%_idx_1978"></a><a name="%_idx_1980"></a><em>stratified\ndesign</em>, the notion that a complex system should be structured as a\nsequence of levels that are described using a sequence of languages.\nEach level is constructed by combining parts that are regarded as\nprimitive at that level, and the parts constructed at each level are\nused as primitives at the next level.  The language used at each level\nof a stratified design has primitives, means of combination, and means\nof abstraction appropriate to that level of detail.<p>\n\nStratified design pervades the engineering of complex systems.  For\nexample, in computer engineering, resistors and transistors are\ncombined (and described using a language of analog circuits) to\nproduce parts such as and-gates and or-gates, which form the\nprimitives of a language for digital-circuit design.<a name="call_footnote_Temp_225" href="#footnote_Temp_225"><sup><small>31</small></sup></a>\nThese parts are combined to build\nprocessors, bus structures, and memory systems, which are in turn\ncombined to form computers, using languages appropriate to computer\narchitecture.  Computers are combined to form distributed systems,\nusing languages appropriate for describing network interconnections,\nand so on.<p>\n\nAs a tiny example of stratification, our picture language uses\nprimitive elements (primitive painters) that are created using a\nlanguage that specifies points and lines to provide the lists of line\nsegments for <tt>segments-&gt;painter</tt>, or the\nshading details for a painter like <tt>rogers</tt>.  The bulk of our\ndescription of the picture language focused on combining these\nprimitives, using geometric combiners such as <tt>beside</tt> and <tt>below</tt>.  We also worked at a higher level, regarding <tt>beside</tt> and\n<tt>below</tt> as primitives to be manipulated in a language whose\noperations, such as <tt>square-of-four</tt>, capture common patterns of\ncombining geometric combiners.<p>\n\n<a name="%_idx_1982"></a>Stratified design helps make programs <em>robust</em>, that is, it makes\nit likely that small changes in a specification will require\ncorrespondingly small changes in the program.  For instance, suppose\nwe wanted to change the image based on <tt>wave</tt> shown in\nfigure&nbsp;<a href="#%_fig_2.9">2.9</a>.  We could work at the lowest level\nto change the detailed appearance of the <tt>wave</tt> element; we could\nwork at the middle level to change the way <tt>corner-split</tt>\nreplicates the <tt>wave</tt>; we could work at the highest level to\nchange how <tt>square-limit</tt> arranges the four copies of the corner.\nIn general, each level of a stratified design provides a different\nvocabulary for expressing the characteristics of the system, and a\ndifferent kind of ability to change it.<p>\n\n<p><a name="%_thm_2.52"></a>\n<b>Exercise 2.52.</b>&nbsp;&nbsp;Make changes to the square limit of <tt>wave</tt> shown in\nfigure&nbsp;<a href="#%_fig_2.9">2.9</a> by working at each of the levels\ndescribed above.  In particular:<p>\n\na.&nbsp;&nbsp;Add some segments to the primitive <tt>wave</tt> painter\nof exercise &nbsp;<a href="#%_thm_2.49">2.49</a> (to add a smile, for example).<p>\n\nb.&nbsp;&nbsp;Change the pattern constructed by <tt>corner-split</tt>\n(for example, by using only one copy of the\n<tt>up-split</tt> and <tt>right-split</tt> images instead of two).<p>\n\nc.&nbsp;&nbsp;Modify the version of <tt>square-limit</tt> that uses <tt>square-of-four</tt>\nso as to assemble the corners in a different pattern.  (For example, you\nmight make the big Mr. Rogers look outward from each corner of the square.)\n<p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_154" href="#call_footnote_Temp_154"><sup><small>6</small></sup></a> The use of the word <a name="%_idx_1536"></a>``closure\'\' here comes from abstract algebra,\nwhere a set of elements is said to be closed under an operation if\napplying the operation to elements in the set produces an element that\nis again an element of the set.  The Lisp community\nalso (unfortunately) uses the word ``closure\'\' to describe a totally unrelated\nconcept: A closure is an implementation technique for representing\nprocedures with free variables.  We do not use the word ``closure\'\' in\nthis second sense in this book.\n\n<p><a name="footnote_Temp_155" href="#call_footnote_Temp_155"><sup><small>7</small></sup></a> The notion that a means of\n<a name="%_idx_1542"></a>combination should satisfy closure is a straightforward idea.\nUnfortunately, the data combiners provided in many popular programming\nlanguages do not satisfy closure, or make closure cumbersome to\nexploit.  In <a name="%_idx_1544"></a>Fortran or <a name="%_idx_1546"></a>Basic, one typically combines data elements by\nassembling them into arrays -- but one cannot form arrays whose\nelements are themselves arrays.  <a name="%_idx_1548"></a>Pascal and <a name="%_idx_1550"></a>C admit structures whose\nelements are structures.  However, this requires that the programmer\nmanipulate pointers explicitly, and adhere to the restriction that\neach field of a structure can contain only elements of a prespecified form.\nUnlike\nLisp with its pairs, these languages have no built-in general-purpose\nglue that makes it easy to manipulate compound data in a uniform way.\nThis limitation lies behind Alan <a name="%_idx_1552"></a>Perlis\'s comment in his foreword to\nthis book: ``In Pascal the plethora of declarable data structures\ninduces a specialization within functions that inhibits and penalizes\ncasual cooperation.  It is better to have 100 functions operate on one\ndata structure than to have 10 functions operate on 10 data\nstructures.\'\'\n\n<p><a name="footnote_Temp_156" href="#call_footnote_Temp_156"><sup><small>8</small></sup></a> In this book, we use <em>list</em> to mean a chain of\npairs terminated by the end-of-list marker.  In contrast, the term\n<a name="%_idx_1572"></a><a name="%_idx_1574"></a><em>list structure</em> refers to any data structure made out of pairs,\nnot just to lists.\n\n<p><a name="footnote_Temp_157" href="#call_footnote_Temp_157"><sup><small>9</small></sup></a> Since nested applications of <tt>car</tt> and <tt>cdr</tt>\nare cumbersome to write, Lisp dialects provide abbreviations for\nthem -- for instance,\n<a name="%_idx_1584"></a><a name="%_idx_1586"></a><p><div align=left><img src="ch2-Z-G-14.gif" border="0"></div><p>\nThe names of all such procedures start with <tt>c</tt> and end with <tt>r</tt>.  Each <tt>a</tt> between them stands for a <a name="%_idx_1588"></a><a name="%_idx_1590"></a><tt>car</tt> operation and\neach <tt>d</tt> for a <tt>cdr</tt> operation, to be applied in the same order\nin which they appear in the name.  The names <tt>car</tt> and <tt>cdr</tt>\npersist because simple combinations like <tt>cadr</tt> are\npronounceable.\n\n<p><a name="footnote_Temp_158" href="#call_footnote_Temp_158"><sup><small>10</small></sup></a> It\'s remarkable how much energy in the\nstandardization of Lisp dialects has been dissipated in arguments that\nare literally over nothing: Should <tt>nil</tt> be an ordinary name?\nShould the value of <tt>nil</tt> be a symbol?  Should it be a list?\nShould it be a pair?  <a name="%_idx_1598"></a>In Scheme, <tt>nil</tt> is an ordinary name,\nwhich we use in this section as a variable whose value is\nthe end-of-list marker (just as <tt>true</tt> is an ordinary variable\nthat has a true value).  Other dialects of\nLisp, including Common Lisp, treat <tt>nil</tt> as a special symbol.  The\n<a name="%_idx_1600"></a>authors of this book, who have endured too many language\nstandardization brawls, would like to avoid the entire issue.  Once we\nhave introduced quotation in section&nbsp;<a href="book-Z-H-16.html#%_sec_2.3">2.3</a>, we will\ndenote the empty list as <tt>\'()</tt> and dispense with the\nvariable <tt>nil</tt> entirely.\n\n<p><a name="footnote_Temp_164" href="#call_footnote_Temp_164"><sup><small>11</small></sup></a> To define <tt>f</tt> and <tt>g</tt> using\n<a name="%_idx_1656"></a><tt>lambda</tt> we would write\n<p><p><tt>(define&nbsp;f&nbsp;(lambda&nbsp;(x&nbsp;y&nbsp;.&nbsp;z)&nbsp;&lt;<em>body</em>&gt;))<br>\n(define&nbsp;g&nbsp;(lambda&nbsp;w&nbsp;&lt;<em>body</em>&gt;))<br>\n</tt><p><p>\n\n<p><a name="footnote_Temp_166" href="#call_footnote_Temp_166"><sup><small>12</small></sup></a> Scheme\nstandardly provides a <a name="%_idx_1664"></a><tt>map</tt> procedure that is more general\nthan the one described here.\nThis more general <tt>map</tt>\ntakes a procedure of <em>n</em> arguments, together with <em>n</em> lists, and\napplies the procedure to all the first elements of\nthe lists, all the second elements of the lists, and so on,\nreturning a list of the results.  For example:\n<p><p><tt>(map&nbsp;+&nbsp;(list&nbsp;1&nbsp;2&nbsp;3)&nbsp;(list&nbsp;40&nbsp;50&nbsp;60)&nbsp;(list&nbsp;700&nbsp;800&nbsp;900))<br>\n<i>(741&nbsp;852&nbsp;963)</i><br>\n<br>\n(map&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(+&nbsp;x&nbsp;(*&nbsp;2&nbsp;y)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;1&nbsp;2&nbsp;3)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;4&nbsp;5&nbsp;6))<br>\n<i>(9&nbsp;12&nbsp;15)</i><br>\n</tt><p><p>\n\n\n\n<p><a name="footnote_Temp_170" href="#call_footnote_Temp_170"><sup><small>13</small></sup></a> The order of the\nfirst two clauses in the <tt>cond</tt> matters, since the empty list\nsatisfies <tt>null?</tt> and also is not a pair.\n\n<p><a name="footnote_Temp_182" href="#call_footnote_Temp_182"><sup><small>14</small></sup></a> This is, in fact, precisely the <a name="%_idx_1746"></a><tt>fringe</tt> procedure from\nexercise&nbsp;<a href="#%_thm_2.28">2.28</a>.  Here we\'ve renamed it to emphasize that\nit is part of a family of general sequence-manipulation procedures.\n\n<p><a name="footnote_Temp_183" href="#call_footnote_Temp_183"><sup><small>15</small></sup></a> <a name="%_idx_1760"></a>Richard Waters (1979)\ndeveloped a program that automatically analyzes traditional <a name="%_idx_1762"></a>Fortran\nprograms, viewing them in terms of maps, filters, and accumulations.\nHe found that fully 90 percent of the code in the Fortran Scientific\nSubroutine Package fits neatly into this paradigm.  One of the reasons\nfor the success of Lisp as a programming language is that lists\nprovide a standard medium for expressing ordered collections so that\nthey can be manipulated using higher-order operations.  The\nprogramming language <a name="%_idx_1764"></a>APL owes much of its power and appeal to a\nsimilar choice. In APL all data are represented as arrays, and there is a\nuniversal and convenient set of generic operators for all sorts of\narray operations.\n\n<p><a name="footnote_Temp_186" href="#call_footnote_Temp_186"><sup><small>16</small></sup></a> According to <a name="%_idx_1776"></a>Knuth (1981), this rule was formulated by\n<a name="%_idx_1778"></a>W. G. Horner early in the nineteenth century, but the method was\nactually used by Newton over a hundred years earlier.  Horner\'s rule\nevaluates the polynomial using fewer additions and multiplications\nthan does the straightforward method of first computing <em>a</em><sub><em>n</em></sub> <em>x</em><sup><em>n</em></sup>,\nthen adding <em>a</em><sub><em>n</em>-1</sub><em>x</em><sup><em>n</em>-1</sup>, and so on.  In fact, it is possible to\nprove that any algorithm for evaluating arbitrary polynomials must use\nat least as many additions and multiplications as does Horner\'s rule,\nand thus Horner\'s rule is an <a name="%_idx_1780"></a><a name="%_idx_1782"></a>optimal algorithm for polynomial\nevaluation.  This was proved (for the number of additions) by\n<a name="%_idx_1784"></a>A. M. Ostrowski in a 1954 paper that essentially founded the modern\nstudy of optimal algorithms.  The analogous statement for\nmultiplications was proved by <a name="%_idx_1786"></a>V. Y. Pan in 1966.  The book by <a name="%_idx_1788"></a>Borodin\nand <a name="%_idx_1790"></a>Munro (1975) provides an overview of these and other results about\noptimal algorithms.\n\n<p><a name="footnote_Temp_190" href="#call_footnote_Temp_190"><sup><small>17</small></sup></a> This definition uses the\nextended version of <tt>map</tt> described in footnote&nbsp;<a href="#footnote_Temp_166">12</a>.\n\n<p><a name="footnote_Temp_194" href="#call_footnote_Temp_194"><sup><small>18</small></sup></a> This approach to nested mappings was shown\nto us by <a name="%_idx_1820"></a>David Turner, whose languages <a name="%_idx_1822"></a>KRC and <a name="%_idx_1824"></a>Miranda provide elegant\nformalisms for dealing with these constructs.  The examples in this\nsection (see also exercise&nbsp;<a href="#%_thm_2.42">2.42</a>) are adapted from Turner\n1981.  In section&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.3">3.5.3</a>, we\'ll see how this\napproach generalizes to infinite sequences.\n\n<p><a name="footnote_Temp_195" href="#call_footnote_Temp_195"><sup><small>19</small></sup></a> We\'re\nrepresenting a pair here as a list of two elements rather than as a\nLisp pair.  Thus, the ``pair\'\' (<em>i</em>,<em>j</em>) is represented as <tt>(list i\nj)</tt>, not <tt>(cons i j)</tt>.\n\n<p><a name="footnote_Temp_196" href="#call_footnote_Temp_196"><sup><small>20</small></sup></a> The set <em>S</em> - <em>x</em> is the set of all elements\nof <em>S</em>, excluding <em>x</em>.\n\n<p><a name="footnote_Temp_197" href="#call_footnote_Temp_197"><sup><small>21</small></sup></a> <a name="%_idx_1834"></a><a name="%_idx_1836"></a><a name="%_idx_1838"></a>Semicolons in Scheme code are used to\nintroduce <em>comments</em>.  Everything from the semicolon to the end of\nthe line is ignored by the interpreter.  In this book we don\'t use\nmany comments; we try to make our programs self-documenting by using\ndescriptive names.\n\n<p><a name="footnote_Temp_202" href="#call_footnote_Temp_202"><sup><small>22</small></sup></a> The picture language is based on the language\n<a name="%_idx_1856"></a>Peter Henderson created to construct\nimages like <a name="%_idx_1858"></a>M.C. Escher\'s ``Square Limit\'\' woodcut (see Henderson 1982).\nThe woodcut incorporates a\nrepeated scaled pattern, similar to the arrangements drawn using\nthe <tt>square-limit</tt> procedure in this section.\n\n<p><a name="footnote_Temp_204" href="#call_footnote_Temp_204"><sup><small>23</small></sup></a> <a name="%_idx_1866"></a><a name="%_idx_1868"></a>William Barton Rogers (1804-1882) was the founder and first president\nof MIT.  A geologist and talented teacher, he taught at William and\nMary College and at the University of Virginia.  In 1859 he moved to\nBoston, where he had more time for research, worked on a plan\nfor establishing a ``polytechnic institute,\'\' and served as\nMassachusetts\'s first State Inspector of Gas Meters.<p>\n\nWhen MIT was established in 1861, Rogers was elected its first\npresident.  Rogers espoused an ideal of ``useful learning\'\' that was\ndifferent from the university education of the time, with its\noveremphasis on the classics, which, as he wrote, ``stand in the way of\nthe broader, higher and more practical instruction and discipline of\nthe natural and social sciences.\'\'  This education was likewise to be\ndifferent from narrow trade-school education.  In Rogers\'s words:\n<blockquote>\n<p>The world-enforced distinction between the practical and the\nscientific worker is utterly futile, and the whole experience of\nmodern times has demonstrated its utter worthlessness.\n</blockquote><p>\n\nRogers served as president of MIT until 1870, when he resigned due to\nill health.  In 1878 the second president of MIT, <a name="%_idx_1870"></a>John Runkle,\nresigned under the pressure of a financial crisis brought on by the\nPanic of 1873 and strain of fighting off attempts by Harvard to take\nover MIT.  Rogers returned to hold the office of president until\n1881.<p>\n\nRogers collapsed and died while addressing MIT\'s graduating class at\nthe commencement exercises of 1882.  Runkle quoted Rogers\'s last\nwords in a memorial address delivered that same year:\n<blockquote>\n<p>``As I stand here today and see what the Institute is, <tt>...</tt> I call\nto mind the beginnings of science.  I remember one hundred and fifty\nyears ago Stephen Hales published a pamphlet on the subject of\nilluminating gas, in which he stated that his researches had\ndemonstrated that 128 grains of bituminous coal -- \'\'\n<a name="%_idx_1872"></a><p>``Bituminous coal,\'\' these were his last words on earth.  Here he bent\nforward, as if consulting some notes on the table before him, then\nslowly regaining an erect position, threw up his hands, and was\ntranslated from the scene of his earthly labors and triumphs to ``the\ntomorrow of death,\'\' where the mysteries of life are solved, and the\ndisembodied spirit finds unending satisfaction in contemplating the\nnew and still unfathomable mysteries of the infinite future.\n</blockquote>\nIn the words of  Francis A. Walker\n<a name="%_idx_1874"></a>(MIT\'s third president):\n<blockquote>\n<p>All his life he had borne himself most faithfully and heroically, and\nhe died as so good a knight would surely have wished, in harness, at\nhis post, and in the very part and act of public duty.\n</blockquote>\n\n<p><a name="footnote_Temp_207" href="#call_footnote_Temp_207"><sup><small>24</small></sup></a> Equivalently, we could\nwrite\n<p><p><tt><a name="%_idx_1902"></a>(define&nbsp;flipped-pairs<br>\n&nbsp;&nbsp;(square-of-four&nbsp;identity&nbsp;flip-vert&nbsp;identity&nbsp;flip-vert))<br>\n</tt><p><p>\n\n\n<p><a name="footnote_Temp_208" href="#call_footnote_Temp_208"><sup><small>25</small></sup></a> <tt>Rotate180</tt>\nrotates a painter by 180 degrees (see exercise&nbsp;<a href="#%_thm_2.50">2.50</a>).\nInstead of <tt>rotate180</tt> we could say <tt>(compose flip-vert flip-horiz)</tt>, using\nthe <tt>compose</tt> procedure from exercise&nbsp;<a href="book-Z-H-12.html#%_thm_1.42">1.42</a>.\n\n<p><a name="footnote_Temp_211" href="#call_footnote_Temp_211"><sup><small>26</small></sup></a> <tt>Frame-coord-map</tt> uses\nthe vector operations described in exercise&nbsp;<a href="#%_thm_2.46">2.46</a> below, which we\nassume have been implemented using some representation for vectors.\nBecause of data abstraction, it doesn\'t matter what this vector\nrepresentation is, so long as the vector operations behave correctly.\n\n<p><a name="footnote_Temp_215" href="#call_footnote_Temp_215"><sup><small>27</small></sup></a> <tt>Segments-&gt;painter</tt> uses the representation for line\nsegments described in exercise&nbsp;<a href="#%_thm_2.48">2.48</a> below.\nIt also uses the <tt>for-each</tt> procedure described in exercise&nbsp;<a href="#%_thm_2.23">2.23</a>.\n\n<p><a name="footnote_Temp_216" href="#call_footnote_Temp_216"><sup><small>28</small></sup></a> For example, the <tt>rogers</tt> painter of\nfigure&nbsp;<a href="#%_fig_2.11">2.11</a> was constructed from a gray-level image.\nFor each point in a given frame,\nthe <tt>rogers</tt> painter determines the point in the image that is mapped to it\nunder the frame coordinate map, and shades it\naccordingly.  By allowing different types of painters, we are capitalizing on the\nabstract data idea discussed in section&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.3">2.1.3</a>, where we\nargued that a rational-number representation could be anything at all that\nsatisfies an appropriate condition.  Here we\'re using the fact that a\npainter can be implemented in any way at all, so long as it draws\nsomething in the designated frame.  Section&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.3">2.1.3</a> also\nshowed how pairs could be implemented as procedures.  Painters are our\nsecond example of a procedural representation for data.\n\n<p><a name="footnote_Temp_220" href="#call_footnote_Temp_220"><sup><small>29</small></sup></a> <tt>Rotate90</tt> is a pure rotation only for square\nframes, because it also stretches and shrinks the image to fit into\nthe rotated frame.\n\n<p><a name="footnote_Temp_221" href="#call_footnote_Temp_221"><sup><small>30</small></sup></a> The diamond-shaped images in figures&nbsp;<a href="#%_fig_2.10">2.10</a>\nand&nbsp;<a href="#%_fig_2.11">2.11</a> were created with <tt>squash-inwards</tt> applied to\n<tt>wave</tt> and <tt>rogers</tt>.\n\n<p><a name="footnote_Temp_225" href="#call_footnote_Temp_225"><sup><small>31</small></sup></a> Section&nbsp;<a href="book-Z-H-22.html#%_sec_3.3.4">3.3.4</a> describes one such language.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_2.3"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_2.3">2.3&nbsp;&nbsp;Symbolic Data</a></h2><p>\n\n\n<a name="%_idx_1984"></a>\n<a name="%_idx_1986"></a>All the compound data objects we have used so far were constructed\nultimately from numbers.  In this section we extend the representational\ncapability of our language by introducing the ability to work with\narbitrary symbols as data.<p>\n\n<a name="%_sec_2.3.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.3.1">2.3.1&nbsp;&nbsp;Quotation</a></h3><p>\n\n\n<a name="%_idx_1988"></a>\nIf we can form compound data using symbols, we can have lists such as<p>\n\n<p><p><tt><a name="%_idx_1990"></a>(a&nbsp;b&nbsp;c&nbsp;d)<br>\n(23&nbsp;45&nbsp;17)<br>\n((Norah&nbsp;12)&nbsp;(Molly&nbsp;9)&nbsp;(Anna&nbsp;7)&nbsp;(Lauren&nbsp;6)&nbsp;(Charlotte&nbsp;4))<br>\n</tt><p><p>\nLists containing symbols can look just like the expressions of our\nlanguage:<p>\n\n<p><p><tt>(*&nbsp;(+&nbsp;23&nbsp;45)&nbsp;(+&nbsp;x&nbsp;9))<br>\n<br>\n(define&nbsp;(fact&nbsp;n)&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)&nbsp;1&nbsp;(*&nbsp;n&nbsp;(fact&nbsp;(-&nbsp;n&nbsp;1)))))<br>\n</tt><p><p><p>\n\nIn order to manipulate symbols we need a new element in our language:\nthe ability to <em>quote</em> a data object.  Suppose we want to\nconstruct the list <tt>(a b)</tt>.  We can\'t accomplish this with <tt>(list a b)</tt>, because this expression constructs\na list of the <em>values</em> of <tt>a</tt> and <tt>b</tt> rather than\nthe symbols themselves.  This issue is well known in the context of\n<a name="%_idx_1992"></a><a name="%_idx_1994"></a>natural languages, where words and sentences may be regarded either as\nsemantic entities or as character strings (syntactic entities).  The\ncommon practice in natural languages is to use quotation marks to\nindicate that a word or a sentence is to be treated literally as a\nstring of characters.  For instance, the first letter of ``John\'\' is\nclearly ``J.\'\'  If we tell somebody ``say your name aloud,\'\' we expect\nto hear that person\'s name.  However, if we tell somebody ``say `your\nname\' aloud,\'\' we expect to hear the words ``your name.\'\'  Note that\nwe are forced to nest quotation marks to describe what somebody else\nmight say.<a name="call_footnote_Temp_227" href="#footnote_Temp_227"><sup><small>32</small></sup></a><p>\n\n<a name="%_idx_1998"></a>We can follow this same practice to identify lists and symbols that are\nto be treated as data objects rather than as expressions to be\nevaluated.  However, our format for quoting differs from that of\nnatural languages in that we place a quotation mark (traditionally,\nthe single <a name="%_idx_2000"></a>quote symbol&nbsp;<tt>\'</tt>) only at the beginning of the object\nto be quoted.  We can get away with this in Scheme syntax because we\nrely on blanks and parentheses to delimit objects.  Thus, the meaning\nof the single quote character is to quote the next object.<a name="call_footnote_Temp_228" href="#footnote_Temp_228"><sup><small>33</small></sup></a><p>\n\n<a name="%_idx_2010"></a>Now we can distinguish between symbols and their values:<p>\n\n<p><p><tt>(define&nbsp;a&nbsp;1)<br>\n<br>\n(define&nbsp;b&nbsp;2)<br>\n<br>\n(list&nbsp;a&nbsp;b)<br>\n<i>(1&nbsp;2)</i><br>\n<br>\n(list&nbsp;\'a&nbsp;\'b)<br>\n<i>(a&nbsp;b)</i><br>\n<br>\n(list&nbsp;\'a&nbsp;b)<br>\n<i>(a&nbsp;2)</i><br>\n</tt><p><p><p>\n\n<a name="%_idx_2012"></a>Quotation also allows us to type in compound objects, using the\nconventional printed representation for lists:<a name="call_footnote_Temp_229" href="#footnote_Temp_229"><sup><small>34</small></sup></a><p>\n\n<p><p><tt>(car&nbsp;\'(a&nbsp;b&nbsp;c))<br>\n<i>a</i><br>\n<br>\n(cdr&nbsp;\'(a&nbsp;b&nbsp;c))<br>\n<i>(b&nbsp;c)</i><br>\n</tt><p><p>\n<a name="%_idx_2018"></a><a name="%_idx_2020"></a>In keeping with this, we can obtain the empty list by evaluating <tt>\'()</tt>, and thus dispense with the variable <tt>nil</tt>.<p>\n\nOne additional primitive used in manipulating symbols is <a name="%_idx_2022"></a><a name="%_idx_2024"></a><a name="%_idx_2026"></a><a name="%_idx_2028"></a><tt>eq?</tt>,\nwhich takes two symbols as arguments and tests whether they are the\nsame.<a name="call_footnote_Temp_230" href="#footnote_Temp_230"><sup><small>35</small></sup></a> Using <tt>eq?</tt>,\nwe can implement a useful procedure called <tt>memq</tt>.  This takes two\narguments, a symbol and a list.  If the symbol is not contained in the\nlist (i.e., is not <tt>eq?</tt> to any item in the list), then <tt>memq</tt> returns false.  Otherwise, it returns the sublist of\nthe list beginning with the first occurrence of the symbol:<p>\n\n<p><p><tt><a name="%_idx_2030"></a>(define&nbsp;(memq&nbsp;item&nbsp;x)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;x)&nbsp;false)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;item&nbsp;(car&nbsp;x))&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(memq&nbsp;item&nbsp;(cdr&nbsp;x)))))<br>\n</tt><p><p>\nFor example, the value of<p>\n\n<p><p><tt>(memq&nbsp;\'apple&nbsp;\'(pear&nbsp;banana&nbsp;prune))<br>\n</tt><p><p>\nis false, whereas the value of<p>\n\n<p><p><tt>(memq&nbsp;\'apple&nbsp;\'(x&nbsp;(apple&nbsp;sauce)&nbsp;y&nbsp;apple&nbsp;pear))<br>\n</tt><p><p>\nis <tt>(apple pear)</tt>.<p>\n\n<p><a name="%_thm_2.53"></a>\n<b>Exercise 2.53.</b>&nbsp;&nbsp;What would the interpreter print in response to evaluating each of the\nfollowing expressions?<p>\n\n<p><p><tt>(list&nbsp;\'a&nbsp;\'b&nbsp;\'c)<br>\n<br>\n(list&nbsp;(list&nbsp;\'george))<br>\n(cdr&nbsp;\'((x1&nbsp;x2)&nbsp;(y1&nbsp;y2)))<br>\n<br>\n(cadr&nbsp;\'((x1&nbsp;x2)&nbsp;(y1&nbsp;y2)))<br>\n(pair?&nbsp;(car&nbsp;\'(a&nbsp;short&nbsp;list)))<br>\n(memq&nbsp;\'red&nbsp;\'((red&nbsp;shoes)&nbsp;(blue&nbsp;socks)))<br>\n<br>\n(memq&nbsp;\'red&nbsp;\'(red&nbsp;shoes&nbsp;blue&nbsp;socks))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_2.54"></a>\n<b>Exercise 2.54.</b>&nbsp;&nbsp;Two lists are said to be <a name="%_idx_2032"></a><a name="%_idx_2034"></a><a name="%_idx_2036"></a><tt>equal?</tt> if they contain equal elements\narranged in the same order.  For example,<p>\n\n<p><p><tt>(equal?&nbsp;\'(this&nbsp;is&nbsp;a&nbsp;list)&nbsp;\'(this&nbsp;is&nbsp;a&nbsp;list))<br>\n</tt><p><p>\nis true, but<p>\n\n<p><p><tt>(equal?&nbsp;\'(this&nbsp;is&nbsp;a&nbsp;list)&nbsp;\'(this&nbsp;(is&nbsp;a)&nbsp;list))<br>\n</tt><p><p>\nis false.  To be more precise, we can define <tt>equal?</tt>\nrecursively in terms of the basic <tt>eq?</tt> equality of symbols by\nsaying that <tt>a</tt> and <tt>b</tt> are <tt>equal?</tt> if they are both\nsymbols and the symbols are <tt>eq?</tt>, or if they are both lists such\nthat <tt>(car a)</tt> is <tt>equal?</tt> to <tt>(car b)</tt> and <tt>(cdr\na)</tt> is <tt>equal?</tt> to <tt>(cdr b)</tt>.  Using this idea, implement\n<tt>equal?</tt> as a procedure.<a name="call_footnote_Temp_233" href="#footnote_Temp_233"><sup><small>36</small></sup></a>\n<p><p>\n\n<p><a name="%_thm_2.55"></a>\n<b>Exercise 2.55.</b>&nbsp;&nbsp;Eva Lu Ator types to the interpreter the expression\n<p><p><tt>(car&nbsp;\'\'abracadabra)<br>\n</tt><p><p>\nTo her surprise, the interpreter prints back <tt>quote</tt>.  Explain.\n\n<p>\n\n<a name="%_sec_2.3.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.3.2">2.3.2&nbsp;&nbsp;Example: Symbolic Differentiation</a></h3><p>\n\n\n<a name="%_idx_2042"></a><a name="%_idx_2044"></a><a name="%_idx_2046"></a>\nAs an illustration of symbol manipulation and a further illustration\nof data abstraction, consider the design of a procedure that performs\nsymbolic differentiation of algebraic expressions.  We would like the\nprocedure to take as arguments an algebraic expression and a variable\nand to return the derivative of the expression with respect to the\nvariable.  For example, if the arguments to the procedure are <em>a</em><em>x</em><sup>2</sup>\n + <em>b</em><em>x</em>  + <em>c</em> and <em>x</em>, the procedure should return 2<em>a</em><em>x</em> + <em>b</em>.  Symbolic\ndifferentiation is of special historical significance in Lisp.  It was\none of the motivating examples behind the development of a computer\nlanguage for symbol manipulation.  Furthermore, it marked the\nbeginning of the line of research that led to the development of\npowerful systems for symbolic mathematical work, which are currently\nbeing used by a growing number of applied mathematicians and\nphysicists.<p>\n\nIn developing the symbolic-differentiation program, we will follow the\nsame strategy of data abstraction that we followed in developing the\nrational-number system of section&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a>.  That is, we will first\ndefine a differentiation algorithm that operates on abstract\nobjects such as ``sums,\'\' ``products,\'\' and ``variables\'\' without\nworrying about how these are to be represented.  Only afterward will\nwe address the representation problem.<p>\n\n<a name="%_sec_Temp_235"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_235">The differentiation program with abstract data</a></h4><p>\n\n<a name="%_idx_2048"></a>\nIn order to keep things simple, we will consider a very simple\nsymbolic-differentiation program that handles expressions that are\nbuilt up using only the operations of addition and multiplication with\ntwo arguments.  Differentiation of any such expression can be carried\nout by applying the following reduction rules:<p>\n\n<p><div align=left><img src="ch2-Z-G-45.gif" border="0"></div><p><p>\n\n<p><div align=left><img src="ch2-Z-G-46.gif" border="0"></div><p><p>\n\n<p><div align=left><img src="ch2-Z-G-47.gif" border="0"></div><p><p>\n\n<p><div align=left><img src="ch2-Z-G-48.gif" border="0"></div><p><p>\n\nObserve that the latter two rules are recursive in nature.  That is,\nto obtain the derivative of a sum we first find the derivatives of the\nterms and add them.  Each of the terms may in turn be an\nexpression that needs to be decomposed.  Decomposing into smaller and\nsmaller pieces will eventually produce pieces that are either\nconstants or variables, whose derivatives will be either 0 or 1.<p>\n\nTo embody these rules in a procedure we indulge in a little <a name="%_idx_2050"></a>wishful\nthinking, as we did in designing the rational-number implementation.\nIf we had a means for representing algebraic expressions, we should be\nable to tell whether an expression is a sum, a product, a constant, or\na variable.  We should be able to extract the parts of an expression.\nFor a sum, for example we want to be able to extract the addend\n(first term) and the augend (second term).  We should also be able to\nconstruct expressions from parts.  Let us assume that we already have\nprocedures to implement the following selectors, constructors, and\npredicates:<p>\n\n<table border=0><tr><td valign=top ><tt>(variable? e)</tt> </td><td valign=top >Is <tt>e</tt> a variable?</td></tr>\n<tr><td valign=top ><tt>(same-variable? v1 v2)</tt> </td><td valign=top >Are <tt>v1</tt> and <tt>v2</tt> the same variable?</td></tr>\n<tr><td valign=top ><p>\n\n<tt>(sum? e)</tt> </td><td valign=top >Is <tt>e</tt> a sum?</td></tr>\n<tr><td valign=top ><tt>(addend e)</tt> </td><td valign=top >Addend of the sum <tt>e</tt>.</td></tr>\n<tr><td valign=top ><tt>(augend e)</tt> </td><td valign=top >Augend of the sum <tt>e</tt>.</td></tr>\n<tr><td valign=top ><tt>(make-sum a1 a2)</tt> </td><td valign=top >Construct the sum of <tt>a1</tt> and <tt>a2</tt>.</td></tr>\n<tr><td valign=top ><p>\n\n<tt>(product? e)</tt> </td><td valign=top >Is <tt>e</tt> a product?</td></tr>\n<tr><td valign=top ><tt>(multiplier e)</tt> </td><td valign=top >Multiplier of the product <tt>e</tt>.</td></tr>\n<tr><td valign=top ><tt>(multiplicand e)</tt> </td><td valign=top >Multiplicand of the product <tt>e</tt>.</td></tr>\n<tr><td valign=top ><tt>(make-product m1 m2)</tt> </td><td valign=top >Construct the product of <tt>m1</tt> and <tt>m2</tt>.\n</td></tr></table>\nUsing these, and the primitive predicate <tt>number?</tt>,\n<a name="%_idx_2052"></a><a name="%_idx_2054"></a>which identifies numbers, we can express the differentiation rules as the\nfollowing procedure:<p>\n\n<p><p><tt><a name="%_idx_2056"></a>(define&nbsp;(deriv&nbsp;exp&nbsp;var)<br>\n&nbsp;&nbsp;(cond&nbsp;((number?&nbsp;exp)&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((variable?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(same-variable?&nbsp;exp&nbsp;var)&nbsp;1&nbsp;0))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((sum?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-sum&nbsp;(deriv&nbsp;(addend&nbsp;exp)&nbsp;var)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(deriv&nbsp;(augend&nbsp;exp)&nbsp;var)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((product?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-sum<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-product&nbsp;(multiplier&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(deriv&nbsp;(multiplicand&nbsp;exp)&nbsp;var))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-product&nbsp;(deriv&nbsp;(multiplier&nbsp;exp)&nbsp;var)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(multiplicand&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;unknown&nbsp;expression&nbsp;type&nbsp;--&nbsp;DERIV&quot;&nbsp;exp))))<br>\n</tt><p><p>\nThis <tt>deriv</tt> procedure incorporates the complete differentiation algorithm.\nSince it is expressed in terms of abstract data, it will work no\nmatter how we choose to represent algebraic expressions, as long as we\ndesign a proper set of selectors and constructors.  This is the issue\nwe must address next.<p>\n\n<a name="%_sec_Temp_236"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_236">Representing algebraic expressions</a></h4><p>\n\n<a name="%_idx_2058"></a>\nWe can imagine many ways to use list structure to represent algebraic\nexpressions.  For example, we could use lists of symbols that mirror\nthe usual algebraic notation, representing <em>a</em><em>x</em> + <em>b</em> as the list <tt>(a\n* x +&nbsp;b)</tt>.  However, one especially straightforward choice is to use\nthe same parenthesized prefix notation that Lisp uses for\ncombinations; that is, to represent <em>a</em><em>x</em> + <em>b</em> as <tt>(+ (* a x) b)</tt>.\nThen our data representation for the differentiation problem is as\nfollows:<p>\n\n<p><ul>\n<li>The variables are symbols.  They are identified by the primitive predicate\n<a name="%_idx_2060"></a><a name="%_idx_2062"></a><tt>symbol?</tt>:<p>\n\n<p><p><tt><a name="%_idx_2064"></a>(define&nbsp;(variable?&nbsp;x)&nbsp;(symbol?&nbsp;x))<br>\n</tt><p><p>\n<p>\n\n<li>Two variables are the same if the symbols representing them are\n<tt>eq?</tt>:<p>\n\n<p><p><tt><a name="%_idx_2066"></a>(define&nbsp;(same-variable?&nbsp;v1&nbsp;v2)<br>\n&nbsp;&nbsp;(and&nbsp;(variable?&nbsp;v1)&nbsp;(variable?&nbsp;v2)&nbsp;(eq?&nbsp;v1&nbsp;v2)))<br>\n</tt><p><p>\n<p>\n\n<li>Sums and products are constructed as lists:<p>\n\n<p><p><tt><a name="%_idx_2068"></a>(define&nbsp;(make-sum&nbsp;a1&nbsp;a2)&nbsp;(list&nbsp;\'+&nbsp;a1&nbsp;a2))<br>\n<br>\n<a name="%_idx_2070"></a>(define&nbsp;(make-product&nbsp;m1&nbsp;m2)&nbsp;(list&nbsp;\'*&nbsp;m1&nbsp;m2))<br>\n</tt><p><p>\n<p>\n\n<li>A sum is a list whose first element is the symbol <tt>+</tt>:<p>\n\n<p><p><tt><a name="%_idx_2072"></a>(define&nbsp;(sum?&nbsp;x)<br>\n&nbsp;&nbsp;(and&nbsp;(pair?&nbsp;x)&nbsp;(eq?&nbsp;(car&nbsp;x)&nbsp;\'+)))<br>\n</tt><p><p>\n<p>\n\n<li>The addend is the second item of the sum list:<p>\n\n<p><p><tt><a name="%_idx_2074"></a>(define&nbsp;(addend&nbsp;s)&nbsp;(cadr&nbsp;s))<br>\n</tt><p><p>\n<p>\n\n<li>The augend is the third item of the sum list:<p>\n\n<p><p><tt><a name="%_idx_2076"></a>(define&nbsp;(augend&nbsp;s)&nbsp;(caddr&nbsp;s))<br>\n</tt><p><p>\n<p>\n\n<li>A product is a list whose first element is the symbol <tt>*</tt>:<p>\n\n<p><p><tt><a name="%_idx_2078"></a>(define&nbsp;(product?&nbsp;x)<br>\n&nbsp;&nbsp;(and&nbsp;(pair?&nbsp;x)&nbsp;(eq?&nbsp;(car&nbsp;x)&nbsp;\'*)))<br>\n</tt><p><p>\n<p>\n\n<li>The multiplier is the second item of the product list:<p>\n\n<p><p><tt><a name="%_idx_2080"></a>(define&nbsp;(multiplier&nbsp;p)&nbsp;(cadr&nbsp;p))<br>\n</tt><p><p>\n<p>\n\n<li>The multiplicand is the third item of the product list:<p>\n\n<p><p><tt><a name="%_idx_2082"></a>(define&nbsp;(multiplicand&nbsp;p)&nbsp;(caddr&nbsp;p))<br>\n</tt><p><p>\n</ul><p><p>\n\nThus, we need only combine these with the algorithm as embodied by\n<tt>deriv</tt> in order to have a working symbolic-differentiation\nprogram.  Let us look at some examples of its behavior:<p>\n\n<p><p><tt>(deriv&nbsp;\'(+&nbsp;x&nbsp;3)&nbsp;\'x)<br>\n<i>(+&nbsp;1&nbsp;0)</i><br>\n(deriv&nbsp;\'(*&nbsp;x&nbsp;y)&nbsp;\'x)<br>\n<i>(+&nbsp;(*&nbsp;x&nbsp;0)&nbsp;(*&nbsp;1&nbsp;y))</i><br>\n(deriv&nbsp;\'(*&nbsp;(*&nbsp;x&nbsp;y)&nbsp;(+&nbsp;x&nbsp;3))&nbsp;\'x)<br>\n<i>(+&nbsp;(*&nbsp;(*&nbsp;x&nbsp;y)&nbsp;(+&nbsp;1&nbsp;0))<br>\n&nbsp;&nbsp;&nbsp;(*&nbsp;(+&nbsp;(*&nbsp;x&nbsp;0)&nbsp;(*&nbsp;1&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;&nbsp;x&nbsp;3)))</i><br>\n</tt><p><p>\nThe program produces answers that are correct; however, they are\nunsimplified.  It is true that<p>\n\n<p><div align=left><img src="ch2-Z-G-49.gif" border="0"></div><p><p>\n\nbut we would like the program to know that <em>x</em> &middot;  0  =  0, 1 &middot;  <em>y</em>  = \n<em>y</em>, and 0 + <em>y</em> = <em>y</em>.  The answer for the second example should have been\nsimply&nbsp;<tt>y</tt>.  As the third example shows, this becomes a serious\nissue when the expressions are complex.<p>\n\n<a name="%_idx_2084"></a><a name="%_idx_2086"></a>Our difficulty is much like the one we encountered with the\nrational-number implementation: we haven\'t reduced answers to simplest\nform.  To accomplish the rational-number reduction, we needed to\nchange only the constructors and the selectors of the implementation.\nWe can adopt a similar strategy here.  We won\'t change <tt>deriv</tt> at\nall.  Instead, we will change <tt>make-sum</tt> so that if both summands\nare numbers, <tt>make-sum</tt> will add them and return their sum.  Also,\nif one of the summands is 0, then <tt>make-sum</tt> will return the other\nsummand.<p>\n\n<p><p><tt><a name="%_idx_2088"></a>(define&nbsp;(make-sum&nbsp;a1&nbsp;a2)<br>\n&nbsp;&nbsp;(cond&nbsp;((=number?&nbsp;a1&nbsp;0)&nbsp;a2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=number?&nbsp;a2&nbsp;0)&nbsp;a1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(number?&nbsp;a1)&nbsp;(number?&nbsp;a2))&nbsp;(+&nbsp;a1&nbsp;a2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(list&nbsp;\'+&nbsp;a1&nbsp;a2))))<br>\n</tt><p><p>\nThis uses the procedure <tt>=number?</tt>, which checks whether an\nexpression is equal to a given number:<p>\n\n<p><p><tt><a name="%_idx_2090"></a>(define&nbsp;(=number?&nbsp;exp&nbsp;num)<br>\n&nbsp;&nbsp;(and&nbsp;(number?&nbsp;exp)&nbsp;(=&nbsp;exp&nbsp;num)))<br>\n</tt><p><p>\nSimilarly, we will change <tt>make-product</tt> to build in the rules that 0\ntimes anything is 0 and 1 times anything is the thing itself:<p>\n\n<p><p><tt><a name="%_idx_2092"></a>(define&nbsp;(make-product&nbsp;m1&nbsp;m2)<br>\n&nbsp;&nbsp;(cond&nbsp;((or&nbsp;(=number?&nbsp;m1&nbsp;0)&nbsp;(=number?&nbsp;m2&nbsp;0))&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=number?&nbsp;m1&nbsp;1)&nbsp;m2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=number?&nbsp;m2&nbsp;1)&nbsp;m1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(number?&nbsp;m1)&nbsp;(number?&nbsp;m2))&nbsp;(*&nbsp;m1&nbsp;m2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(list&nbsp;\'*&nbsp;m1&nbsp;m2))))<br>\n</tt><p><p>\nHere is how this version works on our three examples:<p>\n\n<p><p><tt>(deriv&nbsp;\'(+&nbsp;x&nbsp;3)&nbsp;\'x)<br>\n<i>1</i><br>\n(deriv&nbsp;\'(*&nbsp;x&nbsp;y)&nbsp;\'x)<br>\n<i>y</i><br>\n(deriv&nbsp;\'(*&nbsp;(*&nbsp;x&nbsp;y)&nbsp;(+&nbsp;x&nbsp;3))&nbsp;\'x)<br>\n<i>(+&nbsp;(*&nbsp;x&nbsp;y)&nbsp;(*&nbsp;y&nbsp;(+&nbsp;x&nbsp;3)))</i><br>\n</tt><p><p>\nAlthough this is quite an improvement, the third example shows that\nthere is still a long way to go before we get a program that puts\nexpressions into a form that we might agree is ``simplest.\'\'  The\nproblem of algebraic simplification is complex because, among other\nreasons, a form that may be simplest for one purpose may not be for\nanother.\n\n<p><a name="%_thm_2.56"></a>\n<b>Exercise 2.56.</b>&nbsp;&nbsp;<a name="%_idx_2094"></a>Show how to extend the basic differentiator to handle more kinds of\nexpressions.  For instance, implement the differentiation rule<p>\n\n<p><div align=left><img src="ch2-Z-G-50.gif" border="0"></div><p><p>\n\nby adding a new clause to the <tt>deriv</tt> program\nand defining\nappropriate procedures <tt>exponentiation?</tt>, <tt>base</tt>, <tt>exponent</tt>,\nand <tt>make-exponentiation</tt>.  (You may use the symbol <tt>**</tt> to denote\nexponentiation.)\nBuild in the rules that anything raised to the power 0 is 1 and\nanything raised to the power 1 is the thing itself.\n\n<p><p>\n\n<p><a name="%_thm_2.57"></a>\n<b>Exercise 2.57.</b>&nbsp;&nbsp;Extend the differentiation program to handle sums and products of\narbitrary numbers of (two or more) terms.\nThen the last example above could be expressed as\n<p><p><tt>(deriv&nbsp;\'(*&nbsp;x&nbsp;y&nbsp;(+&nbsp;x&nbsp;3))&nbsp;\'x)<br>\n</tt><p><p>\nTry to do this by changing only the\nrepresentation for sums and products, without changing the <tt>deriv</tt> procedure at all.  For example, the <tt>addend</tt> of a sum would\nbe the first term, and the <tt>augend</tt> would be the sum of the rest\nof the terms.\n<p><p>\n\n<p><a name="%_thm_2.58"></a>\n<b>Exercise 2.58.</b>&nbsp;&nbsp;<a name="%_idx_2096"></a><a name="%_idx_2098"></a>Suppose we want to modify the differentiation program so that it works\nwith ordinary mathematical notation, in which <tt>+</tt> and <tt>*</tt> are\ninfix rather than prefix operators.  Since the differentiation program\nis defined in terms of abstract data, we can modify it to work with\ndifferent representations of expressions solely by changing the\npredicates, selectors, and constructors that define the representation\nof the algebraic expressions on which the differentiator is to\noperate.<p>\n\n<p><p>a. Show how to do this in order to differentiate algebraic\nexpressions presented in infix form, such as <tt>(x + (3 * (x + (y + 2))))</tt>.\nTo simplify the task, assume that <tt>+</tt> and <tt>*</tt> always\ntake two arguments and that expressions are fully parenthesized.<p>\n\n<p><p>b. The problem becomes substantially harder if we allow standard\nalgebraic notation, such as <tt>(x + 3 * (x + y + 2))</tt>, which drops\nunnecessary parentheses and assumes that multiplication is done before\naddition.  Can you design appropriate predicates, selectors, and\nconstructors for this notation such that our derivative program still\nworks?\n<p>\n\n<a name="%_sec_2.3.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.3.3">2.3.3&nbsp;&nbsp;Example: Representing Sets</a></h3><p>\n\n\n<a name="%_idx_2100"></a>\nIn the previous examples we built representations for two kinds of\ncompound data objects: rational numbers and algebraic expressions.  In\none of these examples we had the choice of simplifying (reducing) the\nexpressions at either construction time or selection time, but other\nthan that the choice of a representation for these structures in terms\nof lists was straightforward. When we turn to the representation of\nsets, the choice of a representation is not so obvious.  Indeed, there\nare a number of possible representations, and they differ\nsignificantly from one another in several ways.<p>\n\n\n<a name="%_idx_2102"></a>Informally, a set is simply a collection of distinct objects.  To give\na more precise definition we can employ the method of data\nabstraction.  That is, we define ``set\'\' by specifying the operations\nthat are to be used on sets.  These are <tt>union-set</tt>,\n<tt>intersection-set</tt>, <tt>element-of-set?</tt>, and <tt>adjoin-set</tt>.\n<a name="%_idx_2104"></a><tt>Element-of-set?</tt> is a predicate that determines whether a given\nelement is a member of a set.  <a name="%_idx_2106"></a><tt>Adjoin-set</tt> takes an object and a\nset as arguments and returns a set that contains the elements of the\noriginal set and also the adjoined element.  <a name="%_idx_2108"></a><tt>Union-set</tt> computes\nthe union of two sets, which is the set containing each element that\nappears in either argument.  <a name="%_idx_2110"></a><tt>Intersection-set</tt> computes the\nintersection of two sets, which is the set containing only elements\nthat appear in both arguments.  From the viewpoint of data abstraction, we\nare free to design any representation that implements these operations\nin a way consistent with the interpretations given above.<a name="call_footnote_Temp_240" href="#footnote_Temp_240"><sup><small>37</small></sup></a>\n<p>\n\n\n<a name="%_sec_Temp_241"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_241">Sets as unordered lists</a></h4><p>\n\n<a name="%_idx_2112"></a><a name="%_idx_2114"></a>\nOne way to represent a set is as a list of its elements in which no\nelement appears more than once.  The empty set is represented by the\nempty list.  In this representation, <tt>element-of-set?</tt> is similar\nto the procedure <tt>memq</tt> of section&nbsp;<a href="#%_sec_2.3.1">2.3.1</a>.  It uses <tt>equal?</tt>\ninstead of <tt>eq?</tt> so that the set elements need not be symbols:<p>\n\n<p><p><tt><a name="%_idx_2116"></a>(define&nbsp;(element-of-set?&nbsp;x&nbsp;set)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;set)&nbsp;false)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal?&nbsp;x&nbsp;(car&nbsp;set))&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(element-of-set?&nbsp;x&nbsp;(cdr&nbsp;set)))))<br>\n</tt><p><p>\nUsing this, we can write <tt>adjoin-set</tt>.  If the object to be adjoined\nis already in the set, we just return the set.  Otherwise, we use\n<tt>cons</tt> to add the object to the list that represents the set:<p>\n\n<p><p><tt><a name="%_idx_2118"></a>(define&nbsp;(adjoin-set&nbsp;x&nbsp;set)<br>\n&nbsp;&nbsp;(if&nbsp;(element-of-set?&nbsp;x&nbsp;set)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;x&nbsp;set)))<br>\n</tt><p><p>\nFor <tt>intersection-set</tt> we can use a recursive strategy.  If we\nknow how to form the intersection of <tt>set2</tt> and the <tt>cdr</tt>\nof <tt>set1</tt>, we only need to decide whether to include\nthe <tt>car</tt> of <tt>set1</tt> in this.  But this depends on whether <tt>(car\nset1)</tt> is also in <tt>set2</tt>.  Here is the resulting procedure:<p>\n\n<p><p><tt><a name="%_idx_2120"></a>(define&nbsp;(intersection-set&nbsp;set1&nbsp;set2)<br>\n&nbsp;&nbsp;(cond&nbsp;((or&nbsp;(null?&nbsp;set1)&nbsp;(null?&nbsp;set2))&nbsp;\'())<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((element-of-set?&nbsp;(car&nbsp;set1)&nbsp;set2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;set1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(intersection-set&nbsp;(cdr&nbsp;set1)&nbsp;set2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(intersection-set&nbsp;(cdr&nbsp;set1)&nbsp;set2))))<br>\n</tt><p><p><p>\n\nIn designing a representation, one of the issues we should be\nconcerned with is efficiency.  Consider the number of steps required by our set\noperations.  Since they all use <tt>element-of-set?</tt>, the speed\nof this operation has a major impact on the efficiency of the set\nimplementation as a whole.  Now, in order to check whether an object\nis a member of a set, <tt>element-of-set?</tt> may have to scan the\nentire set. (In the worst case, the object turns out not to be in the\nset.)  Hence, if the set has <em>n</em> elements, <tt>element-of-set?</tt>\nmight take up to <em>n</em> steps.  Thus, the number of steps\nrequired grows as <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>).\nThe number of steps required by <tt>adjoin-set</tt>, which uses this operation,\nalso grows as <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>).  For <tt>intersection-set</tt>, which does an <tt>element-of-set?</tt> check for each element of <tt>set1</tt>, the number of steps\nrequired grows as the product of the sizes of the sets involved, or\n<img src="book-Z-G-D-3.gif" border="0">(<em>n</em><sup>2</sup>) for two sets of size <em>n</em>.  The same will be true of <tt>union-set</tt>.<p>\n\n<p><a name="%_thm_2.59"></a>\n<b>Exercise 2.59.</b>&nbsp;&nbsp;Implement the <a name="%_idx_2122"></a><tt>union-set</tt> operation for the unordered-list\nrepresentation of sets.\n<p><p>\n\n<p><a name="%_thm_2.60"></a>\n<b>Exercise 2.60.</b>&nbsp;&nbsp;We specified that a set would be represented as a list with no\nduplicates.  Now suppose we allow duplicates.  For instance,\nthe set {1,2,3} could be represented as the list <tt>(2 3 2 1 3 2\n2)</tt>.  Design procedures <tt>element-of-set?</tt>, <tt>adjoin-set</tt>, <tt>union-set</tt>, and <tt>intersection-set</tt> that operate on this\nrepresentation.  How does the efficiency of each compare with the\ncorresponding procedure for the non-duplicate representation?  Are\nthere applications for which you would use this representation in\npreference to the non-duplicate one?\n<p>\n\n\n<a name="%_sec_Temp_244"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_244">Sets as ordered lists</a></h4><p>\n\n<a name="%_idx_2124"></a><a name="%_idx_2126"></a>\nOne way to speed up our set operations is to change the representation\nso that the set elements are listed in increasing order.  To do this,\nwe need some way to compare two objects so that we can say which is\nbigger.  For example, we could compare symbols lexicographically, or\nwe could agree on some method for assigning a unique number to an\nobject and then compare the elements by comparing the corresponding\nnumbers.  To keep our discussion simple, we will consider only the\ncase where the set elements are numbers, so that we can compare\nelements using <tt>&gt;</tt> and <tt>&lt;</tt>.  We will represent a set of\nnumbers by listing its elements in increasing order.  Whereas our\nfirst representation above allowed us to represent the set\n{1,3,6,10} by listing the elements in any order, our new\nrepresentation allows only the list <tt>(1 3 6 10)</tt>.<p>\n\nOne advantage of ordering shows up in <tt>element-of-set?</tt>: In\nchecking for the presence of an item, we no longer have to scan the\nentire set.  If we reach a set element that is larger than the item we\nare looking for, then we know that the item is not in the set:<p>\n\n<p><p><tt><a name="%_idx_2128"></a>(define&nbsp;(element-of-set?&nbsp;x&nbsp;set)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;set)&nbsp;false)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;x&nbsp;(car&nbsp;set))&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;x&nbsp;(car&nbsp;set))&nbsp;false)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(element-of-set?&nbsp;x&nbsp;(cdr&nbsp;set)))))<br>\n</tt><p><p>\nHow many steps does this save?  In the worst case, the item we are\nlooking for may be the largest one in the set, so the number of steps\nis the same as for the unordered representation.  On the other hand,\nif we search for items of many different sizes we can expect that\nsometimes we will be able to stop searching at a point near the\nbeginning of the list and that other times we will still need to\nexamine most of the list.  On the average we should expect to have to\nexamine about half of the items in the set.  Thus, the average\nnumber of steps required will be about <em>n</em>/2.\nThis is still <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) growth, but\nit does save us, on the average, a factor of 2 in number of steps over the\nprevious implementation.<p>\n\nWe obtain a more impressive speedup with <tt>intersection-set</tt>.  In\nthe unordered representation this operation required\n<img src="book-Z-G-D-3.gif" border="0">(<em>n</em><sup>2</sup>) steps, because we performed a complete scan of <tt>set2</tt> for\neach element of <tt>set1</tt>.  But with the ordered representation, we\ncan use a more clever method.  Begin by comparing the initial\nelements, <tt>x1</tt> and <tt>x2</tt>, of the two sets.  If <tt>x1</tt>\nequals <tt>x2</tt>, then that gives an element of the intersection, and\nthe rest of the intersection is the intersection of the <tt>cdr</tt>s of\nthe two sets.  Suppose, however, that <tt>x1</tt> is less than <tt>x2</tt>.\nSince <tt>x2</tt> is the smallest element in <tt>set2</tt>, we can\nimmediately conclude that <tt>x1</tt> cannot appear anywhere in <tt>set2</tt> and hence is not in the intersection.  Hence, the intersection\nis equal to the intersection of <tt>set2</tt> with the <tt>cdr</tt> of <tt>set1</tt>.  Similarly, if <tt>x2</tt> is less than <tt>x1</tt>, then the\nintersection is given by the intersection of <tt>set1</tt> with the <tt>cdr</tt> of <tt>set2</tt>.  Here is the procedure:<p>\n\n<p><p><tt><a name="%_idx_2130"></a>(define&nbsp;(intersection-set&nbsp;set1&nbsp;set2)<br>\n&nbsp;&nbsp;(if&nbsp;(or&nbsp;(null?&nbsp;set1)&nbsp;(null?&nbsp;set2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'()&nbsp;&nbsp;&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((x1&nbsp;(car&nbsp;set1))&nbsp;(x2&nbsp;(car&nbsp;set2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((=&nbsp;x1&nbsp;x2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;x1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(intersection-set&nbsp;(cdr&nbsp;set1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;set2))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;x1&nbsp;x2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(intersection-set&nbsp;(cdr&nbsp;set1)&nbsp;set2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;x2&nbsp;x1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(intersection-set&nbsp;set1&nbsp;(cdr&nbsp;set2)))))))<br>\n</tt><p><p>\nTo estimate the number of steps required by this process, observe that at each\nstep we reduce the intersection problem to computing intersections of\nsmaller sets -- removing the first element from <tt>set1</tt> or <tt>set2</tt> or both.  Thus, the number of steps required is at most the sum\nof the sizes of <tt>set1</tt> and <tt>set2</tt>, rather than the product of\nthe sizes as with the unordered representation.  This is <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) growth\nrather than <img src="book-Z-G-D-3.gif" border="0">(<em>n</em><sup>2</sup>) -- a considerable speedup, even for sets of\nmoderate size.<p>\n\n<p><a name="%_thm_2.61"></a>\n<b>Exercise 2.61.</b>&nbsp;&nbsp;Give an implementation of <a name="%_idx_2132"></a><tt>adjoin-set</tt> using the ordered\nrepresentation.  By analogy with <tt>element-of-set?</tt> show how to\ntake advantage of the ordering to produce a procedure that requires on\nthe average about half as many steps as with the unordered\nrepresentation.\n\n<p><p>\n\n<p><a name="%_thm_2.62"></a>\n<b>Exercise 2.62.</b>&nbsp;&nbsp;Give a <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) implementation of <a name="%_idx_2134"></a><tt>union-set</tt> for sets\nrepresented as ordered lists.\n<p>\n<p>\n\n<a name="%_sec_Temp_247"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_247">Sets as binary trees</a></h4><p>\n\n<a name="%_idx_2136"></a><a name="%_idx_2138"></a><a name="%_idx_2140"></a><a name="%_idx_2142"></a><a name="%_idx_2144"></a><a name="%_idx_2146"></a>\nWe can do better than the ordered-list representation by arranging the\nset elements in the form of a tree.  Each node of the tree holds one\nelement of the set, called the ``entry\'\' at that node, and a link to\neach of two other (possibly empty) nodes.  The ``left\'\' link points to\nelements smaller than the one at the node, and the ``right\'\' link to\nelements greater than the one at the node.\nFigure&nbsp;<a href="#%_fig_2.16">2.16</a> shows some trees that represent the set\n{1,3,5,7,9,11}.  The same set may be represented by a tree in a\nnumber of different ways.  The only thing we require for a valid\nrepresentation is that all elements in the left subtree be smaller\nthan the node entry and that all elements in the right subtree be\nlarger.<p>\n\n<a name="%_fig_2.16"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-51.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.16:</b>&nbsp;&nbsp;Various binary trees that represent the set { 1,3,5,7,9,11 }.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nThe advantage of the tree representation is this: Suppose we want to\ncheck whether a number <em>x</em> is contained in a set.  We begin by\ncomparing <em>x</em> with the entry in the top node.  If <em>x</em> is less than\nthis, we know that we need only search the left subtree; if <em>x</em> is\ngreater, we need only search the right subtree.  Now, if the tree is\n``balanced,\'\' each of these subtrees will be about half the size of\nthe original.  Thus, in one step we have reduced the problem of\nsearching a tree of size <em>n</em> to searching a tree of size <em>n</em>/2.  Since\nthe size of the tree is halved at each step, we should expect that the\nnumber of steps needed to search a tree of size <em>n</em> grows as <img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt>\n<em>n</em>).<a name="call_footnote_Temp_248" href="#footnote_Temp_248"><sup><small>38</small></sup></a> For large sets, this will\nbe a significant speedup over the previous representations.<p>\n\n<a name="%_idx_2150"></a>We can represent trees by using lists.  Each node will be a list of\nthree items: the entry at the node, the left subtree, and the right\nsubtree.  A left or a right subtree of the empty list will indicate\nthat there is no subtree connected there.  We can describe this\nrepresentation by the following procedures:<a name="call_footnote_Temp_249" href="#footnote_Temp_249"><sup><small>39</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_2152"></a>(define&nbsp;(entry&nbsp;tree)&nbsp;(car&nbsp;tree))<br>\n<a name="%_idx_2154"></a>(define&nbsp;(left-branch&nbsp;tree)&nbsp;(cadr&nbsp;tree))<br>\n<a name="%_idx_2156"></a>(define&nbsp;(right-branch&nbsp;tree)&nbsp;(caddr&nbsp;tree))<br>\n<a name="%_idx_2158"></a>(define&nbsp;(make-tree&nbsp;entry&nbsp;left&nbsp;right)<br>\n&nbsp;&nbsp;(list&nbsp;entry&nbsp;left&nbsp;right))<br>\n</tt><p><p><p>\n\nNow we can write the <tt>element-of-set?</tt> procedure using the strategy\ndescribed above:<p>\n\n<p><p><tt><a name="%_idx_2160"></a>(define&nbsp;(element-of-set?&nbsp;x&nbsp;set)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;set)&nbsp;false)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;x&nbsp;(entry&nbsp;set))&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;x&nbsp;(entry&nbsp;set))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(element-of-set?&nbsp;x&nbsp;(left-branch&nbsp;set)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&gt;&nbsp;x&nbsp;(entry&nbsp;set))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(element-of-set?&nbsp;x&nbsp;(right-branch&nbsp;set)))))<br>\n</tt><p><p><p>\n\nAdjoining an item to a set is implemented similarly and also requires\n<img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>) steps.  To adjoin an item <tt>x</tt>, we compare <tt>x</tt> with\nthe node entry to determine whether <tt>x</tt> should be added to the\nright or to the left branch, and having adjoined <tt>x</tt> to the\nappropriate branch we piece this newly constructed branch together\nwith the original entry and the other branch.  If <tt>x</tt> is equal to\nthe entry, we just return the node.  If we are asked to adjoin\n<tt>x</tt> to an empty tree, we generate a tree that has <tt>x</tt> as the\nentry and empty right and left branches.  Here is the procedure:<p>\n\n<p><p><tt><a name="%_idx_2162"></a>(define&nbsp;(adjoin-set&nbsp;x&nbsp;set)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;set)&nbsp;(make-tree&nbsp;x&nbsp;\'()&nbsp;\'()))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;x&nbsp;(entry&nbsp;set))&nbsp;set)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;x&nbsp;(entry&nbsp;set))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-tree&nbsp;(entry&nbsp;set)&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(adjoin-set&nbsp;x&nbsp;(left-branch&nbsp;set))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(right-branch&nbsp;set)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&gt;&nbsp;x&nbsp;(entry&nbsp;set))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-tree&nbsp;(entry&nbsp;set)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(left-branch&nbsp;set)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(adjoin-set&nbsp;x&nbsp;(right-branch&nbsp;set))))))<br>\n</tt><p><p><p>\n\nThe above claim that searching the tree can be performed in a logarithmic\nnumber of steps\nrests on the assumption that the tree is <a name="%_idx_2164"></a><a name="%_idx_2166"></a>``balanced,\'\' i.e., that the\nleft and the right subtree of every tree have approximately the same\nnumber of elements, so that each subtree contains about half the\nelements of its parent.  But how can we be certain that the trees we\nconstruct will be balanced?  Even if we start with a balanced tree,\nadding elements with <tt>adjoin-set</tt> may produce an unbalanced\nresult.  Since the position of a newly adjoined element depends on how\nthe element compares with the items already in the set, we can expect\nthat if we add elements ``randomly\'\' the tree will tend to be balanced\non the average.  But this is not a guarantee.  For example, if we\nstart with an empty set and adjoin the numbers 1 through 7 in sequence\nwe end up with the highly unbalanced tree shown in\nfigure&nbsp;<a href="#%_fig_2.17">2.17</a>.  In this tree all the left subtrees\nare empty, so it has no advantage over a simple ordered list.  One\nway to solve this problem is to define an operation that transforms an\narbitrary tree into a balanced tree with the same elements.  Then we\ncan perform this transformation after every few <tt>adjoin-set</tt>\noperations to keep our set in balance.  There are also other ways to\nsolve this problem, most of which involve designing new data\nstructures for which searching and insertion both can be done in\n<img src="book-Z-G-D-3.gif" border="0">(<tt>log</tt> <em>n</em>) steps.<a name="call_footnote_Temp_250" href="#footnote_Temp_250"><sup><small>40</small></sup></a><p>\n\n<a name="%_fig_2.17"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-52.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.17:</b>&nbsp;&nbsp;Unbalanced tree produced by adjoining 1 through 7 in sequence.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<p><a name="%_thm_2.63"></a>\n<b>Exercise 2.63.</b>&nbsp;&nbsp;Each of the following two procedures converts a <a name="%_idx_2182"></a><a name="%_idx_2184"></a>binary tree to a list.\n<a name="%_idx_2186"></a><p><p><tt>(define&nbsp;(tree-&gt;list-1&nbsp;tree)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append&nbsp;(tree-&gt;list-1&nbsp;(left-branch&nbsp;tree))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(entry&nbsp;tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tree-&gt;list-1&nbsp;(right-branch&nbsp;tree))))))<br>\n(define&nbsp;(tree-&gt;list-2&nbsp;tree)<br>\n&nbsp;&nbsp;(define&nbsp;(copy-to-list&nbsp;tree&nbsp;result-list)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-list<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(copy-to-list&nbsp;(left-branch&nbsp;tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(entry&nbsp;tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(copy-to-list&nbsp;(right-branch&nbsp;tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-list)))))<br>\n&nbsp;&nbsp;(copy-to-list&nbsp;tree&nbsp;\'()))<br>\n</tt><p><p>\n<p><p>a. Do the two procedures produce the same result for every tree?  If\nnot, how do the results differ?  What lists do the two procedures\nproduce for the trees in figure&nbsp;<a href="#%_fig_2.16">2.16</a>?\n\n<p><p>b. Do the two procedures have the same order of growth in the number\nof steps required to convert a balanced tree with <em>n</em> elements to a list?\nIf not, which one grows more slowly?\n\n<p><p>\n\n<p><a name="%_thm_2.64"></a>\n<b>Exercise 2.64.</b>&nbsp;&nbsp;<a name="%_idx_2188"></a><a name="%_idx_2190"></a>The following procedure <tt>list-&gt;tree</tt> converts an ordered list to a\nbalanced binary tree.  The helper procedure <tt>partial-tree</tt> takes\nas arguments an integer <em>n</em> and list of at least <em>n</em> elements and\nconstructs a balanced tree containing the first <em>n</em> elements of the\nlist.  The result returned by <tt>partial-tree</tt> is a pair (formed\nwith <tt>cons</tt>) whose <tt>car</tt> is the constructed tree and whose\n<tt>cdr</tt> is the list of elements not included in the tree.<p>\n\n<p><p><tt><a name="%_idx_2192"></a>(define&nbsp;(list-&gt;tree&nbsp;elements)<br>\n&nbsp;&nbsp;(car&nbsp;(partial-tree&nbsp;elements&nbsp;(length&nbsp;elements))))<br>\n<br>\n(define&nbsp;(partial-tree&nbsp;elts&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;\'()&nbsp;elts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((left-size&nbsp;(quotient&nbsp;(-&nbsp;n&nbsp;1)&nbsp;2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((left-result&nbsp;(partial-tree&nbsp;elts&nbsp;left-size)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((left-tree&nbsp;(car&nbsp;left-result))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(non-left-elts&nbsp;(cdr&nbsp;left-result))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(right-size&nbsp;(-&nbsp;n&nbsp;(+&nbsp;left-size&nbsp;1))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((this-entry&nbsp;(car&nbsp;non-left-elts))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(right-result&nbsp;(partial-tree&nbsp;(cdr&nbsp;non-left-elts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right-size)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((right-tree&nbsp;(car&nbsp;right-result))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(remaining-elts&nbsp;(cdr&nbsp;right-result)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(make-tree&nbsp;this-entry&nbsp;left-tree&nbsp;right-tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remaining-elts))))))))<br>\n</tt><p><p><p>\n\n<p><p>a. Write a short paragraph explaining as clearly as you can how <tt>partial-tree</tt> works.  Draw the tree produced by <tt>list-&gt;tree</tt> for\nthe list <tt>(1 3 5 7 9 11)</tt>.\n\n<p><p>b. What is the order of growth in the number of steps required by <tt>list-&gt;tree</tt> to convert a list of <em>n</em> elements?\n\n<p><p>\n\n<p><a name="%_thm_2.65"></a>\n<b>Exercise 2.65.</b>&nbsp;&nbsp;<a name="%_idx_2194"></a><a name="%_idx_2196"></a>Use the results of exercises&nbsp;<a href="#%_thm_2.63">2.63</a> and\n&nbsp;<a href="#%_thm_2.64">2.64</a> to give <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) implementations of <tt>union-set</tt> and <tt>intersection-set</tt> for sets implemented as\n(balanced) binary trees.<a name="call_footnote_Temp_254" href="#footnote_Temp_254"><sup><small>41</small></sup></a>\n\n<p>\n\n<a name="%_sec_Temp_255"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_255">Sets and information retrieval</a></h4><p>\n\n<a name="%_idx_2200"></a>\nWe have examined options for using lists to represent sets and have\nseen how the choice of representation for a data object can have a\nlarge impact on the performance of the programs that use the data.\nAnother reason for concentrating on sets is that the techniques\ndiscussed here appear again and again in applications involving\ninformation retrieval.<p>\n\n<a name="%_idx_2202"></a>Consider a data base containing a large number of individual records,\n<a name="%_idx_2204"></a>such as the personnel files for a company or the transactions in an\naccounting system.  A typical data-management system spends a large\namount of time accessing or modifying the data in the records and\ntherefore requires an efficient method for accessing records.  This is\ndone by identifying a part of each record to serve as an identifying\n<a name="%_idx_2206"></a><em>key</em>.  A key can be anything that uniquely identifies the\nrecord.  For a personnel file, it might be an employee\'s ID number.\nFor an accounting system, it might be a transaction number.  Whatever\nthe key is, when we define the record as a data structure we should\ninclude a <a name="%_idx_2208"></a><tt>key</tt> selector procedure that retrieves the key\nassociated with a given record.<p>\n\nNow we represent the data base as a set of records. To locate the\nrecord with a given key we use a procedure <tt>lookup</tt>, which takes\nas arguments a key and a data base and which returns the record that\nhas that key, or false if there is no such record.  <tt>Lookup</tt>\nis implemented in almost the same way as <tt>element-of-set?</tt>.  For\nexample, if the set of records is implemented as an unordered list, we\ncould use<p>\n\n<p><p><tt><a name="%_idx_2210"></a>(define&nbsp;(lookup&nbsp;given-key&nbsp;set-of-records)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;set-of-records)&nbsp;false)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal?&nbsp;given-key&nbsp;(key&nbsp;(car&nbsp;set-of-records)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;set-of-records))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(lookup&nbsp;given-key&nbsp;(cdr&nbsp;set-of-records)))))<br>\n</tt><p><p><p>\n\nOf course, there are better ways to represent large sets than as\nunordered lists.  Information-retrieval systems in which records have\nto be ``randomly accessed\'\' are typically implemented by a tree-based\nmethod, such as the binary-tree representation discussed previously.\nIn designing such a system the methodology of data abstraction\ncan be a great help.  The designer can create an initial\nimplementation using a simple, straightforward representation such as\nunordered lists.  This will be unsuitable for the eventual system, but\nit can be useful in providing a ``quick and dirty\'\' data base with\nwhich to test the rest of the system.  Later on, the data\nrepresentation can be modified to be more sophisticated.  If the data\nbase is accessed in terms of abstract selectors and constructors, this\nchange in representation will not require any changes to the rest of\nthe system.<p>\n\n<p><a name="%_thm_2.66"></a>\n<b>Exercise 2.66.</b>&nbsp;&nbsp;Implement the <tt>lookup</tt> procedure for the case\nwhere the set of records is structured as a binary tree, ordered by\nthe numerical values of the keys.\n\n<p><p>\n\n<a name="%_sec_2.3.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.3.4">2.3.4&nbsp;&nbsp;Example: Huffman Encoding Trees</a></h3><p>\n\n<a name="%_idx_2212"></a>\nThis section provides practice in the use of list structure and data\nabstraction to manipulate sets and trees.  The application is to\nmethods for representing data as sequences of ones and zeros (bits).\nFor example, the <a name="%_idx_2214"></a><a name="%_idx_2216"></a>ASCII standard code used to represent text in\ncomputers encodes each <a name="%_idx_2218"></a>character as a sequence of seven bits.  Using\nseven bits allows us to distinguish 2<sup>7</sup>, or 128, possible different\ncharacters.  In general, if we want to distinguish <em>n</em> different\nsymbols, we will need to use <tt>log</tt><sub>2</sub> <em>n</em> bits per symbol.  If all our\nmessages are made up of the eight symbols A, B, C, D, E, F, G, and H,\nwe can choose a code with three bits per character, for example\n<table border=0><tr><td valign=top >A 000 </td><td valign=top >C 010 </td><td valign=top >E 100 </td><td valign=top >G 110</td></tr>\n<tr><td valign=top >B 001 </td><td valign=top >D 011 </td><td valign=top >F 101 </td><td valign=top >H 111\n</td></tr></table>\nWith this code, the message<p>\n\n<p><p>BACADAEAFABBAAAGAH<p>\n\n<p><p>is encoded as the string of 54 bits<p>\n\n<p><p>001000010000011000100000101000001001000000000110000111<p>\n\n<p><p>Codes such as ASCII and the A-through-H code above are known as <a name="%_idx_2220"></a><a name="%_idx_2222"></a><em>fixed-length</em> codes, because they represent each symbol in the message\nwith the same number of bits.  It is sometimes advantageous to use\n<a name="%_idx_2224"></a><a name="%_idx_2226"></a><em>variable-length</em> codes, in which different symbols may be\nrepresented by different numbers of bits.  For example, <a name="%_idx_2228"></a><a name="%_idx_2230"></a>Morse code\ndoes not use the same number of dots and dashes for each letter of the\nalphabet.  In particular, E, the most frequent letter, is represented\nby a single dot.  In general, if our messages are such that some\nsymbols appear very frequently and some very rarely, we can encode\ndata more efficiently (i.e., using fewer bits per message) if we\nassign shorter codes to the frequent symbols.  Consider the following\nalternative code for the letters A through H:\n<table border=0><tr><td valign=top >A 0 </td><td valign=top >C 1010 </td><td valign=top >E 1100 </td><td valign=top >G 1110</td></tr>\n<tr><td valign=top >B 100 </td><td valign=top >D 1011 </td><td valign=top >F 1101 </td><td valign=top >H 1111\n</td></tr></table>\nWith this code, the same message as above is encoded as the string<p>\n\n<p><p>100010100101101100011010100100000111001111<p>\n\n<p><p>This string contains 42 bits, so it saves more than 20% in space in\ncomparison with the fixed-length code shown above.<p>\n\nOne of the difficulties of using a variable-length code is knowing\nwhen you have reached the end of a symbol in reading a sequence of\nzeros and ones.  Morse code solves this problem by using a special\n<a name="%_idx_2232"></a><em>separator code</em> (in this case, a pause) after the sequence of\ndots and dashes for each letter.  Another solution is to design the\ncode in such a way that no complete code for any symbol is the\nbeginning (or <em>prefix</em>) of the code for another symbol.  Such a\ncode is called a <a name="%_idx_2234"></a><a name="%_idx_2236"></a><em>prefix code</em>.  In the example above, A is\nencoded by 0 and B is encoded by 100, so no other symbol can have a\ncode that begins with 0 or with 100.<p>\n\nIn general, we can attain significant savings if we use\nvariable-length prefix codes that take advantage of the relative\nfrequencies of the symbols in the messages to be encoded.  One\nparticular scheme for doing this is called the Huffman encoding\nmethod, after its discoverer, <a name="%_idx_2238"></a>David Huffman.  A Huffman code can be\nrepresented as a <a name="%_idx_2240"></a><a name="%_idx_2242"></a>binary tree whose leaves are the symbols that are\nencoded.  At each non-leaf node of the tree there is a set containing\nall the symbols in the leaves that lie below the node.  In addition,\neach symbol at a leaf is assigned a weight (which is its\nrelative frequency), and each non-leaf\nnode contains a weight that is the sum of all the weights of the\nleaves lying below it.  The weights are not used in the encoding or\nthe decoding process.  We will see below how they are used to help\nconstruct the tree.<p>\n\n<a name="%_fig_2.18"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-53.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.18:</b>&nbsp;&nbsp;A Huffman encoding tree.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nFigure&nbsp;<a href="#%_fig_2.18">2.18</a> shows the Huffman tree for the A-through-H \ncode given above.  The weights at the leaves\nindicate that the tree was designed for messages in which A appears\nwith relative frequency 8, B with relative frequency 3, and the\nother letters each with relative frequency 1.<p>\n\nGiven a Huffman tree, we can find the encoding of any symbol by\nstarting at the root and moving down until we reach the leaf that\nholds the symbol.  Each time we move down a left branch we add a 0 to\nthe code, and each time we move down a right branch we add a 1.  (We\ndecide which branch to follow by testing to see which branch either is\nthe leaf node for the symbol or contains the symbol in its set.)  For\nexample, starting from the root of the tree in\nfigure&nbsp;<a href="#%_fig_2.18">2.18</a>, we arrive at the leaf for D by following a\nright branch, then a left branch, then a right branch, then a right\nbranch; hence, the code for D is 1011.<p>\n\nTo decode a bit sequence using a Huffman tree, we begin at the root\nand use the successive zeros and ones of the bit sequence to determine\nwhether to move down the left or the right branch.  Each time we come\nto a leaf, we have generated a new symbol in the message, at which\npoint we start over from the root of the tree to find the next symbol.\nFor example, suppose we are given the tree above and the sequence\n10001010.  Starting at the root, we move down the right branch, (since\nthe first bit of the string is&nbsp;1), then down the left branch (since\nthe second bit is&nbsp;0), then down the left branch (since the third bit\nis also&nbsp;0).  This brings us to the leaf for&nbsp;B, so the first symbol of\nthe decoded message is&nbsp;B.  Now we start again at the root, and we make\na left move because the next bit in the string is&nbsp;0.  This brings us\nto the leaf for&nbsp;A.  Then we start again at the root with the rest of\nthe string 1010, so we move right, left, right, left and reach&nbsp;C.\nThus, the entire message is BAC.<p>\n\n<a name="%_sec_Temp_257"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_257">Generating Huffman trees</a></h4><p>\n\nGiven an ``alphabet\'\' of symbols and their relative frequencies, how\ndo we construct the ``best\'\' code?  (In other words, which tree will\nencode messages with the fewest bits?)  Huffman gave an algorithm for\ndoing this and showed that the resulting code is indeed the best\nvariable-length code for messages where the relative frequency of the\nsymbols matches the frequencies with which the code was constructed.\n<a name="%_idx_2244"></a><a name="%_idx_2246"></a>We will not prove this optimality of Huffman codes here, but we will\nshow how Huffman trees are constructed.<a name="call_footnote_Temp_258" href="#footnote_Temp_258"><sup><small>42</small></sup></a><p>\n\nThe algorithm for generating a Huffman tree is very simple. The idea\nis to arrange the tree so that the symbols with the lowest frequency\nappear farthest away from the root. Begin with the set of leaf nodes,\ncontaining symbols and their frequencies, as determined by the initial data\nfrom which the code is to be constructed. Now find two leaves with\nthe lowest weights and merge them to produce a node that has these\ntwo nodes as its left and right branches. The weight of the new node\nis the sum of the two weights. Remove the two leaves from the\noriginal set and replace them by this new node. Now continue this\nprocess. At each step, merge two nodes with the smallest weights,\nremoving them from the set and replacing them with a node that has\nthese two as its left and right branches. The process stops when\nthere is only one node left, which is the root of the entire tree.\nHere is how the Huffman tree of figure&nbsp;<a href="#%_fig_2.18">2.18</a> was generated:<p>\n\n<table border=0><tr><td valign=top >Initial leaves </td><td valign=top >{(A 8)  (B 3)  (C 1)\n (D 1)  (E 1)  (F 1)  (G 1)  (H 1)}</td></tr>\n<tr><td valign=top ><p>\n\nMerge </td><td valign=top >{(A 8)  (B 3)  ({C D} 2)  (E\n1)  (F 1)  (G 1)  (H 1)}</td></tr>\n<tr><td valign=top ><p>\n\nMerge </td><td valign=top >{(A 8)  (B 3)  ({C D} 2) \n({E F} 2)  (G 1)  (H 1)}</td></tr>\n<tr><td valign=top ><p>\n\nMerge </td><td valign=top >{(A 8)  (B 3)  ({C D} 2) \n({E F} 2)   ({G H} 2)}</td></tr>\n<tr><td valign=top ><p>\n\nMerge </td><td valign=top >{(A 8)   (B 3)  ({C D} 2)  ({E F G H} 4)}</td></tr>\n<tr><td valign=top ><p>\n\nMerge </td><td valign=top >{(A 8)  ({B C D} 5)  ({E F G H} 4)}</td></tr>\n<tr><td valign=top ><p>\n\nMerge </td><td valign=top >{(A 8)  ({B C D E F G H} 9)}</td></tr>\n<tr><td valign=top ><p>\n\nFinal merge </td><td valign=top >{({A B C D E F G H} 17)}</td></tr>\n<tr><td valign=top ></td></tr></table>\nThe algorithm does not always specify a unique tree, because there may\nnot be unique smallest-weight nodes at each step.  Also, the choice of\nthe order in which the two nodes are merged (i.e., which will be the\nright branch and which will be the left branch) is arbitrary.<p>\n\n<a name="%_sec_Temp_259"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_259">Representing Huffman trees</a></h4><p>\n\nIn the exercises below we will work with a system that uses\nHuffman trees to encode and decode messages and generates Huffman\ntrees according to the algorithm outlined above.  We will begin by\ndiscussing how trees are represented.<p>\n\nLeaves of the tree are represented by a list consisting of the\nsymbol <tt>leaf</tt>, the symbol at the leaf, and the weight:<p>\n\n<p><p><tt><a name="%_idx_2250"></a>(define&nbsp;(make-leaf&nbsp;symbol&nbsp;weight)<br>\n&nbsp;&nbsp;(list&nbsp;\'leaf&nbsp;symbol&nbsp;weight))<br>\n<a name="%_idx_2252"></a>(define&nbsp;(leaf?&nbsp;object)<br>\n&nbsp;&nbsp;(eq?&nbsp;(car&nbsp;object)&nbsp;\'leaf))<br>\n<a name="%_idx_2254"></a>(define&nbsp;(symbol-leaf&nbsp;x)&nbsp;(cadr&nbsp;x))<br>\n<a name="%_idx_2256"></a>(define&nbsp;(weight-leaf&nbsp;x)&nbsp;(caddr&nbsp;x))<br>\n</tt><p><p>\nA general tree will be a list of a left branch, a right branch, a set\nof symbols, and a weight.  The set of symbols will be simply a list of\nthe symbols, rather than some more sophisticated set representation.\nWhen we make a tree by merging two nodes, we obtain the weight of the\ntree as the sum of the weights of the nodes, and the set of symbols as\nthe union of the sets of symbols for the nodes.  Since our symbol sets are\nrepresented as lists, we can form the union by using the <tt>append</tt>\nprocedure we defined in section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.1">2.2.1</a>:<p>\n\n<p><p><tt><a name="%_idx_2258"></a>(define&nbsp;(make-code-tree&nbsp;left&nbsp;right)<br>\n&nbsp;&nbsp;(list&nbsp;left<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append&nbsp;(symbols&nbsp;left)&nbsp;(symbols&nbsp;right))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(weight&nbsp;left)&nbsp;(weight&nbsp;right))))<br>\n</tt><p><p>\nIf we make a tree in this way, we have the following selectors:<p>\n\n<p><p><tt><a name="%_idx_2260"></a>(define&nbsp;(left-branch&nbsp;tree)&nbsp;(car&nbsp;tree))<br>\n<br>\n<a name="%_idx_2262"></a>(define&nbsp;(right-branch&nbsp;tree)&nbsp;(cadr&nbsp;tree))<br>\n<a name="%_idx_2264"></a>(define&nbsp;(symbols&nbsp;tree)<br>\n&nbsp;&nbsp;(if&nbsp;(leaf?&nbsp;tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(symbol-leaf&nbsp;tree))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(caddr&nbsp;tree)))<br>\n<a name="%_idx_2266"></a>(define&nbsp;(weight&nbsp;tree)<br>\n&nbsp;&nbsp;(if&nbsp;(leaf?&nbsp;tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(weight-leaf&nbsp;tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cadddr&nbsp;tree)))<br>\n</tt><p><p>\nThe procedures <tt>symbols</tt> and <tt>weight</tt> must do something\nslightly different depending on whether they are called with a leaf or\na general tree.  These are simple examples of <a name="%_idx_2268"></a><a name="%_idx_2270"></a><em>generic\nprocedures</em> (procedures that can handle more than one kind of data),\nwhich we will have much more to say about in\nsections&nbsp;<a href="book-Z-H-17.html#%_sec_2.4">2.4</a> and&nbsp;<a href="book-Z-H-18.html#%_sec_2.5">2.5</a>.<p>\n\n<a name="%_sec_Temp_260"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_260">The decoding procedure</a></h4><p>\n\nThe following procedure implements the decoding algorithm.\nIt takes as arguments a list of zeros and ones, together with\na Huffman tree.<p>\n\n<p><p><tt><a name="%_idx_2272"></a>(define&nbsp;(decode&nbsp;bits&nbsp;tree)<br>\n&nbsp;&nbsp;(define&nbsp;(decode-1&nbsp;bits&nbsp;current-branch)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;bits)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((next-branch<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(choose-branch&nbsp;(car&nbsp;bits)&nbsp;current-branch)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(leaf?&nbsp;next-branch)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(symbol-leaf&nbsp;next-branch)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(decode-1&nbsp;(cdr&nbsp;bits)&nbsp;tree))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(decode-1&nbsp;(cdr&nbsp;bits)&nbsp;next-branch)))))<br>\n&nbsp;&nbsp;(decode-1&nbsp;bits&nbsp;tree))<br>\n(define&nbsp;(choose-branch&nbsp;bit&nbsp;branch)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;bit&nbsp;0)&nbsp;(left-branch&nbsp;branch))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;bit&nbsp;1)&nbsp;(right-branch&nbsp;branch))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;bad&nbsp;bit&nbsp;--&nbsp;CHOOSE-BRANCH&quot;&nbsp;bit))))<br>\n</tt><p><p>\nThe procedure <tt>decode-1</tt> takes two arguments: the list of remaining bits\nand the current position in the tree.  It keeps moving\n``down\'\' the tree, choosing a left or a right branch according to\nwhether the next bit in the list is a zero or a one.  (This is done\nwith the procedure <tt>choose-branch</tt>.)  When it reaches a leaf, it\nreturns the symbol at that leaf as the next symbol in the message by\n<tt>cons</tt>ing it onto the result of decoding\nthe rest of the message, starting at the root of the tree.\nNote the error check in the final clause of <tt>choose-branch</tt>, which\ncomplains if the procedure finds something other than a zero or a one in the\ninput data.<p>\n\n<a name="%_sec_Temp_261"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_261">Sets of weighted elements</a></h4><p>\n\nIn our representation of trees, each non-leaf node contains a set of\nsymbols, which we have represented as a simple list.  However, the\ntree-generating algorithm discussed above requires that we also work\nwith sets of leaves and trees, successively merging the two smallest\nitems.  Since we will be required to repeatedly find the smallest item\nin a set, it is convenient to use an ordered representation for this\nkind of set.<p>\n\nWe will represent a set of leaves and trees as a list of elements,\narranged in increasing order of weight.  The following <tt>adjoin-set</tt> procedure for constructing sets is similar to the one\ndescribed in exercise&nbsp;<a href="#%_thm_2.61">2.61</a>; however, items are compared\nby their weights, and the element being added to the set is\nnever already in it.<p>\n\n<p><p><tt><a name="%_idx_2274"></a>(define&nbsp;(adjoin-set&nbsp;x&nbsp;set)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;set)&nbsp;(list&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;(weight&nbsp;x)&nbsp;(weight&nbsp;(car&nbsp;set)))&nbsp;(cons&nbsp;x&nbsp;set))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(cons&nbsp;(car&nbsp;set)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(adjoin-set&nbsp;x&nbsp;(cdr&nbsp;set))))))<br>\n</tt><p><p><p>\n\nThe following procedure takes a list of\nsymbol-frequency pairs such as <tt>((A 4) (B 2) (C 1) (D 1))</tt> and\nconstructs an initial ordered set of leaves, ready to be merged\naccording to the Huffman algorithm:<p>\n\n<p><p><tt><a name="%_idx_2276"></a>(define&nbsp;(make-leaf-set&nbsp;pairs)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;pairs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((pair&nbsp;(car&nbsp;pairs)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(adjoin-set&nbsp;(make-leaf&nbsp;(car&nbsp;pair)&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;symbol</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cadr&nbsp;pair))&nbsp;&nbsp;<em>;&nbsp;frequency</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-leaf-set&nbsp;(cdr&nbsp;pairs))))))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_2.67"></a>\n<b>Exercise 2.67.</b>&nbsp;&nbsp;Define an encoding tree and a sample message:<p>\n\n\n<p><p><tt>(define&nbsp;sample-tree<br>\n&nbsp;&nbsp;(make-code-tree&nbsp;(make-leaf&nbsp;\'A&nbsp;4)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-code-tree<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-leaf&nbsp;\'B&nbsp;2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-code-tree&nbsp;(make-leaf&nbsp;\'D&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-leaf&nbsp;\'C&nbsp;1)))))<br>\n<br>\n(define&nbsp;sample-message&nbsp;\'(0&nbsp;1&nbsp;1&nbsp;0&nbsp;0&nbsp;1&nbsp;0&nbsp;1&nbsp;0&nbsp;1&nbsp;1&nbsp;1&nbsp;0))<br>\n</tt><p><p>\nUse the <tt>decode</tt> procedure to decode the\nmessage, and give the result.\n\n<p><p>\n\n\n<p><a name="%_thm_2.68"></a>\n<b>Exercise 2.68.</b>&nbsp;&nbsp;The <tt>encode</tt> procedure takes as arguments a message and a tree and\nproduces the list of bits that gives the encoded message.<p>\n\n\n<p><p><tt><a name="%_idx_2278"></a>(define&nbsp;(encode&nbsp;message&nbsp;tree)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;message)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append&nbsp;(encode-symbol&nbsp;(car&nbsp;message)&nbsp;tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(encode&nbsp;(cdr&nbsp;message)&nbsp;tree))))<br>\n</tt><p><p>\n<tt>Encode-symbol</tt> is a procedure, which you must write, that returns\nthe list of bits that encodes a given symbol according to a given\ntree.  You should design <tt>encode-symbol</tt> so that it signals an\nerror if the symbol is not in the tree at all.  Test your procedure by\nencoding the result you obtained in exercise&nbsp;<a href="#%_thm_2.67">2.67</a> with\nthe sample tree and seeing whether it is the same as the original\nsample message.\n<p><p>\n\n<p><a name="%_thm_2.69"></a>\n<b>Exercise 2.69.</b>&nbsp;&nbsp;The following procedure takes as its argument a list of\nsymbol-frequency pairs (where no symbol appears in more than one pair)\nand generates a Huffman encoding tree according to the Huffman\nalgorithm.<p>\n\n<p><p><tt><a name="%_idx_2280"></a>(define&nbsp;(generate-huffman-tree&nbsp;pairs)<br>\n&nbsp;&nbsp;(successive-merge&nbsp;(make-leaf-set&nbsp;pairs)))<br>\n</tt><p><p>\n<tt>Make-leaf-set</tt> is the procedure given above that transforms the\nlist of pairs into an ordered set of leaves.  <tt>Successive-merge</tt>\nis the procedure you must write, using <tt>make-code-tree</tt> to\nsuccessively merge the smallest-weight elements of the set until there\nis only one element left, which is the desired Huffman tree.  (This\nprocedure is slightly tricky, but not really complicated.  If you find\nyourself designing a complex procedure, then you are almost certainly\ndoing something wrong.  You can take significant advantage of the fact\nthat we are using an ordered set representation.)\n\n<p><p>\n\n<p><a name="%_thm_2.70"></a>\n<b>Exercise 2.70.</b>&nbsp;&nbsp;<a name="%_idx_2282"></a>The following eight-symbol alphabet with associated relative\nfrequencies was designed to efficiently encode the lyrics of 1950s\nrock songs.  (Note that the ``symbols\'\' of an ``alphabet\'\' need not be\nindividual letters.)<p>\n\n<table border=0><tr><td valign=top >A    </td><td valign=top >2 </td><td valign=top >NA  </td><td valign=top >16</td></tr>\n<tr><td valign=top >BOOM </td><td valign=top >1 </td><td valign=top >SHA </td><td valign=top >3</td></tr>\n<tr><td valign=top >GET  </td><td valign=top >2 </td><td valign=top >YIP </td><td valign=top >9</td></tr>\n<tr><td valign=top >JOB  </td><td valign=top >2 </td><td valign=top >WAH </td><td valign=top >1\n</td></tr></table>\nUse <tt>generate-huffman-tree</tt> (exercise&nbsp;<a href="#%_thm_2.69">2.69</a>)\nto generate a corresponding Huffman tree, and use\n<tt>encode</tt> (exercise&nbsp;<a href="#%_thm_2.68">2.68</a>)\nto encode the following message:<p>\n\n<p><p>Get a job<p>\n\nSha na na na na na na na na<p>\n\nGet a job<p>\n\nSha na na na na na na na na<p>\n\nWah yip yip yip yip yip yip yip yip yip<p>\n\nSha boom<p>\n\n<p><p>How many bits are required for the encoding?  What is the smallest\nnumber of bits that would be needed to encode this song if we \nused a fixed-length code for the eight-symbol alphabet?\n<p><p>\n\n<p><a name="%_thm_2.71"></a>\n<b>Exercise 2.71.</b>&nbsp;&nbsp;Suppose we have a Huffman tree for an alphabet of <em>n</em> symbols, and\nthat the relative frequencies of the symbols are 1, 2, 4, <tt>...</tt>,\n2<sup><em>n</em>-1</sup>.  Sketch the tree for <em>n</em>=5; for <em>n</em>=10.  In such a tree\n(for general <em>n</em>) how many bits are required to encode the most\nfrequent symbol?  the least frequent symbol?\n\n<p><p>\n\n<p><a name="%_thm_2.72"></a>\n<b>Exercise 2.72.</b>&nbsp;&nbsp;<a name="%_idx_2284"></a>Consider the encoding procedure that you designed in\nexercise&nbsp;<a href="#%_thm_2.68">2.68</a>.  What is the order of growth in the\nnumber of steps needed to encode a symbol?  Be sure to include the\nnumber of steps needed to search the symbol list at each node\nencountered.  To answer this question in general is difficult.\nConsider the special case where the relative frequencies of the <em>n</em>\nsymbols are as described in exercise&nbsp;<a href="#%_thm_2.71">2.71</a>, and give\nthe order of growth (as a function of <em>n</em>) of the number of steps\nneeded to encode the most frequent and least frequent symbols in the\nalphabet.\n<p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_227" href="#call_footnote_Temp_227"><sup><small>32</small></sup></a> Allowing quotation in a language wreaks havoc\nwith the ability to reason about the language in simple terms, because\nit destroys the notion that equals can be substituted for equals.  For\nexample, three is one plus two, but the word ``three\'\' is not the\nphrase ``one plus two.\'\'  Quotation is powerful because it gives us a way\nto build expressions that manipulate other expressions (as we will see\nwhen we write an interpreter in chapter&nbsp;4). But allowing statements in\na language that talk about other statements in that language makes it\nvery difficult to maintain any coherent principle of what ``equals can\nbe substituted for equals\'\' should mean.  For example, if we know that\n<a name="%_idx_1996"></a>the evening star is the morning star, then from the statement ``the\nevening star is Venus\'\' we can deduce ``the morning star is Venus.\'\'\nHowever, given that ``John knows that the evening star is Venus\'\' we\ncannot infer that ``John knows that the morning star is Venus.\'\'\n\n<p><a name="footnote_Temp_228" href="#call_footnote_Temp_228"><sup><small>33</small></sup></a> The single quote is different <a name="%_idx_2002"></a><a name="%_idx_2004"></a><a name="%_idx_2006"></a><a name="%_idx_2008"></a>from the double quote we have\nbeen using to enclose character strings to be printed.  Whereas the\nsingle quote can be used to denote lists or symbols, the double quote\nis used only with character strings.  In this book, the only use for\ncharacter strings is as items to be printed.\n\n<p><a name="footnote_Temp_229" href="#call_footnote_Temp_229"><sup><small>34</small></sup></a> Strictly, our\nuse of the quotation mark violates the general rule that all compound\nexpressions in our language should be delimited by parentheses\nand look like lists.  We\n<a name="%_idx_2014"></a><a name="%_idx_2016"></a>can recover this consistency by introducing a special form <tt>quote</tt>, which serves the same purpose as the quotation mark.  Thus, we\nwould type <tt>(quote a)</tt> instead of <tt>\'a</tt>, and we would type <tt>(quote (a b c))</tt> instead of <tt>\'(a b c)</tt>.  This is precisely how the\ninterpreter works.  The quotation mark is just a single-character\nabbreviation for wrapping the next complete expression with <tt>quote</tt> to form <tt>(quote &lt;<em>expression</em>&gt;)</tt>.  This is important\nbecause it maintains the principle that any expression seen by the\ninterpreter can be manipulated as a data object.  For instance, we\ncould construct the expression\n<tt>(car \'(a&nbsp;b&nbsp;c))</tt>, which is the same as <tt>(car (quote (a b c)))</tt>,\nby evaluating <tt>(list&nbsp;\'car&nbsp;(list&nbsp;\'quote&nbsp;\'(a&nbsp;b&nbsp;c)))</tt>.\n\n<p><a name="footnote_Temp_230" href="#call_footnote_Temp_230"><sup><small>35</small></sup></a> We can consider two symbols to be ``the same\'\' if they\nconsist of the same characters in the same order.  Such a definition\nskirts a deep issue that we are not yet ready to address: the meaning\nof ``sameness\'\' in a programming language.  We will return to this in\nchapter&nbsp;3 (section&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a>).\n\n<p><a name="footnote_Temp_233" href="#call_footnote_Temp_233"><sup><small>36</small></sup></a> In practice, programmers\nuse <tt>equal?</tt> to compare lists that contain numbers as well as\nsymbols.  Numbers are not considered to be symbols.  The question\n<a name="%_idx_2038"></a><a name="%_idx_2040"></a>of whether two numerically equal numbers (as tested by <tt>=</tt>) are also\n<tt>eq?</tt> is highly implementation-dependent.  A better definition\nof <tt>equal?</tt> (such as the one that comes as a primitive in Scheme)\nwould also stipulate that if <tt>a</tt> and <tt>b</tt> are\nboth numbers, then <tt>a</tt> and <tt>b</tt> are <tt>equal?</tt> if they are\nnumerically equal.\n\n<p><a name="footnote_Temp_240" href="#call_footnote_Temp_240"><sup><small>37</small></sup></a> If\nwe want to be more formal, we can specify ``consistent with the\ninterpretations given above\'\' to mean that the operations satisfy a\ncollection of rules such as these:<p>\n\n<p><ul>\n<li>For any set <tt>S</tt> and any object <tt>x</tt>,\n<tt>(element-of-set? x (adjoin-set x S))</tt>\nis true (informally: ``Adjoining an object to a \nset produces a set that contains the object\'\').<p>\n\n<li>For any sets <tt>S</tt> and <tt>T</tt> and any object <tt>x</tt>,\n<tt>(element-of-set? x (union-set S T))</tt>\nis equal to\n<tt>(or (element-of-set? x S) (element-of-set? x T))</tt>\n(informally: ``The elements of <tt>(union S T)</tt> are the elements that\nare in <tt>S</tt> or in <tt>T</tt>\'\').<p>\n\n<li>For any object <tt>x</tt>,\n<tt>(element-of-set? x \'())</tt>\nis false (informally: ``No object is an element of the empty set\'\').\n</ul><p>\n\n\n<p><a name="footnote_Temp_248" href="#call_footnote_Temp_248"><sup><small>38</small></sup></a> Halving the size of the problem at each step is the\ndistinguishing characteristic of <a name="%_idx_2148"></a>logarithmic growth, as we saw with\nthe fast-exponentiation algorithm of section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.4">1.2.4</a>\nand the half-interval search method of\nsection&nbsp;<a href="book-Z-H-12.html#%_sec_1.3.3">1.3.3</a>.\n\n<p><a name="footnote_Temp_249" href="#call_footnote_Temp_249"><sup><small>39</small></sup></a> We are\nrepresenting sets in terms of trees, and trees in terms of lists -- in\neffect, a data abstraction built upon a data abstraction.  We can\nregard the procedures <tt>entry</tt>, <tt>left-branch</tt>, <tt>right-branch</tt>, and <tt>make-tree</tt> as a way of isolating the\nabstraction of a ``binary tree\'\' from the particular way we might wish\nto represent such a tree in terms of list structure.\n\n<p><a name="footnote_Temp_250" href="#call_footnote_Temp_250"><sup><small>40</small></sup></a> Examples of such structures include\n<a name="%_idx_2168"></a><a name="%_idx_2170"></a><a name="%_idx_2172"></a><a name="%_idx_2174"></a><em>B-trees</em> and <em>red-black trees</em>.  There is a large literature on\ndata structures devoted to this problem.  See Cormen,\n<a name="%_idx_2176"></a><a name="%_idx_2178"></a><a name="%_idx_2180"></a>Leiserson, and Rivest 1990.\n\n<p><a name="footnote_Temp_254" href="#call_footnote_Temp_254"><sup><small>41</small></sup></a> Exercises&nbsp;<a href="#%_thm_2.63">2.63</a>-<a href="#%_thm_2.65">2.65</a>\n<a name="%_idx_2198"></a>are due to Paul Hilfinger.\n\n<p><a name="footnote_Temp_258" href="#call_footnote_Temp_258"><sup><small>42</small></sup></a> See Hamming 1980\n<a name="%_idx_2248"></a>for a discussion of the mathematical properties of Huffman codes.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_2.4"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_2.4">2.4&nbsp;&nbsp;Multiple Representations for Abstract Data</a></h2><p>\n\n\n<a name="%_idx_2286"></a><a name="%_idx_2288"></a>\nWe have introduced data abstraction, a methodology for structuring\nsystems in such a way that much of a program can be specified\nindependent of the choices involved in implementing the data objects\nthat the program manipulates.  For example, we saw in\nsection&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a> how to separate the task of designing a\nprogram that uses rational numbers from the task of implementing\nrational numbers in terms of the computer language\'s primitive\nmechanisms for constructing compound data.  The key idea was to erect\nan abstraction barrier -- in this case, the selectors and constructors\nfor rational numbers (<tt>make-rat</tt>, <tt>numer</tt>, <tt>denom</tt>) -- that\nisolates the way rational numbers are used from their underlying\nrepresentation in terms of list structure.  A similar abstraction\nbarrier isolates the details of the procedures that perform rational\narithmetic (<tt>add-rat</tt>, <tt>sub-rat</tt>, <tt>mul-rat</tt>, and <tt>div-rat</tt>) from the ``higher-level\'\' procedures that use rational\nnumbers.  The resulting program has the structure shown in\nfigure&nbsp;<a href="book-Z-H-14.html#%_fig_2.1">2.1</a>.<p>\n\nThese data-abstraction barriers are powerful tools for controlling\ncomplexity.  By isolating the underlying representations of data\nobjects, we can divide the task of designing a large program into\nsmaller tasks that can be performed separately.  But this kind of data\nabstraction is not yet powerful enough, because it may not always make\nsense to speak of ``the underlying representation\'\' for a data object.<p>\n\n\nFor one thing, there might be more than one useful representation for\na data object, and we might like to design systems that can deal with\nmultiple representations.  To take a simple example, complex numbers\nmay be represented in two almost equivalent ways: in rectangular form\n(real and imaginary parts) and in polar form (magnitude and angle).\nSometimes rectangular form is more appropriate and sometimes polar\nform is more appropriate.  Indeed, it is perfectly plausible to\nimagine a system in which complex numbers are represented in both\nways, and in which the procedures for manipulating complex numbers work\nwith either representation.<p>\n\nMore importantly, programming systems are often designed by many\npeople working over extended periods of time, subject to requirements\nthat change over time.  In such an environment, it is simply not\npossible for everyone to agree in advance on choices of data\nrepresentation.  So in addition to the data-abstraction barriers that\nisolate representation from use, we need abstraction barriers that\nisolate different design choices from each other and permit different\nchoices to coexist in a single program.  Furthermore, since large\nprograms are often created by combining pre-existing modules that were\ndesigned in isolation, we need conventions that permit programmers to\nincorporate modules into larger systems <a name="%_idx_2290"></a><em>additively</em>, that is,\nwithout having to redesign or reimplement these modules.<p>\n\nIn this section, we will learn how to cope with data that may be\nrepresented in different ways by different parts of a program.  This\nrequires constructing <a name="%_idx_2292"></a><a name="%_idx_2294"></a><em>generic procedures</em> -- procedures that can\noperate on data that may be represented in more than one way.  Our\nmain technique for building generic procedures will be to work in terms\nof data objects that have <a name="%_idx_2296"></a><em>type tags</em>, that is, data objects\nthat include explicit information about how they are to be processed.\nWe will also discuss <a name="%_idx_2298"></a><em>data-directed</em> programming, a powerful and\nconvenient implementation strategy for additively assembling systems\nwith generic operations.<p>\n\nWe begin with the simple complex-number example. We will see how\ntype tags and data-directed style enable us to design separate\nrectangular and polar representations for complex numbers while\nmaintaining the notion of an abstract ``complex-number\'\' data object.\n<a name="%_idx_2300"></a><a name="%_idx_2302"></a>We will accomplish this by defining arithmetic procedures for complex\nnumbers (<tt>add-complex</tt>, <tt>sub-complex</tt>, <tt>mul-complex</tt>, and\n<tt>div-complex</tt>) in terms of generic selectors that access parts of\na complex number independent of how the number is represented.  The\nresulting complex-number system, as shown in\nfigure&nbsp;<a href="#%_fig_2.19">2.19</a>, contains two different kinds of\n<a name="%_idx_2304"></a>abstraction barriers.  The ``horizontal\'\' abstraction barriers play\nthe same role as the ones in\nfigure&nbsp;<a href="book-Z-H-14.html#%_fig_2.1">2.1</a>.  They isolate ``higher-level\'\'\noperations from ``lower-level\'\' representations.  In addition, there\nis a ``vertical\'\' barrier that gives us the ability to separately\ndesign and install alternative representations.<p>\n\n<a name="%_fig_2.19"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-54.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.19:</b>&nbsp;&nbsp;Data-abstraction barriers in the complex-number system.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n\nIn section&nbsp;<a href="book-Z-H-18.html#%_sec_2.5">2.5</a> we will show how to use\ntype tags and data-directed style to develop a generic arithmetic\npackage.  This provides procedures (<tt>add</tt>, <tt>mul</tt>, and so on)\nthat can be used to manipulate all sorts of ``numbers\'\' and can be\neasily extended when a new kind of number is needed.\nIn section&nbsp;<a href="book-Z-H-18.html#%_sec_2.5.3">2.5.3</a>, we\'ll show how to use generic\narithmetic in a system that performs symbolic algebra.<p>\n\n<a name="%_sec_2.4.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.4.1">2.4.1&nbsp;&nbsp;Representations for Complex Numbers</a></h3><p>\n\n<p>\n\n<a name="%_idx_2306"></a>We will develop a system that performs arithmetic operations on\ncomplex numbers as a simple but unrealistic example of a program that\nuses generic operations.  We begin by discussing two plausible\nrepresentations for complex numbers as ordered pairs: rectangular form\n(real part and imaginary part) and polar form (magnitude and\nangle).<a name="call_footnote_Temp_268" href="#footnote_Temp_268"><sup><small>43</small></sup></a>  Section&nbsp;<a href="#%_sec_2.4.2">2.4.2</a>\nwill show how both representations can be made to coexist in a single\nsystem through the use of type tags and generic operations.<p>\n\nLike rational numbers, complex numbers are naturally represented as\nordered pairs.  The set of complex numbers can be thought of as a\ntwo-dimensional space with two orthogonal axes, the ``real\'\' axis and\nthe ``imaginary\'\' axis. (See figure&nbsp;<a href="#%_fig_2.20">2.20</a>.)  From\nthis point of view, the complex number <em>z</em> = <em>x</em> + <em>i</em><em>y</em> (where <em>i</em><sup>2</sup>  =  - 1)\ncan be thought of as the point in the plane whose real coordinate is <em>x</em> and whose\nimaginary coordinate is <em>y</em>.  Addition of complex numbers reduces in\nthis representation to addition of coordinates:<p>\n\n<p><div align=left><img src="ch2-Z-G-55.gif" border="0"></div><p><p>\n\n<p><div align=left><img src="ch2-Z-G-56.gif" border="0"></div><p><p>\n\nWhen multiplying complex numbers, it is more natural to think in terms\nof representing a complex number in polar form, as a magnitude and an\nangle (<em>r</em> and <em>A</em> in figure&nbsp;<a href="#%_fig_2.20">2.20</a>).\nThe product of two complex numbers is the vector obtained by\nstretching one complex number by the length of the other and then\nrotating it through the angle of the other:<p>\n\n<p><div align=left><img src="ch2-Z-G-57.gif" border="0"></div><p><p>\n\n<p><div align=left><img src="ch2-Z-G-58.gif" border="0"></div><p>\n\nThus, there are two different representations for complex numbers,\nwhich are appropriate for different operations.  Yet, from the\nviewpoint of someone writing a program that uses complex numbers, the\nprinciple of data abstraction suggests that all the operations for\nmanipulating complex numbers should be available regardless of which\nrepresentation is used by the computer.  For example, it is often\nuseful to be able to find the magnitude of a complex number that is\nspecified by rectangular coordinates.  Similarly, it is often useful\nto be able to determine the real part of a complex number that is\nspecified by polar coordinates.<p>\n\n<a name="%_fig_2.20"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-59.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.20:</b>&nbsp;&nbsp;Complex numbers as points in the plane.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nTo design such a system, we can follow the same <a name="%_idx_2310"></a>data-abstraction\nstrategy we followed in designing the rational-number package in\nsection&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a>.  Assume that the operations on complex numbers are\nimplemented in terms of four selectors: <tt>real-part</tt>,\n<tt>imag-part</tt>, <tt>magnitude</tt>, and <tt>angle</tt>.  Also assume that\nwe have two procedures for constructing complex numbers: <tt>make-from-real-imag</tt> returns a complex number with specified real and\nimaginary parts, and <tt>make-from-mag-ang</tt> returns a complex number with\nspecified magnitude and angle.  These procedures have the property that,\nfor any complex number <tt>z</tt>, both<p>\n\n\n<p><p><tt>(make-from-real-imag&nbsp;(real-part&nbsp;z)&nbsp;(imag-part&nbsp;z))<br>\n</tt><p><p>\nand<p>\n\n\n<p><p><tt>(make-from-mag-ang&nbsp;(magnitude&nbsp;z)&nbsp;(angle&nbsp;z))<br>\n</tt><p><p>\nproduce complex numbers that are equal to <tt>z</tt>.<p>\n\nUsing these constructors and selectors, we can implement\narithmetic on complex numbers using the ``abstract data\'\' specified by\nthe constructors and selectors, just as we did for rational numbers in\nsection&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a>.  As shown in the formulas above, we can add and\nsubtract complex numbers in terms of real and imaginary parts while\nmultiplying and dividing complex numbers in terms of magnitudes and\nangles:<p>\n\n<p><p><tt><a name="%_idx_2312"></a>(define&nbsp;(add-complex&nbsp;z1&nbsp;z2)<br>\n&nbsp;&nbsp;(make-from-real-imag&nbsp;(+&nbsp;(real-part&nbsp;z1)&nbsp;(real-part&nbsp;z2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(imag-part&nbsp;z1)&nbsp;(imag-part&nbsp;z2))))<br>\n<a name="%_idx_2314"></a>(define&nbsp;(sub-complex&nbsp;z1&nbsp;z2)<br>\n&nbsp;&nbsp;(make-from-real-imag&nbsp;(-&nbsp;(real-part&nbsp;z1)&nbsp;(real-part&nbsp;z2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;(imag-part&nbsp;z1)&nbsp;(imag-part&nbsp;z2))))<br>\n<a name="%_idx_2316"></a>(define&nbsp;(mul-complex&nbsp;z1&nbsp;z2)<br>\n&nbsp;&nbsp;(make-from-mag-ang&nbsp;(*&nbsp;(magnitude&nbsp;z1)&nbsp;(magnitude&nbsp;z2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(angle&nbsp;z1)&nbsp;(angle&nbsp;z2))))<br>\n<a name="%_idx_2318"></a>(define&nbsp;(div-complex&nbsp;z1&nbsp;z2)<br>\n&nbsp;&nbsp;(make-from-mag-ang&nbsp;(/&nbsp;(magnitude&nbsp;z1)&nbsp;(magnitude&nbsp;z2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;(angle&nbsp;z1)&nbsp;(angle&nbsp;z2))))<br>\n</tt><p><p><p>\n\nTo complete the complex-number package, we must choose a\nrepresentation and we must implement the constructors and selectors in\nterms of primitive numbers and primitive list structure.\nThere are two obvious ways to do this: We can represent a complex\nnumber in ``rectangular form\'\' as a pair (real part, imaginary part)\nor in ``polar form\'\' as a pair (magnitude, angle).  Which shall we\nchoose?<p>\n\n\nIn order to make the different choices concrete, imagine that there\nare two programmers, Ben Bitdiddle and Alyssa P. Hacker, who are\nindependently designing representations for the complex-number system.\n<a name="%_idx_2320"></a>Ben chooses to represent complex numbers in rectangular form.  With\nthis choice, selecting the real and imaginary parts of a complex\nnumber is straightforward, as is constructing a complex number with\ngiven real and imaginary parts.  To find the magnitude and the angle,\nor to construct a complex number with a given magnitude and angle, he\nuses the trigonometric relations<p>\n\n<p><div align=left><img src="ch2-Z-G-60.gif" border="0"></div><p>\n<p><div align=left><img src="ch2-Z-G-61.gif" border="0"></div><p><p>\n\nwhich relate the real and imaginary parts (<em>x</em>, <em>y</em>) to the magnitude\nand the angle (<em>r</em>, <em>A</em>).<a name="call_footnote_Temp_269" href="#footnote_Temp_269"><sup><small>44</small></sup></a>  Ben\'s representation is\ntherefore given by the following selectors and constructors:<p>\n\n<p><p><tt><a name="%_idx_2328"></a>(define&nbsp;(real-part&nbsp;z)&nbsp;(car&nbsp;z))<br>\n<a name="%_idx_2330"></a>(define&nbsp;(imag-part&nbsp;z)&nbsp;(cdr&nbsp;z))<br>\n<a name="%_idx_2332"></a>(define&nbsp;(magnitude&nbsp;z)<br>\n&nbsp;&nbsp;(sqrt&nbsp;(+&nbsp;(square&nbsp;(real-part&nbsp;z))&nbsp;(square&nbsp;(imag-part&nbsp;z)))))<br>\n<a name="%_idx_2334"></a>(define&nbsp;(angle&nbsp;z)<br>\n&nbsp;&nbsp;(atan&nbsp;(imag-part&nbsp;z)&nbsp;(real-part&nbsp;z)))<br>\n<a name="%_idx_2336"></a>(define&nbsp;(make-from-real-imag&nbsp;x&nbsp;y)&nbsp;(cons&nbsp;x&nbsp;y))<br>\n<a name="%_idx_2338"></a>(define&nbsp;(make-from-mag-ang&nbsp;r&nbsp;a)&nbsp;<br>\n&nbsp;&nbsp;(cons&nbsp;(*&nbsp;r&nbsp;(cos&nbsp;a))&nbsp;(*&nbsp;r&nbsp;(sin&nbsp;a))))<br>\n</tt><p><p><p>\n\n<a name="%_idx_2340"></a>Alyssa, in contrast, chooses to represent complex numbers in polar\nform.  For her, selecting the magnitude and angle is straightforward,\nbut she has to use the <a name="%_idx_2342"></a>trigonometric relations to obtain the real and\nimaginary parts.  Alyssa\'s representation is:<p>\n\n<p><p><tt><a name="%_idx_2344"></a>(define&nbsp;(real-part&nbsp;z)<br>\n&nbsp;&nbsp;(*&nbsp;(magnitude&nbsp;z)&nbsp;(cos&nbsp;(angle&nbsp;z))))<br>\n<a name="%_idx_2346"></a>(define&nbsp;(imag-part&nbsp;z)<br>\n&nbsp;&nbsp;(*&nbsp;(magnitude&nbsp;z)&nbsp;(sin&nbsp;(angle&nbsp;z))))<br>\n<a name="%_idx_2348"></a>(define&nbsp;(magnitude&nbsp;z)&nbsp;(car&nbsp;z))<br>\n<a name="%_idx_2350"></a>(define&nbsp;(angle&nbsp;z)&nbsp;(cdr&nbsp;z))<br>\n<a name="%_idx_2352"></a>(define&nbsp;(make-from-real-imag&nbsp;x&nbsp;y)&nbsp;<br>\n&nbsp;&nbsp;(cons&nbsp;(sqrt&nbsp;(+&nbsp;(square&nbsp;x)&nbsp;(square&nbsp;y)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(atan&nbsp;y&nbsp;x)))<br>\n<a name="%_idx_2354"></a>(define&nbsp;(make-from-mag-ang&nbsp;r&nbsp;a)&nbsp;(cons&nbsp;r&nbsp;a))<br>\n</tt><p><p><p>\n\nThe discipline of data abstraction ensures that the same implementation of\n<tt>add-complex</tt>, <tt>sub-complex</tt>, <tt>mul-complex</tt>, and <tt>div-complex</tt> will work with either Ben\'s representation or Alyssa\'s\nrepresentation. <p>\n\n<a name="%_sec_2.4.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.4.2">2.4.2&nbsp;&nbsp;Tagged data</a></h3><p>\n\n\n<a name="%_idx_2356"></a><a name="%_idx_2358"></a><a name="%_idx_2360"></a>\nOne way to view data abstraction is as an application of the\n<a name="%_idx_2362"></a><a name="%_idx_2364"></a>``principle of least commitment.\'\'  In implementing the complex-number\nsystem in section&nbsp;<a href="#%_sec_2.4.1">2.4.1</a>, we can\nuse either Ben\'s rectangular representation or Alyssa\'s polar\nrepresentation.  The abstraction barrier formed by the selectors and\nconstructors permits us to defer to the last possible moment the\nchoice of a concrete representation for our data objects and thus\nretain maximum flexibility in our system design.<p>\n\nThe principle of least commitment can be carried to even further\nextremes.  If we desire, we can maintain the ambiguity of\nrepresentation even <em>after</em> we have designed the selectors and\nconstructors, and elect to use both Ben\'s representation <em>and</em>\nAlyssa\'s representation.  If both representations are included in a\nsingle system, however, we will need some way to distinguish data in\npolar form from data in rectangular form.  Otherwise, if we were\nasked, for instance, to find the <tt>magnitude</tt> of the pair (3,4),\nwe wouldn\'t know whether to answer 5 (interpreting the number in\nrectangular form) or 3 (interpreting the number in polar form).  A\nstraightforward way to accomplish this distinction is to include a\n<a name="%_idx_2366"></a><em>type tag</em> -- the symbol <tt>rectangular</tt> or <tt>polar</tt> -- as\npart of each complex number.  Then when we need to manipulate a\ncomplex number we can use the tag to decide which selector to apply.<p>\n\nIn order to manipulate tagged data,\nwe will assume that we have procedures <tt>type-tag</tt> and <tt>contents</tt> that extract from a data object the tag and the actual\ncontents (the polar or rectangular coordinates, in the case of a\ncomplex number).  We will also postulate a procedure <tt>attach-tag</tt> that takes a tag and contents and produces a tagged data\nobject.  A straightforward way to implement this is to use ordinary\nlist structure:<p>\n\n<p><p><tt><a name="%_idx_2368"></a>(define&nbsp;(attach-tag&nbsp;type-tag&nbsp;contents)<br>\n&nbsp;&nbsp;(cons&nbsp;type-tag&nbsp;contents))<br>\n<a name="%_idx_2370"></a>(define&nbsp;(type-tag&nbsp;datum)<br>\n&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;datum)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;datum)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Bad&nbsp;tagged&nbsp;datum&nbsp;--&nbsp;TYPE-TAG&quot;&nbsp;datum)))<br>\n<a name="%_idx_2372"></a>(define&nbsp;(contents&nbsp;datum)<br>\n&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;datum)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;datum)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Bad&nbsp;tagged&nbsp;datum&nbsp;--&nbsp;CONTENTS&quot;&nbsp;datum)))<br>\n</tt><p><p><p>\n\nUsing these procedures, we can define predicates <tt>rectangular?</tt>\nand <tt>polar?</tt>, which recognize polar and rectangular numbers,\nrespectively:<p>\n\n<p><p><tt><a name="%_idx_2374"></a>(define&nbsp;(rectangular?&nbsp;z)<br>\n&nbsp;&nbsp;(eq?&nbsp;(type-tag&nbsp;z)&nbsp;\'rectangular))<br>\n<a name="%_idx_2376"></a>(define&nbsp;(polar?&nbsp;z)<br>\n&nbsp;&nbsp;(eq?&nbsp;(type-tag&nbsp;z)&nbsp;\'polar))<br>\n</tt><p><p><p>\n\nWith type tags, Ben and Alyssa can now modify their code so that\ntheir two different representations can coexist in the same system.\nWhenever Ben constructs a complex number, he tags it as rectangular.\nWhenever Alyssa constructs a complex number, she tags it as polar.\nIn addition, Ben and Alyssa must make sure that the names of their\nprocedures do not conflict.  One way to do this is for Ben to append\nthe suffix <tt>rectangular</tt> to the name of each of his representation\nprocedures and for Alyssa to append <tt>polar</tt> to the names of hers.\nHere is Ben\'s revised rectangular representation from\nsection&nbsp;<a href="#%_sec_2.4.1">2.4.1</a>:<p>\n\n<p><p><tt><a name="%_idx_2378"></a>(define&nbsp;(real-part-rectangular&nbsp;z)&nbsp;(car&nbsp;z))<br>\n<a name="%_idx_2380"></a>(define&nbsp;(imag-part-rectangular&nbsp;z)&nbsp;(cdr&nbsp;z))<br>\n<a name="%_idx_2382"></a>(define&nbsp;(magnitude-rectangular&nbsp;z)<br>\n&nbsp;&nbsp;(sqrt&nbsp;(+&nbsp;(square&nbsp;(real-part-rectangular&nbsp;z))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(square&nbsp;(imag-part-rectangular&nbsp;z)))))<br>\n<a name="%_idx_2384"></a>(define&nbsp;(angle-rectangular&nbsp;z)<br>\n&nbsp;&nbsp;(atan&nbsp;(imag-part-rectangular&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(real-part-rectangular&nbsp;z)))<br>\n<a name="%_idx_2386"></a>(define&nbsp;(make-from-real-imag-rectangular&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(attach-tag&nbsp;\'rectangular&nbsp;(cons&nbsp;x&nbsp;y)))<br>\n<a name="%_idx_2388"></a>(define&nbsp;(make-from-mag-ang-rectangular&nbsp;r&nbsp;a)&nbsp;<br>\n&nbsp;&nbsp;(attach-tag&nbsp;\'rectangular<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(*&nbsp;r&nbsp;(cos&nbsp;a))&nbsp;(*&nbsp;r&nbsp;(sin&nbsp;a)))))<br>\n</tt><p><p>\nand here is Alyssa\'s revised polar representation:<p>\n\n<p><p><tt><a name="%_idx_2390"></a>(define&nbsp;(real-part-polar&nbsp;z)<br>\n&nbsp;&nbsp;(*&nbsp;(magnitude-polar&nbsp;z)&nbsp;(cos&nbsp;(angle-polar&nbsp;z))))<br>\n<a name="%_idx_2392"></a>(define&nbsp;(imag-part-polar&nbsp;z)<br>\n&nbsp;&nbsp;(*&nbsp;(magnitude-polar&nbsp;z)&nbsp;(sin&nbsp;(angle-polar&nbsp;z))))<br>\n<a name="%_idx_2394"></a>(define&nbsp;(magnitude-polar&nbsp;z)&nbsp;(car&nbsp;z))<br>\n<a name="%_idx_2396"></a>(define&nbsp;(angle-polar&nbsp;z)&nbsp;(cdr&nbsp;z))<br>\n<a name="%_idx_2398"></a>(define&nbsp;(make-from-real-imag-polar&nbsp;x&nbsp;y)&nbsp;<br>\n&nbsp;&nbsp;(attach-tag&nbsp;\'polar<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(sqrt&nbsp;(+&nbsp;(square&nbsp;x)&nbsp;(square&nbsp;y)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(atan&nbsp;y&nbsp;x))))<br>\n<a name="%_idx_2400"></a>(define&nbsp;(make-from-mag-ang-polar&nbsp;r&nbsp;a)<br>\n&nbsp;&nbsp;(attach-tag&nbsp;\'polar&nbsp;(cons&nbsp;r&nbsp;a)))<br>\n</tt><p><p><p>\n\n\n<a name="%_idx_2402"></a><a name="%_idx_2404"></a>Each generic selector is implemented as a procedure that checks the\ntag of its argument and calls the appropriate procedure for handling\ndata of that type.  For example, to obtain the real part of a complex\nnumber, <tt>real-part</tt> examines the tag to determine whether to use\nBen\'s <tt>real-part-rectangular</tt> or Alyssa\'s <tt>real-part-polar</tt>.\nIn either case, we use <tt>contents</tt> to extract the bare, untagged\ndatum and send this to the rectangular or polar procedure as required:<p>\n\n<p><p><tt><a name="%_idx_2406"></a>(define&nbsp;(real-part&nbsp;z)<br>\n&nbsp;&nbsp;(cond&nbsp;((rectangular?&nbsp;z)&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(real-part-rectangular&nbsp;(contents&nbsp;z)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((polar?&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(real-part-polar&nbsp;(contents&nbsp;z)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;type&nbsp;--&nbsp;REAL-PART&quot;&nbsp;z))))<br>\n<a name="%_idx_2408"></a>(define&nbsp;(imag-part&nbsp;z)<br>\n&nbsp;&nbsp;(cond&nbsp;((rectangular?&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(imag-part-rectangular&nbsp;(contents&nbsp;z)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((polar?&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(imag-part-polar&nbsp;(contents&nbsp;z)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;type&nbsp;--&nbsp;IMAG-PART&quot;&nbsp;z))))<br>\n<a name="%_idx_2410"></a>(define&nbsp;(magnitude&nbsp;z)<br>\n&nbsp;&nbsp;(cond&nbsp;((rectangular?&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(magnitude-rectangular&nbsp;(contents&nbsp;z)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((polar?&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(magnitude-polar&nbsp;(contents&nbsp;z)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;type&nbsp;--&nbsp;MAGNITUDE&quot;&nbsp;z))))<br>\n<a name="%_idx_2412"></a>(define&nbsp;(angle&nbsp;z)<br>\n&nbsp;&nbsp;(cond&nbsp;((rectangular?&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(angle-rectangular&nbsp;(contents&nbsp;z)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((polar?&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(angle-polar&nbsp;(contents&nbsp;z)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;type&nbsp;--&nbsp;ANGLE&quot;&nbsp;z))))<br>\n</tt><p><p><p>\n\nTo implement the complex-number arithmetic operations, we can use the\nsame procedures <tt>add-complex</tt>, <tt>sub-complex</tt>, <tt>mul-complex</tt>, and <tt>div-complex</tt> from\nsection&nbsp;<a href="#%_sec_2.4.1">2.4.1</a>, because the\nselectors they call are generic, and so will work with either\nrepresentation.  For example, the procedure <tt>add-complex</tt> is still<p>\n\n<p><p><tt>(define&nbsp;(add-complex&nbsp;z1&nbsp;z2)<br>\n&nbsp;&nbsp;(make-from-real-imag&nbsp;(+&nbsp;(real-part&nbsp;z1)&nbsp;(real-part&nbsp;z2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(imag-part&nbsp;z1)&nbsp;(imag-part&nbsp;z2))))<br>\n</tt><p><p><p>\n\nFinally, we must choose whether to construct complex numbers using\nBen\'s representation or Alyssa\'s representation.  One reasonable\nchoice is to construct rectangular numbers whenever we have real and\nimaginary parts and to construct polar numbers whenever we have\nmagnitudes and angles:<p>\n\n<p><p><tt><a name="%_idx_2414"></a>(define&nbsp;(make-from-real-imag&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(make-from-real-imag-rectangular&nbsp;x&nbsp;y))<br>\n<a name="%_idx_2416"></a>(define&nbsp;(make-from-mag-ang&nbsp;r&nbsp;a)<br>\n&nbsp;&nbsp;(make-from-mag-ang-polar&nbsp;r&nbsp;a))<br>\n</tt><p><p><p>\n\n<a name="%_fig_2.21"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-62.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.21:</b>&nbsp;&nbsp;Structure of the generic complex-arithmetic system.</div></caption><tr><td>\n<a name="%_idx_2418"></a>\n</td></tr></table></div><p><p>\n\nThe resulting complex-number system has the structure shown in\nfigure&nbsp;<a href="#%_fig_2.21">2.21</a>.  The system has been\ndecomposed into three relatively independent parts: the\ncomplex-number-arithmetic operations, Alyssa\'s polar\nimplementation, and Ben\'s rectangular implementation.  The polar and\nrectangular implementations could have been written by Ben and Alyssa\nworking separately, and both of these can be used as underlying\nrepresentations by a third programmer implementing the\ncomplex-arithmetic procedures in terms of the abstract\nconstructor/selector interface.<p>\n\n<a name="%_idx_2420"></a><a name="%_idx_2422"></a>Since each data object is tagged with its type, the selectors operate\non the data in a generic manner.  That is, each selector is defined to\nhave a behavior that depends upon the particular type of data it is\napplied to.  Notice the general mechanism for interfacing the separate\nrepresentations: Within a given representation implementation (say,\nAlyssa\'s polar package) a complex number is an untyped pair\n(magnitude, angle).  When a generic selector operates on a number of\n<tt>polar</tt> type, it strips off the tag and passes the contents on to\nAlyssa\'s code.  Conversely, when Alyssa constructs a number for general\nuse, she tags it with a type so that it can be appropriately\nrecognized by the higher-level procedures.  This discipline of\nstripping off and attaching tags as data objects are passed from level\nto level can be an important organizational strategy, as we shall see\nin section&nbsp;<a href="book-Z-H-18.html#%_sec_2.5">2.5</a>.\n\n<p>\n\n<a name="%_sec_2.4.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.4.3">2.4.3&nbsp;&nbsp;Data-Directed Programming and Additivity</a></h3><p>\n\n\n<a name="%_idx_2424"></a><a name="%_idx_2426"></a>\n<a name="%_idx_2428"></a>The general strategy of checking the type of a datum and calling an\nappropriate procedure is called <a name="%_idx_2430"></a><a name="%_idx_2432"></a><em>dispatching on type</em>.  This is a\npowerful strategy for obtaining modularity in system design.  On\nthe other hand, implementing the dispatch as in\nsection&nbsp;<a href="#%_sec_2.4.2">2.4.2</a> has two significant weaknesses.  One\nweakness is that the generic interface procedures (<tt>real-part</tt>,\n<tt>imag-part</tt>, <tt>magnitude</tt>, and <tt>angle</tt>) must know about all\nthe different representations.  For instance, suppose we wanted to\nincorporate a new representation for complex numbers into our\ncomplex-number system.  We would need to identify this new\nrepresentation with a type, and then add a clause to each of the\ngeneric interface procedures to check for the new type and apply the\nappropriate selector for that representation.<p>\n\nAnother weakness of the technique is that even though the individual\nrepresentations can be designed separately, we must guarantee that\nno two procedures in the entire system have the same name.  This is\nwhy Ben and Alyssa had to change the names of their original\nprocedures from section&nbsp;<a href="#%_sec_2.4.1">2.4.1</a>.<p>\n\nThe issue underlying both of these weaknesses is that the technique\nfor implementing generic interfaces is not <em>additive</em>.  The person\nimplementing the generic selector procedures must modify those\nprocedures each time a new representation is installed, and the people\ninterfacing the individual representations must modify their\ncode to avoid name conflicts.  In each of these cases, the changes\nthat must be made to the code are straightforward, but they must be\nmade nonetheless, and this is a source of inconvenience and error.\nThis is not much of a problem for the complex-number system as it\nstands, but suppose there were not two but hundreds of different\nrepresentations for complex numbers.  And suppose that there were many\ngeneric selectors to be maintained in the abstract-data interface.\nSuppose, in fact, that no one programmer knew all the interface\nprocedures or all the representations.  The problem is real and must\nbe addressed in such programs as large-scale data-base-management\nsystems.<p>\n\nWhat we need is a means for modularizing the system design even\nfurther.  This is provided by the programming technique known as <em>data-directed programming</em>.  To understand how data-directed\nprogramming works, begin with the observation that whenever we deal\nwith a set of generic operations that are common to a set of\ndifferent types we are, in effect, dealing with a two-dimensional\ntable that contains the possible operations on one axis and the\npossible types on the other axis.  The entries in the table are the\nprocedures that implement each operation for each type of argument\npresented.  In the complex-number system developed in the previous\nsection, the correspondence between operation name, data type, and\nactual procedure was spread out among the various conditional clauses\nin the generic interface procedures.  But the same information could\nhave been organized in a table, as shown in\nfigure&nbsp;<a href="#%_fig_2.22">2.22</a>.<p>\n\n\n<a name="%_idx_2434"></a>Data-directed programming is the technique of designing programs to\nwork with such a table directly.  Previously, we implemented the\nmechanism that interfaces the complex-arithmetic code with the two\nrepresentation packages as a set of procedures that each perform an\nexplicit dispatch on type.  Here we will implement the interface as a single\nprocedure that looks up the combination of the operation name and\nargument type in\nthe table to find the correct procedure to apply, and then applies it\nto the contents of the argument.  If we do this, then to add a new\nrepresentation package to the system we need not change any existing\nprocedures; we need only add new entries to the table.<p>\n\n<a name="%_fig_2.22"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-63.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.22:</b>&nbsp;&nbsp;Table of operations for the complex-number system.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nTo implement this plan, assume that we have two procedures,\n<tt>put</tt> and <tt>get</tt>, for manipulating the\noperation-and-type table:\n<a name="%_idx_2436"></a>\n<p><ul>\n<a name="%_idx_2438"></a><li><tt>(put &lt;<em>op</em>&gt; &lt;<em>type</em>&gt; &lt;<em>item</em>&gt;)</tt><br>\ninstalls the <tt>&lt;<em>item</em>&gt;</tt> in the table, indexed by the\n<tt>&lt;<em>op</em>&gt;</tt> and the <tt>&lt;<em>type</em>&gt;</tt>.<p>\n\n<a name="%_idx_2440"></a><li><tt>(get &lt;<em>op</em>&gt; &lt;<em>type</em>&gt;)</tt><br>\nlooks up the <tt>&lt;<em>op</em>&gt;</tt>, <tt>&lt;<em>type</em>&gt;</tt> entry in the table\nand returns the item found there.  If no item is found, <tt>get</tt>\nreturns false.\n</ul><p><p>\n\nFor now, we can assume that <tt>put</tt> and <tt>get</tt> are\nincluded in our language.  In chapter&nbsp;3\n(section&nbsp;<a href="book-Z-H-22.html#%_sec_3.3.3">3.3.3</a>, exercise&nbsp;<a href="book-Z-H-22.html#%_thm_3.24">3.24</a>)\nwe will see how to implement these and\nother operations for manipulating tables.<p>\n\n\nHere is how data-directed programming can be used in the\ncomplex-number system.  Ben, who developed the rectangular\nrepresentation, implements his code just as he did originally.  He\ndefines a collection of procedures, or a <a name="%_idx_2442"></a><em>package</em>, and interfaces\nthese to the rest of the system by adding entries to the table that\ntell the system how to operate on rectangular numbers.\nThis is accomplished by calling the following procedure:\n<a name="%_idx_2444"></a><a name="%_idx_2446"></a>\n<p><p><tt><a name="%_idx_2448"></a>(define&nbsp;(install-rectangular-package)<br>\n&nbsp;&nbsp;<em>;;&nbsp;internal&nbsp;procedures</em><br>\n&nbsp;&nbsp;(define&nbsp;(real-part&nbsp;z)&nbsp;(car&nbsp;z))<br>\n&nbsp;&nbsp;(define&nbsp;(imag-part&nbsp;z)&nbsp;(cdr&nbsp;z))<br>\n&nbsp;&nbsp;(define&nbsp;(make-from-real-imag&nbsp;x&nbsp;y)&nbsp;(cons&nbsp;x&nbsp;y))<br>\n&nbsp;&nbsp;(define&nbsp;(magnitude&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(sqrt&nbsp;(+&nbsp;(square&nbsp;(real-part&nbsp;z))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(square&nbsp;(imag-part&nbsp;z)))))<br>\n&nbsp;&nbsp;(define&nbsp;(angle&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(atan&nbsp;(imag-part&nbsp;z)&nbsp;(real-part&nbsp;z)))<br>\n&nbsp;&nbsp;(define&nbsp;(make-from-mag-ang&nbsp;r&nbsp;a)&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(*&nbsp;r&nbsp;(cos&nbsp;a))&nbsp;(*&nbsp;r&nbsp;(sin&nbsp;a))))<br>\n&nbsp;&nbsp;<em>;;&nbsp;interface&nbsp;to&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;system</em><br>\n&nbsp;&nbsp;(define&nbsp;(tag&nbsp;x)&nbsp;(attach-tag&nbsp;\'rectangular&nbsp;x))<br>\n&nbsp;&nbsp;(put&nbsp;\'real-part&nbsp;\'(rectangular)&nbsp;real-part)<br>\n&nbsp;&nbsp;(put&nbsp;\'imag-part&nbsp;\'(rectangular)&nbsp;imag-part)<br>\n&nbsp;&nbsp;(put&nbsp;\'magnitude&nbsp;\'(rectangular)&nbsp;magnitude)<br>\n&nbsp;&nbsp;(put&nbsp;\'angle&nbsp;\'(rectangular)&nbsp;angle)<br>\n&nbsp;&nbsp;(put&nbsp;\'make-from-real-imag&nbsp;\'rectangular&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(tag&nbsp;(make-from-real-imag&nbsp;x&nbsp;y))))<br>\n&nbsp;&nbsp;(put&nbsp;\'make-from-mag-ang&nbsp;\'rectangular&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(r&nbsp;a)&nbsp;(tag&nbsp;(make-from-mag-ang&nbsp;r&nbsp;a))))<br>\n&nbsp;&nbsp;\'done)<br>\n</tt><p><p><p>\n\nNotice that the internal procedures here are the same procedures from\nsection&nbsp;<a href="#%_sec_2.4.1">2.4.1</a> that Ben wrote when\nhe was working in isolation.  No changes are necessary in order to\ninterface them to the rest of the system.  Moreover, since these\nprocedure definitions are internal to the installation procedure, Ben\nneedn\'t worry about name conflicts with other procedures outside the\nrectangular package.  To interface these to the rest of the system,\nBen installs his <tt>real-part</tt> procedure under the operation name\n<tt>real-part</tt> and the type <tt>(rectangular)</tt>, and similarly\nfor the other selectors.<a name="call_footnote_Temp_270" href="#footnote_Temp_270"><sup><small>45</small></sup></a>  The interface also defines\nthe constructors to be used by the external system.<a name="call_footnote_Temp_271" href="#footnote_Temp_271"><sup><small>46</small></sup></a>\nThese are\nidentical to Ben\'s internally defined constructors, except that they\nattach the tag.<p>\n\n<a name="%_idx_2450"></a><a name="%_idx_2452"></a>Alyssa\'s polar package is analogous:\n<p><p><tt><a name="%_idx_2454"></a>(define&nbsp;(install-polar-package)<br>\n&nbsp;&nbsp;<em>;;&nbsp;internal&nbsp;procedures</em><br>\n&nbsp;&nbsp;(define&nbsp;(magnitude&nbsp;z)&nbsp;(car&nbsp;z))<br>\n&nbsp;&nbsp;(define&nbsp;(angle&nbsp;z)&nbsp;(cdr&nbsp;z))<br>\n&nbsp;&nbsp;(define&nbsp;(make-from-mag-ang&nbsp;r&nbsp;a)&nbsp;(cons&nbsp;r&nbsp;a))<br>\n&nbsp;&nbsp;(define&nbsp;(real-part&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(magnitude&nbsp;z)&nbsp;(cos&nbsp;(angle&nbsp;z))))<br>\n&nbsp;&nbsp;(define&nbsp;(imag-part&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(magnitude&nbsp;z)&nbsp;(sin&nbsp;(angle&nbsp;z))))<br>\n&nbsp;&nbsp;(define&nbsp;(make-from-real-imag&nbsp;x&nbsp;y)&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(sqrt&nbsp;(+&nbsp;(square&nbsp;x)&nbsp;(square&nbsp;y)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(atan&nbsp;y&nbsp;x)))<br>\n&nbsp;&nbsp;<em>;;&nbsp;interface&nbsp;to&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;system</em><br>\n&nbsp;&nbsp;(define&nbsp;(tag&nbsp;x)&nbsp;(attach-tag&nbsp;\'polar&nbsp;x))<br>\n&nbsp;&nbsp;(put&nbsp;\'real-part&nbsp;\'(polar)&nbsp;real-part)<br>\n&nbsp;&nbsp;(put&nbsp;\'imag-part&nbsp;\'(polar)&nbsp;imag-part)<br>\n&nbsp;&nbsp;(put&nbsp;\'magnitude&nbsp;\'(polar)&nbsp;magnitude)<br>\n&nbsp;&nbsp;(put&nbsp;\'angle&nbsp;\'(polar)&nbsp;angle)<br>\n&nbsp;&nbsp;(put&nbsp;\'make-from-real-imag&nbsp;\'polar<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(tag&nbsp;(make-from-real-imag&nbsp;x&nbsp;y))))<br>\n&nbsp;&nbsp;(put&nbsp;\'make-from-mag-ang&nbsp;\'polar&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(r&nbsp;a)&nbsp;(tag&nbsp;(make-from-mag-ang&nbsp;r&nbsp;a))))<br>\n&nbsp;&nbsp;\'done)<br>\n</tt><p><p>\n<p>\n\nEven though Ben and Alyssa both still use their original procedures\ndefined with the same names as each other\'s (e.g., <tt>real-part</tt>), these\ndefinitions are now internal to different procedures (see\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.8">1.1.8</a>), so there is no name\nconflict.<p>\n\nThe complex-arithmetic selectors access the table by means of a\ngeneral ``operation\'\' procedure called <tt>apply-generic</tt>, which\napplies a generic operation to some arguments.  <tt>Apply-generic</tt>\nlooks in the table under the name of the operation and the types of the\narguments and applies the resulting procedure if one is present:<a name="call_footnote_Temp_272" href="#footnote_Temp_272"><sup><small>47</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_2462"></a>(define&nbsp;(apply-generic&nbsp;op&nbsp;.&nbsp;args)<br>\n&nbsp;&nbsp;(let&nbsp;((type-tags&nbsp;(map&nbsp;type-tag&nbsp;args)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((proc&nbsp;(get&nbsp;op&nbsp;type-tags)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;proc<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;proc&nbsp;(map&nbsp;contents&nbsp;args))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;No&nbsp;method&nbsp;for&nbsp;these&nbsp;types&nbsp;--&nbsp;APPLY-GENERIC&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;op&nbsp;type-tags))))))<br>\n</tt><p><p>\nUsing <tt>apply-generic</tt>, we can define our generic selectors as follows:<p>\n\n<p><p><tt><a name="%_idx_2464"></a>(define&nbsp;(real-part&nbsp;z)&nbsp;(apply-generic&nbsp;\'real-part&nbsp;z))<br>\n<a name="%_idx_2466"></a>(define&nbsp;(imag-part&nbsp;z)&nbsp;(apply-generic&nbsp;\'imag-part&nbsp;z))<br>\n<a name="%_idx_2468"></a>(define&nbsp;(magnitude&nbsp;z)&nbsp;(apply-generic&nbsp;\'magnitude&nbsp;z))<br>\n<a name="%_idx_2470"></a>(define&nbsp;(angle&nbsp;z)&nbsp;(apply-generic&nbsp;\'angle&nbsp;z))<br>\n</tt><p><p>\nObserve that these do not change at all if a new representation is\nadded to the system.<p>\n\nWe can also extract from the table the\nconstructors to be used by the programs external to the packages in\nmaking complex numbers from real and imaginary parts and from\nmagnitudes and angles.\nAs in section&nbsp;<a href="#%_sec_2.4.2">2.4.2</a>, we\nconstruct rectangular numbers whenever we have real and\nimaginary parts, and polar numbers whenever we have magnitudes and angles:<p>\n\n<p><p><tt><a name="%_idx_2472"></a>(define&nbsp;(make-from-real-imag&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;((get&nbsp;\'make-from-real-imag&nbsp;\'rectangular)&nbsp;x&nbsp;y))<br>\n<a name="%_idx_2474"></a>(define&nbsp;(make-from-mag-ang&nbsp;r&nbsp;a)<br>\n&nbsp;&nbsp;((get&nbsp;\'make-from-mag-ang&nbsp;\'polar)&nbsp;r&nbsp;a))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_2.73"></a>\n<b>Exercise 2.73.</b>&nbsp;&nbsp;Section&nbsp;<a href="book-Z-H-16.html#%_sec_2.3.2">2.3.2</a> described a program that\nperforms symbolic differentiation:\n<a name="%_idx_2476"></a><a name="%_idx_2478"></a><p><p><tt>(define&nbsp;(deriv&nbsp;exp&nbsp;var)<br>\n&nbsp;&nbsp;(cond&nbsp;((number?&nbsp;exp)&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((variable?&nbsp;exp)&nbsp;(if&nbsp;(same-variable?&nbsp;exp&nbsp;var)&nbsp;1&nbsp;0))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((sum?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-sum&nbsp;(deriv&nbsp;(addend&nbsp;exp)&nbsp;var)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(deriv&nbsp;(augend&nbsp;exp)&nbsp;var)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((product?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-sum<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-product&nbsp;(multiplier&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(deriv&nbsp;(multiplicand&nbsp;exp)&nbsp;var))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-product&nbsp;(deriv&nbsp;(multiplier&nbsp;exp)&nbsp;var)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(multiplicand&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>more&nbsp;rules&nbsp;can&nbsp;be&nbsp;added&nbsp;here</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;unknown&nbsp;expression&nbsp;type&nbsp;--&nbsp;DERIV&quot;&nbsp;exp))))<br>\n</tt><p><p>\nWe can regard this program as performing a dispatch on the type of the\nexpression to be differentiated.  In this situation the ``type tag\'\' of the\ndatum is the algebraic operator symbol (such as <tt>+</tt>) and the\noperation being performed is <tt>deriv</tt>.  We can transform this\nprogram into data-directed style by rewriting the basic derivative\nprocedure as\n<p><p><tt><a name="%_idx_2480"></a>(define&nbsp;(deriv&nbsp;exp&nbsp;var)<br>\n&nbsp;&nbsp;&nbsp;(cond&nbsp;((number?&nbsp;exp)&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((variable?&nbsp;exp)&nbsp;(if&nbsp;(same-variable?&nbsp;exp&nbsp;var)&nbsp;1&nbsp;0))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;((get&nbsp;\'deriv&nbsp;(operator&nbsp;exp))&nbsp;(operands&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var))))<br>\n(define&nbsp;(operator&nbsp;exp)&nbsp;(car&nbsp;exp))<br>\n(define&nbsp;(operands&nbsp;exp)&nbsp;(cdr&nbsp;exp))<br>\n</tt><p><p><p>\n\na.&nbsp;&nbsp;Explain what was done above.\nWhy can\'t we assimilate the predicates <tt>number?</tt> and <tt>same-variable?</tt> into the data-directed dispatch?<p>\n\nb.&nbsp;&nbsp;Write the procedures for derivatives of sums and products, and the\nauxiliary code required to install them in the table used by the\nprogram above.<p>\n\nc.&nbsp;&nbsp;Choose any additional differentiation rule that you like, such as\nthe one for exponents (exercise&nbsp;<a href="book-Z-H-16.html#%_thm_2.56">2.56</a>),\nand install it in this data-directed system.<p>\n\nd.&nbsp;&nbsp;In this simple algebraic manipulator the type of an expression is\nthe algebraic operator that binds it together.  Suppose, however, we\nindexed the procedures in the opposite way, so that the dispatch line\nin <tt>deriv</tt> looked like<p>\n\n<p><p><tt>((get&nbsp;(operator&nbsp;exp)&nbsp;\'deriv)&nbsp;(operands&nbsp;exp)&nbsp;var)<br>\n</tt><p><p>\nWhat corresponding changes to the derivative system are required?\n\n<p><p>\n\n\n<p><a name="%_thm_2.74"></a>\n<b>Exercise 2.74.</b>&nbsp;&nbsp;<a name="%_idx_2482"></a><a name="%_idx_2484"></a>Insatiable Enterprises, Inc., is a highly decentralized conglomerate\ncompany consisting of a large number of independent divisions located\nall over the world.  The company\'s computer facilities have just been\ninterconnected by means of a clever network-interfacing scheme that\nmakes the entire network appear to any user to be a single computer.\nInsatiable\'s president, in her first attempt to exploit the ability of\nthe network to extract administrative information from division files,\nis dismayed to discover that, although all the division files have\nbeen implemented as data structures in Scheme, the particular data\nstructure used varies from division to division.  A meeting of\ndivision managers is hastily called to search for a strategy to\nintegrate the files that will satisfy headquarters\' needs while\npreserving the existing autonomy of the divisions.<p>\n\nShow how such a strategy can be implemented with data-directed\nprogramming.  As an example, suppose that each division\'s personnel\nrecords consist of a single file, which contains a set of records\nkeyed on employees\' names.  The structure of the set varies from\ndivision to division.  Furthermore, each employee\'s record is itself a\nset (structured differently from division to division) that contains\ninformation keyed under identifiers such as <tt>address</tt> and <tt>salary</tt>.  In particular:<p>\n\na.&nbsp;&nbsp;Implement for headquarters a <tt>get-record</tt> procedure that\nretrieves a specified employee\'s record from a specified personnel\nfile.  The procedure should be applicable to any division\'s file.\nExplain how the individual divisions\' files should be structured.  In\nparticular, what type information must be supplied?<p>\n\nb.&nbsp;&nbsp;Implement for headquarters a <tt>get-salary</tt> procedure that\nreturns the salary information from a given employee\'s record from any\ndivision\'s personnel file.  How should the record be structured in\norder to make this operation work?<p>\n\nc.&nbsp;&nbsp;Implement for headquarters a <tt>find-employee-record</tt> procedure.\nThis should search all the divisions\' files for the record of a given\nemployee and return the record.  Assume that this procedure takes as\narguments an employee\'s name and a list of all the divisions\' files.<p>\n\nd.&nbsp;&nbsp;When Insatiable takes over a new company, what changes must\nbe made in order to incorporate the new personnel information into the\ncentral system?\n<p>\n\n<a name="%_sec_Temp_275"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_275">Message passing</a></h4><p>\n\n<a name="%_idx_2486"></a>\nThe key idea of data-directed programming is to handle generic\noperations in programs by dealing explicitly with operation-and-type\ntables, such as the table in figure&nbsp;<a href="#%_fig_2.22">2.22</a>.  The\nstyle of programming we used in section&nbsp;<a href="#%_sec_2.4.2">2.4.2</a>\norganized the required dispatching on type by having each operation\ntake care of its own dispatching.  In effect, this decomposes the\noperation-and-type table into rows, with each generic operation\nprocedure representing a row of the table.<p>\n\nAn alternative implementation strategy is to decompose the table into\ncolumns and, instead of using ``intelligent operations\'\' that dispatch\non data types, to work with ``intelligent data objects\'\' that dispatch\non operation names.  We can do this by arranging things so that a data\nobject, such as a rectangular number, is represented as a procedure\nthat takes as input the required operation name and performs the\noperation indicated.  In such a discipline, <tt>make-from-real-imag</tt>\ncould be written as<p>\n\n<p><p><tt><a name="%_idx_2488"></a>(define&nbsp;(make-from-real-imag&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;op)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;op&nbsp;\'real-part)&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;op&nbsp;\'imag-part)&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;op&nbsp;\'magnitude)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt&nbsp;(+&nbsp;(square&nbsp;x)&nbsp;(square&nbsp;y))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;op&nbsp;\'angle)&nbsp;(atan&nbsp;y&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;op&nbsp;--&nbsp;MAKE-FROM-REAL-IMAG&quot;&nbsp;op))))<br>\n&nbsp;&nbsp;dispatch)<br>\n</tt><p><p>\nThe corresponding <tt>apply-generic</tt> procedure, which applies a\ngeneric operation to an argument, now simply feeds the operation\'s\nname to the data object and lets the object do the work:<a name="call_footnote_Temp_276" href="#footnote_Temp_276"><sup><small>48</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_2490"></a>(define&nbsp;(apply-generic&nbsp;op&nbsp;arg)&nbsp;(arg&nbsp;op))<br>\n</tt><p><p>\nNote that the value returned by <tt>make-from-real-imag</tt> is a\nprocedure -- the internal <tt>dispatch</tt> procedure.  This is the\nprocedure that is invoked when <tt>apply-generic</tt> requests an operation to\nbe performed.<p>\n\nThis style of programming is called <em>message passing</em>.  The name\ncomes from the image that a data object is an entity that receives the\nrequested operation name as a ``message.\'\'  We have already seen an\nexample of message passing in section&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.3">2.1.3</a>, where we saw\nhow <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> could be defined with no data\nobjects but only procedures.  Here we see that message passing is not\na mathematical trick but a useful technique for organizing systems\nwith generic operations.  In the remainder of this chapter we will\ncontinue to use data-directed programming, rather than message\npassing, to discuss generic arithmetic operations.  In chapter&nbsp;3 we\nwill return to message passing, and we will see that it can be a\npowerful tool for structuring simulation programs.<p>\n\n<p><a name="%_thm_2.75"></a>\n<b>Exercise 2.75.</b>&nbsp;&nbsp;<a name="%_idx_2492"></a>Implement the constructor <tt>make-from-mag-ang</tt> in message-passing style.\nThis procedure should be analogous to the <tt>make-from-real-imag</tt>\nprocedure given above.\n<p><p>\n\n<p><a name="%_thm_2.76"></a>\n<b>Exercise 2.76.</b>&nbsp;&nbsp;<a name="%_idx_2494"></a>As a large system with generic operations evolves, new types of data\nobjects or new operations may be needed.  For each of the three\nstrategies -- generic operations with explicit dispatch, data-directed\nstyle, and message-passing-style -- describe the changes that must be\nmade to a system in order to add new types or new operations.  Which\norganization would be most appropriate for a system in which new types\nmust often be added?  Which would be most appropriate for a system in\nwhich new operations must often be added?\n<p><p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_268" href="#call_footnote_Temp_268"><sup><small>43</small></sup></a> In actual computational systems, rectangular form is\npreferable to polar form most of the time because of <a name="%_idx_2308"></a>roundoff errors\nin conversion between rectangular and polar form.  This is why the\ncomplex-number example is unrealistic.  Nevertheless, it provides a\nclear illustration of the design of a system using generic operations\nand a good introduction to the more substantial systems to be\ndeveloped later in this chapter.\n\n<p><a name="footnote_Temp_269" href="#call_footnote_Temp_269"><sup><small>44</small></sup></a> The arctangent function referred to\n<a name="%_idx_2322"></a><a name="%_idx_2324"></a><a name="%_idx_2326"></a>here, computed by Scheme\'s <tt>atan</tt> procedure,\nis defined so as to take two arguments <em>y</em>&nbsp;and <em>x</em> and to return\nthe angle whose tangent is <em>y</em>/<em>x</em>.  The signs of the arguments\ndetermine the quadrant of the angle.\n\n<p><a name="footnote_Temp_270" href="#call_footnote_Temp_270"><sup><small>45</small></sup></a> We use the list <tt>(rectangular)</tt>\nrather than the symbol <tt>rectangular</tt> to allow for the possibility\nof operations with multiple arguments, not all of the same\ntype.\n\n<p><a name="footnote_Temp_271" href="#call_footnote_Temp_271"><sup><small>46</small></sup></a> The\ntype the constructors are installed under needn\'t be a list because\na constructor is always used to make an object of one particular\ntype.\n\n<p><a name="footnote_Temp_272" href="#call_footnote_Temp_272"><sup><small>47</small></sup></a> <tt>Apply-generic</tt> uses the <a name="%_idx_2456"></a>dotted-tail notation described in\nexercise&nbsp;<a href="book-Z-H-15.html#%_thm_2.20">2.20</a>, because different generic operations\nmay take different numbers of arguments.  In <tt>apply-generic</tt>, <tt>op</tt> has as its value the first argument to <tt>apply-generic</tt> and\n<tt>args</tt> has as its value a list of the remaining arguments.<p>\n\n<tt>Apply-generic</tt> also uses the primitive procedure <a name="%_idx_2458"></a><a name="%_idx_2460"></a><tt>apply</tt>,\nwhich takes two arguments, a procedure and a list.  <tt>Apply</tt>\napplies the procedure, using the elements in the list as arguments.\nFor example,\n<p><p><tt>(apply&nbsp;+&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4))<br>\n</tt><p><p>\nreturns 10.\n\n<p><a name="footnote_Temp_276" href="#call_footnote_Temp_276"><sup><small>48</small></sup></a> One\nlimitation of this organization is it permits only generic procedures\nof one argument.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_2.5"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_2.5">2.5&nbsp;&nbsp;Systems with Generic Operations</a></h2><p>\n\n<p>\n\n<a name="%_idx_2496"></a>In the previous section, we saw how to design systems in which data\nobjects can be represented in more than one way.  The key idea is to\nlink the code that specifies the data operations to the several\nrepresentations by means of generic interface procedures.  Now we will\nsee how to use this same idea not only to define operations that are\ngeneric over different representations but also to define operations\nthat are generic over different kinds of arguments.  We have already\nseen several different packages of arithmetic operations: the primitive\narithmetic (<tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt>) built into our\nlanguage, the rational-number arithmetic (<tt>add-rat</tt>, <tt>sub-rat</tt>, <tt>mul-rat</tt>, <tt>div-rat</tt>) of\nsection&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a>, and the complex-number arithmetic that we\nimplemented in section&nbsp;<a href="book-Z-H-17.html#%_sec_2.4.3">2.4.3</a>.  We will now use\ndata-directed techniques to construct a package of arithmetic\noperations that incorporates all the arithmetic packages we have already\nconstructed.<p>\n\nFigure&nbsp;<a href="#%_fig_2.23">2.23</a> shows the structure of the system we\nshall build.  Notice the <a name="%_idx_2498"></a>abstraction barriers.  From the perspective\nof someone using ``numbers,\'\' there is a single procedure <tt>add</tt>\nthat operates on whatever numbers are supplied.  <tt>Add</tt> is part of\na generic interface that allows the separate ordinary-arithmetic,\nrational-arithmetic, and complex-arithmetic packages to be accessed\nuniformly by programs that use numbers.  Any individual arithmetic\npackage (such as the complex package) may itself be accessed through\ngeneric procedures (such as <tt>add-complex</tt>) that combine packages\ndesigned for different representations (such as rectangular and\npolar).  Moreover, the structure of the system is additive, so\nthat one can design the individual arithmetic packages separately and\ncombine them to produce a generic arithmetic system.\n\n<a name="%_fig_2.23"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-64.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.23:</b>&nbsp;&nbsp;Generic arithmetic system.</div></caption><tr><td>\n<a name="%_idx_2500"></a>\n</td></tr></table></div><p><p>\n\n<a name="%_sec_2.5.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.5.1">2.5.1&nbsp;&nbsp;Generic Arithmetic Operations</a></h3><p>\n\n\n<a name="%_idx_2502"></a>\nThe task of designing generic arithmetic operations is analogous to\nthat of designing the generic complex-number operations.  We would\nlike, for instance, to have a generic addition procedure <tt>add</tt> that\nacts like ordinary primitive addition <tt>+</tt> on ordinary numbers,\nlike <tt>add-rat</tt> on rational numbers, and like <tt>add-complex</tt> on\ncomplex numbers.  We can implement <tt>add</tt>, and the other generic\narithmetic operations, by following the same strategy we used in\nsection&nbsp;<a href="book-Z-H-17.html#%_sec_2.4.3">2.4.3</a> to implement the generic selectors for\ncomplex numbers.  We will attach a type tag to each kind of\nnumber and cause the generic procedure to dispatch to an appropriate\npackage according to the data type of its arguments.<p>\n\nThe generic arithmetic procedures are defined as follows:<p>\n\n\n<p><p><tt><a name="%_idx_2504"></a>(define&nbsp;(add&nbsp;x&nbsp;y)&nbsp;(apply-generic&nbsp;\'add&nbsp;x&nbsp;y))<br>\n<a name="%_idx_2506"></a>(define&nbsp;(sub&nbsp;x&nbsp;y)&nbsp;(apply-generic&nbsp;\'sub&nbsp;x&nbsp;y))<br>\n<a name="%_idx_2508"></a>(define&nbsp;(mul&nbsp;x&nbsp;y)&nbsp;(apply-generic&nbsp;\'mul&nbsp;x&nbsp;y))<br>\n<a name="%_idx_2510"></a>(define&nbsp;(div&nbsp;x&nbsp;y)&nbsp;(apply-generic&nbsp;\'div&nbsp;x&nbsp;y))<br>\n</tt><p><p><p>\n\n<a name="%_idx_2512"></a><a name="%_idx_2514"></a>We begin by installing a package for handling <em>ordinary</em> numbers,\nthat is, the primitive numbers of our language.  We will tag these\nwith the symbol <tt>scheme-number</tt>.  The arithmetic operations in this\npackage are the primitive arithmetic procedures (so there is no need to\ndefine extra procedures to handle the untagged numbers).  Since\nthese operations each take two arguments, they are installed in the\ntable keyed by the list <tt>(scheme-number scheme-number)</tt>:\n<a name="%_idx_2516"></a><a name="%_idx_2518"></a>\n\n<p><p><tt><a name="%_idx_2520"></a>(define&nbsp;(install-scheme-number-package)<br>\n&nbsp;&nbsp;(define&nbsp;(tag&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(attach-tag&nbsp;\'scheme-number&nbsp;x))&nbsp;&nbsp;&nbsp;&nbsp;<br>\n&nbsp;&nbsp;(put&nbsp;\'add&nbsp;\'(scheme-number&nbsp;scheme-number)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(tag&nbsp;(+&nbsp;x&nbsp;y))))<br>\n&nbsp;&nbsp;(put&nbsp;\'sub&nbsp;\'(scheme-number&nbsp;scheme-number)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(tag&nbsp;(-&nbsp;x&nbsp;y))))<br>\n&nbsp;&nbsp;(put&nbsp;\'mul&nbsp;\'(scheme-number&nbsp;scheme-number)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(tag&nbsp;(*&nbsp;x&nbsp;y))))<br>\n&nbsp;&nbsp;(put&nbsp;\'div&nbsp;\'(scheme-number&nbsp;scheme-number)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(tag&nbsp;(/&nbsp;x&nbsp;y))))<br>\n&nbsp;&nbsp;(put&nbsp;\'make&nbsp;\'scheme-number<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(tag&nbsp;x)))<br>\n&nbsp;&nbsp;\'done)<br>\n</tt><p><p><p>\n\n\nUsers of the Scheme-number package\nwill create (tagged) ordinary numbers by means of the procedure:<p>\n\n\n<p><p><tt><a name="%_idx_2522"></a>(define&nbsp;(make-scheme-number&nbsp;n)<br>\n&nbsp;&nbsp;((get&nbsp;\'make&nbsp;\'scheme-number)&nbsp;n))<br>\n</tt><p><p><p>\n\nNow that the framework of the generic arithmetic system is in place,\nwe can readily include new kinds of numbers.  Here is a package that\nperforms rational arithmetic.  Notice that, as a benefit of\nadditivity, we can use without modification the rational-number code\nfrom section&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a> as the internal procedures in the\npackage:\n<a name="%_idx_2524"></a><a name="%_idx_2526"></a><a name="%_idx_2528"></a>\n<p><p><tt><a name="%_idx_2530"></a>(define&nbsp;(install-rational-package)<br>\n&nbsp;&nbsp;<em>;;&nbsp;internal&nbsp;procedures</em><br>\n&nbsp;&nbsp;(define&nbsp;(numer&nbsp;x)&nbsp;(car&nbsp;x))<br>\n&nbsp;&nbsp;(define&nbsp;(denom&nbsp;x)&nbsp;(cdr&nbsp;x))<br>\n&nbsp;&nbsp;(define&nbsp;(make-rat&nbsp;n&nbsp;d)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((g&nbsp;(gcd&nbsp;n&nbsp;d)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(/&nbsp;n&nbsp;g)&nbsp;(/&nbsp;d&nbsp;g))))<br>\n&nbsp;&nbsp;(define&nbsp;(add-rat&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(make-rat&nbsp;(+&nbsp;(*&nbsp;(numer&nbsp;x)&nbsp;(denom&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(numer&nbsp;y)&nbsp;(denom&nbsp;x)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(denom&nbsp;x)&nbsp;(denom&nbsp;y))))<br>\n&nbsp;&nbsp;(define&nbsp;(sub-rat&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(make-rat&nbsp;(-&nbsp;(*&nbsp;(numer&nbsp;x)&nbsp;(denom&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(numer&nbsp;y)&nbsp;(denom&nbsp;x)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(denom&nbsp;x)&nbsp;(denom&nbsp;y))))<br>\n&nbsp;&nbsp;(define&nbsp;(mul-rat&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(make-rat&nbsp;(*&nbsp;(numer&nbsp;x)&nbsp;(numer&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(denom&nbsp;x)&nbsp;(denom&nbsp;y))))<br>\n&nbsp;&nbsp;(define&nbsp;(div-rat&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(make-rat&nbsp;(*&nbsp;(numer&nbsp;x)&nbsp;(denom&nbsp;y))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(denom&nbsp;x)&nbsp;(numer&nbsp;y))))<br>\n&nbsp;&nbsp;<em>;;&nbsp;interface&nbsp;to&nbsp;rest&nbsp;of&nbsp;the&nbsp;system</em><br>\n&nbsp;&nbsp;(define&nbsp;(tag&nbsp;x)&nbsp;(attach-tag&nbsp;\'rational&nbsp;x))<br>\n&nbsp;&nbsp;(put&nbsp;\'add&nbsp;\'(rational&nbsp;rational)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(tag&nbsp;(add-rat&nbsp;x&nbsp;y))))<br>\n&nbsp;&nbsp;(put&nbsp;\'sub&nbsp;\'(rational&nbsp;rational)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(tag&nbsp;(sub-rat&nbsp;x&nbsp;y))))<br>\n&nbsp;&nbsp;(put&nbsp;\'mul&nbsp;\'(rational&nbsp;rational)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(tag&nbsp;(mul-rat&nbsp;x&nbsp;y))))<br>\n&nbsp;&nbsp;(put&nbsp;\'div&nbsp;\'(rational&nbsp;rational)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(tag&nbsp;(div-rat&nbsp;x&nbsp;y))))<br>\n<br>\n&nbsp;&nbsp;(put&nbsp;\'make&nbsp;\'rational<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n&nbsp;d)&nbsp;(tag&nbsp;(make-rat&nbsp;n&nbsp;d))))<br>\n&nbsp;&nbsp;\'done)<br>\n<a name="%_idx_2532"></a>(define&nbsp;(make-rational&nbsp;n&nbsp;d)<br>\n&nbsp;&nbsp;((get&nbsp;\'make&nbsp;\'rational)&nbsp;n&nbsp;d))<br>\n</tt><p><p><p>\n\nWe can install a similar package to handle complex numbers, using the\ntag <tt>complex</tt>.  In creating the package, we extract from the table\nthe operations <tt>make-from-real-imag</tt> and <tt>make-from-mag-ang</tt>\nthat were defined by the rectangular and polar packages.  <a name="%_idx_2534"></a>Additivity\npermits us to use, as the internal operations, the same <tt>add-complex</tt>, <tt>sub-complex</tt>, <tt>mul-complex</tt>, and <tt>div-complex</tt> procedures from\nsection&nbsp;<a href="book-Z-H-17.html#%_sec_2.4.1">2.4.1</a>.\n<a name="%_idx_2536"></a><a name="%_idx_2538"></a><a name="%_idx_2540"></a>\n<p><p><tt><a name="%_idx_2542"></a>(define&nbsp;(install-complex-package)<br>\n&nbsp;&nbsp;<em>;;&nbsp;imported&nbsp;procedures&nbsp;from&nbsp;rectangular&nbsp;and&nbsp;polar&nbsp;packages</em><br>\n&nbsp;&nbsp;(define&nbsp;(make-from-real-imag&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;((get&nbsp;\'make-from-real-imag&nbsp;\'rectangular)&nbsp;x&nbsp;y))<br>\n&nbsp;&nbsp;(define&nbsp;(make-from-mag-ang&nbsp;r&nbsp;a)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;((get&nbsp;\'make-from-mag-ang&nbsp;\'polar)&nbsp;r&nbsp;a))<br>\n&nbsp;&nbsp;<em>;;&nbsp;internal&nbsp;procedures</em><br>\n&nbsp;&nbsp;(define&nbsp;(add-complex&nbsp;z1&nbsp;z2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(make-from-real-imag&nbsp;(+&nbsp;(real-part&nbsp;z1)&nbsp;(real-part&nbsp;z2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(imag-part&nbsp;z1)&nbsp;(imag-part&nbsp;z2))))<br>\n&nbsp;&nbsp;(define&nbsp;(sub-complex&nbsp;z1&nbsp;z2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(make-from-real-imag&nbsp;(-&nbsp;(real-part&nbsp;z1)&nbsp;(real-part&nbsp;z2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;(imag-part&nbsp;z1)&nbsp;(imag-part&nbsp;z2))))<br>\n&nbsp;&nbsp;(define&nbsp;(mul-complex&nbsp;z1&nbsp;z2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(make-from-mag-ang&nbsp;(*&nbsp;(magnitude&nbsp;z1)&nbsp;(magnitude&nbsp;z2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(angle&nbsp;z1)&nbsp;(angle&nbsp;z2))))<br>\n&nbsp;&nbsp;(define&nbsp;(div-complex&nbsp;z1&nbsp;z2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(make-from-mag-ang&nbsp;(/&nbsp;(magnitude&nbsp;z1)&nbsp;(magnitude&nbsp;z2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;(angle&nbsp;z1)&nbsp;(angle&nbsp;z2))))<br>\n&nbsp;&nbsp;<em>;;&nbsp;interface&nbsp;to&nbsp;rest&nbsp;of&nbsp;the&nbsp;system</em><br>\n&nbsp;&nbsp;(define&nbsp;(tag&nbsp;z)&nbsp;(attach-tag&nbsp;\'complex&nbsp;z))<br>\n&nbsp;&nbsp;(put&nbsp;\'add&nbsp;\'(complex&nbsp;complex)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(z1&nbsp;z2)&nbsp;(tag&nbsp;(add-complex&nbsp;z1&nbsp;z2))))<br>\n&nbsp;&nbsp;(put&nbsp;\'sub&nbsp;\'(complex&nbsp;complex)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(z1&nbsp;z2)&nbsp;(tag&nbsp;(sub-complex&nbsp;z1&nbsp;z2))))<br>\n&nbsp;&nbsp;(put&nbsp;\'mul&nbsp;\'(complex&nbsp;complex)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(z1&nbsp;z2)&nbsp;(tag&nbsp;(mul-complex&nbsp;z1&nbsp;z2))))<br>\n&nbsp;&nbsp;(put&nbsp;\'div&nbsp;\'(complex&nbsp;complex)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(z1&nbsp;z2)&nbsp;(tag&nbsp;(div-complex&nbsp;z1&nbsp;z2))))<br>\n&nbsp;&nbsp;(put&nbsp;\'make-from-real-imag&nbsp;\'complex<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(tag&nbsp;(make-from-real-imag&nbsp;x&nbsp;y))))<br>\n&nbsp;&nbsp;(put&nbsp;\'make-from-mag-ang&nbsp;\'complex<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(r&nbsp;a)&nbsp;(tag&nbsp;(make-from-mag-ang&nbsp;r&nbsp;a))))<br>\n&nbsp;&nbsp;\'done)<br>\n</tt><p><p>\n<p>\n\nPrograms outside the complex-number package can construct complex\nnumbers either from real and imaginary parts or from magnitudes and\nangles.  Notice how the underlying procedures, originally defined in\nthe rectangular and polar packages, are exported to the complex\npackage, and exported from there to the outside world.<p>\n\n<p><p><tt><a name="%_idx_2544"></a>(define&nbsp;(make-complex-from-real-imag&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;((get&nbsp;\'make-from-real-imag&nbsp;\'complex)&nbsp;x&nbsp;y))<br>\n<a name="%_idx_2546"></a>(define&nbsp;(make-complex-from-mag-ang&nbsp;r&nbsp;a)<br>\n&nbsp;&nbsp;((get&nbsp;\'make-from-mag-ang&nbsp;\'complex)&nbsp;r&nbsp;a))<br>\n</tt><p><p><p>\n\n<a name="%_idx_2548"></a>What we have here is a two-level tag system.  A typical complex number,\nsuch as 3 + 4<em>i</em> in rectangular form, would be\nrepresented as shown in figure&nbsp;<a href="#%_fig_2.24">2.24</a>.\nThe outer tag (<tt>complex</tt>) is used to direct the number to the\ncomplex package.  Once within the complex package, the next tag (<tt>rectangular</tt>) is used to direct the number to the rectangular package.\nIn a large and complicated system there might be many levels, each\ninterfaced with the next by means of generic operations.  As a data\nobject is passed ``downward,\'\' the outer tag that is used to direct\nit to the appropriate package is stripped off (by applying <tt>contents</tt>) and the next level of tag (if any) becomes visible to be used for\nfurther dispatching.<p>\n\n<a name="%_fig_2.24"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-65.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.24:</b>&nbsp;&nbsp;Representation of 3 + 4<em>i</em> in rectangular form.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nIn the above packages, we used <tt>add-rat</tt>, <tt>add-complex</tt>, and\nthe other arithmetic procedures exactly as originally written.\nOnce these definitions are internal to different installation procedures,\nhowever, they no longer need names that are distinct from each other:\nwe could simply name them <tt>add</tt>, <tt>sub</tt>, <tt>mul</tt>, and <tt>div</tt>\nin both packages.<p>\n\n<p><a name="%_thm_2.77"></a>\n<b>Exercise 2.77.</b>&nbsp;&nbsp;Louis Reasoner tries to evaluate the\nexpression <tt>(magnitude z)</tt> where <tt>z</tt> is the object\nshown in figure&nbsp;<a href="#%_fig_2.24">2.24</a>.  To his\nsurprise, instead of the answer 5\nhe gets an error message from <tt>apply-generic</tt>,\nsaying there is no method for the operation <tt>magnitude</tt>\non the types <tt>(complex)</tt>.\nHe shows this interaction to Alyssa P. Hacker, who says\n``The problem is that the complex-number selectors were never\ndefined for <tt>complex</tt> numbers, just for <tt>polar</tt> and <tt>rectangular</tt>\nnumbers.  All you have to do to make this work is add the following\nto the <tt>complex</tt> package:\'\'<p>\n\n<p><p><tt>(put&nbsp;\'real-part&nbsp;\'(complex)&nbsp;real-part)<br>\n(put&nbsp;\'imag-part&nbsp;\'(complex)&nbsp;imag-part)<br>\n(put&nbsp;\'magnitude&nbsp;\'(complex)&nbsp;magnitude)<br>\n(put&nbsp;\'angle&nbsp;\'(complex)&nbsp;angle)<br>\n</tt><p><p>\nDescribe in detail why this works.  As an example, trace through all\nthe procedures called in evaluating the expression <tt>(magnitude z)</tt>\nwhere <tt>z</tt> is the object shown in\nfigure&nbsp;<a href="#%_fig_2.24">2.24</a>.  In particular, how many\ntimes is <tt>apply-generic</tt> invoked?  What procedure is dispatched to\nin each case?\n<p><p>\n\n<p><a name="%_thm_2.78"></a>\n<b>Exercise 2.78.</b>&nbsp;&nbsp;<a name="%_idx_2550"></a><a name="%_idx_2552"></a><a name="%_idx_2554"></a><a name="%_idx_2556"></a><a name="%_idx_2558"></a><a name="%_idx_2560"></a><a name="%_idx_2562"></a>The internal procedures in the <tt>scheme-number</tt> package are essentially\nnothing more than calls to the primitive procedures <tt>+</tt>, <tt>-</tt>,\netc.  It was not possible to use the primitives of the language\ndirectly because our type-tag system requires that each data\nobject have a type attached to it.  In fact, however, all Lisp\nimplementations do have a type system, which they use internally.\nPrimitive predicates such as <tt>symbol?</tt> and <tt>number?</tt>\ndetermine whether data objects have particular types.  Modify the\ndefinitions of <tt>type-tag</tt>, <tt>contents</tt>, and <tt>attach-tag</tt>\nfrom section&nbsp;<a href="book-Z-H-17.html#%_sec_2.4.2">2.4.2</a> so that our generic system takes\nadvantage of Scheme\'s internal type system.  That is to say, the system\nshould work as before except that ordinary numbers should be\nrepresented simply as Scheme numbers rather than as pairs whose <tt>car</tt> is\nthe symbol <tt>scheme-number</tt>.\n\n<p><p>\n\n<p><a name="%_thm_2.79"></a>\n<b>Exercise 2.79.</b>&nbsp;&nbsp;<a name="%_idx_2564"></a><a name="%_idx_2566"></a>Define a generic equality predicate <tt>equ?</tt> that tests the equality\nof two numbers, and install it in the generic arithmetic\npackage.  This operation should work for ordinary numbers, rational numbers, and\ncomplex numbers.\n\n<p><p>\n\n<p><a name="%_thm_2.80"></a>\n<b>Exercise 2.80.</b>&nbsp;&nbsp;<a name="%_idx_2568"></a><a name="%_idx_2570"></a>Define a generic\npredicate <tt>=zero?</tt> that tests if its argument is zero,\nand install it in the generic arithmetic package.  This\noperation should work for ordinary numbers, rational numbers, and\ncomplex numbers.\n\n<p>\n\n<a name="%_sec_2.5.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.5.2">2.5.2&nbsp;&nbsp;Combining Data of Different Types</a></h3><p>\n\n<p>\n\nWe have seen how to define a unified arithmetic system that\nencompasses ordinary numbers, complex numbers, rational numbers, and\nany other type of number we might decide to invent, but we have\nignored an important issue.  The operations we have defined so far\ntreat the different data types as being completely independent.  Thus,\nthere are separate packages for adding, say, two ordinary numbers, or\ntwo complex numbers.  What we have not yet considered is the fact that\nit is meaningful to define operations that cross the type boundaries,\nsuch as the addition of a complex number to an ordinary number.  We\nhave gone to great pains to introduce barriers between parts of our\nprograms so that they can be developed and understood separately.  We\nwould like to introduce the cross-type operations in some carefully\ncontrolled way, so that we can support them\nwithout seriously violating our module boundaries.<p>\n\n<a name="%_idx_2572"></a><a name="%_idx_2574"></a><a name="%_idx_2576"></a>One way to handle cross-type operations is to design a different\nprocedure for each possible combination of types for which the\noperation is valid.  For example, we could extend the complex-number\npackage so that it provides a procedure for adding complex numbers to\nordinary numbers and installs this in the table using the tag <tt>(complex scheme-number)</tt>:<a name="call_footnote_Temp_283" href="#footnote_Temp_283"><sup><small>49</small></sup></a>\n<p><p><tt><em>;;&nbsp;to&nbsp;be&nbsp;included&nbsp;in&nbsp;the&nbsp;complex&nbsp;package</em><br>\n<a name="%_idx_2578"></a>(define&nbsp;(add-complex-to-schemenum&nbsp;z&nbsp;x)<br>\n&nbsp;&nbsp;(make-from-real-imag&nbsp;(+&nbsp;(real-part&nbsp;z)&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(imag-part&nbsp;z)))<br>\n(put&nbsp;\'add&nbsp;\'(complex&nbsp;scheme-number)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(z&nbsp;x)&nbsp;(tag&nbsp;(add-complex-to-schemenum&nbsp;z&nbsp;x))))<br>\n</tt><p><p><p>\n\nThis technique works, but it is cumbersome.  With such a system, the\ncost of introducing a new type is not just the construction of the\npackage of procedures for that type but also the construction and\ninstallation of the procedures that implement the cross-type\noperations.  This can easily be much more code than is needed to\ndefine the operations on the type itself.  The method also undermines\nour ability to combine separate packages additively, or\nleast to limit the extent to which the implementors of the individual\npackages need to take account of other packages.  For instance, in the\nexample above, it seems reasonable that handling mixed operations on\ncomplex numbers and ordinary numbers should be the responsibility of\nthe complex-number package.  Combining rational numbers and complex\nnumbers, however, might be done by the complex package, by the\nrational package, or by some third package that uses operations\nextracted from these two packages.  Formulating coherent policies on the\ndivision of responsibility among packages can be an overwhelming task\nin designing systems with many packages and many cross-type\noperations.<p>\n\n<a name="%_sec_Temp_284"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_284">Coercion</a></h4><p>\n\n<a name="%_idx_2580"></a>\nIn the general situation of completely unrelated operations acting on\ncompletely unrelated types, implementing explicit cross-type\noperations, cumbersome though it may be, is the best that one can hope\nfor.  Fortunately, we can usually do better by taking advantage of\nadditional structure that may be latent in our type system.  Often the\ndifferent data types are not completely independent, and there may be\nways by which objects of one type may be viewed as being of another\ntype.  This process is called <em>coercion</em>.  For example, if we are\nasked to arithmetically combine an ordinary number with a complex\nnumber, we can view the ordinary number as a complex number whose\nimaginary part is zero.  This transforms the problem to that of\ncombining two complex numbers, which can be handled in the ordinary\nway by the complex-arithmetic package.<p>\n\n<a name="%_idx_2582"></a>In general, we can implement this idea by designing coercion\nprocedures that transform an object of one type into an equivalent\nobject of another type.  Here is a typical coercion procedure, which\ntransforms a given ordinary number to a complex number with that real\npart and zero imaginary part:<p>\n\n<p><p><tt><a name="%_idx_2584"></a>(define&nbsp;(scheme-number-&gt;complex&nbsp;n)<br>\n&nbsp;&nbsp;(make-complex-from-real-imag&nbsp;(contents&nbsp;n)&nbsp;0))<br>\n</tt><p><p>\n<a name="%_idx_2586"></a><a name="%_idx_2588"></a>We install these coercion procedures in a special coercion table,\nindexed under the names of the two types:<p>\n\n<p><p><tt>(put-coercion&nbsp;\'scheme-number&nbsp;\'complex&nbsp;scheme-number-&gt;complex)<br>\n</tt><p><p>\n(We assume that there are <tt>put-coercion</tt> and <tt>get-coercion</tt>\nprocedures available for manipulating this table.)  Generally some of\nthe slots in the table will be empty, because it is not generally\npossible to coerce an arbitrary data object of each type into all\nother types.  For example, there is no way to coerce an arbitrary\ncomplex number to an ordinary number, so there will be no general <tt>complex-&gt;scheme-number</tt> procedure included in the table.<p>\n\nOnce the coercion table has been set up, we can handle coercion in a\nuniform manner by modifying the <tt>apply-generic</tt> procedure of\nsection&nbsp;<a href="book-Z-H-17.html#%_sec_2.4.3">2.4.3</a>.  When asked to apply an operation, we\nfirst check whether the operation is defined for the arguments\' types,\njust as before.  If so, we dispatch to the procedure found in the\noperation-and-type table.\nOtherwise, we try coercion.  For simplicity, we consider only the case\nwhere there are two arguments.<a name="call_footnote_Temp_285" href="#footnote_Temp_285"><sup><small>50</small></sup></a>  We\ncheck the coercion table to see if objects of the first type can\nbe coerced to the second type.  If so, we coerce the first argument and try the\noperation again.  If objects of the first type cannot in general be coerced to\nthe second type, we try the coercion the other way around to see if there is a\nway to coerce the second argument to the type of the first argument.\nFinally, if there\nis no known way to coerce either type to the other type, we give up.\nHere is the procedure:<p>\n\n<p><p><tt><a name="%_idx_2590"></a>(define&nbsp;(apply-generic&nbsp;op&nbsp;.&nbsp;args)<br>\n&nbsp;&nbsp;(let&nbsp;((type-tags&nbsp;(map&nbsp;type-tag&nbsp;args)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((proc&nbsp;(get&nbsp;op&nbsp;type-tags)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;proc<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;proc&nbsp;(map&nbsp;contents&nbsp;args))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;(length&nbsp;args)&nbsp;2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((type1&nbsp;(car&nbsp;type-tags))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(type2&nbsp;(cadr&nbsp;type-tags))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a1&nbsp;(car&nbsp;args))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a2&nbsp;(cadr&nbsp;args)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((t1-&gt;t2&nbsp;(get-coercion&nbsp;type1&nbsp;type2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t2-&gt;t1&nbsp;(get-coercion&nbsp;type2&nbsp;type1)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;(t1-&gt;t2<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply-generic&nbsp;op&nbsp;(t1-&gt;t2&nbsp;a1)&nbsp;a2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t2-&gt;t1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply-generic&nbsp;op&nbsp;a1&nbsp;(t2-&gt;t1&nbsp;a2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;No&nbsp;method&nbsp;for&nbsp;these&nbsp;types&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;op&nbsp;type-tags))))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;No&nbsp;method&nbsp;for&nbsp;these&nbsp;types&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;op&nbsp;type-tags)))))))<br>\n</tt><p><p><p>\n\nThis coercion scheme has many advantages over the method of defining\nexplicit cross-type operations, as outlined above.  Although we still\nneed to write coercion procedures to relate the types (possibly <em>n</em><sup>2</sup>\nprocedures for a system with <em>n</em> types), we need to write only one\nprocedure for each pair of types rather than a different procedure for\neach collection of types and each generic operation.<a name="call_footnote_Temp_286" href="#footnote_Temp_286"><sup><small>51</small></sup></a>  What we are counting on here is the fact that the\nappropriate transformation between types depends only on the types\nthemselves, not on the operation to be applied.<p>\n\nOn the other hand, there may be applications for which our coercion\nscheme is not general enough.  Even when neither of the objects to be\ncombined can be converted to the type of the other it may still be\npossible to perform the operation by converting both objects to a\nthird type.  In order to deal with such complexity and still preserve\nmodularity in our programs, it is usually necessary to build systems\nthat take advantage of still further structure in the relations among\ntypes, as we discuss next.<p>\n\n<a name="%_sec_Temp_287"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_287">Hierarchies of types</a></h4><p>\n\n<a name="%_idx_2592"></a><a name="%_idx_2594"></a>\nThe coercion scheme presented above relied on the existence of natural\nrelations between pairs of types.  Often there is more ``global\'\'\nstructure in how the different types relate to each other.  For\ninstance, suppose we are building a generic arithmetic system to\nhandle integers, rational numbers, real numbers, and complex numbers.\nIn such a system, it is quite natural to regard an integer as a\nspecial kind of rational number, which is in turn a special kind of\nreal number, which is in turn a special kind of complex number.  What\nwe actually have is a so-called <em>hierarchy of types</em>, in which,\nfor example, integers are a <a name="%_idx_2596"></a><a name="%_idx_2598"></a><em>subtype</em> of rational numbers (i.e.,\nany operation that can be applied to a rational number can\nautomatically be applied to an integer).  Conversely, we say that\nrational numbers form a <a name="%_idx_2600"></a><a name="%_idx_2602"></a><em>supertype</em> of integers.  The particular\nhierarchy we have here is of a very simple kind, in which each type\nhas at most one supertype and at most one subtype.  Such a structure,\ncalled a <em>tower</em>, is illustrated in figure&nbsp;<a href="#%_fig_2.25">2.25</a>.<p>\n\n<a name="%_fig_2.25"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-66.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.25:</b>&nbsp;&nbsp;A tower of types.</div></caption><tr><td>\n<a name="%_idx_2604"></a><a name="%_idx_2606"></a>\n</td></tr></table></div><p><p>\n\nIf we have a tower structure, then we can greatly simplify the problem\nof adding a new type to the hierarchy, for we need only specify how\nthe new type is embedded in the next supertype above it and how it is\nthe supertype of the type below it.  For example, if we want to add an\ninteger to a complex number, we need not explicitly define a special\ncoercion procedure <tt>integer-&gt;complex</tt>.  Instead, we define how an\ninteger can be transformed into a rational number, how a rational\nnumber is transformed into a real number, and how a real number is\ntransformed into a complex number.  We then allow the system to\ntransform the integer into a complex number through these steps and\nthen add the two complex numbers.<p>\n\n<a name="%_idx_2608"></a><a name="%_idx_2610"></a>We can redesign our <tt>apply-generic</tt> procedure in the following\nway: For each type, we need to supply a <tt>raise</tt> procedure, which\n``raises\'\' objects of that type one level in the tower.  Then when the\nsystem is required to operate on objects of different types it can\nsuccessively raise the lower types until all the objects are at\nthe same level in the tower.  (Exercises&nbsp;<a href="#%_thm_2.83">2.83</a>\nand &nbsp;<a href="#%_thm_2.84">2.84</a>\nconcern the details of implementing such a strategy.)<p>\n\nAnother advantage of a tower is that we can easily implement the\nnotion that every type ``inherits\'\' all operations defined on a\nsupertype.  For instance, if we do not supply a special procedure for\nfinding the real part of an integer, we should nevertheless expect\nthat <tt>real-part</tt> will be defined for integers by virtue of the\nfact that integers are a subtype of complex numbers.  In a tower, we\ncan arrange for this to happen in a uniform way by modifying <tt>apply-generic</tt>.  If the required operation is not directly defined for\nthe type of the object given, we raise the object to its supertype and\ntry again.  We thus crawl up the tower, transforming our argument as we\ngo, until we either find a level at which the desired operation can be\nperformed or hit the top (in which case we give up).<p>\n\n<a name="%_idx_2612"></a>Yet another advantage of a tower over a more general hierarchy is that\nit gives us a simple way to ``lower\'\' a data object to the simplest\nrepresentation.  For example, if we add 2 + 3<em>i</em> to 4 - 3<em>i</em>, it would be\nnice to obtain the answer as the integer 6 rather than as the complex\nnumber 6 + 0<em>i</em>.  Exercise&nbsp;<a href="#%_thm_2.85">2.85</a> discusses a way to implement\nsuch a lowering operation.  (The trick is that we need a general way\nto distinguish those objects that can be lowered, such as 6 + 0<em>i</em>, from\nthose that cannot, such as 6 + 2<em>i</em>.)<p>\n\n<a name="%_fig_2.26"></a><p><div align=left><table width=100%><tr><td><img src="ch2-Z-G-67.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 2.26:</b>&nbsp;&nbsp;Relations among types of geometric figures.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_sec_Temp_288"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_288">Inadequacies of hierarchies</a></h4><p>\n\n<a name="%_idx_2614"></a>\n\nIf the data types in our system can be naturally arranged in a tower,\nthis greatly simplifies the problems of dealing with generic operations\non different types, as we have seen.  Unfortunately, this is usually\nnot the case.  Figure&nbsp;<a href="#%_fig_2.26">2.26</a> illustrates a\nmore complex arrangement of mixed types, this one showing relations\namong different types of geometric figures.  We see that, in general,\n<a name="%_idx_2616"></a><a name="%_idx_2618"></a><a name="%_idx_2620"></a>a type may have more than one subtype.  Triangles and quadrilaterals,\nfor instance, are both subtypes of polygons.  In addition, a type may\nhave more than one supertype.  For example, an isosceles right\ntriangle may be regarded either as an isosceles triangle or as a right\ntriangle.  This multiple-supertypes issue is particularly thorny,\nsince it means that there is no unique way to ``raise\'\' a type in the\nhierarchy.  Finding the ``correct\'\' supertype in which to apply an\noperation to an object may involve considerable searching through the\nentire type network on the part of a procedure such as <tt>apply-generic</tt>.  Since there generally are multiple subtypes for a\ntype, there is a similar problem in coercing a value ``down\'\' the type\nhierarchy.  Dealing with large numbers of interrelated types while\nstill preserving modularity in the design of large systems is very\ndifficult, and is an area of much current research.<a name="call_footnote_Temp_289" href="#footnote_Temp_289"><sup><small>52</small></sup></a><p>\n\n\n<p><a name="%_thm_2.81"></a>\n<b>Exercise 2.81.</b>&nbsp;&nbsp;<a name="%_idx_2626"></a>Louis Reasoner has noticed that <tt>apply-generic</tt> may try to\ncoerce the arguments to each other\'s type even if they already have\nthe same type.  Therefore, he reasons, we need to put procedures\nin the coercion table to &quot;coerce&quot; arguments of each type to their\nown type.  For example, in addition to the <tt>scheme-number-&gt;complex</tt>\ncoercion shown above, he would do:<p>\n\n\n\n<p><p><tt><a name="%_idx_2628"></a>(define&nbsp;(scheme-number-&gt;scheme-number&nbsp;n)&nbsp;n)<br>\n<a name="%_idx_2630"></a>(define&nbsp;(complex-&gt;complex&nbsp;z)&nbsp;z)<br>\n(put-coercion&nbsp;\'scheme-number&nbsp;\'scheme-number<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scheme-number-&gt;scheme-number)<br>\n(put-coercion&nbsp;\'complex&nbsp;\'complex&nbsp;complex-&gt;complex)<br>\n</tt><p><p><p>\n\n<p><p>a. With Louis\'s coercion procedures installed, what happens if <tt>apply-generic</tt>\nis called with two arguments of type <tt>scheme-number</tt> or two arguments of\ntype <tt>complex</tt> for an operation that is not found in the table for those\ntypes?  For example, assume that we\'ve defined a generic exponentiation\noperation:<p>\n\n\n<p><p><tt>(define&nbsp;(exp&nbsp;x&nbsp;y)&nbsp;(apply-generic&nbsp;\'exp&nbsp;x&nbsp;y))<br>\n</tt><p><p>\nand have put a procedure for exponentiation in the Scheme-number\npackage but not in any other package:<p>\n\n\n<p><p><tt><em>;;&nbsp;following&nbsp;added&nbsp;to&nbsp;Scheme-number&nbsp;package</em><br>\n(put&nbsp;\'exp&nbsp;\'(scheme-number&nbsp;scheme-number)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(tag&nbsp;(expt&nbsp;x&nbsp;y))))&nbsp;<em>;&nbsp;using&nbsp;primitive&nbsp;<tt>expt</tt></em><br>\n</tt><p><p>\nWhat happens if we call <tt>exp</tt> with two complex numbers as arguments?<p>\n\n<p><p>b. Is Louis correct that something had to be done about\ncoercion with arguments of the same type, or does <tt>apply-generic</tt>\nwork correctly as is?<p>\n\n<p><p>c. Modify <tt>apply-generic</tt> so that it doesn\'t try coercion if\nthe two arguments have the same type.\n<p><p>\n\n<p><a name="%_thm_2.82"></a>\n<b>Exercise 2.82.</b>&nbsp;&nbsp;<a name="%_idx_2632"></a>Show how to generalize <tt>apply-generic</tt> to handle\ncoercion in the general case of multiple arguments.  One strategy is\nto attempt to coerce all the arguments to the type of the first argument, then\nto the type of the second argument, and so on.  Give an example of a situation\nwhere this strategy (and likewise the two-argument version given\nabove) is not sufficiently general.  (Hint: Consider the case where\nthere are some suitable mixed-type operations present in the table\nthat will not be tried.)\n\n<p><p>\n\n<p><a name="%_thm_2.83"></a>\n<b>Exercise 2.83.</b>&nbsp;&nbsp;<a name="%_idx_2634"></a>Suppose you are designing a generic arithmetic system for dealing with\nthe tower of types shown in figure&nbsp;<a href="#%_fig_2.25">2.25</a>:\ninteger, rational, real, complex.  For\neach type (except complex), design a procedure that raises objects of\nthat type one level in the tower.  Show how to install a generic <tt>raise</tt> operation that will work for each type (except complex).\n\n<p><p>\n\n<p><a name="%_thm_2.84"></a>\n<b>Exercise 2.84.</b>&nbsp;&nbsp;<a name="%_idx_2636"></a>Using the <tt>raise</tt> operation of exercise&nbsp;<a href="#%_thm_2.83">2.83</a>, modify the <tt>apply-generic</tt> procedure so that it coerces its arguments to have the\nsame type by the method of successive raising, as discussed in this\nsection.  You will need to devise a way to test which of two types is\nhigher in the tower.  Do this in a manner that is ``compatible\'\' with\nthe rest of the system and will not lead to problems in adding new\nlevels to the tower.\n\n<p><p>\n\n<p><a name="%_thm_2.85"></a>\n<b>Exercise 2.85.</b>&nbsp;&nbsp;<a name="%_idx_2638"></a><a name="%_idx_2640"></a>This section mentioned a method for ``simplifying\'\' a data object\nby lowering it in the tower of types as far as possible.  Design\na procedure <tt>drop</tt> that accomplishes this for the tower described\nin exercise&nbsp;<a href="#%_thm_2.83">2.83</a>.  The key is to decide, in some general way, whether\nan object can be lowered.  For example, the complex number 1.5 + 0<em>i</em>\ncan be lowered as far as <tt>real</tt>, the complex number 1 + 0<em>i</em> can be\nlowered as far as <tt>integer</tt>, and the complex number 2 + 3<em>i</em> cannot\nbe lowered at all.  Here is a plan for determining whether an object\ncan be lowered: Begin by defining a generic operation <tt>project</tt>\nthat ``pushes\'\' an object down in the tower.  For example, projecting\na complex number would involve throwing away the imaginary part.  Then\na number can be dropped if, when we <tt>project</tt> it and <tt>raise</tt>\nthe result back to the type we started with, we end up with something\nequal to what we started with.  Show how to implement this idea in\ndetail, by writing a <tt>drop</tt> procedure that drops an object as far\nas possible.  You will need to design the various projection\noperations<a name="call_footnote_Temp_295" href="#footnote_Temp_295"><sup><small>53</small></sup></a> and install <tt>project</tt> as a generic operation in\nthe system.  You will also need to make use of a generic equality\npredicate, such as described in exercise&nbsp;<a href="#%_thm_2.79">2.79</a>.  Finally, use <tt>drop</tt>\nto rewrite <tt>apply-generic</tt> from exercise&nbsp;<a href="#%_thm_2.84">2.84</a> so that it\n``simplifies\'\' its answers.\n\n<p> <p>\n\n<p><a name="%_thm_2.86"></a>\n<b>Exercise 2.86.</b>&nbsp;&nbsp;Suppose we want to handle complex numbers whose real\nparts, imaginary parts, magnitudes, and angles can be either ordinary\nnumbers, rational numbers, or other numbers we might wish to add to\nthe system.  Describe and implement the changes to the system needed\nto accommodate this.  You will have to define operations such as <tt>sine</tt> and <tt>cosine</tt> that are generic over ordinary numbers and\nrational numbers.\n<p> \n<p>\n\n<a name="%_sec_2.5.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.5.3">2.5.3&nbsp;&nbsp;Example: Symbolic Algebra</a></h3><p>\n\n\n<a name="%_idx_2646"></a>\nThe manipulation of symbolic algebraic expressions is a complex\nprocess that illustrates many of the hardest problems that occur in\nthe design of large-scale systems.  An algebraic expression, in\n<a name="%_idx_2648"></a>general, can be viewed as a hierarchical structure, a tree of\noperators applied to operands.  We can construct algebraic expressions\nby starting with a set of primitive objects, such as constants and\nvariables, and combining these by means of algebraic operators, such\nas addition and multiplication.  As in other languages, we form\nabstractions that enable us to refer to compound objects in simple\nterms.  Typical abstractions in symbolic algebra are ideas such as\nlinear combination, polynomial, rational function, or trigonometric\nfunction.  We can regard these as compound ``types,\'\' which are often\nuseful for directing the processing of expressions.  For example, we\ncould describe the expression<p>\n\n<p><div align=left><img src="ch2-Z-G-68.gif" border="0"></div><p>\nas a polynomial in <em>x</em> with coefficients that are trigonometric\nfunctions of polynomials in <em>y</em> whose coefficients are integers.<p>\n\nWe will not attempt to develop a complete algebraic-manipulation\nsystem here.  Such systems are exceedingly complex programs, embodying\ndeep algebraic knowledge and elegant algorithms.  What we will do is\nlook at a simple but important part of algebraic manipulation: the\narithmetic of polynomials.  We will illustrate the kinds of decisions\nthe designer of such a system faces, and how to apply the ideas of\nabstract data and generic operations to help organize this effort.<p>\n\n<a name="%_sec_Temp_297"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_297">Arithmetic on polynomials</a></h4><p>\n\n<a name="%_idx_2650"></a><a name="%_idx_2652"></a>\nOur first task in designing a system for performing arithmetic on\npolynomials is to decide just what a polynomial is.  Polynomials are\nnormally defined relative to certain variables (the <a name="%_idx_2654"></a><a name="%_idx_2656"></a><em>indeterminates</em> of the polynomial).  For simplicity, we will restrict\nourselves to polynomials having just one indeterminate (<a name="%_idx_2658"></a><a name="%_idx_2660"></a><em>univariate polynomials</em>).<a name="call_footnote_Temp_298" href="#footnote_Temp_298"><sup><small>54</small></sup></a> We will define a polynomial to be a\nsum of terms, each of which is either a coefficient, a power of the\nindeterminate, or a product of a coefficient and a power of the\nindeterminate.  A coefficient is defined as an algebraic expression\nthat is not dependent upon the indeterminate of the polynomial.  For\nexample,\n<p><div align=left><img src="ch2-Z-G-69.gif" border="0"></div><p>\nis a simple polynomial in <em>x</em>, and\n<p><div align=left><img src="ch2-Z-G-70.gif" border="0"></div><p>\nis a polynomial in <em>x</em> whose coefficients are polynomials in <em>y</em>.<p>\n\nAlready we are skirting some thorny issues.  Is the first of these\npolynomials the same as the polynomial 5<em>y</em><sup>2</sup>  + 3<em>y</em>  + 7, or not?  A\nreasonable answer might be ``yes, if we are considering a polynomial\npurely as a mathematical function, but no, if we are considering a\npolynomial to be a syntactic form.\'\'  The second polynomial is\nalgebraically equivalent to a polynomial in <em>y</em> whose coefficients are\npolynomials in <em>x</em>.  Should our system recognize this, or not?\nFurthermore, there are other ways to represent a polynomial -- for\nexample, as a product of factors, or (for a univariate polynomial) as\nthe set of roots, or as a listing of the values of the polynomial at a\nspecified set of points.<a name="call_footnote_Temp_299" href="#footnote_Temp_299"><sup><small>55</small></sup></a>\nWe can finesse these questions by deciding that in our\nalgebraic-manipulation system a ``polynomial\'\' will be a\nparticular syntactic form, not its underlying mathematical meaning.<p>\n\nNow we must consider how to go about doing arithmetic on polynomials.\nIn this simple system, we will consider only addition and\nmultiplication.  Moreover, we will insist that two polynomials to be\ncombined must have the same indeterminate.<p>\n\n\nWe will approach the design of our system by following the familiar\ndiscipline of data abstraction.  We will represent polynomials using a\ndata structure called a <a name="%_idx_2664"></a><em>poly</em>, which consists of a variable and a\n<a name="%_idx_2666"></a>collection of terms.  We assume that we have selectors <tt>variable</tt>\nand <tt>term-list</tt> that extract those parts from a poly and\na constructor <tt>make-poly</tt> that assembles a\npoly from a given variable and a term list.\nA variable will be just a symbol, so we can use the <a name="%_idx_2668"></a><tt>same-variable?</tt>\nprocedure of section&nbsp;<a href="book-Z-H-16.html#%_sec_2.3.2">2.3.2</a> to compare variables.\n<a name="%_idx_2670"></a><a name="%_idx_2672"></a>The following procedures define addition and multiplication of polys:<p>\n\n<p><p><tt><a name="%_idx_2674"></a>(define&nbsp;(add-poly&nbsp;p1&nbsp;p2)<br>\n&nbsp;&nbsp;(if&nbsp;(same-variable?&nbsp;(variable&nbsp;p1)&nbsp;(variable&nbsp;p2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-poly&nbsp;(variable&nbsp;p1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-terms&nbsp;(term-list&nbsp;p1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(term-list&nbsp;p2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Polys&nbsp;not&nbsp;in&nbsp;same&nbsp;var&nbsp;--&nbsp;ADD-POLY&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;p1&nbsp;p2))))<br>\n<a name="%_idx_2676"></a>(define&nbsp;(mul-poly&nbsp;p1&nbsp;p2)<br>\n&nbsp;&nbsp;(if&nbsp;(same-variable?&nbsp;(variable&nbsp;p1)&nbsp;(variable&nbsp;p2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-poly&nbsp;(variable&nbsp;p1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mul-terms&nbsp;(term-list&nbsp;p1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(term-list&nbsp;p2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Polys&nbsp;not&nbsp;in&nbsp;same&nbsp;var&nbsp;--&nbsp;MUL-POLY&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;p1&nbsp;p2))))<br>\n</tt><p><p><p>\n\nTo incorporate polynomials into our generic arithmetic system, we need\nto supply them with type tags.  We\'ll use the tag <tt>polynomial</tt>,\nand install appropriate operations on tagged polynomials in\nthe operation table.  We\'ll embed all our code\nin an installation procedure for the polynomial package,\nsimilar to the ones in\nsection&nbsp;<a href="#%_sec_2.5.1">2.5.1</a>:\n<a name="%_idx_2678"></a><a name="%_idx_2680"></a><a name="%_idx_2682"></a>\n<p><p><tt><a name="%_idx_2684"></a><a name="%_idx_2686"></a><a name="%_idx_2688"></a><a name="%_idx_2690"></a>(define&nbsp;(install-polynomial-package)<br>\n&nbsp;&nbsp;<em>;;&nbsp;internal&nbsp;procedures</em><br>\n&nbsp;&nbsp;<em>;;&nbsp;representation&nbsp;of&nbsp;poly</em><br>\n&nbsp;&nbsp;(define&nbsp;(make-poly&nbsp;variable&nbsp;term-list)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;variable&nbsp;term-list))<br>\n&nbsp;&nbsp;(define&nbsp;(variable&nbsp;p)&nbsp;(car&nbsp;p))<br>\n&nbsp;&nbsp;(define&nbsp;(term-list&nbsp;p)&nbsp;(cdr&nbsp;p))<br>\n&nbsp;&nbsp;&lt;<em>procedures&nbsp;<tt>same-variable?</tt>&nbsp;and&nbsp;<tt>variable?</tt>&nbsp;from&nbsp;section&nbsp;<a href="book-Z-H-16.html#%_sec_2.3.2">2.3.2</a></em>&gt;<br>\n&nbsp;&nbsp;<em>;;&nbsp;representation&nbsp;of&nbsp;terms&nbsp;and&nbsp;term&nbsp;lists</em><br>\n&nbsp;&nbsp;&lt;<em>procedures&nbsp;<tt>adjoin-term&nbsp;<tt>...</tt><tt>coeff</tt></tt>&nbsp;from&nbsp;text&nbsp;below</em>&gt;<br>\n<br>\n&nbsp;&nbsp;<em>;;&nbsp;continued&nbsp;on&nbsp;next&nbsp;page</em><br>\n<br>\n&nbsp;&nbsp;(define&nbsp;(add-poly&nbsp;p1&nbsp;p2)&nbsp;<tt>...</tt>)<br>\n&nbsp;&nbsp;&lt;<em>procedures&nbsp;used&nbsp;by&nbsp;<tt>add-poly</tt></em>&gt;<br>\n&nbsp;&nbsp;(define&nbsp;(mul-poly&nbsp;p1&nbsp;p2)&nbsp;<tt>...</tt>)<br>\n&nbsp;&nbsp;&lt;<em>procedures&nbsp;used&nbsp;by&nbsp;<tt>mul-poly</tt></em>&gt;<br>\n&nbsp;&nbsp;<em>;;&nbsp;interface&nbsp;to&nbsp;rest&nbsp;of&nbsp;the&nbsp;system</em><br>\n&nbsp;&nbsp;(define&nbsp;(tag&nbsp;p)&nbsp;(attach-tag&nbsp;\'polynomial&nbsp;p))<br>\n&nbsp;&nbsp;(put&nbsp;\'add&nbsp;\'(polynomial&nbsp;polynomial)&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(p1&nbsp;p2)&nbsp;(tag&nbsp;(add-poly&nbsp;p1&nbsp;p2))))<br>\n&nbsp;&nbsp;(put&nbsp;\'mul&nbsp;\'(polynomial&nbsp;polynomial)&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(p1&nbsp;p2)&nbsp;(tag&nbsp;(mul-poly&nbsp;p1&nbsp;p2))))<br>\n&nbsp;&nbsp;(put&nbsp;\'make&nbsp;\'polynomial<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(var&nbsp;terms)&nbsp;(tag&nbsp;(make-poly&nbsp;var&nbsp;terms))))<br>\n&nbsp;&nbsp;\'done)<br>\n</tt><p><p><p>\n\nPolynomial addition is performed termwise.  Terms of the same order\n(i.e., with the same power of the indeterminate) must be combined.\nThis is done by forming a new term of the same order whose coefficient\nis the sum of the coefficients of the addends.  Terms in one addend\nfor which there are no terms of the same order in the other addend are\nsimply accumulated into the sum polynomial being constructed.<p>\n\nIn order to manipulate term lists, we will assume that we have a\nconstructor <a name="%_idx_2692"></a><tt>the-empty-termlist</tt> that returns an empty term list\nand a constructor <a name="%_idx_2694"></a><tt>adjoin-term</tt> that adjoins a new term to a term\nlist.  We will also assume that we have a predicate <a name="%_idx_2696"></a><tt>empty-termlist?</tt> that tells if a given term list is empty, a selector\n<a name="%_idx_2698"></a><tt>first-term</tt> that extracts the highest-order term from a term\nlist, and a selector <a name="%_idx_2700"></a><tt>rest-terms</tt> that returns all but the highest-order\nterm.  To manipulate terms, we will suppose that we have a\nconstructor <a name="%_idx_2702"></a><tt>make-term</tt> that constructs a term with given\norder and coefficient, and selectors <a name="%_idx_2704"></a><tt>order</tt> and <a name="%_idx_2706"></a><tt>coeff</tt> that return, respectively, the order and the\ncoefficient of the term.  These operations allow us to consider both\nterms and term lists as data abstractions, whose concrete\nrepresentations we can worry about separately.<p>\n\nHere is the procedure that constructs the term list for the sum of two\npolynomials:<a name="call_footnote_Temp_300" href="#footnote_Temp_300"><sup><small>56</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_2708"></a>(define&nbsp;(add-terms&nbsp;L1&nbsp;L2)<br>\n&nbsp;&nbsp;(cond&nbsp;((empty-termlist?&nbsp;L1)&nbsp;L2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((empty-termlist?&nbsp;L2)&nbsp;L1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((t1&nbsp;(first-term&nbsp;L1))&nbsp;(t2&nbsp;(first-term&nbsp;L2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((&gt;&nbsp;(order&nbsp;t1)&nbsp;(order&nbsp;t2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(adjoin-term<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1&nbsp;(add-terms&nbsp;(rest-terms&nbsp;L1)&nbsp;L2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;(order&nbsp;t1)&nbsp;(order&nbsp;t2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(adjoin-term<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t2&nbsp;(add-terms&nbsp;L1&nbsp;(rest-terms&nbsp;L2))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(adjoin-term<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-term&nbsp;(order&nbsp;t1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add&nbsp;(coeff&nbsp;t1)&nbsp;(coeff&nbsp;t2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-terms&nbsp;(rest-terms&nbsp;L1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rest-terms&nbsp;L2)))))))))<br>\n</tt><p><p>\nThe most important point to note here is that we used the generic\naddition procedure <a name="%_idx_2710"></a><tt>add</tt> to add together the coefficients of the\nterms being combined.  This has powerful consequences, as we will see\nbelow.<p>\n\nIn order to multiply two term lists, we multiply each term of the\nfirst list by all the terms of the other list, repeatedly using\n<tt>mul-term-by-all-terms</tt>, which multiplies a given term by\nall terms in a given term list.  The resulting term lists (one for\neach term of the first list) are accumulated into a sum.  Multiplying\ntwo terms forms a term whose order is the sum of the orders of the\nfactors and whose coefficient is the product of the coefficients of\nthe factors:<p>\n\n<p><p><tt><a name="%_idx_2712"></a>(define&nbsp;(mul-terms&nbsp;L1&nbsp;L2)<br>\n&nbsp;&nbsp;(if&nbsp;(empty-termlist?&nbsp;L1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(the-empty-termlist)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-terms&nbsp;(mul-term-by-all-terms&nbsp;(first-term&nbsp;L1)&nbsp;L2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mul-terms&nbsp;(rest-terms&nbsp;L1)&nbsp;L2))))<br>\n(define&nbsp;(mul-term-by-all-terms&nbsp;t1&nbsp;L)<br>\n&nbsp;&nbsp;(if&nbsp;(empty-termlist?&nbsp;L)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(the-empty-termlist)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((t2&nbsp;(first-term&nbsp;L)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(adjoin-term<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-term&nbsp;(+&nbsp;(order&nbsp;t1)&nbsp;(order&nbsp;t2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mul&nbsp;(coeff&nbsp;t1)&nbsp;(coeff&nbsp;t2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mul-term-by-all-terms&nbsp;t1&nbsp;(rest-terms&nbsp;L))))))<br>\n</tt><p><p><p>\n\nThis is really all there is to polynomial addition and multiplication.\n<a name="%_idx_2714"></a><a name="%_idx_2716"></a>Notice that, since we operate on terms using the generic procedures\n<tt>add</tt> and <tt>mul</tt>, our polynomial package is automatically able\nto handle any type of coefficient that is known about by the generic\narithmetic package.  If we include a <a name="%_idx_2718"></a>coercion mechanism such as one of\nthose discussed in section&nbsp;<a href="#%_sec_2.5.2">2.5.2</a>,\nthen we also are automatically able to handle operations on\npolynomials of different coefficient types, such as\n<p><div align=left><img src="ch2-Z-G-71.gif" border="0"></div><p><p>\n\nBecause we installed the polynomial addition and\nmultiplication procedures <tt>add-poly</tt> and <tt>mul-poly</tt> in the generic\narithmetic system as the <tt>add</tt> and <tt>mul</tt> operations\nfor type <tt>polynomial</tt>, our system is also\nautomatically able to handle polynomial operations such as\n<p><div align=left><img src="ch2-Z-G-72.gif" border="0"></div><p><p>\n\nThe reason is that when the system tries to combine coefficients, it\nwill dispatch through <tt>add</tt> and <tt>mul</tt>.  Since the coefficients\nare themselves polynomials (in <em>y</em>), these will be combined using <tt>add-poly</tt> and <tt>mul-poly</tt>.  The result is a kind of <a name="%_idx_2720"></a><a name="%_idx_2722"></a>``data-directed\nrecursion\'\' in which, for example, a call to <tt>mul-poly</tt> will result\nin recursive calls to <tt>mul-poly</tt> in order to multiply the\ncoefficients.  If the coefficients of the coefficients were themselves\npolynomials (as might be used to represent polynomials in three\nvariables), the data direction would ensure that the system would\nfollow through another level of recursive calls, and so on through as\nmany levels as the structure of the data dictates.<a name="call_footnote_Temp_301" href="#footnote_Temp_301"><sup><small>57</small></sup></a>\n\n<a name="%_sec_Temp_302"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_302">Representing term lists</a></h4><p>\n\n<a name="%_idx_2724"></a>\nFinally, we must confront the job of implementing a good\nrepresentation for term lists.  A term list is, in effect, a set of\ncoefficients keyed by the order of the term.  Hence, any of the\nmethods for representing sets, as discussed in\nsection&nbsp;<a href="book-Z-H-16.html#%_sec_2.3.3">2.3.3</a>, can be applied to this task.  On\nthe other hand, our procedures <tt>add-terms</tt> and <tt>mul-terms</tt> always\naccess term lists sequentially from highest to lowest order.  Thus, we\nwill use some kind of ordered list representation.<p>\n\nHow should we structure the list that represents a term list?  One\nconsideration is the ``density\'\' of the polynomials we intend to\nmanipulate.  A polynomial is said to be <a name="%_idx_2726"></a><a name="%_idx_2728"></a><em>dense</em> if it has nonzero\ncoefficients in terms of most orders.  If it has many zero terms it\nis said to be <a name="%_idx_2730"></a><a name="%_idx_2732"></a><em>sparse</em>.  For example,\n<p><div align=left><img src="ch2-Z-G-74.gif" border="0"></div><p>\nis a dense polynomial, whereas\n<p><div align=left><img src="ch2-Z-G-75.gif" border="0"></div><p>\nis sparse.<p>\n\nThe term lists of dense polynomials are most efficiently represented\nas lists of the coefficients.  For example, <em>A</em> above would be nicely\nrepresented as <tt>(1 2 0 3 -2 -5)</tt>.  The order of a term in this\nrepresentation is the length of the sublist beginning with that term\'s\ncoefficient, decremented by 1.<a name="call_footnote_Temp_303" href="#footnote_Temp_303"><sup><small>58</small></sup></a>  This would be a terrible representation for a\nsparse polynomial such as <em>B</em>: There would be a giant list of zeros\npunctuated by a few lonely nonzero terms.  A more reasonable\nrepresentation of the term list of a sparse polynomial is as a list of\nthe nonzero terms, where each term is a list containing the order of the\nterm and the coefficient for that order.  In such a scheme, polynomial\n<em>B</em> is efficiently represented as <tt>((100 1) (2 2) (0 1))</tt>.  As\nmost polynomial manipulations are performed on sparse polynomials, we\nwill use this method.  We will assume that term lists are represented\nas lists of terms, arranged from highest-order to lowest-order term.\nOnce we have made this decision, implementing the selectors and\nconstructors for terms and term lists is straightforward:<a name="call_footnote_Temp_304" href="#footnote_Temp_304"><sup><small>59</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_2734"></a>(define&nbsp;(adjoin-term&nbsp;term&nbsp;term-list)<br>\n&nbsp;&nbsp;(if&nbsp;(=zero?&nbsp;(coeff&nbsp;term))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;term-list<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;term&nbsp;term-list)))<br>\n<a name="%_idx_2736"></a>(define&nbsp;(the-empty-termlist)&nbsp;\'())<br>\n<a name="%_idx_2738"></a>(define&nbsp;(first-term&nbsp;term-list)&nbsp;(car&nbsp;term-list))<br>\n<a name="%_idx_2740"></a>(define&nbsp;(rest-terms&nbsp;term-list)&nbsp;(cdr&nbsp;term-list))<br>\n<a name="%_idx_2742"></a>(define&nbsp;(empty-termlist?&nbsp;term-list)&nbsp;(null?&nbsp;term-list))<br>\n<a name="%_idx_2744"></a>(define&nbsp;(make-term&nbsp;order&nbsp;coeff)&nbsp;(list&nbsp;order&nbsp;coeff))<br>\n<a name="%_idx_2746"></a>(define&nbsp;(order&nbsp;term)&nbsp;(car&nbsp;term))<br>\n<a name="%_idx_2748"></a>(define&nbsp;(coeff&nbsp;term)&nbsp;(cadr&nbsp;term))<br>\n</tt><p><p>\nwhere <tt>=zero?</tt> is as defined in\nexercise&nbsp;<a href="#%_thm_2.80">2.80</a>.  (See also exercise&nbsp;<a href="#%_thm_2.87">2.87</a> below.)<p>\n\nUsers of the polynomial package\nwill create (tagged) polynomials by means of the procedure:<p>\n\n<p><p><tt><a name="%_idx_2750"></a>(define&nbsp;(make-polynomial&nbsp;var&nbsp;terms)<br>\n&nbsp;&nbsp;((get&nbsp;\'make&nbsp;\'polynomial)&nbsp;var&nbsp;terms))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_2.87"></a>\n<b>Exercise 2.87.</b>&nbsp;&nbsp;<a name="%_idx_2752"></a><a name="%_idx_2754"></a>Install <tt>=zero?</tt> for polynomials in the generic arithmetic\npackage.  This will allow <tt>adjoin-term</tt> to work for polynomials\nwith coefficients that are themselves polynomials.\n\n<p> <p>\n\n<p><a name="%_thm_2.88"></a>\n<b>Exercise 2.88.</b>&nbsp;&nbsp;<a name="%_idx_2756"></a>Extend the polynomial system to include subtraction of polynomials.\n(Hint: You may find it helpful to define a generic negation operation.)\n\n<p> <p>\n\n<p><a name="%_thm_2.89"></a>\n<b>Exercise 2.89.</b>&nbsp;&nbsp;Define procedures that implement the term-list representation\ndescribed above as appropriate for dense polynomials.\n<p> <p>\n\n<p><a name="%_thm_2.90"></a>\n<b>Exercise 2.90.</b>&nbsp;&nbsp;Suppose we want to have a polynomial system that is efficient for both\nsparse and dense polynomials.  One way to do this is to allow both\nkinds of term-list representations in our system.  The situation is\nanalogous to the complex-number example of section&nbsp;<a href="book-Z-H-17.html#%_sec_2.4">2.4</a>,\nwhere we allowed both rectangular and polar representations.\nTo do this we must distinguish different types of term lists and make\nthe operations on term lists generic.  Redesign the polynomial system\nto implement this generalization.  This is a major effort, not a local\nchange.\n<p> \n\n<p><a name="%_thm_2.91"></a>\n<b>Exercise 2.91.</b>&nbsp;&nbsp;<a name="%_idx_2758"></a>A univariate polynomial can be divided by another one to produce a\npolynomial quotient and a polynomial remainder.  For example,<p>\n\n<p><div align=left><img src="ch2-Z-G-76.gif" border="0"></div><p><p>\n\nDivision can be performed via long division.\nThat is, divide the highest-order term of the dividend by\nthe highest-order term of the divisor.  The result is the first term of the\nquotient.  Next, multiply the result by the divisor, subtract that\nfrom the dividend, and produce the rest of the answer by recursively\ndividing the difference by the divisor.  Stop when the order of the\ndivisor exceeds the order of the dividend and declare the dividend to\nbe the remainder.  Also, if the dividend ever becomes zero, return\nzero as both quotient and remainder.<p>\n\n<a name="%_idx_2760"></a>We can design a <tt>div-poly</tt> procedure on the model of <tt>add-poly</tt> and\n<tt>mul-poly</tt>. The procedure checks to see if the two polys have\nthe same variable.  If so, <tt>div-poly</tt> strips off the variable and\npasses the problem to <tt>div-terms</tt>, which performs the division\noperation on term lists. <tt>Div-poly</tt> finally reattaches the variable\nto the result supplied by <tt>div-terms</tt>.  It is convenient\nto design <tt>div-terms</tt> to compute both the quotient and the remainder\nof a division.  <tt>Div-terms</tt> can take two term lists as arguments and\nreturn a list of the quotient term list and the remainder term list.<p>\n\nComplete the following definition of <tt>div-terms</tt> by filling in the\nmissing expressions.  Use this to implement <tt>div-poly</tt>, which takes\ntwo polys as arguments and returns a list of the quotient and\nremainder polys.<p>\n\n<p><p><tt><a name="%_idx_2762"></a>(define&nbsp;(div-terms&nbsp;L1&nbsp;L2)<br>\n&nbsp;&nbsp;(if&nbsp;(empty-termlist?&nbsp;L1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(the-empty-termlist)&nbsp;(the-empty-termlist))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((t1&nbsp;(first-term&nbsp;L1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t2&nbsp;(first-term&nbsp;L2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;(order&nbsp;t2)&nbsp;(order&nbsp;t1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(the-empty-termlist)&nbsp;L1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((new-c&nbsp;(div&nbsp;(coeff&nbsp;t1)&nbsp;(coeff&nbsp;t2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new-o&nbsp;(-&nbsp;(order&nbsp;t1)&nbsp;(order&nbsp;t2))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((rest-of-result<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>compute&nbsp;rest&nbsp;of&nbsp;result&nbsp;recursively</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>form&nbsp;complete&nbsp;result</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;))))))<br>\n</tt><p><p>\n<p> <p>\n\n<a name="%_sec_Temp_310"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_310">Hierarchies of types in symbolic algebra</a></h4><p>\n\n<a name="%_idx_2764"></a><a name="%_idx_2766"></a><a name="%_idx_2768"></a>\nOur polynomial system illustrates how objects of one type\n(polynomials) may in fact be complex objects that have objects of many\ndifferent types as parts.  This poses no real difficulty in defining\ngeneric operations.  We need only install appropriate generic operations\nfor performing the necessary manipulations of the parts of the\ncompound types.  In fact, we saw that polynomials form a kind of\n``recursive data abstraction,\'\' in that parts of a polynomial may\nthemselves be polynomials.  Our generic operations and our\ndata-directed programming style can handle this complication without\nmuch trouble.<p>\n\nOn the other hand, polynomial algebra is a system for which the data\ntypes cannot be naturally arranged in a tower.  For instance, it is\npossible to have polynomials in <em>x</em> whose coefficients are polynomials\nin <em>y</em>.  It is also possible to have polynomials in <em>y</em> whose\ncoefficients are polynomials in <em>x</em>.  Neither of these types is\n``above\'\' the other in any natural way, yet it is often necessary to\nadd together elements from each set.  There are several ways to do\nthis.  One possibility is to convert one polynomial to the type of the\nother by expanding and rearranging terms so that both polynomials have\nthe same principal variable.  One can impose a towerlike structure on\nthis by ordering the variables and thus always converting any\npolynomial to a <a name="%_idx_2770"></a><a name="%_idx_2772"></a>``canonical form\'\' with the highest-priority variable\ndominant and the lower-priority variables buried in the coefficients.\nThis strategy works fairly well, except that the conversion may expand\na polynomial unnecessarily, making it hard to read and perhaps less\nefficient to work with.  The tower strategy is certainly not natural\nfor this domain or for any domain where the user can invent new types\ndynamically using old types in various combining forms, such as\ntrigonometric functions, power series, and integrals.<p>\n\nIt should not be surprising that controlling <a name="%_idx_2774"></a>coercion is a serious\nproblem in the design of large-scale algebraic-manipulation systems.\nMuch of the complexity of such systems is concerned with relationships\namong diverse types.  Indeed, it is fair to say that we do not yet\ncompletely understand coercion.  In fact, we do not yet completely\nunderstand the concept of a data type.  Nevertheless, what we know\nprovides us with powerful structuring and modularity principles to\nsupport the design of large systems.<p>\n\n<p><a name="%_thm_2.92"></a>\n<b>Exercise 2.92.</b>&nbsp;&nbsp;By imposing an ordering on variables, extend the polynomial package so\nthat addition and multiplication of polynomials works for polynomials\nin different variables.  (This is not easy!)\n<p> \n\n<a name="%_sec_Temp_312"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_312">Extended exercise: Rational functions</a></h4><p>\n\n<a name="%_idx_2776"></a><a name="%_idx_2778"></a><a name="%_idx_2780"></a>We can extend our generic arithmetic system to include <em>rational\nfunctions</em>.  These are ``fractions\'\' whose numerator and denominator\nare polynomials, such as<p>\n\n<p><div align=left><img src="ch2-Z-G-77.gif" border="0"></div><p>\nThe system should be able to add, subtract, multiply, and divide\nrational functions, and to perform such computations as\n<p><div align=left><img src="ch2-Z-G-78.gif" border="0"></div><p>\n(Here the sum has been simplified by removing common factors.\nOrdinary ``cross multiplication\'\' would have produced a \nfourth-degree polynomial over a fifth-degree polynomial.)<p>\n\nIf we modify our rational-arithmetic package so that it uses generic\noperations, then it will do what we want, except for the problem\nof reducing fractions to lowest terms.<p>\n\n<p><a name="%_thm_2.93"></a>\n<b>Exercise 2.93.</b>&nbsp;&nbsp;Modify the rational-arithmetic package to use generic operations, but\nchange <tt>make-rat</tt> so that it does not attempt to reduce fractions\nto lowest terms.  Test your system by calling <tt>make-rational</tt> on\ntwo polynomials to produce a rational function<p>\n\n<p><p><tt>(define&nbsp;p1&nbsp;(make-polynomial&nbsp;\'x&nbsp;\'((2&nbsp;1)(0&nbsp;1))))<br>\n(define&nbsp;p2&nbsp;(make-polynomial&nbsp;\'x&nbsp;\'((3&nbsp;1)(0&nbsp;1))))<br>\n(define&nbsp;rf&nbsp;(make-rational&nbsp;p2&nbsp;p1))<br>\n</tt><p><p>\nNow add <tt>rf</tt> to itself, using <tt>add</tt>. You will observe that\nthis addition procedure does not reduce fractions to lowest terms.\n\n<p> <p>\n\n<p><p>\nWe can reduce polynomial fractions to lowest terms using the same idea\nwe used with integers: modifying <tt>make-rat</tt> to divide both the\nnumerator and the denominator by their greatest common divisor.  The\nnotion of <a name="%_idx_2782"></a><a name="%_idx_2784"></a>``greatest common divisor\'\' makes sense for polynomials.  In\nfact, we can compute the GCD of two polynomials using essentially the\nsame Euclid\'s Algorithm that works for integers.<a name="call_footnote_Temp_314" href="#footnote_Temp_314"><sup><small>60</small></sup></a>  The\ninteger version is<p>\n\n\n<p><p><tt>(define&nbsp;(gcd&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;b&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gcd&nbsp;b&nbsp;(remainder&nbsp;a&nbsp;b))))<br>\n</tt><p><p>\nUsing this, we could make the obvious modification to define a GCD\noperation that works on term lists:<p>\n\n<p><p><tt><a name="%_idx_2794"></a>(define&nbsp;(gcd-terms&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(empty-termlist?&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gcd-terms&nbsp;b&nbsp;(remainder-terms&nbsp;a&nbsp;b))))<br>\n</tt><p><p>\nwhere <tt>remainder-terms</tt> picks out the remainder component of the\nlist returned by the term-list division operation <tt>div-terms</tt> that\nwas implemented in exercise&nbsp;<a href="#%_thm_2.91">2.91</a>.<p>\n\n<p><a name="%_thm_2.94"></a>\n<b>Exercise 2.94.</b>&nbsp;&nbsp;<a name="%_idx_2796"></a><a name="%_idx_2798"></a>Using <tt>div-terms</tt>, implement the procedure <tt>remainder-terms</tt> and\nuse this to define <tt>gcd-terms</tt> as above.  Now write a procedure\n<tt>gcd-poly</tt> that computes the polynomial GCD of two polys.\n(The procedure should signal an error if the two polys are not\nin the same variable.)  Install in the system a generic operation <tt>greatest-common-divisor</tt> that reduces to <tt>gcd-poly</tt> for polynomials\nand to ordinary <tt>gcd</tt> for ordinary numbers.  As a test, try<p>\n\n<p><p><tt>(define&nbsp;p1&nbsp;(make-polynomial&nbsp;\'x&nbsp;\'((4&nbsp;1)&nbsp;(3&nbsp;-1)&nbsp;(2&nbsp;-2)&nbsp;(1&nbsp;2))))<br>\n(define&nbsp;p2&nbsp;(make-polynomial&nbsp;\'x&nbsp;\'((3&nbsp;1)&nbsp;(1&nbsp;-1))))<br>\n(greatest-common-divisor&nbsp;p1&nbsp;p2)<br>\n</tt><p><p>\nand check your result by hand.\n\n<p> <p>\n\n<p><a name="%_thm_2.95"></a>\n<b>Exercise 2.95.</b>&nbsp;&nbsp;Define <em>P</em><sub>1</sub>, <em>P</em><sub>2</sub>, and <em>P</em><sub>3</sub> to be the polynomials<p>\n\n<p><div align=left><img src="ch2-Z-G-79.gif" border="0"></div><p><p>\n\n<p><div align=left><img src="ch2-Z-G-80.gif" border="0"></div><p><p>\n\n<p><div align=left><img src="ch2-Z-G-81.gif" border="0"></div><p><p>\n\nNow define <em>Q</em><sub>1</sub> to be the product of <em>P</em><sub>1</sub> and <em>P</em><sub>2</sub> and <em>Q</em><sub>2</sub> to\nbe the product of <em>P</em><sub>1</sub> and <em>P</em><sub>3</sub>, and use <tt>greatest-common-divisor</tt>\n(exercise&nbsp;<a href="#%_thm_2.94">2.94</a>) to\ncompute the GCD of <em>Q</em><sub>1</sub> and <em>Q</em><sub>2</sub>.\nNote that the answer is not the same as <em>P</em><sub>1</sub>.\nThis example introduces noninteger\noperations into the computation, causing difficulties with the GCD\nalgorithm.<a name="call_footnote_Temp_317" href="#footnote_Temp_317"><sup><small>61</small></sup></a>\nTo understand what is happening,\ntry tracing <tt>gcd-terms</tt> while computing the GCD or\ntry performing the division by hand.\n\n<p> <p>\n\n<p><p>We can solve the problem exhibited in exercise&nbsp;<a href="#%_thm_2.95">2.95</a> if\nwe use the following modification of the GCD algorithm (which really\nworks only in the case of polynomials with integer coefficients).\nBefore performing any polynomial division in the GCD computation, we\nmultiply the dividend by an integer constant factor, chosen to\nguarantee that no fractions will arise during the division process.\nOur answer will thus differ from the actual GCD by an integer constant\nfactor, but this does not matter in the case of reducing rational\nfunctions to lowest terms; the GCD will be used to divide both the\nnumerator and denominator, so the integer constant factor will cancel\nout.<p>\n\nMore precisely, if <em>P</em> and <em>Q</em> are polynomials, let <em>O</em><sub>1</sub> be the\norder of <em>P</em> (i.e., the order of the largest term of <em>P</em>) and let\n<em>O</em><sub>2</sub> be the order of <em>Q</em>.  Let <em>c</em> be the leading coefficient of\n<em>Q</em>.  Then it can be shown that, if we multiply <em>P</em> by the <a name="%_idx_2800"></a><em>integerizing factor</em> <em>c</em><sup>1+<em>O</em><sub>1</sub> -<em>O</em><sub>2</sub></sup>, the resulting polynomial can\nbe divided by <em>Q</em> by using the <tt>div-terms</tt> algorithm without\nintroducing any fractions.  The operation of multiplying the dividend\nby this constant and then dividing is sometimes called the <a name="%_idx_2802"></a><a name="%_idx_2804"></a><em>pseudodivision</em> of <em>P</em> by <em>Q</em>.  The remainder of the division is\ncalled the <em>pseudoremainder</em>.<p>\n\n<p><a name="%_thm_2.96"></a>\n<b>Exercise 2.96.</b>&nbsp;&nbsp;a.&nbsp;&nbsp;&nbsp;&nbsp;Implement the procedure <tt>pseudoremainder-terms</tt>, which is just like\n<tt>remainder-terms</tt> except that it multiplies the dividend by\nthe integerizing factor described above before calling <tt>div-terms</tt>.\nModify <tt>gcd-terms</tt> to use <tt>pseudoremainder-terms</tt>, and verify\nthat <tt>greatest-common-divisor</tt> now produces an answer with integer\ncoefficients on the example in exercise&nbsp;<a href="#%_thm_2.95">2.95</a>.<p>\n\n<p><p>b.&nbsp;&nbsp;&nbsp;&nbsp;The GCD now has integer coefficients, but they are larger than those\nof <em>P</em><sub>1</sub>.  Modify <tt>gcd-terms</tt> so that it removes common factors from\nthe coefficients of the answer by dividing all the coefficients by their\n(integer) greatest common divisor.\n\n<p>\n\n<p><p><a name="%_idx_2806"></a><a name="%_idx_2808"></a>Thus, here is how to reduce a rational function to lowest terms:<p>\n\n<p><ul>\n<li>Compute the GCD of the numerator and denominator, using\nthe version of <tt>gcd-terms</tt> from exercise&nbsp;<a href="#%_thm_2.96">2.96</a>.<p>\n\n<li>When you obtain the GCD, multiply both numerator and\ndenominator by the same integerizing factor before dividing through by\nthe GCD, so that division by the GCD will not introduce any noninteger\ncoefficients.  As the factor you can use the leading coefficient of\nthe GCD raised to the power 1 + <em>O</em><sub>1</sub>  - <em>O</em><sub>2</sub>, where <em>O</em><sub>2</sub> is the order\nof the GCD and <em>O</em><sub>1</sub> is the maximum of the orders of the numerator\nand denominator.  This will ensure that dividing the numerator and\ndenominator by the GCD will not introduce any fractions.<p>\n\n<li>The result of this operation will be a numerator and denominator\nwith integer coefficients.  The coefficients will normally be very\nlarge because of all of the integerizing factors, so the last step is\nto remove the redundant factors by computing the (integer) greatest\ncommon divisor of all the coefficients of the numerator and the\ndenominator and dividing through by this factor.\n</ul><p><p>\n\n<p><a name="%_thm_2.97"></a>\n<b>Exercise 2.97.</b>&nbsp;&nbsp;a. Implement this algorithm as a procedure <tt>reduce-terms</tt> that takes two\nterm lists <tt>n</tt> and <tt>d</tt> as arguments and returns a list <tt>nn</tt>, <tt>dd</tt>, which are <tt>n</tt> and <tt>d</tt> reduced to lowest terms\nvia the algorithm given above.\nAlso write a procedure <tt>reduce-poly</tt>, analogous to <tt>add-poly</tt>,\nthat checks to see if the two polys have\nthe same variable.  If so, <tt>reduce-poly</tt> strips off the variable and\npasses the problem to <tt>reduce-terms</tt>, then reattaches the variable\nto the two term lists supplied by <tt>reduce-terms</tt>.\n<p>\n\n<p><p>b. Define a procedure analogous to <tt>reduce-terms</tt>\nthat does what the original <tt>make-rat</tt> did for integers:<p>\n\n<p><p><tt>(define&nbsp;(reduce-integers&nbsp;n&nbsp;d)<br>\n&nbsp;&nbsp;(let&nbsp;((g&nbsp;(gcd&nbsp;n&nbsp;d)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(/&nbsp;n&nbsp;g)&nbsp;(/&nbsp;d&nbsp;g))))<br>\n</tt><p><p>\nand define\n<tt>reduce</tt> as a generic operation that calls <tt>apply-generic</tt> to\ndispatch to either <tt>reduce-poly</tt> (for <tt>polynomial</tt> arguments)\nor <tt>reduce-integers</tt> (for <tt>scheme-number</tt> arguments).\nYou can now easily make the\nrational-arithmetic package reduce fractions to lowest terms by\nhaving <tt>make-rat</tt> call <tt>reduce</tt> before combining the given\nnumerator and denominator to form a rational number.\nThe system now\nhandles rational expressions in either integers or polynomials.\nTo test your program, try the example at the beginning of this\nextended exercise:<p>\n\n<p><p><tt>(define&nbsp;p1&nbsp;(make-polynomial&nbsp;\'x&nbsp;\'((1&nbsp;1)(0&nbsp;1))))<br>\n(define&nbsp;p2&nbsp;(make-polynomial&nbsp;\'x&nbsp;\'((3&nbsp;1)(0&nbsp;-1))))<br>\n(define&nbsp;p3&nbsp;(make-polynomial&nbsp;\'x&nbsp;\'((1&nbsp;1))))<br>\n(define&nbsp;p4&nbsp;(make-polynomial&nbsp;\'x&nbsp;\'((2&nbsp;1)(0&nbsp;-1))))<br>\n<br>\n(define&nbsp;rf1&nbsp;(make-rational&nbsp;p1&nbsp;p2))<br>\n(define&nbsp;rf2&nbsp;(make-rational&nbsp;p3&nbsp;p4))<br>\n<br>\n(add&nbsp;rf1&nbsp;rf2)<br>\n</tt><p><p>\nSee if you get the correct answer, correctly reduced to lowest terms.\n<p> \n\n<p><p>The GCD computation is at the heart of any system that does operations\non rational functions.  The algorithm used above, although\nmathematically straightforward, is extremely slow.  The slowness is\ndue partly to the large number of division operations and partly to\nthe enormous size of the intermediate coefficients generated by the\npseudodivisions.  One of the active areas in the development of\nalgebraic-manipulation systems is the design of better algorithms for\ncomputing polynomial GCDs.<a name="call_footnote_Temp_320" href="#footnote_Temp_320"><sup><small>62</small></sup></a>\n\n<p>\n\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_283" href="#call_footnote_Temp_283"><sup><small>49</small></sup></a> We also have to supply an almost identical\nprocedure to handle the types <tt>(scheme-number complex)</tt>.\n\n<p><a name="footnote_Temp_285" href="#call_footnote_Temp_285"><sup><small>50</small></sup></a> See\nexercise&nbsp;<a href="#%_thm_2.82">2.82</a> for generalizations.\n\n<p><a name="footnote_Temp_286" href="#call_footnote_Temp_286"><sup><small>51</small></sup></a> If we are\nclever, we can usually get by with fewer than <em>n</em><sup>2</sup> coercion\nprocedures.  For instance, if we know how to convert from type 1 to\ntype 2 and from type 2 to type 3, then we can use this knowledge to\nconvert from type 1 to type 3.  This can greatly decrease the number\nof coercion procedures we need to supply explicitly when we add a new\ntype to the system.  If we are willing to build the required amount of\nsophistication into our system, we can have it search the ``graph\'\' of\nrelations among types and automatically generate those coercion\nprocedures that can be inferred from the ones that are supplied\nexplicitly.\n\n<p><a name="footnote_Temp_289" href="#call_footnote_Temp_289"><sup><small>52</small></sup></a> This statement, which also appears in the first edition of this book,\nis just as true now as it was when we wrote it twelve years ago.\nDeveloping a useful, general framework for expressing the relations\namong different types of entities (what philosophers call\n``ontology\'\') seems intractably difficult.  The main difference\nbetween the confusion that existed ten years ago and the confusion\nthat exists now is that now a variety of inadequate ontological\ntheories have been embodied in a plethora of correspondingly\ninadequate programming languages.  For example, much of the complexity\nof <a name="%_idx_2622"></a><a name="%_idx_2624"></a>object-oriented programming languages -- and the subtle and\nconfusing differences among contemporary object-oriented\nlanguages -- centers on the treatment of generic operations on\ninterrelated types.  Our own discussion of computational objects in\nchapter&nbsp;3 avoids these issues entirely.  Readers familiar with\nobject-oriented programming will notice that we have much to say in\nchapter&nbsp;3 about local state, but we do not even mention ``classes\'\' or\n``inheritance.\'\'  In fact, we suspect that these problems cannot be\nadequately addressed in terms of computer-language design alone,\nwithout also drawing on work in knowledge representation and automated\nreasoning.\n\n<p><a name="footnote_Temp_295" href="#call_footnote_Temp_295"><sup><small>53</small></sup></a> A real number can be projected to an integer\nusing the <a name="%_idx_2642"></a><a name="%_idx_2644"></a><tt>round</tt> primitive, which returns the closest integer\nto its argument.\n\n<p><a name="footnote_Temp_298" href="#call_footnote_Temp_298"><sup><small>54</small></sup></a> On the other hand, we will allow\npolynomials whose coefficients are themselves polynomials in other\nvariables.  This will give us essentially the same representational\npower as a full multivariate system, although it does lead to coercion\nproblems, as discussed below.\n\n<p><a name="footnote_Temp_299" href="#call_footnote_Temp_299"><sup><small>55</small></sup></a> For univariate polynomials, giving\nthe value of a polynomial at a given set of points can be a\nparticularly good representation.  This makes polynomial arithmetic\nextremely simple.  To obtain, for example, the sum of two polynomials\nrepresented in this way, we need only add the values of the\npolynomials at corresponding points.  To transform back to a more\nfamiliar representation, we can use the <a name="%_idx_2662"></a>Lagrange interpolation\nformula, which shows how to recover the coefficients of a polynomial\nof degree <em>n</em> given the values of the polynomial at <em>n</em> + 1 points.\n\n<p><a name="footnote_Temp_300" href="#call_footnote_Temp_300"><sup><small>56</small></sup></a> This operation is very much like the ordered\n<tt>union-set</tt> operation we developed in exercise &nbsp;<a href="book-Z-H-16.html#%_thm_2.62">2.62</a>.\nIn fact, if we think of the terms of the polynomial as a set ordered\naccording to the power of the indeterminate, then the program that\nproduces the term list for a sum is almost identical to <tt>union-set</tt>.\n\n<p><a name="footnote_Temp_301" href="#call_footnote_Temp_301"><sup><small>57</small></sup></a> To make\nthis work completely smoothly, we should also add to our generic\narithmetic system the ability to coerce a ``number\'\' to a polynomial\nby regarding it as a polynomial of degree zero whose coefficient is\nthe number.  This is necessary if we are going to perform operations\nsuch as\n<p><div align=left><img src="ch2-Z-G-73.gif" border="0"></div><p>\nwhich requires adding the coefficient <em>y</em> + 1 to the coefficient 2.\n\n<p><a name="footnote_Temp_303" href="#call_footnote_Temp_303"><sup><small>58</small></sup></a> In these polynomial examples,\nwe assume that we have implemented the generic arithmetic system using\nthe type mechanism suggested in exercise&nbsp;<a href="#%_thm_2.78">2.78</a>.\nThus, coefficients that are ordinary numbers will be represented as\nthe numbers themselves rather than as pairs whose <tt>car</tt> is the\nsymbol <tt>scheme-number</tt>.\n\n<p><a name="footnote_Temp_304" href="#call_footnote_Temp_304"><sup><small>59</small></sup></a> Although\nwe are assuming that term\nlists are ordered, we have implemented <tt>adjoin-term</tt> to simply\n<tt>cons</tt> the new term onto the existing term list.  We can get away\nwith this so long as we guarantee that the procedures (such as <tt>add-terms</tt>) that use <tt>adjoin-term</tt> always call it with a higher-order\nterm than appears in the list.  If we did not want to make such a\nguarantee, we could have implemented <tt>adjoin-term</tt> to be similar\nto the <tt>adjoin-set</tt> constructor for the ordered-list\nrepresentation of sets (exercise&nbsp;<a href="book-Z-H-16.html#%_thm_2.61">2.61</a>).\n\n<p><a name="footnote_Temp_314" href="#call_footnote_Temp_314"><sup><small>60</small></sup></a> The fact\nthat <a name="%_idx_2786"></a><a name="%_idx_2788"></a>Euclid\'s Algorithm works for polynomials is formalized in algebra\nby saying that polynomials form a kind of algebraic domain called a\n<a name="%_idx_2790"></a><a name="%_idx_2792"></a><em>Euclidean ring</em>.  A Euclidean ring is a domain that admits\naddition, subtraction, and commutative multiplication, together with a\nway of assigning to each element <em>x</em> of the ring a positive integer\n``measure\'\' <em>m</em>(<em>x</em>) with the properties that <em>m</em>(<em>x</em><em>y</em>)<u>&gt;</u> <em>m</em>(<em>x</em>) for\nany nonzero <em>x</em> and <em>y</em> and that, given any <em>x</em> and <em>y</em>, there exists\na <em>q</em> such that <em>y</em> = <em>q</em><em>x</em> + <em>r</em> and either <em>r</em> = 0 or <em>m</em>(<em>r</em>)&lt; <em>m</em>(<em>x</em>).  From an\nabstract point of view, this is what is needed to prove that Euclid\'s\nAlgorithm works.  For the domain of integers, the measure <em>m</em> of an\ninteger is the absolute value of the integer itself.  For the domain\nof polynomials, the measure of a polynomial is its degree.\n\n<p><a name="footnote_Temp_317" href="#call_footnote_Temp_317"><sup><small>61</small></sup></a> In an implementation like MIT Scheme, this produces a polynomial\nthat is indeed a divisor of <em>Q</em><sub>1</sub> and <em>Q</em><sub>2</sub>, but with rational coefficients.\nIn many other Scheme systems, in which division of integers can produce\nlimited-precision decimal numbers, we may fail to get a valid divisor.\n\n<p><a name="footnote_Temp_320" href="#call_footnote_Temp_320"><sup><small>62</small></sup></a> One extremely efficient and\nelegant method for computing <a name="%_idx_2810"></a><a name="%_idx_2812"></a><a name="%_idx_2814"></a><a name="%_idx_2816"></a>polynomial GCDs was discovered by <a name="%_idx_2818"></a>Richard\nZippel (1979).  The method is a probabilistic algorithm, as is the\nfast test for primality that we discussed in chapter&nbsp;1.  Zippel\'s book\n(1993) describes this method, together with other ways to compute\npolynomial GCDs.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_chap_3"></a>\n<h1 class=chapter>\n<div class=chapterheading><a href="book-Z-H-4.html#%_toc_%_chap_3">Chapter 3</a></div><p>\n<a href="book-Z-H-4.html#%_toc_%_chap_3">Modularity, Objects, and State</a></h1><p>\n\n<p>\n\n<p>\n<div align=right> \n<table width=60%><tr><td>\n<span class=epigraph>\n<p>\n\nM<img src="ch3-Z-G-1.gif" border="0"><p>\n\n<p><p><p>\n\n(Even while it changes, it stands still.)<p>\n\n<a name="%_idx_2820"></a>Heraclitus<p>\n\nPlus &ccedil;a change, plus c\'est la m&ecirc;me chose.<p>\n\n<a name="%_idx_2822"></a>Alphonse Karr<p>\n\n</span>\n</td></tr></table>\n</div>\n\n<p><p>\n\nThe preceding chapters introduced the basic elements from which\nprograms are made.  We saw how primitive procedures and primitive data\nare combined to construct compound entities, and we learned that\nabstraction is vital in helping us to cope with the complexity of\nlarge systems.  But these tools are not sufficient for designing\nprograms.  Effective program synthesis also requires organizational\nprinciples that can guide us in formulating the overall design of a\nprogram.  In particular, we need strategies to help us structure large\nsystems so that they will be <em>modular</em>, that is, so that they can\nbe divided ``naturally\'\' into coherent parts that can be separately\ndeveloped and maintained.<p>\n\n<a name="%_idx_2824"></a><a name="%_idx_2826"></a>One powerful design strategy, which is particularly appropriate to the\nconstruction of programs for modeling physical systems, is to base the\nstructure of our programs on the structure of the system being\nmodeled.  For each object in the system, we construct a corresponding\ncomputational object.  For each system action, we define a symbolic\noperation in our computational model.  Our hope in using this strategy\nis that extending the model to accommodate new objects or new actions\nwill require no strategic changes to the program, only the addition of\nthe new symbolic analogs of those objects or actions.  If we have been\nsuccessful in our system organization, then to add a new feature or\ndebug an old one we will have to work on only a localized part of the\nsystem.<p>\n\n\nTo a large extent, then, the way we organize a large program is\ndictated by our perception of the system to be modeled.  In this\nchapter we will investigate two prominent organizational strategies\narising from two rather different ``world views\'\' of the structure of\nsystems.  The first organizational strategy concentrates on <a name="%_idx_2828"></a><em>objects</em>, viewing a large system as a collection of distinct objects\nwhose behaviors may change over time.  An alternative organizational\nstrategy concentrates on the <a name="%_idx_2830"></a><em>streams</em> of information that flow in\nthe system, much as an electrical engineer views a signal-processing\nsystem.<p>\n\nBoth the object-based approach and the stream-processing approach\nraise significant linguistic issues in programming.\nWith objects, we must be concerned with how a computational object can\nchange and yet maintain its identity.  This will force us to abandon\nour old substitution model of computation\n(section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a>) in favor of a more mechanistic\nbut less theoretically tractable <a name="%_idx_2832"></a><em>environment model</em> of\ncomputation.  The difficulties of dealing with objects, change, and\nidentity are a fundamental consequence of the need to grapple with\ntime in our computational models.  These difficulties become even\ngreater when we allow the possibility of concurrent execution of\nprograms.  The stream approach can be most fully exploited when we\ndecouple simulated time in our model from the order of the events that\ntake place in the computer during evaluation.  We will accomplish this\nusing a technique known as <a name="%_idx_2834"></a><em>delayed evaluation</em>.<p>\n\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_3.1"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_3.1">3.1&nbsp;&nbsp;Assignment and Local State</a></h2><p>\n\n<a name="%_idx_2836"></a><a name="%_idx_2838"></a>\nWe ordinarily view the world as populated by independent objects, each\nof which has a state that changes over time.  An object is said to\n``have state\'\' if its behavior is influenced by its history.  A bank\naccount, for example, has state in that the answer to the question\n``Can I withdraw $100?\'\'  depends upon the history of deposit and\nwithdrawal transactions.  We can characterize an object\'s state by one\nor more <a name="%_idx_2840"></a><em>state variables</em>, which among them maintain enough\ninformation about history to determine the object\'s current behavior.\nIn a simple banking system, we could characterize the state of an\naccount by a current balance rather than by remembering the entire\nhistory of account transactions.<p>\n\nIn a system composed of many objects, the objects are rarely\ncompletely independent.  Each may influence the states of others\nthrough interactions, which serve to couple the state variables of one\nobject to those of other objects.  Indeed, the view that a system is\ncomposed of separate objects is most useful when the state variables\nof the system can be grouped into closely coupled subsystems that are\nonly loosely coupled to other subsystems.<p>\n\n\nThis view of a system can be a powerful framework for organizing\ncomputational models of the system.  For such a model to be modular,\nit should be decomposed into computational objects that model the\nactual objects in the system.  Each computational object must have its\nown <em>local state variables</em> describing the actual object\'s state.\nSince the states of objects in the system being modeled change over\ntime, the state variables of the corresponding computational objects\nmust also change.  If we choose to model the flow of time in the\nsystem by the elapsed time in the computer, then we must have a way to\nconstruct computational objects whose behaviors change as our programs\nrun.  In particular, if we wish to model state variables by ordinary\nsymbolic names in the programming language, then the language must\nprovide an <a name="%_idx_2842"></a><em>assignment operator</em> to enable us to change the value\nassociated with a name.<p>\n\n<a name="%_sec_3.1.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.1.1">3.1.1&nbsp;&nbsp;Local State Variables</a></h3><p>\n\n\n<a name="%_idx_2844"></a><a name="%_idx_2846"></a>\n<a name="%_idx_2848"></a><a name="%_idx_2850"></a>To illustrate what we mean by having a computational object with\ntime-varying state, let us model the situation of withdrawing money\nfrom a bank account.  We will do this using a procedure <tt>withdraw</tt>, which takes as argument an <tt>amount</tt> to be withdrawn.\nIf there is enough money in the account to accommodate the withdrawal,\nthen <tt>withdraw</tt> should return the balance remaining after the\nwithdrawal.  Otherwise, <tt>withdraw</tt> should return the message <em>Insufficient funds.</em> For example, if we begin with $100 in the\naccount, we should obtain the following sequence of responses using\n<tt>withdraw</tt>:<p>\n\n<p><p><tt>(withdraw&nbsp;25)<br>\n<i>75</i><br>\n(withdraw&nbsp;25)<br>\n<i>50</i><br>\n(withdraw&nbsp;60)<br>\n<i>&quot;Insufficient&nbsp;funds&quot;</i><br>\n(withdraw&nbsp;15)<br>\n<i>35</i><br>\n</tt><p><p>\nObserve that the expression <tt>(withdraw 25)</tt>, evaluated twice,\nyields different values.  This is a new kind of behavior for a\nprocedure.  Until now, all our procedures could be viewed as\nspecifications for computing mathematical functions.  A call to a\nprocedure computed the value of the function applied to the given\narguments, and two calls to the same procedure with the\nsame arguments always produced the same result.<a name="call_footnote_Temp_321" href="#footnote_Temp_321"><sup><small>1</small></sup></a><p>\n\nTo implement <tt>withdraw</tt>, we can use a variable <tt>balance</tt> to\nindicate the balance of money in the account and define <tt>withdraw</tt>\nas a procedure that accesses <tt>balance</tt>.  The <tt>withdraw</tt>\nprocedure checks to see if <tt>balance</tt> is at least as large as the\nrequested <tt>amount</tt>.  If so, <tt>withdraw</tt> decrements <tt>balance</tt> by <tt>amount</tt> and returns the new value of <tt>balance</tt>.\nOtherwise, <tt>withdraw</tt> returns the <em>Insufficient funds</em>\nmessage.  Here are the definitions of <tt>balance</tt> and <tt>withdraw</tt>:<p>\n\n<p><p><tt>(define&nbsp;balance&nbsp;100)<br>\n<br>\n<a name="%_idx_2858"></a>(define&nbsp;(withdraw&nbsp;amount)<br>\n&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;))<br>\n</tt><p><p>\nDecrementing <tt>balance</tt> is accomplished by the expression<p>\n\n<p><p><tt>(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n</tt><p><p>\n<a name="%_idx_2860"></a><a name="%_idx_2862"></a>This uses the <tt>set!</tt> special form, whose syntax is<p>\n\n<p><p><tt>(set!&nbsp;&lt;<em>name</em>&gt;&nbsp;&lt;<em>new-value</em>&gt;)<br>\n</tt><p><p>\nHere &lt;<em>name</em>&gt; is a symbol and &lt;<em>new-value</em>&gt; is any expression.  <tt>Set!</tt> changes &lt;<em>name</em>&gt; so that its value is the result obtained by\nevaluating &lt;<em>new-value</em>&gt;.  In the case at hand, we are changing <tt>balance</tt> so that its new value will be the result of subtracting <tt>amount</tt> from the previous value of <tt>balance</tt>.<a name="call_footnote_Temp_322" href="#footnote_Temp_322"><sup><small>2</small></sup></a><p>\n\n<a name="%_idx_2874"></a><a name="%_idx_2876"></a><tt>Withdraw</tt> also uses the <tt>begin</tt> special form to cause\ntwo expressions to be evaluated\nin the case where the <tt>if</tt> test is true: first decrementing <tt>balance</tt> and then returning the value of <tt>balance</tt>.  In general,\nevaluating the expression<p>\n\n<p><p><tt>(begin&nbsp;&lt;<em>exp<sub>1</sub></em>&gt;&nbsp;&lt;<em>exp<sub>2</sub></em>&gt;&nbsp;<tt>...</tt> &lt;<em>exp<sub><em>k</em></sub></em>&gt;)<br>\n</tt><p><p>\ncauses the expressions &lt;<em>exp<sub>1</sub></em>&gt; through &lt;<em>exp<sub><em>k</em></sub></em>&gt; to be\nevaluated in sequence and the value of the final expression\n&lt;<em>exp<sub><em>k</em></sub></em>&gt; to be returned as the value of the entire <tt>begin</tt>\nform.<a name="call_footnote_Temp_323" href="#footnote_Temp_323"><sup><small>3</small></sup></a><p>\n\nAlthough <tt>withdraw</tt> works as desired, the variable\n<tt>balance</tt> presents a problem.  As specified above, <tt>balance</tt>\nis a name defined in the global environment and is freely accessible\nto be examined or modified by any procedure.  It would be much better\nif we could somehow make <tt>balance</tt> internal to <tt>withdraw</tt>, so\nthat <tt>withdraw</tt> would be the only procedure that could access <tt>balance</tt> directly and any other procedure could access <tt>balance</tt>\nonly indirectly (through calls to <tt>withdraw</tt>).  This would more\naccurately model the notion that <tt>balance</tt> is a local state\nvariable used by <tt>withdraw</tt> to keep track of the state of the\naccount.<p>\n\nWe can make <tt>balance</tt> internal to <tt>withdraw</tt> by rewriting the\ndefinition as follows:<p>\n\n<p><p><tt><a name="%_idx_2884"></a>(define&nbsp;new-withdraw<br>\n&nbsp;&nbsp;(let&nbsp;((balance&nbsp;100))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;))))<br>\n</tt><p><p>\nWhat we have done here is use <tt>let</tt> to establish an environment\nwith a local variable <tt>balance</tt>, bound to the initial value 100.\nWithin this local environment, we use <tt>lambda</tt> to create a\nprocedure that takes <tt>amount</tt> as an argument and behaves like our\nprevious <tt>withdraw</tt> procedure.  This procedure -- returned as the\nresult of evaluating the <tt>let</tt> expression -- is <tt>new-withdraw</tt>,\nwhich behaves in precisely the same way as <tt>withdraw</tt> but whose\nvariable <tt>balance</tt> is not accessible by any other\nprocedure.<a name="call_footnote_Temp_324" href="#footnote_Temp_324"><sup><small>4</small></sup></a><p>\n\nCombining <tt>set!</tt> with local variables is the general programming\ntechnique we will use for constructing computational objects with\nlocal state.  Unfortunately, using this technique raises a serious\nproblem: When we first introduced procedures, we also introduced the\nsubstitution model of evaluation\n(section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a>) to provide an interpretation of\nwhat procedure application means.  We said that applying a procedure\nshould be interpreted as evaluating the body of the procedure with the\nformal parameters replaced by their values.  The trouble is that, as\nsoon as we introduce assignment into our language, substitution is no\nlonger an adequate model of procedure application.  (We will see why\nthis is so in section&nbsp;<a href="#%_sec_3.1.3">3.1.3</a>.)  As a\nconsequence, we technically have at this point no way to understand\nwhy the <tt>new-withdraw</tt> procedure behaves as claimed above.  In\norder to really understand a procedure such as <tt>new-withdraw</tt>, we\nwill need to develop a new model of procedure application.  In\nsection&nbsp;<a href="book-Z-H-21.html#%_sec_3.2">3.2</a> we will introduce such a model,\ntogether with an explanation of <tt>set!</tt> and local variables.\nFirst, however, we examine some variations on the theme established by\n<tt>new-withdraw</tt>.<p>\n\nThe following procedure, <tt>make-withdraw</tt>, creates ``withdrawal\nprocessors.\'\'  The formal parameter <tt>balance</tt> in <tt>make-withdraw</tt> specifies the initial amount of money in the\naccount.<a name="call_footnote_Temp_325" href="#footnote_Temp_325"><sup><small>5</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_2894"></a>(define&nbsp;(make-withdraw&nbsp;balance)<br>\n&nbsp;&nbsp;(lambda&nbsp;(amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;)))<br>\n</tt><p><p>\n<tt>Make-withdraw</tt> can be used as follows to create two objects\n<tt>W1</tt> and <tt>W2</tt>:<p>\n\n<p><p><tt>(define&nbsp;W1&nbsp;(make-withdraw&nbsp;100))<br>\n(define&nbsp;W2&nbsp;(make-withdraw&nbsp;100))<br>\n(W1&nbsp;50)<br>\n<i>50</i><br>\n(W2&nbsp;70)<br>\n<i>30</i><br>\n(W2&nbsp;40)<br>\n<i>&quot;Insufficient&nbsp;funds&quot;</i><br>\n(W1&nbsp;40)<br>\n<i>10</i><br>\n</tt><p><p>\nObserve that <tt>W1</tt> and <tt>W2</tt> are completely independent objects,\neach with its own local state variable <tt>balance</tt>.  Withdrawals\nfrom one do not affect the other.<p>\n\nWe can also create objects that handle deposits as well as\nwithdrawals, and thus we can represent simple bank accounts.  Here is\na procedure that returns a ``bank-account object\'\' with\na specified initial balance:<p>\n\n<p><p><tt><a name="%_idx_2896"></a><a name="%_idx_2898"></a>(define&nbsp;(make-account&nbsp;balance)<br>\n&nbsp;&nbsp;(define&nbsp;(withdraw&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;))<br>\n&nbsp;&nbsp;(define&nbsp;(deposit&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;balance&nbsp;(+&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;m&nbsp;\'withdraw)&nbsp;withdraw)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'deposit)&nbsp;deposit)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;MAKE-ACCOUNT&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m))))<br>\n&nbsp;&nbsp;dispatch)<br>\n</tt><p><p>\nEach call to <tt>make-account</tt> sets up an environment with a local\nstate variable <tt>balance</tt>.  Within this environment, <tt>make-account</tt> defines procedures <tt>deposit</tt> and <tt>withdraw</tt>\nthat access <tt>balance</tt> and an additional procedure <tt>dispatch</tt>\nthat takes a ``message\'\' as input and returns one of the two local\nprocedures.  The <tt>dispatch</tt> procedure itself is returned as the\nvalue that represents the bank-account object.\nThis is precisely the <a name="%_idx_2900"></a><em>message-passing</em>\nstyle of programming that we saw in section&nbsp;<a href="book-Z-H-17.html#%_sec_2.4.3">2.4.3</a>, although\nhere we are using it in conjunction with the ability to modify local\nvariables.<p>\n\n<tt>Make-account</tt> can be used as follows:<p>\n\n<p><p><tt>(define&nbsp;acc&nbsp;(make-account&nbsp;100))<br>\n((acc&nbsp;\'withdraw)&nbsp;50)<br>\n<i>50</i><br>\n((acc&nbsp;\'withdraw)&nbsp;60)<br>\n<i>&quot;Insufficient&nbsp;funds&quot;</i><br>\n((acc&nbsp;\'deposit)&nbsp;40)<br>\n<i>90</i><br>\n((acc&nbsp;\'withdraw)&nbsp;60)<br>\n<i>30</i><br>\n</tt><p><p>\nEach call to <tt>acc</tt> returns the locally defined <tt>deposit</tt> or\n<tt>withdraw</tt> procedure, which is then applied to the specified <tt>amount</tt>.  As was the case with <tt>make-withdraw</tt>, another call to <tt>make-account</tt><p>\n\n<p><p><tt>(define&nbsp;acc2&nbsp;(make-account&nbsp;100))<br>\n</tt><p><p>\nwill produce a completely separate account object, which maintains its\nown local <tt>balance</tt>.<p>\n\n<p><a name="%_thm_3.1"></a>\n<b>Exercise 3.1.</b>&nbsp;&nbsp;An <a name="%_idx_2902"></a><em>accumulator</em> is a procedure that is called repeatedly with a\nsingle numeric argument and accumulates its arguments into a sum.\nEach time it is called, it returns the currently accumulated sum.\nWrite a procedure <a name="%_idx_2904"></a><tt>make-accumulator</tt> that generates accumulators,\neach maintaining an independent sum.  The input to <tt>make-accumulator</tt> should specify the initial value of the sum; for\nexample<p>\n\n<p><p><tt>(define&nbsp;A&nbsp;(make-accumulator&nbsp;5))<br>\n(A&nbsp;10)<br>\n<i>15</i><br>\n(A&nbsp;10)<br>\n<i>25</i><br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_3.2"></a>\n<b>Exercise 3.2.</b>&nbsp;&nbsp;In software-testing applications, it is useful to be able to count the\nnumber of times a given procedure is called during the course of a\ncomputation.  Write a procedure <a name="%_idx_2906"></a><a name="%_idx_2908"></a><a name="%_idx_2910"></a><tt>make-monitored</tt> that takes as\ninput a procedure, <tt>f</tt>, that itself takes one input.  The result\nreturned by <tt>make-monitored</tt> is a third procedure, say <tt>mf</tt>,\nthat keeps track of the number of times it has been called by\nmaintaining an internal counter.  If the input to <tt>mf</tt> is the\nspecial symbol <tt>how-many-calls?</tt>, then <tt>mf</tt> returns the\nvalue of the counter.  If the input is the special symbol <tt>reset-count</tt>, then <tt>mf</tt> resets the counter to zero.  For any other\ninput, <tt>mf</tt> returns the result of calling <tt>f</tt> on that input\nand increments the counter.  For instance, we could make a monitored\nversion of the <tt>sqrt</tt> procedure:<p>\n\n<p><p><tt>(define&nbsp;s&nbsp;(make-monitored&nbsp;sqrt))<br>\n<br>\n(s&nbsp;100)<br>\n<i>10</i><br>\n<br>\n(s&nbsp;\'how-many-calls?)<br>\n<i>1</i><br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_3.3"></a>\n<b>Exercise 3.3.</b>&nbsp;&nbsp;<a name="%_idx_2912"></a><a name="%_idx_2914"></a>Modify the <tt>make-account</tt> procedure so that it creates\npassword-protected accounts.  That is, <tt>make-account</tt> should take\na symbol as an additional argument, as in<p>\n\n<p><p><tt>(define&nbsp;acc&nbsp;(make-account&nbsp;100&nbsp;\'secret-password))<br>\n</tt><p><p>\nThe resulting account object should process a request only if it is\naccompanied by the password with which the account was created, and\nshould otherwise return a complaint:<p>\n\n<p><p><tt>((acc&nbsp;\'secret-password&nbsp;\'withdraw)&nbsp;40)<br>\n<i>60</i><br>\n<br>\n((acc&nbsp;\'some-other-password&nbsp;\'deposit)&nbsp;50)<br>\n<i>&quot;Incorrect&nbsp;password&quot;</i><br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_3.4"></a>\n<b>Exercise 3.4.</b>&nbsp;&nbsp;Modify the <tt>make-account</tt> procedure of\nexercise&nbsp;<a href="#%_thm_3.3">3.3</a> by adding another local state\nvariable so that, if an account is accessed more than seven\nconsecutive times with an incorrect password, it invokes the procedure\n<tt>call-the-cops</tt>.\n<p>\n<p>\n\n<a name="%_sec_3.1.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.1.2">3.1.2&nbsp;&nbsp;The Benefits of Introducing Assignment</a></h3><p>\n\n\n<a name="%_idx_2916"></a>\n<a name="%_idx_2918"></a><a name="%_idx_2920"></a>As we shall see, introducing assignment into our programming language\nleads us into a thicket of difficult conceptual issues.  Nevertheless,\nviewing systems as collections of objects with local state is a\npowerful technique for maintaining a modular design.  As a simple\nexample, consider the design of a procedure <tt>rand</tt> that, whenever\nit is called, returns an integer chosen at random.<p>\n\n<a name="%_idx_2922"></a>It is not at all clear what is meant by ``chosen at random.\'\'  What we\npresumably want is for successive calls to <tt>rand</tt> to produce a\nsequence of numbers that has statistical properties of uniform\ndistribution.  We will not discuss methods for generating suitable\nsequences here.  Rather, let us assume that we have a procedure <tt>rand-update</tt> that has the property that if we start with a given\nnumber <em>x</em><sub>1</sub> and form<p>\n\n<p><p><tt><em>x</em><sub>2</sub>&nbsp;=&nbsp;(rand-update&nbsp;<em>x</em><sub>1</sub>)<br>\n<em>x</em><sub>3</sub>&nbsp;=&nbsp;(rand-update&nbsp;<em>x</em><sub>2</sub>)<br>\n</tt><p><p>\nthen the sequence of values <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>, <tt>...</tt>, will have the\ndesired statistical properties.<a name="call_footnote_Temp_330" href="#footnote_Temp_330"><sup><small>6</small></sup></a><p>\n\nWe can implement <tt>rand</tt> as a procedure with a local state variable\n<tt>x</tt> that is initialized to some fixed value <tt>random-init</tt>.\nEach call to <tt>rand</tt> computes <tt>rand-update</tt> of the current\nvalue of <tt>x</tt>, returns this as the random number, and also stores\nthis as the new value of <tt>x</tt>.<p>\n\n<p><p><tt><a name="%_idx_2934"></a>(define&nbsp;rand<br>\n&nbsp;&nbsp;(let&nbsp;((x&nbsp;random-init))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;x&nbsp;(rand-update&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)))<br>\n</tt><p><p><p>\n\nOf course, we could generate the same sequence of random numbers\nwithout using assignment by simply calling <tt>rand-update</tt> directly.\nHowever, this would mean that any part of our program that used random\nnumbers would have to explicitly remember the current value of <tt>x</tt>\nto be passed as an argument to <tt>rand-update</tt>.  To realize what an\nannoyance this would be, consider using random numbers to implement a\ntechnique called <a name="%_idx_2936"></a><a name="%_idx_2938"></a><em>Monte Carlo simulation</em>.<p>\n\nThe Monte Carlo method consists of choosing sample experiments at\nrandom from a large set and then making deductions on the basis of the\nprobabilities estimated from tabulating the results of those\nexperiments.  For example, we can approximate <a name="%_idx_2940"></a><img src="book-Z-G-D-9.gif" border="0"> using the fact\nthat 6/<img src="book-Z-G-D-9.gif" border="0"><sup>2</sup> is the probability that two integers chosen at random\nwill have no factors in common; that is, that their greatest common\ndivisor will be 1.<a name="call_footnote_Temp_331" href="#footnote_Temp_331"><sup><small>7</small></sup></a> To obtain\nthe approximation to <img src="book-Z-G-D-9.gif" border="0">, we perform a large number of experiments.\nIn each experiment we choose two integers at random and perform a test\n<a name="%_idx_2946"></a>to see if their GCD is 1.  The fraction of times that the test is\npassed gives us our estimate of 6/<img src="book-Z-G-D-9.gif" border="0"><sup>2</sup>, and from this we obtain our\napproximation to <img src="book-Z-G-D-9.gif" border="0">.<p>\n\nThe heart of our program is a procedure <tt>monte-carlo</tt>, which takes\nas arguments the number of times to try an experiment, together with\nthe experiment, represented as a no-argument procedure that will\nreturn either true or false each time it is run.  <tt>Monte-carlo</tt>\nruns the experiment for the designated number of trials and returns a\nnumber telling the fraction of the trials in which the experiment was\nfound to be true.<p>\n\n<p><p><tt><a name="%_idx_2948"></a>(define&nbsp;(estimate-pi&nbsp;trials)<br>\n&nbsp;&nbsp;(sqrt&nbsp;(/&nbsp;6&nbsp;(monte-carlo&nbsp;trials&nbsp;cesaro-test))))<br>\n<a name="%_idx_2950"></a>(define&nbsp;(cesaro-test)<br>\n&nbsp;&nbsp;&nbsp;(=&nbsp;(gcd&nbsp;(rand)&nbsp;(rand))&nbsp;1))<br>\n<a name="%_idx_2952"></a>(define&nbsp;(monte-carlo&nbsp;trials&nbsp;experiment)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;trials-remaining&nbsp;trials-passed)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((=&nbsp;trials-remaining&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;trials-passed&nbsp;trials))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((experiment)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;(-&nbsp;trials-remaining&nbsp;1)&nbsp;(+&nbsp;trials-passed&nbsp;1)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;(-&nbsp;trials-remaining&nbsp;1)&nbsp;trials-passed))))<br>\n&nbsp;&nbsp;(iter&nbsp;trials&nbsp;0))<br>\n</tt><p><p><p>\n\nNow let us try the same computation using <tt>rand-update</tt> directly\nrather than <tt>rand</tt>, the way we would be forced to proceed if we\ndid not use assignment to model local state:<p>\n\n<p><p><tt><a name="%_idx_2954"></a>(define&nbsp;(estimate-pi&nbsp;trials)<br>\n&nbsp;&nbsp;(sqrt&nbsp;(/&nbsp;6&nbsp;(random-gcd-test&nbsp;trials&nbsp;random-init))))<br>\n(define&nbsp;(random-gcd-test&nbsp;trials&nbsp;initial-x)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;trials-remaining&nbsp;trials-passed&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((x1&nbsp;(rand-update&nbsp;x)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((x2&nbsp;(rand-update&nbsp;x1)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((=&nbsp;trials-remaining&nbsp;0)&nbsp;&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;trials-passed&nbsp;trials))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;(gcd&nbsp;x1&nbsp;x2)&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;(-&nbsp;trials-remaining&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;trials-passed&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;(-&nbsp;trials-remaining&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trials-passed<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x2))))))<br>\n&nbsp;&nbsp;(iter&nbsp;trials&nbsp;0&nbsp;initial-x))<br>\n</tt><p><p><p>\n\nWhile the program is still simple, it betrays some painful\nbreaches of modularity.  In our first version of the program, using\n<tt>rand</tt>, we can express the Monte Carlo method directly as\na general <tt>monte-carlo</tt> procedure that takes as an argument an\narbitrary <tt>experiment</tt> procedure.  In our second version of the\nprogram, with no local state for the random-number generator, <tt>random-gcd-test</tt> must explicitly manipulate the random numbers <tt>x1</tt> and <tt>x2</tt> and recycle <tt>x2</tt> through the iterative loop as\nthe new input to <tt>rand-update</tt>.  This explicit handling of the\nrandom numbers intertwines the structure of accumulating test results\nwith the fact that our particular experiment uses two random numbers,\nwhereas other Monte Carlo experiments might use one random number or\nthree.  Even the top-level procedure <tt>estimate-pi</tt> has to be\nconcerned with supplying an initial random number.  The fact that the\nrandom-number generator\'s insides are leaking out into other parts of\nthe program makes it difficult for us to isolate the Monte Carlo idea\nso that it can be applied to other tasks.  In the first version of the\nprogram, assignment encapsulates the state of the random-number\ngenerator within the <tt>rand</tt> procedure, so that the details of\nrandom-number generation remain independent of the rest of the\nprogram.<p>\n\nThe general phenomenon illustrated by the Monte Carlo example is this:\nFrom the point of view of one part of a complex process, the other\nparts appear to change with time.  They have hidden time-varying local\nstate.  If we wish to write computer programs whose structure reflects\nthis decomposition, we make\ncomputational objects (such as bank accounts and random-number\ngenerators) whose behavior changes with time.  We model state with\nlocal state variables, and we model the changes of state with\nassignments to those variables.<p>\n\nIt is tempting to conclude this discussion by saying that, by\nintroducing assignment and the technique of hiding state in local\nvariables, we are able to structure systems in a more modular fashion\nthan if all state had to be manipulated explicitly, by passing\nadditional parameters.  Unfortunately, as we shall see, the story is\nnot so simple.<p>\n\n<p><a name="%_thm_3.5"></a>\n<b>Exercise 3.5.</b>&nbsp;&nbsp;<a name="%_idx_2956"></a><a name="%_idx_2958"></a><a name="%_idx_2960"></a><em>Monte Carlo integration</em> is a method of estimating definite\nintegrals by means of Monte Carlo simulation.  Consider computing the\narea of a region of space described by a predicate <em>P</em>(<em>x</em>, <em>y</em>) that is\ntrue for points (<em>x</em>, <em>y</em>) in the region and false for points not in the\nregion.  For example, the region contained within a circle of radius\n3 centered at (5, 7) is described by the predicate that tests\nwhether (<em>x</em> - 5)<sup>2</sup>  +  (<em>y</em> - 7)<sup>2</sup><u>&lt;</u> 3<sup>2</sup>.  To estimate the area of the\nregion described by such a predicate, begin by choosing a rectangle\nthat contains the region.  For example, a rectangle with diagonally\nopposite corners at (2, 4) and (8, 10) contains the circle above.\nThe desired integral is the area of that portion of the rectangle that\nlies in the region.  We can estimate the integral by picking, at\nrandom, points (<em>x</em>,<em>y</em>) that lie in the rectangle, and testing <em>P</em>(<em>x</em>,\n<em>y</em>) for each point to determine whether the point lies in the region.\nIf we try this with many points, then the fraction of points that fall\nin the region should give an estimate of the proportion of the\nrectangle that lies in the region.  Hence, multiplying this fraction\nby the area of the entire rectangle should produce an estimate of the\nintegral.<p>\n\nImplement Monte Carlo integration as a procedure <a name="%_idx_2962"></a><tt>estimate-integral</tt> that takes as arguments a predicate <tt>P</tt>, upper\nand lower bounds <tt>x1</tt>, <tt>x2</tt>, <tt>y1</tt>, and <tt>y2</tt> for the\nrectangle, and the number of trials to perform in order to produce the\nestimate.  Your procedure should use the same <tt>monte-carlo</tt> procedure that was used above to estimate <img src="book-Z-G-D-9.gif" border="0">.  Use\nyour <tt>estimate-integral</tt> to produce an estimate of <img src="book-Z-G-D-9.gif" border="0"> by\nmeasuring the area of a unit circle.<p>\n\nYou will find it useful to have a procedure that returns a number\nchosen at random from a given range.  The following <tt>random-in-range</tt>\nprocedure implements this in terms of the <tt>random</tt>\nprocedure used in section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.6">1.2.6</a>, which returns a nonnegative\nnumber less than its input.<a name="call_footnote_Temp_333" href="#footnote_Temp_333"><sup><small>8</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_2970"></a>(define&nbsp;(random-in-range&nbsp;low&nbsp;high)<br>\n&nbsp;&nbsp;(let&nbsp;((range&nbsp;(-&nbsp;high&nbsp;low)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;low&nbsp;(random&nbsp;range))))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_3.6"></a>\n<b>Exercise 3.6.</b>&nbsp;&nbsp;<a name="%_idx_2972"></a><a name="%_idx_2974"></a>It is useful to be able to reset a random-number generator to produce\na sequence starting from a given value.  Design a new <tt>rand</tt>\nprocedure that is called with an argument that is either the symbol\n<tt>generate</tt> or the symbol <tt>reset</tt> and behaves as follows: <tt>(rand\n\'generate)</tt> produces a new random number; <tt>((rand \'reset)\n&lt;<em>new-value</em>&gt;)</tt> resets the internal state variable to the designated\n&lt;<em>new-value</em>&gt;.  Thus, by resetting the state, one can generate\nrepeatable sequences.  These are very handy to have when testing and\ndebugging programs that use random numbers.\n\n<p>\n<p>\n\n<a name="%_sec_3.1.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.1.3">3.1.3&nbsp;&nbsp;The Costs of Introducing Assignment</a></h3><p>\n\n\n<a name="%_idx_2976"></a>\nAs we have seen, the <tt>set!</tt> operation enables us to model objects\nthat have local state.  However, this advantage comes at a price.  Our\nprogramming language can no longer be interpreted in terms of the\nsubstitution model of procedure application that we introduced in\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a>.  Moreover, no simple model with\n``nice\'\' mathematical properties can be an adequate framework for\ndealing with objects and assignment in programming languages.<p>\n\nSo long as we do not use assignments, two evaluations of the same\nprocedure with the same arguments will produce the same result, so\nthat procedures can be viewed as computing mathematical functions.\nProgramming without any use of assignments, as we did throughout the\nfirst two chapters of this book, is accordingly known as <a name="%_idx_2978"></a><em>functional programming</em>.<p>\n\n<a name="%_idx_2980"></a>To understand how assignment complicates matters, consider a\nsimplified version of the <tt>make-withdraw</tt> procedure of\nsection&nbsp;<a href="#%_sec_3.1.1">3.1.1</a> that does not bother to check\nfor an insufficient amount:<p>\n\n<p><p><tt><a name="%_idx_2982"></a>(define&nbsp;(make-simplified-withdraw&nbsp;balance)<br>\n&nbsp;&nbsp;(lambda&nbsp;(amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;balance))<br>\n(define&nbsp;W&nbsp;(make-simplified-withdraw&nbsp;25))<br>\n(W&nbsp;20)<br>\n<i>5</i><br>\n(W&nbsp;10)<br>\n<i> - 5</i><br>\n</tt><p><p>\nCompare this procedure with the following <tt>make-decrementer</tt>\nprocedure, which does not use <tt>set!</tt>:<p>\n\n<p><p><tt><a name="%_idx_2984"></a>(define&nbsp;(make-decrementer&nbsp;balance)<br>\n&nbsp;&nbsp;(lambda&nbsp;(amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;balance&nbsp;amount)))<br>\n</tt><p><p>\n<tt>Make-decrementer</tt> returns a procedure that subtracts its input\nfrom a designated amount <tt>balance</tt>, but there is no accumulated effect\nover successive calls, as with <tt>make-simplified-withdraw</tt>:<p>\n\n<p><p><tt>(define&nbsp;D&nbsp;(make-decrementer&nbsp;25))<br>\n(D&nbsp;20)<br>\n<i>5</i><br>\n(D&nbsp;10)<br>\n<i>15</i><br>\n</tt><p><p>\nWe can use the substitution model to explain how <tt>make-decrementer</tt> works.  For instance, let us analyze the evaluation\nof the expression<p>\n\n<p><p><tt>((make-decrementer&nbsp;25)&nbsp;20)<br>\n</tt><p><p>\nWe first simplify the operator of the combination by substituting 25\nfor <tt>balance</tt> in the body of <tt>make-decrementer</tt>.  This reduces\nthe expression to<p>\n\n\n<p><p><tt>((lambda&nbsp;(amount)&nbsp;(-&nbsp;25&nbsp;amount))&nbsp;20)<br>\n</tt><p><p>\nNow we apply the operator by substituting 20 for <tt>amount</tt> in the\nbody of the <tt>lambda</tt> expression:<p>\n\n\n<p><p><tt>(-&nbsp;25&nbsp;20)<br>\n</tt><p><p>\nThe final answer is 5.<p>\n\nObserve, however, what happens if we attempt a similar substitution\nanalysis with <tt>make-simplified-withdraw</tt>:<p>\n\n\n<p><p><tt>((make-simplified-withdraw&nbsp;25)&nbsp;20)<br>\n</tt><p><p>\nWe first simplify the operator by substituting 25 for <tt>balance</tt> in\nthe body of <tt>make-simplified-withdraw</tt>.\nThis reduces the expression to<a name="call_footnote_Temp_335" href="#footnote_Temp_335"><sup><small>9</small></sup></a><p>\n\n\n<p><p><tt>((lambda&nbsp;(amount)&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;25&nbsp;amount))&nbsp;25)&nbsp;20)<br>\n</tt><p><p>\nNow we apply the operator by substituting 20 for <tt>amount</tt> in the\nbody of the <tt>lambda</tt> expression:<p>\n\n\n<p><p><tt>(set!&nbsp;balance&nbsp;(-&nbsp;25&nbsp;20))&nbsp;25<br>\n</tt><p><p>\nIf we adhered to the substitution model, we would have to say that the\nmeaning of the procedure application is to first set <tt>balance</tt> to\n5 and then return 25 as the value of the expression.  This gets the\nwrong answer.  In order to get the correct answer, we would have to\nsomehow distinguish the first occurrence of <tt>balance</tt> (before the\neffect of the <tt>set!</tt>)  from the second occurrence of <tt>balance</tt>\n(after the effect of the <tt>set!</tt>), and the substitution model\ncannot do this.<p>\n\n\nThe trouble here is that substitution is based ultimately on the\nnotion that the symbols in our language are essentially names for\nvalues.  But as soon as we introduce <tt>set!</tt> and the idea that the\nvalue of a variable can change, a variable can no longer be simply a\nname.  Now a variable somehow refers to a place where a value can be\nstored, and the value stored at this place can change.  In\nsection&nbsp;<a href="book-Z-H-21.html#%_sec_3.2">3.2</a>\nwe will see how environments play this role of ``place\'\' in our\ncomputational model.\n<p>\n\n<a name="%_sec_Temp_336"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_336">Sameness and change</a></h4><p>\n\n<a name="%_idx_2986"></a><a name="%_idx_2988"></a>\nThe issue surfacing here is more profound than the mere breakdown of a\nparticular model of computation.  As soon as we introduce change into\nour computational models, many notions that were previously\nstraightforward become problematical.  Consider the concept of two\nthings being ``the same.\'\'<p>\n\nSuppose we call <tt>make-decrementer</tt> twice with the same argument to\ncreate two procedures:<p>\n\n<p><p><tt>(define&nbsp;D1&nbsp;(make-decrementer&nbsp;25))<br>\n(define&nbsp;D2&nbsp;(make-decrementer&nbsp;25))<br>\n</tt><p><p>\nAre <tt>D1</tt> and <tt>D2</tt> the same?  An acceptable answer is yes,\nbecause <tt>D1</tt> and <tt>D2</tt> have the same computational\nbehavior -- each is a procedure that subtracts its input from 25.  In\nfact, <tt>D1</tt> could be substituted for <tt>D2</tt> in any computation\nwithout changing the result.<p>\n\nContrast this with making two calls to <tt>make-simplified-withdraw</tt>:<p>\n\n<p><p><tt>(define&nbsp;W1&nbsp;(make-simplified-withdraw&nbsp;25))<br>\n(define&nbsp;W2&nbsp;(make-simplified-withdraw&nbsp;25))<br>\n</tt><p><p>\nAre <tt>W1</tt> and <tt>W2</tt> the same?  Surely not, because calls to <tt>W1</tt> and <tt>W2</tt> have distinct effects, as shown by the following\nsequence of interactions:<p>\n\n<p><p><tt>(W1&nbsp;20)<br>\n<i>5</i><br>\n(W1&nbsp;20)<br>\n<i> - 15</i><br>\n(W2&nbsp;20)<br>\n<i>5</i><br>\n</tt><p><p>\nEven though <tt>W1</tt> and <tt>W2</tt> are ``equal\'\' in the sense that they\nare both created by evaluating the same expression, <tt>(make-simplified-withdraw&nbsp;25)</tt>, it is not true that <tt>W1</tt> could be\nsubstituted for <tt>W2</tt> in any expression without changing the result\nof evaluating the expression.<p>\n\nA language that supports the concept that ``equals can be substituted\nfor equals\'\' in an expresssion\nwithout changing the value of the expression is said to be\n<a name="%_idx_2990"></a><a name="%_idx_2992"></a><a name="%_idx_2994"></a><em>referentially transparent</em>.  Referential transparency is violated\nwhen we include <tt>set!</tt> in our computer language.  This makes it\ntricky to determine when we can simplify expressions by substituting\nequivalent expressions.  Consequently, reasoning about programs that\nuse assignment becomes drastically more difficult.<p>\n\nOnce we forgo referential transparency, the notion of what it means\nfor computational objects to be ``the same\'\' becomes difficult to\ncapture in a formal way.  Indeed, the meaning of ``same\'\' in the real\nworld that our programs model is hardly clear in itself.  In general,\nwe can determine that two apparently identical objects are indeed\n``the same one\'\' only by modifying one object and then observing\nwhether the other object has changed in the same way.  But how can we\ntell if an object has ``changed\'\' other than by observing the ``same\'\'\nobject twice and seeing whether some property of the object differs\nfrom one observation to the next?  Thus, we cannot determine\n``change\'\' without some <em>a priori</em> notion of ``sameness,\'\' and we\ncannot determine sameness without observing the effects of change.<p>\n\n<a name="%_idx_2996"></a>As an example of how this issue arises in programming, consider the\nsituation where Peter and Paul have a bank account with $100 in\nit.  There is a substantial difference between modeling this as<p>\n\n<p><p><tt>(define&nbsp;peter-acc&nbsp;(make-account&nbsp;100))<br>\n(define&nbsp;paul-acc&nbsp;(make-account&nbsp;100))<br>\n</tt><p><p>\nand modeling it as<p>\n\n<p><p><tt>(define&nbsp;peter-acc&nbsp;(make-account&nbsp;100))<br>\n(define&nbsp;paul-acc&nbsp;peter-acc)<br>\n</tt><p><p>\nIn the first situation, the two bank accounts are distinct.\nTransactions made by Peter will not affect Paul\'s account, and vice\nversa.  In the second situation, however, we have defined <tt>paul-acc</tt> to be <em>the same thing</em> as <tt>peter-acc</tt>.  In effect,\nPeter and Paul now have a joint bank account, and if Peter makes a\nwithdrawal from <tt>peter-acc</tt> Paul will observe less money in <tt>paul-acc</tt>.  These two similar but distinct situations can cause\nconfusion in building computational models.  With the shared account,\nin particular, it can be especially confusing that there is one object\n(the bank account) that has two different names (<tt>peter-acc</tt> and\n<tt>paul-acc</tt>); if we are searching for all the places in our program\nwhere <tt>paul-acc</tt> can be changed, we must remember to look also at\nthings that change <tt>peter-acc</tt>.<a name="call_footnote_Temp_337" href="#footnote_Temp_337"><sup><small>10</small></sup></a><p>\n\n\nWith reference to the above remarks on ``sameness\'\' and ``change,\'\'\nobserve that if Peter and Paul could only examine their bank balances,\nand could not perform operations that changed the balance, then the\nissue of whether the two accounts are distinct would be moot.  In\ngeneral, so long as we never modify data objects, we can regard a\ncompound data object to be precisely the totality of its pieces.  For\nexample, a rational number is determined by giving its numerator and\nits denominator.  But this view is no longer valid in the presence of\nchange, where a compound data object has an ``identity\'\' that is\nsomething different from the pieces of which it is composed.  A bank\naccount is still ``the same\'\' bank account even if we change the\nbalance by making a withdrawal; conversely, we could have two\ndifferent bank accounts with the same state information.  This\ncomplication is a consequence, not of our programming language, but of\nour perception of a bank account as an object.  We do not, for\nexample, ordinarily regard a rational number as a changeable object\nwith identity, such that we could change the numerator and still have\n``the same\'\' rational number.\n\n<a name="%_sec_Temp_338"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_338">Pitfalls of imperative programming</a></h4><p>\n\nIn contrast to functional programming, programming that makes\nextensive use of assignment is known as <a name="%_idx_3014"></a><a name="%_idx_3016"></a><em>imperative\nprogramming</em>.  In addition to raising complications about\ncomputational models, programs written in imperative style are\nsusceptible to bugs that cannot occur in functional programs.  For\nexample, recall the iterative factorial program from\nsection&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a>:\n\n<p><p><tt>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;product&nbsp;counter)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;counter&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;(*&nbsp;counter&nbsp;product)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;counter&nbsp;1))))<br>\n&nbsp;&nbsp;(iter&nbsp;1&nbsp;1))<br>\n</tt><p><p>\nInstead of passing arguments in the internal iterative loop, we could\nadopt a more imperative style by using explicit assignment\nto update the values of the variables <tt>product</tt> and <tt>counter</tt>:\n<p><p><tt><a name="%_idx_3018"></a>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(let&nbsp;((product&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(counter&nbsp;1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(iter)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;counter&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;product&nbsp;(*&nbsp;counter&nbsp;product))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;counter&nbsp;(+&nbsp;counter&nbsp;1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(iter)))<br>\n</tt><p><p>\n<a name="%_idx_3020"></a><a name="%_idx_3022"></a>This does not change the results produced by the program, but it does\nintroduce a subtle trap.  How do we decide the order of the assignments?\nAs it happens, the program is correct as written.  But\nwriting the assignments in the opposite order\n<p><p><tt>(set!&nbsp;counter&nbsp;(+&nbsp;counter&nbsp;1))<br>\n(set!&nbsp;product&nbsp;(*&nbsp;counter&nbsp;product))<br>\n</tt><p><p>\nwould have produced a different, incorrect result.\nIn general, programming with assignment forces us to\ncarefully consider the relative orders of the assignments to make sure\nthat each statement is using the correct version of the variables that\nhave been changed.  This issue simply does not arise in functional\nprograms.<a name="call_footnote_Temp_339" href="#footnote_Temp_339"><sup><small>11</small></sup></a>\n\nThe complexity of imperative programs becomes even worse if we\nconsider applications in which several processes execute concurrently.  We\nwill return to this in section&nbsp;<a href="book-Z-H-23.html#%_sec_3.4">3.4</a>.\nFirst, however, we will address the issue of providing a computational\nmodel for expressions that involve assignment, and explore the uses of\nobjects with local state in designing simulations.<p>\n\n<p><a name="%_thm_3.7"></a>\n<b>Exercise 3.7.</b>&nbsp;&nbsp;<a name="%_idx_3026"></a>Consider the bank account objects created by <tt>make-account</tt>, with\nthe password modification described in\nexercise&nbsp;<a href="#%_thm_3.3">3.3</a>.  Suppose that our banking\nsystem requires the ability to make joint accounts.  Define a\nprocedure <a name="%_idx_3028"></a><tt>make-joint</tt> that accomplishes this.  <tt>Make-joint</tt>\nshould take three arguments.  The first is a password-protected\naccount.  The second argument must match the password with which the\naccount was defined in order for the <tt>make-joint</tt> operation to\nproceed.  The third argument is a new password.  <tt>Make-joint</tt> is\nto create an additional access to the original account using the new\npassword.  For example, if <tt>peter-acc</tt> is a bank account with\npassword <tt>open-sesame</tt>, then<p>\n\n<p><p><tt>(define&nbsp;paul-acc<br>\n&nbsp;&nbsp;(make-joint&nbsp;peter-acc&nbsp;\'open-sesame&nbsp;\'rosebud))<br>\n</tt><p><p>\nwill allow one to make transactions on <tt>peter-acc</tt> using the name\n<tt>paul-acc</tt> and the password <tt>rosebud</tt>.  You may wish to modify\nyour solution to exercise&nbsp;<a href="#%_thm_3.3">3.3</a> to accommodate\nthis new feature.\n<p><p>\n\n<p><a name="%_thm_3.8"></a>\n<b>Exercise 3.8.</b>&nbsp;&nbsp;<a name="%_idx_3030"></a><a name="%_idx_3032"></a>When we defined the evaluation model in\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.3">1.1.3</a>, we said that the first step\nin evaluating an expression is to evaluate its subexpressions.  But we\nnever specified the order in which the subexpressions should be\nevaluated (e.g., left to right or right to left).  When we introduce\nassignment, the order in which the arguments to a procedure are\nevaluated can make a difference to the result.  Define a simple\nprocedure <tt>f</tt> such that evaluating <tt>(+ (f 0) (f 1))</tt> will\nreturn 0 if the arguments to <tt>+</tt> are evaluated from left to right\nbut will return 1 if the arguments are evaluated from right to left.\n\n<p>\n<p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_321" href="#call_footnote_Temp_321"><sup><small>1</small></sup></a> Actually,\nthis is not quite true.  One exception was the <a name="%_idx_2852"></a><a name="%_idx_2854"></a>random-number generator\nin section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.6">1.2.6</a>.  Another exception involved the\n<a name="%_idx_2856"></a>operation/type tables we introduced in section&nbsp;<a href="book-Z-H-17.html#%_sec_2.4.3">2.4.3</a>,\nwhere the values of two calls to <tt>get</tt> with the same arguments\ndepended on intervening calls to <tt>put</tt>.\nOn the other hand, until we introduce\nassignment, we have no way to create such procedures ourselves.\n\n<p><a name="footnote_Temp_322" href="#call_footnote_Temp_322"><sup><small>2</small></sup></a> <a name="%_idx_2864"></a><a name="%_idx_2866"></a>The value of a <tt>set!</tt> expression is implementation-dependent.\n<tt>Set!</tt> should be used only for its effect, not for its value.<p>\n\n<a name="%_idx_2868"></a><a name="%_idx_2870"></a><a name="%_idx_2872"></a>The name\n<tt>set!</tt> reflects a naming convention used in Scheme: Operations\nthat change the values of variables (or that change data structures,\nas we will see in section&nbsp;<a href="book-Z-H-22.html#%_sec_3.3">3.3</a>) are given names that\nend with an exclamation point.  This is similar to the convention of\ndesignating predicates by names that end with a question mark.\n\n<p><a name="footnote_Temp_323" href="#call_footnote_Temp_323"><sup><small>3</small></sup></a> We have already used <a name="%_idx_2878"></a><tt>begin</tt> implicitly in our\nprograms, because in Scheme the body of a procedure can be a sequence\nof expressions.  Also, the &lt;<em>consequent</em>&gt; part of each clause in a\n<a name="%_idx_2880"></a><a name="%_idx_2882"></a><tt>cond</tt> expression can be a sequence of expressions rather than a\nsingle expression.\n\n<p><a name="footnote_Temp_324" href="#call_footnote_Temp_324"><sup><small>4</small></sup></a> In programming-language jargon, the variable <tt>balance</tt> is said to be <a name="%_idx_2886"></a><a name="%_idx_2888"></a><em>encapsulated</em> within the <tt>new-withdraw</tt> procedure.  Encapsulation reflects the general\nsystem-design principle known as the <a name="%_idx_2890"></a><a name="%_idx_2892"></a><em>hiding principle</em>: One can\nmake a system more modular and robust by protecting parts of the\nsystem from each other; that is, by providing information access only\nto those parts of the system that have a ``need to know.\'\'\n\n<p><a name="footnote_Temp_325" href="#call_footnote_Temp_325"><sup><small>5</small></sup></a> In contrast with <tt>new-withdraw</tt> above, we do not\nhave to use <tt>let</tt> to make <tt>balance</tt> a local variable, since\nformal parameters are already local.  This will be clearer after the\ndiscussion of the environment model of evaluation in section&nbsp;<a href="book-Z-H-21.html#%_sec_3.2">3.2</a>.\n(See also exercise&nbsp;<a href="book-Z-H-21.html#%_thm_3.10">3.10</a>.)\n\n<p><a name="footnote_Temp_330" href="#call_footnote_Temp_330"><sup><small>6</small></sup></a> One common way to implement\n<tt>rand-update</tt> is to use the rule that <em>x</em> is updated to <em>a</em><em>x</em> + <em>b</em>\nmodulo <em>m</em>, where <em>a</em>, <em>b</em>, and <em>m</em> are appropriately chosen integers.\nChapter&nbsp;3 of <a name="%_idx_2924"></a>Knuth 1981 includes an extensive discussion of techniques\nfor generating sequences of random numbers and establishing their\nstatistical properties.  Notice that the <tt>rand-update</tt> procedure\ncomputes a mathematical function: Given the same input twice, it\nproduces the same output.  Therefore, the number sequence produced by\n<tt>rand-update</tt> certainly is not ``random,\'\' if by ``random\'\' we\ninsist that each number in the sequence is unrelated to the preceding\nnumber.  The relation between ``real randomness\'\' and so-called <a name="%_idx_2926"></a><em>pseudo-random</em> sequences, which are produced by well-determined\ncomputations and yet have suitable statistical properties, is a\ncomplex question involving difficult issues in mathematics and\nphilosophy.  <a name="%_idx_2928"></a><a name="%_idx_2930"></a><a name="%_idx_2932"></a>Kolmogorov, Solomonoff, and Chaitin have made great\nprogress in clarifying these issues; a discussion can be found in\nChaitin 1975.\n\n<p><a name="footnote_Temp_331" href="#call_footnote_Temp_331"><sup><small>7</small></sup></a> This theorem is due to E. <a name="%_idx_2942"></a>Ces&agrave;ro.  See\nsection 4.5.2 of <a name="%_idx_2944"></a>Knuth 1981 for a discussion and a proof.\n\n<p><a name="footnote_Temp_333" href="#call_footnote_Temp_333"><sup><small>8</small></sup></a> <a name="%_idx_2964"></a>MIT Scheme provides such a procedure.  If <a name="%_idx_2966"></a><a name="%_idx_2968"></a><tt>random</tt>\nis given an exact\ninteger (as in section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.6">1.2.6</a>) it returns an exact integer,\nbut if it is given a decimal value (as in this exercise) it returns\na decimal value.\n\n<p><a name="footnote_Temp_335" href="#call_footnote_Temp_335"><sup><small>9</small></sup></a> We don\'t substitute for\nthe occurrence of <tt>balance</tt> in the <tt>set!</tt> expression because\nthe &lt;<em>name</em>&gt; in a <tt>set!</tt> is not evaluated.\nIf we did substitute for it, we would get\n<tt>(set!&nbsp;25&nbsp;(-&nbsp;25&nbsp;amount))</tt>, which makes no sense.\n\n<p><a name="footnote_Temp_337" href="#call_footnote_Temp_337"><sup><small>10</small></sup></a> The phenomenon of a\nsingle computational object being accessed by more than one name is\nknown as <a name="%_idx_2998"></a><em>aliasing</em>.  The joint bank account situation illustrates\na very simple example of an alias.  In section&nbsp;<a href="book-Z-H-22.html#%_sec_3.3">3.3</a>\nwe will see much more complex examples, such as ``distinct\'\' compound\ndata structures that share parts.  Bugs can occur in our programs if\n<a name="%_idx_3000"></a><a name="%_idx_3002"></a><a name="%_idx_3004"></a>we forget that a change to an object may also, as a ``side effect,\'\'\nchange a ``different\'\' object because the two ``different\'\' objects\nare actually a single object appearing under different aliases.  These\nso-called <em>side-effect bugs</em> are so difficult to locate and to\nanalyze that some people have proposed that programming languages be\ndesigned in such a way as to not allow side effects or aliasing\n<a name="%_idx_3006"></a><a name="%_idx_3008"></a><a name="%_idx_3010"></a><a name="%_idx_3012"></a>(Lampson et al. 1981; Morris, Schmidt, and Wadler 1980).\n\n<p><a name="footnote_Temp_339" href="#call_footnote_Temp_339"><sup><small>11</small></sup></a> In view of this, it is ironic that introductory programming\nis most often taught in a highly imperative style.  This may be a\nvestige of a belief, common throughout the 1960s and 1970s, that\nprograms that call procedures must inherently be less efficient than\nprograms that perform assignments.  (Steele (1977) <a name="%_idx_3024"></a>debunks this\nargument.)  Alternatively it may reflect a view that step-by-step\nassignment is easier for beginners to visualize than procedure call.\nWhatever the reason, it often saddles beginning programmers with\n``should I set this variable before or after that one\'\' concerns that can\ncomplicate programming and obscure the important ideas.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_3.2"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_3.2">3.2&nbsp;&nbsp;The Environment Model of Evaluation</a></h2><p>\n\n\n<a name="%_idx_3034"></a>\nWhen we introduced compound procedures in chapter&nbsp;1, we used the\n<a name="%_idx_3036"></a>substitution model of evaluation\n(section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a>) to define what is meant by\napplying a procedure to arguments:<p>\n\n<p><ul>\n<li>To apply a compound procedure to arguments, evaluate the body of the\nprocedure with each formal parameter replaced by the corresponding\nargument.\n</ul><p><p>\n\nOnce we admit assignment into our programming language, such a\ndefinition is no longer adequate.  In particular,\nsection&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a> argued that, in the presence of\nassignment, a variable can no longer be considered to be merely a name\nfor a value.  Rather, a variable must somehow designate a ``place\'\' in\nwhich values can be stored.  In our new model of evaluation, these\nplaces will be maintained in structures called <a name="%_idx_3038"></a><em>environments</em>.<p>\n\nAn environment is a sequence of <a name="%_idx_3040"></a><em>frames</em>.  Each frame is a table\n(possibly empty) of <a name="%_idx_3042"></a><em>bindings</em>, which associate variable names with\ntheir corresponding values.  (A single frame may contain at most one\nbinding for any variable.)  Each frame also has a pointer to its <a name="%_idx_3044"></a><a name="%_idx_3046"></a><em>enclosing environment</em>, unless, for the purposes of discussion, the\nframe is considered to be <a name="%_idx_3048"></a><a name="%_idx_3050"></a><em>global</em>.  The <a name="%_idx_3052"></a><em>value of a variable</em>\nwith respect to an environment is the value given by the binding of\nthe variable in the first frame in the environment that contains a\nbinding for that variable.  If no frame in the sequence specifies a\nbinding for the variable, then the variable is said to be <a name="%_idx_3054"></a><a name="%_idx_3056"></a><em>unbound</em> in the environment.<p>\n\n<a name="%_fig_3.1"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-2.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.1:</b>&nbsp;&nbsp;A simple environment structure.</div></caption><tr><td>\n\n<a name="%_idx_3058"></a></td></tr></table></div><p><p>\n\nFigure&nbsp;<a href="#%_fig_3.1">3.1</a> shows a simple environment\nstructure consisting of three frames, labeled I, II, and III.  In the\ndiagram, A, B, C, and D are pointers to environments.  C and D point\nto the same environment.  The variables <tt>z</tt> and <tt>x</tt> are bound\nin frame II, while <tt>y</tt> and <tt>x</tt> are bound in frame I.  The\nvalue of <tt>x</tt> in environment D is 3.  The value of <tt>x</tt> with\nrespect to environment B is also 3.  This is determined as follows: We\nexamine the first frame in the sequence (frame III) and do not find a\nbinding for <tt>x</tt>, so we proceed to the enclosing environment D and\nfind the binding in frame I.  On the other hand, the value of <tt>x</tt>\nin environment A is 7, because the first frame in the sequence (frame\nII) contains a binding of <tt>x</tt> to 7.  With respect to environment\nA, the binding of <tt>x</tt> to 7 in frame II is said to <a name="%_idx_3060"></a><em>shadow</em> the\nbinding of <tt>x</tt> to 3 in frame I.<p>\n\n\nThe environment is crucial to the evaluation process,\nbecause it determines the context in which an expression should be\nevaluated.  Indeed, one could say that expressions in a programming\nlanguage do not, in themselves, have any meaning.  Rather, an\nexpression acquires a meaning only with respect to some environment in\nwhich it is evaluated.  Even the interpretation of an expression as\nstraightforward as <tt>(+&nbsp;1&nbsp;1)</tt> depends on an understanding that one\nis operating in a context in which <tt>+</tt> is the symbol for addition.\nThus, in our model of evaluation we will always speak of evaluating an\nexpression with respect to some environment.  To describe interactions\nwith the interpreter, we will suppose that there is a <a name="%_idx_3062"></a>global\nenvironment, consisting of a single frame (with no enclosing\nenvironment) that includes values for the symbols associated with the\nprimitive procedures.  For example, the idea that <tt>+</tt> is the\nsymbol for addition is captured by saying that the symbol <tt>+</tt> is\nbound in the global environment to the primitive addition procedure.<p>\n\n<a name="%_sec_3.2.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.2.1">3.2.1&nbsp;&nbsp;The Rules for Evaluation</a></h3><p>\n\n<a name="%_idx_3064"></a>\nThe overall specification of how the interpreter evaluates a\ncombination remains the same as when we first introduced it in\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.3">1.1.3</a>:<p>\n\n<p><ul>\n<li>To evaluate a combination:\n</ul><p><p>\n\n<blockquote>\n<p>1.&nbsp;&nbsp;Evaluate the subexpressions of the\ncombination.<a name="call_footnote_Temp_342" href="#footnote_Temp_342"><sup><small>12</small></sup></a><p>\n\n<p>2.&nbsp;&nbsp;Apply the value of the operator subexpression to the values of the\noperand subexpressions.\n</blockquote><p>\n\nThe environment model of evaluation replaces the substitution model in\nspecifying what it means to apply a compound procedure to arguments.<p>\n\nIn the environment model of evaluation, a procedure is always a pair\nconsisting of some code and a pointer to an environment.  Procedures\nare created in one way only: by evaluating a <tt>lambda</tt> expression.\n<a name="%_idx_3070"></a>This produces a procedure whose code is obtained from the text of the\n<tt>lambda</tt> expression and whose environment is the environment in\nwhich the <tt>lambda</tt> expression was evaluated to produce the\nprocedure.  For example, consider the procedure definition<p>\n\n<p><p><tt><a name="%_idx_3072"></a>(define&nbsp;(square&nbsp;x)<br>\n&nbsp;&nbsp;(*&nbsp;x&nbsp;x))<br>\n</tt><p><p>\nevaluated in the global environment.  The procedure definition syntax\nis just syntactic sugar for an underlying implicit <tt>lambda</tt>\nexpression.  It would have been equivalent to have used<p>\n\n<p><p><tt>(define&nbsp;square<br>\n&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;x)))<br>\n</tt><p><p>\nwhich evaluates <tt>(lambda (x) (* x x))</tt> and binds <tt>square</tt> to the resulting value, all in the global environment.<p>\n\nFigure&nbsp;<a href="#%_fig_3.2">3.2</a> shows the result of evaluating this\n<tt>define</tt> expression.  The procedure object is a pair whose code\nspecifies that the procedure has one formal parameter, namely <tt>x</tt>,\nand a procedure body <tt>(* x x)</tt>.  The environment part of the\nprocedure is a pointer to the global environment, since that is the\nenvironment in which the <tt>lambda</tt> expression was evaluated to\nproduce the procedure. A new binding, which associates the procedure\nobject with the symbol <tt>square</tt>, has been added to the global\nframe.  In general, <tt>define</tt> creates definitions by adding\nbindings to frames.<p>\n\n<a name="%_fig_3.2"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-3.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.2:</b>&nbsp;&nbsp;Environment structure produced by\nevaluating\n<tt>(define (square x) (* x x))</tt> in the global environment.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nNow that we have seen how procedures are created, we can describe how\nprocedures are applied.  The environment model specifies: To apply a\nprocedure to arguments, create a new environment containing a frame\nthat binds the parameters to the values of the arguments.  The\nenclosing environment of this frame is the environment specified by\nthe procedure.  Now, within this new environment, evaluate the\nprocedure body.<p>\n\n\nTo show how this rule is followed, figure&nbsp;<a href="#%_fig_3.3">3.3</a>\nillustrates the environment structure created by evaluating the\nexpression <tt>(square 5)</tt> in the global environment, where <tt>square</tt> is the procedure generated in\nfigure&nbsp;<a href="#%_fig_3.2">3.2</a>.  Applying the procedure results in\nthe creation of a new environment, labeled E1 in the figure, that\nbegins with a frame in which <tt>x</tt>, the formal parameter for the\nprocedure, is bound to the argument 5.  The pointer leading upward\nfrom this frame shows that the frame\'s enclosing environment is the\nglobal environment.  The global environment is chosen here, because\nthis is the environment that is indicated as part of the <tt>square</tt>\nprocedure object.  Within E1, we evaluate the body of the procedure,\n<tt>(* x x)</tt>.  Since the value of <tt>x</tt> in E1 is 5, the result is\n<tt>(*&nbsp;5&nbsp;5)</tt>, or&nbsp;25.\n\n<a name="%_fig_3.3"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-4.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.3:</b>&nbsp;&nbsp;Environment created by evaluating <tt>(square 5)</tt>\nin the global environment.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nThe environment model of procedure application can be summarized by\ntwo rules:<p>\n\n<p><ul>\n<li>A procedure object is applied to a set of arguments by\nconstructing a frame, binding the formal parameters of the procedure\nto the arguments of the call, and then evaluating the body of\nthe procedure in the context of the new environment constructed.  The\nnew frame has as its enclosing environment the environment part of the\nprocedure object being applied.<p>\n\n<a name="%_idx_3074"></a><a name="%_idx_3076"></a><li>A procedure is created by evaluating a <tt>lambda</tt>\nexpression relative to a given environment.  The resulting procedure\nobject is a pair consisting of the text of the <tt>lambda</tt> expression\nand a pointer to the environment in which the procedure was created.\n</ul><p><p>\n\n<a name="%_idx_3078"></a>We also specify that defining a symbol using <tt>define</tt> creates a\nbinding in the current environment frame and assigns to the symbol the\nindicated value.<a name="call_footnote_Temp_343" href="#footnote_Temp_343"><sup><small>13</small></sup></a>  Finally, we specify the behavior of\n<tt>set!</tt>, the operation that forced us to introduce the environment\nmodel in the first place.  Evaluating the expression <tt>(set!\n&lt;<em>variable</em>&gt; &lt;<em>value</em>&gt;)</tt> in some environment locates the binding of\nthe variable in the environment and changes that binding to indicate\nthe new value.  That is, one finds the first frame in the environment\nthat contains a binding for the variable and modifies that frame.  If\nthe variable is unbound in the environment, then <tt>set!</tt> signals\nan error.<p>\n\n\nThese evaluation rules, though considerably more complex than the\nsubstitution model, are still reasonably straightforward.  Moreover,\nthe evaluation model, though abstract, provides a correct description\nof how the interpreter evaluates expressions.  In chapter&nbsp;4 we shall\nsee how this model can serve as a blueprint for implementing a working\ninterpreter.  The following sections elaborate the details of the\nmodel by analyzing some illustrative programs.\n\n<a name="%_sec_3.2.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.2.2">3.2.2&nbsp;&nbsp;Applying Simple Procedures</a></h3><p>\n\n<a name="%_idx_3082"></a><a name="%_idx_3084"></a>\n<a name="%_idx_3086"></a>When we introduced the substitution model in\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a> we showed how the combination\n<tt>(f 5)</tt> evaluates to 136, given the following procedure\ndefinitions:<p>\n\n<p><p><tt>(define&nbsp;(square&nbsp;x)<br>\n&nbsp;&nbsp;(*&nbsp;x&nbsp;x))<br>\n(define&nbsp;(sum-of-squares&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(+&nbsp;(square&nbsp;x)&nbsp;(square&nbsp;y)))<br>\n(define&nbsp;(f&nbsp;a)<br>\n&nbsp;&nbsp;(sum-of-squares&nbsp;(+&nbsp;a&nbsp;1)&nbsp;(*&nbsp;a&nbsp;2)))<br>\n</tt><p><p>\nWe can analyze the same example using the environment model.\nFigure&nbsp;<a href="#%_fig_3.4">3.4</a> shows the three procedure objects\ncreated by evaluating the definitions of <tt>f</tt>, <tt>square</tt>, and\n<tt>sum-of-squares</tt> in the global environment.  Each procedure object\nconsists of some code, together with a pointer to the global\nenvironment.<p>\n\n<a name="%_fig_3.4"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-5.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.4:</b>&nbsp;&nbsp;Procedure objects in the global frame.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nIn figure&nbsp;<a href="#%_fig_3.5">3.5</a> we see the environment structure created\nby evaluating the expression <tt>(f 5)</tt>.  The call to <tt>f</tt> creates\na new environment E1 beginning with a frame in which <tt>a</tt>, the\nformal parameter of <tt>f</tt>, is bound to the argument 5.  In E1, we\nevaluate the body of <tt>f</tt>:<p>\n\n<p><p><tt>(sum-of-squares&nbsp;(+&nbsp;a&nbsp;1)&nbsp;(*&nbsp;a&nbsp;2))<br>\n</tt><p><p><p>\n\n<a name="%_fig_3.5"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-6.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.5:</b>&nbsp;&nbsp;Environments created by evaluating <tt>(f 5)</tt>\nusing the procedures in figure&nbsp;<a href="#%_fig_3.4">3.4</a>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n\nTo evaluate this combination, we first evaluate the subexpressions.\nThe first subexpression, <tt>sum-of-squares</tt>, has a value that is a\nprocedure object.  (Notice how this value is found: We first look in\nthe first frame of E1, which contains no binding for <tt>sum-of-squares</tt>.  Then we proceed to the enclosing environment,\ni.e. the global environment, and find the binding shown in\nfigure&nbsp;<a href="#%_fig_3.4">3.4</a>.)  The other two subexpressions are\nevaluated by applying the primitive operations <tt>+</tt> and <tt>*</tt> to\nevaluate the two combinations <tt>(+ a 1)</tt> and <tt>(* a 2)</tt> to\nobtain 6 and 10, respectively.<p>\n\nNow we apply the procedure object <tt>sum-of-squares</tt> to the\narguments 6 and 10.  This results in a new environment E2 in which the\nformal parameters <tt>x</tt> and <tt>y</tt> are bound to the arguments.\nWithin E2 we evaluate the combination <tt>(+ (square x) (square y))</tt>.\nThis leads us to evaluate <tt>(square x)</tt>, where <tt>square</tt> is\nfound in the global frame and <tt>x</tt> is 6.  Once again, we set up a\nnew environment, E3, in which <tt>x</tt> is bound to 6, and within this\nwe evaluate the body of <tt>square</tt>, which is <tt>(* x x)</tt>.  Also as\npart of applying <tt>sum-of-squares</tt>, we must evaluate the\nsubexpression <tt>(square y)</tt>, where <tt>y</tt> is 10.  This second call\nto <tt>square</tt> creates another environment, E4, in which <tt>x</tt>, the\nformal parameter of <tt>square</tt>, is bound to 10.  And within E4 we\nmust evaluate <tt>(* x x)</tt>.<p>\n\nThe important point to observe is that each call to <tt>square</tt>\ncreates a new environment containing a binding for <tt>x</tt>.  We can\nsee here how the different frames serve to keep separate the different\nlocal variables all named <tt>x</tt>.  Notice that each frame created by\n<tt>square</tt> points to the global environment, since this is the\nenvironment indicated by the <tt>square</tt> procedure object.<p>\n\nAfter the subexpressions are evaluated, the results are\nreturned.  The values generated by the two calls to <tt>square</tt> are\nadded by <tt>sum-of-squares</tt>, and this result is returned by <tt>f</tt>.\nSince our focus here is on the environment structures, we will not\ndwell on how these returned values are passed from call to call;\nhowever, this is also an important aspect of the evaluation process,\nand we will return to it in detail in chapter&nbsp;5.\n\n<p><a name="%_thm_3.9"></a>\n<b>Exercise 3.9.</b>&nbsp;&nbsp;<a name="%_idx_3088"></a><a name="%_idx_3090"></a><a name="%_idx_3092"></a>In section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a>\nwe used the substitution model to analyze two\nprocedures for computing factorials, a recursive version<p>\n\n<p><p><tt>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;n&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1)))))<br>\n</tt><p><p>\nand an iterative version<p>\n\n<p><p><tt>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(fact-iter&nbsp;1&nbsp;1&nbsp;n))<br>\n(define&nbsp;(fact-iter&nbsp;product&nbsp;counter&nbsp;max-count)<br>\n&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;counter&nbsp;max-count)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fact-iter&nbsp;(*&nbsp;counter&nbsp;product)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;counter&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max-count)))<br>\n</tt><p><p>\nShow the environment structures created by evaluating <tt>(factorial 6)</tt>\nusing each version of the <tt>factorial</tt> procedure.<a name="call_footnote_Temp_345" href="#footnote_Temp_345"><sup><small>14</small></sup></a>\n<p>\n\n<a name="%_sec_3.2.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.2.3">3.2.3&nbsp;&nbsp;Frames as the Repository of Local State</a></h3><p>\n\n\n<a name="%_idx_3098"></a><a name="%_idx_3100"></a><a name="%_idx_3102"></a>\n<a name="%_idx_3104"></a>We can turn to the environment model to see how procedures and\nassignment can be used to represent objects with local state.  As an\nexample, consider the ``withdrawal processor\'\' from\nsection&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a> created by calling the\nprocedure<p>\n\n<p><p><tt>(define&nbsp;(make-withdraw&nbsp;balance)<br>\n&nbsp;&nbsp;(lambda&nbsp;(amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;)))<br>\n</tt><p><p>\nLet us describe the evaluation of<p>\n\n<p><p><tt>(define&nbsp;W1&nbsp;(make-withdraw&nbsp;100))<br>\n</tt><p><p>\nfollowed by<p>\n\n<p><p><tt>(W1&nbsp;50)<br>\n<i>50</i><br>\n</tt><p><p>\nFigure&nbsp;<a href="#%_fig_3.6">3.6</a> shows the result of defining the <tt>make-withdraw</tt> procedure in the global environment.  This produces a\nprocedure object that contains a pointer to the global environment.\nSo far, this is no different from the examples we have already seen,\nexcept that the body of the procedure is itself a <tt>lambda</tt>\nexpression.<p>\n\n<a name="%_fig_3.6"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-7.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.6:</b>&nbsp;&nbsp;Result of defining <tt>make-withdraw</tt>\nin the global environment.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nThe interesting part of the computation happens when we apply the\nprocedure <tt>make-withdraw</tt> to an argument:<p>\n\n<p><p><tt>(define&nbsp;W1&nbsp;(make-withdraw&nbsp;100))<br>\n</tt><p><p>\nWe begin, as usual, by setting up an environment E1 in which the\nformal parameter <tt>balance</tt> is bound to the argument 100.  Within\nthis environment, we evaluate the body of <tt>make-withdraw</tt>, namely\nthe <tt>lambda</tt> expression.  This constructs a new procedure object,\nwhose code is as specified by the <tt>lambda</tt> and whose environment\nis E1, the environment in which the <tt>lambda</tt> was evaluated to\nproduce the procedure.  The resulting procedure object is the value\nreturned by the call to <tt>make-withdraw</tt>.  This is bound to <tt>W1</tt> in the global environment, since the <tt>define</tt> itself is being\nevaluated in the global environment.  Figure&nbsp;<a href="#%_fig_3.7">3.7</a> shows the\nresulting environment structure.<p>\n\n<a name="%_fig_3.7"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-8.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.7:</b>&nbsp;&nbsp;Result of evaluating <tt>(define W1 (make-withdraw 100))</tt>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nNow we can analyze what happens when <tt>W1</tt> is applied to an\nargument:<p>\n\n<p><p><tt>(W1&nbsp;50)<br>\n<i>50</i><br>\n</tt><p><p>\nWe begin by constructing a frame in which <tt>amount</tt>, the formal\nparameter of <tt>W1</tt>, is bound to the argument 50.  The crucial point\nto observe is that this frame has as its enclosing environment not the\nglobal environment, but rather the environment E1, because this is the\nenvironment that is specified by the <tt>W1</tt> procedure object.\nWithin this new environment, we evaluate the body of the procedure:<p>\n\n<p><p><tt>(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;)<br>\n</tt><p><p>\nThe resulting environment structure is shown in\nfigure&nbsp;<a href="#%_fig_3.8">3.8</a>.  The expression being evaluated references\nboth <tt>amount</tt> and <tt>balance</tt>.  <tt>Amount</tt> will be found in\nthe first frame in the environment, while <tt>balance</tt> will be found\nby following the enclosing-environment pointer to E1.<p>\n\n<a name="%_fig_3.8"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-9.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.8:</b>&nbsp;&nbsp;Environments created by applying the procedure\nobject <tt>W1</tt>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nWhen the <tt>set!</tt> is executed, the binding of <tt>balance</tt> in E1 is changed.  At the completion of the call to <tt>W1</tt>,\n<tt>balance</tt> is 50, and the frame that contains <tt>balance</tt>\nis still pointed to by the procedure object <tt>W1</tt>.  The frame\nthat binds <tt>amount</tt>\n(in which we executed the code that changed <tt>balance</tt>) is no longer\nrelevant, since the procedure call that constructed it has terminated,\nand there are no pointers to that frame from other parts of the\nenvironment.  The next time <tt>W1</tt> is called, this will build a new\nframe that binds <tt>amount</tt> and whose enclosing environment is E1.\nWe see that E1 serves as the ``place\'\' that holds the local state\nvariable for the procedure object <tt>W1</tt>.  Figure&nbsp;<a href="#%_fig_3.9">3.9</a>\nshows the situation after the call to <tt>W1</tt>.<p>\n\n<a name="%_fig_3.9"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-10.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.9:</b>&nbsp;&nbsp;Environments after the call to <tt>W1</tt>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nObserve what happens when we create a second ``withdraw\'\' object by\nmaking another call to <tt>make-withdraw</tt>:<p>\n\n<p><p><tt>(define&nbsp;W2&nbsp;(make-withdraw&nbsp;100))<br>\n</tt><p><p>\nThis produces the environment structure of figure&nbsp;<a href="#%_fig_3.10">3.10</a>, which shows\nthat <tt>W2</tt> is a procedure object, that is, a pair with some code\nand an environment.  The environment E2 for <tt>W2</tt> was created by\nthe call to <tt>make-withdraw</tt>.  It contains a frame with its own\nlocal binding for <tt>balance</tt>.  On the other hand, <tt>W1</tt> and <tt>W2</tt> have the same code: the code specified by the <tt>lambda</tt>\nexpression in the body of <tt>make-withdraw</tt>.<a name="call_footnote_Temp_346" href="#footnote_Temp_346"><sup><small>15</small></sup></a> We see here why <tt>W1</tt> and <tt>W2</tt>\nbehave as independent objects.  Calls to <tt>W1</tt> reference the state\nvariable <tt>balance</tt> stored in E1, whereas calls to <tt>W2</tt>\nreference the <tt>balance</tt> stored in E2. Thus, changes to the local\nstate of one object do not affect the other object.<p>\n\n<a name="%_fig_3.10"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-11.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.10:</b>&nbsp;&nbsp;Using <tt>(define W2 (make-withdraw 100))</tt>\nto create a second object.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<p><a name="%_thm_3.10"></a>\n<b>Exercise 3.10.</b>&nbsp;&nbsp;In the <tt>make-withdraw</tt> procedure, the local variable <tt>balance</tt>\nis created as a parameter of <tt>make-withdraw</tt>.  We could also\ncreate the local state variable explicitly, using <tt>let</tt>, as\nfollows:\n<p>\n\n<p><p><tt><a name="%_idx_3106"></a>(define&nbsp;(make-withdraw&nbsp;initial-amount)<br>\n&nbsp;&nbsp;(let&nbsp;((balance&nbsp;initial-amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;))))<br>\n</tt><p><p>\n<a name="%_idx_3108"></a><a name="%_idx_3110"></a>Recall from section&nbsp;<a href="book-Z-H-12.html#%_sec_1.3.2">1.3.2</a> that <tt>let</tt> is simply\nsyntactic sugar for a procedure call:<p>\n\n\n<p><p><tt>(let&nbsp;((&lt;<em>var</em>&gt;&nbsp;&lt;<em>exp</em>&gt;))&nbsp;&lt;<em>body</em>&gt;)<br>\n</tt><p><p>\nis interpreted as an alternate syntax for<p>\n\n\n<p><p><tt>((lambda&nbsp;(&lt;<em>var</em>&gt;)&nbsp;&lt;<em>body</em>&gt;)&nbsp;&lt;<em>exp</em>&gt;)<br>\n</tt><p><p>\nUse the environment model to analyze this alternate\nversion of <tt>make-withdraw</tt>, drawing figures like the ones above to\nillustrate the interactions<p>\n\n<p><p><tt>(define&nbsp;W1&nbsp;(make-withdraw&nbsp;100))<br>\n<br>\n(W1&nbsp;50)<br>\n<br>\n(define&nbsp;W2&nbsp;(make-withdraw&nbsp;100))<br>\n</tt><p><p>\nShow that the two versions of <tt>make-withdraw</tt> create objects with\nthe same behavior.  How do the environment structures differ for the two\nversions?\n\n<p>\n<p>\n\n<a name="%_sec_3.2.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.2.4">3.2.4&nbsp;&nbsp;Internal Definitions</a></h3><p>\n\n<a name="%_idx_3112"></a><a name="%_idx_3114"></a><a name="%_idx_3116"></a>\nSection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.8">1.1.8</a> introduced the idea that procedures can have internal\ndefinitions, thus leading to a block structure as in the\nfollowing procedure to compute square roots:<p>\n\n\n<p><p><tt><a name="%_idx_3118"></a>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(define&nbsp;(good-enough?&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&nbsp;(abs&nbsp;(-&nbsp;(square&nbsp;guess)&nbsp;x))&nbsp;0.001))<br>\n&nbsp;&nbsp;(define&nbsp;(improve&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(average&nbsp;guess&nbsp;(/&nbsp;x&nbsp;guess)))<br>\n&nbsp;&nbsp;(define&nbsp;(sqrt-iter&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(good-enough?&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guess<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt-iter&nbsp;(improve&nbsp;guess))))<br>\n&nbsp;&nbsp;(sqrt-iter&nbsp;1.0))<br>\n</tt><p><p>\nNow we can use the environment model to see why these internal\ndefinitions behave as desired.  Figure&nbsp;<a href="#%_fig_3.11">3.11</a> shows the point in the\nevaluation of the expression <tt>(sqrt 2)</tt> where the internal\nprocedure <tt>good-enough?</tt> has been called for the first time with\n<tt>guess</tt> equal to 1.<p>\n\n<a name="%_fig_3.11"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-12.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.11:</b>&nbsp;&nbsp;<tt>Sqrt</tt> procedure with internal definitions.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nObserve the structure of the environment.  <tt>Sqrt</tt> is a symbol in\nthe global environment that is bound to a procedure object whose\nassociated environment is the global environment.  When <tt>sqrt</tt> was\ncalled, a new environment E1 was formed, subordinate to the global\nenvironment, in which the parameter <tt>x</tt> is bound to 2.  The body\nof <tt>sqrt</tt> was then evaluated in E1.  Since the first expression in\nthe body of <tt>sqrt</tt> is<p>\n\n<p><p><tt>(define&nbsp;(good-enough?&nbsp;guess)<br>\n&nbsp;&nbsp;(&lt;&nbsp;(abs&nbsp;(-&nbsp;(square&nbsp;guess)&nbsp;x))&nbsp;0.001))<br>\n</tt><p><p>\nevaluating this expression defined the procedure <tt>good-enough?</tt>\nin the environment E1.  To be more precise, the symbol <tt>good-enough?</tt> was added to the first frame of E1, bound to a\nprocedure object whose associated environment is E1.  Similarly, <tt>improve</tt> and <tt>sqrt-iter</tt> were defined as procedures in E1.  For\nconciseness, figure&nbsp;<a href="#%_fig_3.11">3.11</a> shows only the procedure\nobject for <tt>good-enough?</tt>.<p>\n\nAfter the local procedures were defined, the\nexpression <tt>(sqrt-iter 1.0)</tt> was evaluated,\nstill in environment E1.  So the\nprocedure object bound to <tt>sqrt-iter</tt> in E1 was called with 1 as\nan argument.  This created an environment E2 in which <tt>guess</tt>,\nthe parameter of <tt>sqrt-iter</tt>, is bound to 1.  <tt>Sqrt-iter</tt> in\nturn called <tt>good-enough?</tt> with the value of <tt>guess</tt> (from\nE2) as the argument for <tt>good-enough?</tt>.  This set up another\nenvironment, E3, in which <tt>guess</tt> (the parameter of <tt>good-enough?</tt>) is bound to 1.  Although <tt>sqrt-iter</tt> and <tt>good-enough?</tt> both have a parameter named <tt>guess</tt>, these are two\ndistinct local variables located in different frames.  Also, E2 and E3\nboth have E1 as their enclosing environment, because the <tt>sqrt-iter</tt> and <tt>good-enough?</tt> procedures both have E1 as their\nenvironment part.  One consequence of this is that the symbol <tt>x</tt>\nthat appears in the body of <tt>good-enough?</tt> will reference the\nbinding of <tt>x</tt> that appears in E1, namely the value of <tt>x</tt>\nwith which the original <tt>sqrt</tt> procedure was called.\n\nThe environment model thus explains the two key properties that make\nlocal procedure definitions a useful technique for modularizing\nprograms:\n<p><ul>\n<li>The names of the local procedures do not interfere with\nnames external to the enclosing procedure, because the local procedure\nnames will be bound in the frame that the procedure creates when it is\nrun, rather than being bound in the global environment.<p>\n\n<li>The local procedures can access the arguments of the enclosing\nprocedure, simply by using parameter names as free variables.\nThis is because the body of the local procedure is evaluated in an\nenvironment that is subordinate to the evaluation environment for the\nenclosing procedure.\n</ul><p><p>\n\n<p><a name="%_thm_3.11"></a>\n<b>Exercise 3.11.</b>&nbsp;&nbsp;<a name="%_idx_3120"></a><a name="%_idx_3122"></a><a name="%_idx_3124"></a>In section&nbsp;<a href="#%_sec_3.2.3">3.2.3</a>\nwe saw how the environment model described the\nbehavior of procedures with local state.  Now we have seen how\ninternal definitions work.  A typical message-passing procedure\ncontains both of these aspects.  Consider the bank account procedure\nof section&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:<p>\n\n<p><p><tt><a name="%_idx_3126"></a>(define&nbsp;(make-account&nbsp;balance)<br>\n&nbsp;&nbsp;(define&nbsp;(withdraw&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;))<br>\n&nbsp;&nbsp;(define&nbsp;(deposit&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;balance&nbsp;(+&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;m&nbsp;\'withdraw)&nbsp;withdraw)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'deposit)&nbsp;deposit)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;MAKE-ACCOUNT&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m))))<br>\n&nbsp;&nbsp;dispatch)<br>\n</tt><p><p>\nShow the environment structure generated by the sequence of\ninteractions<p>\n\n<p><p><tt>(define&nbsp;acc&nbsp;(make-account&nbsp;50))<br>\n<br>\n((acc&nbsp;\'deposit)&nbsp;40)<br>\n<i>90</i><br>\n<br>\n((acc&nbsp;\'withdraw)&nbsp;60)<br>\n<i>30</i><br>\n</tt><p><p>\nWhere is the local state for <tt>acc</tt> kept?  Suppose we define\nanother account<p>\n\n<p><p><tt>(define&nbsp;acc2&nbsp;(make-account&nbsp;100))<br>\n</tt><p><p>\nHow are the local states for the two accounts kept distinct?  Which\nparts of the environment structure are shared between <tt>acc</tt> and\n<tt>acc2</tt>?\n\n<p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_342" href="#call_footnote_Temp_342"><sup><small>12</small></sup></a> Assignment introduces a subtlety into step 1 of\nthe evaluation rule.  As shown in\nexercise&nbsp;<a href="book-Z-H-20.html#%_thm_3.8">3.8</a>, the presence of assignment\nallows us to write expressions that will produce different values\ndepending on the order in which the subexpressions in a combination\n<a name="%_idx_3066"></a><a name="%_idx_3068"></a>are evaluated.  Thus, to be precise, we should specify an evaluation\norder in step 1 (e.g., left to right or right to left).  However, this\norder should always be considered to be an implementation detail, and\none should never write programs that depend on some particular order.\nFor instance, a sophisticated compiler might optimize a program by\nvarying the order in which subexpressions are evaluated.\n\n<p><a name="footnote_Temp_343" href="#call_footnote_Temp_343"><sup><small>13</small></sup></a> If there is already a binding for the\nvariable in the current frame, then the binding is changed.  This is\nconvenient because it allows redefinition of symbols; however, it also\nmeans that <tt>define</tt> can be used to change values, and this brings\nup the issues of assignment without explicitly using <a name="%_idx_3080"></a><tt>set!</tt>.\nBecause of this, some people prefer redefinitions of existing symbols\nto signal errors or warnings.\n\n<p><a name="footnote_Temp_345" href="#call_footnote_Temp_345"><sup><small>14</small></sup></a> The\nenvironment model will not clarify our claim in\nsection&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a> that the interpreter can\nexecute a procedure such as <tt>fact-iter</tt> in a constant amount of\nspace using tail recursion.  We will discuss tail recursion when we\n<a name="%_idx_3094"></a><a name="%_idx_3096"></a>deal with the control structure of the interpreter in\nsection&nbsp;<a href="book-Z-H-34.html#%_sec_5.4">5.4</a>.\n\n<p><a name="footnote_Temp_346" href="#call_footnote_Temp_346"><sup><small>15</small></sup></a> Whether\n<tt>W1</tt> and <tt>W2</tt> share the same physical code stored in the\ncomputer, or whether they each keep a copy of the code, is a detail of\nthe implementation.  For the interpreter we implement in chapter&nbsp;4,\nthe code is in fact shared.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_3.3"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_3.3">3.3&nbsp;&nbsp;Modeling with Mutable Data</a></h2><p>\n\n\n<a name="%_idx_3128"></a>\nChapter&nbsp;2 dealt with compound data as a means for constructing\ncomputational objects that have several parts, in order to model\nreal-world objects that have several aspects.  In that chapter we\nintroduced the discipline of data abstraction, according to which data\nstructures are specified in terms of constructors, which create data\nobjects, and selectors, which access the parts of compound data\nobjects.  But we now know that there is another aspect of data that\nchapter&nbsp;2 did not address.  The desire to model systems composed of\nobjects that have changing state leads us to the need to modify\ncompound data objects, as well as to construct and select from them.\nIn order to model compound objects with changing state, we will design\ndata abstractions to include, in addition to selectors and\nconstructors, operations called <a name="%_idx_3130"></a><em>mutators</em>, which modify data\nobjects.  For instance, modeling a banking system requires us to\nchange account balances.  Thus, a data structure for representing bank\naccounts might admit an operation<p>\n\n<p><p><tt>(set-balance!&nbsp;&lt;<em>account</em>&gt;&nbsp;&lt;<em>new-value</em>&gt;)<br>\n</tt><p><p>\nthat changes the balance of the designated account to the designated\nnew value.  Data objects for which mutators are defined are known as\n<em>mutable data objects</em>.<p>\n\nChapter&nbsp;2 introduced pairs as a general-purpose ``glue\'\' for\nsynthesizing compound data.  We begin this section by defining basic\nmutators for pairs, so that pairs can serve as building blocks for\nconstructing mutable data objects.  These mutators greatly enhance the\nrepresentational power of pairs, enabling us to build data structures\nother than the sequences and trees that we worked with in\nsection&nbsp;<a href="book-Z-H-15.html#%_sec_2.2">2.2</a>.  We also present some examples of\nsimulations in which complex systems are modeled as collections of\nobjects with local state.<p>\n\n<a name="%_sec_3.3.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.3.1">3.3.1&nbsp;&nbsp;Mutable List Structure</a></h3><p>\n\n\n<a name="%_idx_3132"></a><a name="%_idx_3134"></a>\n<a name="%_idx_3136"></a><a name="%_idx_3138"></a>\nThe basic operations on pairs -- <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> -- can be used to construct list structure and to select parts\nfrom list structure, but they are incapable of modifying list\nstructure.  The same is true of the list operations we have used so\nfar, such as <tt>append</tt> and <tt>list</tt>, since these can be defined\nin terms of <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>.  To modify list\nstructures we need new operations.<p>\n\n<a name="%_fig_3.12"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-13.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.12:</b>&nbsp;&nbsp;Lists <tt>x</tt>: <tt>((a b) c d)</tt> and <tt>y</tt>: <tt>(e\nf)</tt>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_fig_3.13"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-14.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.13:</b>&nbsp;&nbsp;Effect of <tt>(set-car! x y)</tt> on the lists in\nfigure&nbsp;<a href="#%_fig_3.12">3.12</a>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_fig_3.14"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-15.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.14:</b>&nbsp;&nbsp;Effect of <tt>(define z (cons y (cdr x)))</tt> on \nthe lists in figure&nbsp;<a href="#%_fig_3.12">3.12</a>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_fig_3.15"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-16.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.15:</b>&nbsp;&nbsp;Effect of <tt>(set-cdr! x y)</tt> on the lists in\nfigure&nbsp;<a href="#%_fig_3.12">3.12</a>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_idx_3140"></a><a name="%_idx_3142"></a><a name="%_idx_3144"></a><a name="%_idx_3146"></a>The primitive mutators for pairs are <tt>set-car!</tt> and <tt>set-cdr!</tt>. <tt>Set-car!</tt> takes two arguments, the first of which\nmust be a pair.  It modifies this pair, replacing the <tt>car</tt>\npointer by a pointer to the second argument of <tt>set-car!</tt>.<a name="call_footnote_Temp_349" href="#footnote_Temp_349"><sup><small>16</small></sup></a><p>\n\nAs an example, suppose that <tt>x</tt> is bound to the list <tt>((a b) c\nd)</tt> and <tt>y</tt> to the list <tt>(e f)</tt> as illustrated in\nfigure&nbsp;<a href="#%_fig_3.12">3.12</a>.  Evaluating the expression <tt>(set-car!\nx y)</tt> modifies the pair to which <tt>x</tt> is bound, replacing its <tt>car</tt> by the value of <tt>y</tt>.  The result of the operation is shown in\nfigure&nbsp;<a href="#%_fig_3.13">3.13</a>.  The structure <tt>x</tt> has been modified and\nwould now be printed\nas <tt>((e&nbsp;f)&nbsp;c&nbsp;d)</tt>.  The\npairs representing the list <tt>(a b)</tt>, identified by the pointer\nthat was replaced, are now detached from the original\nstructure.<a name="call_footnote_Temp_350" href="#footnote_Temp_350"><sup><small>17</small></sup></a><p>\n\nCompare figure&nbsp;<a href="#%_fig_3.13">3.13</a> with figure&nbsp;<a href="#%_fig_3.14">3.14</a>,\nwhich illustrates the result of executing <tt>(define z (cons y (cdr\nx)))</tt> with <tt>x</tt> and <tt>y</tt> bound to the original lists of\nfigure&nbsp;<a href="#%_fig_3.12">3.12</a>.  The variable <tt>z</tt> is now bound to a\nnew pair created by the <tt>cons</tt> operation; the list to which <tt>x</tt> is bound is unchanged.<p>\n\nThe <tt>set-cdr!</tt> operation is similar to <tt>set-car!</tt>.  The\nonly difference is that the <tt>cdr</tt> pointer of the pair, rather than\nthe <tt>car</tt> pointer, is replaced.  The effect of executing <tt>(set-cdr! x y)</tt> on the lists of figure&nbsp;<a href="#%_fig_3.12">3.12</a> is shown\nin figure&nbsp;<a href="#%_fig_3.15">3.15</a>.\nHere the <tt>cdr</tt> pointer of <tt>x</tt> has been replaced by the pointer\nto <tt>(e f)</tt>.  Also, the list <tt>(c d)</tt>, which used to be the <tt>cdr</tt> of <tt>x</tt>, is now detached from the structure.<p>\n\n<a name="%_idx_3158"></a><tt>Cons</tt> builds new list structure by creating new pairs, while\n<tt>set-car!</tt> and <tt>set-cdr!</tt> modify existing pairs.  Indeed, we\ncould implement <tt>cons</tt> in terms of the two mutators, together with\na procedure <tt>get-new-pair</tt>, which returns a new pair that is not\npart of any existing list structure.  We obtain the new pair, set its\n<tt>car</tt> and <tt>cdr</tt> pointers to the designated objects, and return\nthe new pair as the result of the <tt>cons</tt>.<a name="call_footnote_Temp_351" href="#footnote_Temp_351"><sup><small>18</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_3160"></a>(define&nbsp;(cons&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(let&nbsp;((new&nbsp;(get-new-pair)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;new&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;new&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;new))<br>\n</tt><p><p>\n\n<p><a name="%_thm_3.12"></a>\n<b>Exercise 3.12.</b>&nbsp;&nbsp;<a name="%_idx_3162"></a>The following procedure for appending lists was introduced in\nsection&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.1">2.2.1</a>:<p>\n\n<p><p><tt><a name="%_idx_3164"></a>(define&nbsp;(append&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;x)&nbsp;(append&nbsp;(cdr&nbsp;x)&nbsp;y))))<br>\n</tt><p><p>\n<tt>Append</tt> forms a new list by successively <tt>cons</tt>ing the\nelements of <tt>x</tt> onto <tt>y</tt>.  The procedure <tt>append!</tt> is\nsimilar to <tt>append</tt>, but it is a mutator rather than a constructor.\nIt appends the lists by splicing them together, modifying the final\npair of <tt>x</tt> so that its <tt>cdr</tt> is now <tt>y</tt>.\n(It is an error to call <tt>append!</tt> with an empty&nbsp;<tt>x</tt>.)<p>\n\n<p><p><tt><a name="%_idx_3166"></a>(define&nbsp;(append!&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(set-cdr!&nbsp;(last-pair&nbsp;x)&nbsp;y)<br>\n&nbsp;&nbsp;x)<br>\n</tt><p><p>\nHere <tt>last-pair</tt> is a procedure that returns the last pair in its\nargument:<p>\n\n<p><p><tt><a name="%_idx_3168"></a>(define&nbsp;(last-pair&nbsp;x)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;(cdr&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(last-pair&nbsp;(cdr&nbsp;x))))<br>\n</tt><p><p>\nConsider the interaction<p>\n\n<p><p><tt>(define&nbsp;x&nbsp;(list&nbsp;\'a&nbsp;\'b))<br>\n(define&nbsp;y&nbsp;(list&nbsp;\'c&nbsp;\'d))<br>\n(define&nbsp;z&nbsp;(append&nbsp;x&nbsp;y))<br>\nz<br>\n<i>(a&nbsp;b&nbsp;c&nbsp;d)</i><br>\n(cdr&nbsp;x)<br>\n&lt;<em>response</em>&gt;<br>\n(define&nbsp;w&nbsp;(append!&nbsp;x&nbsp;y))<br>\nw<br>\n<i>(a&nbsp;b&nbsp;c&nbsp;d)</i><br>\n(cdr&nbsp;x)<br>\n&lt;<em>response</em>&gt;<br>\n</tt><p><p>\nWhat are the missing &lt;<em>response</em>&gt;s?\nDraw box-and-pointer diagrams to explain your answer.\n\n<p><p>\n\n<p><a name="%_thm_3.13"></a>\n<b>Exercise 3.13.</b>&nbsp;&nbsp;<a name="%_idx_3170"></a>Consider the following <tt>make-cycle</tt> procedure, which uses the <tt>last-pair</tt> procedure defined in exercise&nbsp;<a href="#%_thm_3.12">3.12</a>:<p>\n\n<p><p><tt><a name="%_idx_3172"></a>(define&nbsp;(make-cycle&nbsp;x)<br>\n&nbsp;&nbsp;(set-cdr!&nbsp;(last-pair&nbsp;x)&nbsp;x)<br>\n&nbsp;&nbsp;x)<br>\n</tt><p><p>\nDraw a box-and-pointer diagram that shows the structure <tt>z</tt>\ncreated by<p>\n\n<p><p><tt>(define&nbsp;z&nbsp;(make-cycle&nbsp;(list&nbsp;\'a&nbsp;\'b&nbsp;\'c)))<br>\n</tt><p><p>\nWhat happens if we try to compute <tt>(last-pair z)</tt>?\n\n<p><p>\n\n<p><a name="%_thm_3.14"></a>\n<b>Exercise 3.14.</b>&nbsp;&nbsp;The following procedure is quite useful, although obscure:<p>\n\n<p><p><tt><a name="%_idx_3174"></a>(define&nbsp;(mystery&nbsp;x)<br>\n&nbsp;&nbsp;(define&nbsp;(loop&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((temp&nbsp;(cdr&nbsp;x)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;temp&nbsp;x))))<br>\n&nbsp;&nbsp;(loop&nbsp;x&nbsp;\'()))<br>\n</tt><p><p>\n<tt>Loop</tt> uses the ``temporary\'\' variable <tt>temp</tt> to hold\nthe old value of the <tt>cdr</tt> of <tt>x</tt>, since the <tt>set-cdr!</tt>\non the next line destroys the <tt>cdr</tt>.  Explain what <tt>mystery</tt>\ndoes in general.  Suppose <tt>v</tt> is defined by <tt>(define v (list \'a\n\'b \'c \'d))</tt>. Draw the box-and-pointer diagram that represents the list\nto which <tt>v</tt> is bound.  Suppose that we now evaluate <tt>(define\nw (mystery v))</tt>. Draw box-and-pointer diagrams that show the\nstructures <tt>v</tt> and <tt>w</tt> after evaluating this expression.  What\nwould be printed as the values of <tt>v</tt> and <tt>w</tt> ?\n<p>\n\n\n<a name="%_sec_Temp_355"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_355">Sharing and identity</a></h4><p>\n\n<a name="%_idx_3176"></a><a name="%_idx_3178"></a>\n<a name="%_idx_3180"></a><a name="%_idx_3182"></a>We mentioned in section&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a> the theoretical\nissues of ``sameness\'\' and ``change\'\' raised by the introduction of\nassignment.  These issues arise in practice when individual pairs are\n<em>shared</em> among different data objects.  For example, consider the\nstructure formed by<p>\n\n\n<p><p><tt>(define&nbsp;x&nbsp;(list&nbsp;\'a&nbsp;\'b))<br>\n(define&nbsp;z1&nbsp;(cons&nbsp;x&nbsp;x))<br>\n</tt><p><p>\nAs shown in figure&nbsp;<a href="#%_fig_3.16">3.16</a>, <tt>z1</tt> is a pair whose <tt>car</tt> and <tt>cdr</tt> both point to the same pair <tt>x</tt>.  This sharing\nof <tt>x</tt> by the <tt>car</tt> and <tt>cdr</tt> of <tt>z1</tt> is a consequence\nof the straightforward way in which <tt>cons</tt> is implemented.  In\ngeneral, using <tt>cons</tt> to construct lists will result in an\ninterlinked structure of pairs in which many individual pairs are\nshared by many different structures.<p>\n\n<a name="%_fig_3.16"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-17.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.16:</b>&nbsp;&nbsp;The list <tt>z1</tt> formed by <tt>(cons x x)</tt>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_fig_3.17"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-18.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.17:</b>&nbsp;&nbsp;The list <tt>z2</tt> formed by \n<tt>(cons (list \'a \'b) (list \'a \'b))</tt>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n\nIn contrast to figure&nbsp;<a href="#%_fig_3.16">3.16</a>, figure&nbsp;<a href="#%_fig_3.17">3.17</a> shows\nthe structure created by<p>\n\n\n<p><p><tt>(define&nbsp;z2&nbsp;(cons&nbsp;(list&nbsp;\'a&nbsp;\'b)&nbsp;(list&nbsp;\'a&nbsp;\'b)))<br>\n</tt><p><p>\nIn this structure, the pairs in the two <tt>(a b)</tt> lists are\ndistinct, although the actual symbols are shared.<a name="call_footnote_Temp_356" href="#footnote_Temp_356"><sup><small>19</small></sup></a><p>\n\nWhen thought of as a list, <tt>z1</tt> and <tt>z2</tt> both represent ``the\nsame\'\' list, <tt>((a b) a b)</tt>.  In general, sharing is completely\nundetectable if we operate on lists using only <tt>cons</tt>, <tt>car</tt>,\nand <tt>cdr</tt>.  However, if we allow mutators on list structure,\nsharing becomes significant.  As an example of the difference that\nsharing can make, consider the following procedure, which modifies the\n<tt>car</tt> of the structure to which it is applied:<p>\n\n<p><p><tt>(define&nbsp;(set-to-wow!&nbsp;x)<br>\n&nbsp;&nbsp;(set-car!&nbsp;(car&nbsp;x)&nbsp;\'wow)<br>\n&nbsp;&nbsp;x)<br>\n</tt><p><p>\nEven though <tt>z1</tt> and <tt>z2</tt> are ``the same\'\' structure,\napplying <tt>set-to-wow!</tt> to them yields different results.  With\n<tt>z1</tt>, altering the <tt>car</tt> also changes the <tt>cdr</tt>, because\nin <tt>z1</tt> the <tt>car</tt> and the <tt>cdr</tt> are the same pair.  With\n<tt>z2</tt>, the <tt>car</tt> and <tt>cdr</tt> are distinct, so <tt>set-to-wow!</tt> modifies only the <tt>car</tt>:<p>\n\n<p><p><tt>z1<br>\n<i>((a&nbsp;b)&nbsp;a&nbsp;b)</i><br>\n<br>\n(set-to-wow!&nbsp;z1)<br>\n<i>((wow&nbsp;b)&nbsp;wow&nbsp;b)</i><br>\n<br>\nz2<br>\n<i>((a&nbsp;b)&nbsp;a&nbsp;b)</i><br>\n<br>\n(set-to-wow!&nbsp;z2)<br>\n<i>((wow&nbsp;b)&nbsp;a&nbsp;b)</i><br>\n</tt><p><p><p>\n\nOne way to detect sharing in list structures is to use the predicate\n<a name="%_idx_3186"></a><a name="%_idx_3188"></a><tt>eq?</tt>, which we introduced in section&nbsp;<a href="book-Z-H-16.html#%_sec_2.3.1">2.3.1</a> as a\nway to test whether two symbols are equal.  More generally, <tt>(eq?\nx y)</tt> tests whether <tt>x</tt> and <tt>y</tt> are the same object (that is,\nwhether <tt>x</tt> and <tt>y</tt> are equal as pointers).  Thus, with <tt>z1</tt> and <tt>z2</tt> as defined in figures&nbsp;<a href="#%_fig_3.16">3.16</a>\nand&nbsp;<a href="#%_fig_3.17">3.17</a>, <tt>(eq? (car&nbsp;z1) (cdr&nbsp;z1))</tt> is true and\n<tt>(eq? (car z2) (cdr z2))</tt> is false.<p>\n\n<a name="%_idx_3190"></a>As will be seen in the following sections, we can exploit sharing to\ngreatly extend the repertoire of data structures that can be\nrepresented by pairs.  On the other hand, sharing can also be\ndangerous, since modifications made to structures will also affect\nother structures that happen to share the modified parts.  The\nmutation operations <tt>set-car!</tt> and <tt>set-cdr!</tt> should be used\nwith care; unless we have a good understanding of how our data objects\nare shared, mutation can have unanticipated results.<a name="call_footnote_Temp_357" href="#footnote_Temp_357"><sup><small>20</small></sup></a><p>\n\n<p><a name="%_thm_3.15"></a>\n<b>Exercise 3.15.</b>&nbsp;&nbsp;Draw box-and-pointer diagrams to explain the effect of <tt>set-to-wow!</tt> on the structures <tt>z1</tt> and <tt>z2</tt> above.\n<p><p>\n\n<p><a name="%_thm_3.16"></a>\n<b>Exercise 3.16.</b>&nbsp;&nbsp;Ben Bitdiddle decides to write a procedure to count the number of\npairs in any list structure.  ``It\'s easy,\'\' he reasons.  ``The number\nof pairs in any structure is the number in the <tt>car</tt> plus the\nnumber in the <tt>cdr</tt> plus one more to count the current pair.\'\'\nSo Ben writes the following procedure:<p>\n\n<p><p><tt><a name="%_idx_3192"></a>(define&nbsp;(count-pairs&nbsp;x)<br>\n&nbsp;&nbsp;(if&nbsp;(not&nbsp;(pair?&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(count-pairs&nbsp;(car&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(count-pairs&nbsp;(cdr&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)))<br>\n</tt><p><p>\nShow that this procedure is not correct.  In particular, draw\nbox-and-pointer diagrams representing list structures made up of\nexactly three pairs for which Ben\'s procedure would return 3; return\n4; return 7; never return at all.\n\n<p><p>\n\n<p><a name="%_thm_3.17"></a>\n<b>Exercise 3.17.</b>&nbsp;&nbsp;Devise a correct version of the <tt>count-pairs</tt> procedure of\nexercise&nbsp;<a href="#%_thm_3.16">3.16</a> that returns the number of distinct\npairs in any structure.  (Hint: Traverse the structure, maintaining an\nauxiliary data structure that is used to keep track of which pairs\nhave already been counted.)\n<p><p>\n\n<p>\n\n<p><a name="%_thm_3.18"></a>\n<b>Exercise 3.18.</b>&nbsp;&nbsp;<a name="%_idx_3194"></a>Write a procedure that examines a list and determines whether it\ncontains a cycle, that is, whether a program that tried to find the\nend of the list by taking successive <tt>cdr</tt>s would go into an\ninfinite loop.  Exercise&nbsp;<a href="#%_thm_3.13">3.13</a> constructed such lists.\n\n<p><p>\n\n<p><a name="%_thm_3.19"></a>\n<b>Exercise 3.19.</b>&nbsp;&nbsp;Redo exercise&nbsp;<a href="#%_thm_3.18">3.18</a> using an algorithm that takes only a\nconstant amount of space.  (This requires a very clever idea.)\n<p>\n\n<a name="%_sec_Temp_363"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_363">Mutation is just assignment</a></h4><p>\n\n<a name="%_idx_3196"></a><a name="%_idx_3198"></a><a name="%_idx_3200"></a><a name="%_idx_3202"></a>\nWhen we introduced compound data, we observed in\nsection&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.3">2.1.3</a> that pairs can be represented purely in terms\nof procedures:<p>\n\n<p><p><tt><a name="%_idx_3204"></a>(define&nbsp;(cons&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;m&nbsp;\'car)&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'cdr)&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Undefined&nbsp;operation&nbsp;--&nbsp;CONS&quot;&nbsp;m))))<br>\n&nbsp;&nbsp;dispatch)<br>\n<a name="%_idx_3206"></a>(define&nbsp;(car&nbsp;z)&nbsp;(z&nbsp;\'car))<br>\n<a name="%_idx_3208"></a>(define&nbsp;(cdr&nbsp;z)&nbsp;(z&nbsp;\'cdr))<br>\n</tt><p><p>\nThe same observation is true for mutable data.  We can implement\nmutable data objects as procedures using assignment and local state.\nFor instance, we can extend the above pair implementation to handle\n<tt>set-car!</tt> and <tt>set-cdr!</tt> in a manner analogous to the way\nwe implemented bank accounts using <tt>make-account</tt> in\nsection&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:<p>\n\n<p><p><tt><a name="%_idx_3210"></a>(define&nbsp;(cons&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(define&nbsp;(set-x!&nbsp;v)&nbsp;(set!&nbsp;x&nbsp;v))<br>\n&nbsp;&nbsp;(define&nbsp;(set-y!&nbsp;v)&nbsp;(set!&nbsp;y&nbsp;v))<br>\n&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;m&nbsp;\'car)&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'cdr)&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'set-car!)&nbsp;set-x!)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'set-cdr!)&nbsp;set-y!)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Undefined&nbsp;operation&nbsp;--&nbsp;CONS&quot;&nbsp;m))))<br>\n&nbsp;&nbsp;dispatch)<br>\n<a name="%_idx_3212"></a>(define&nbsp;(car&nbsp;z)&nbsp;(z&nbsp;\'car))<br>\n<a name="%_idx_3214"></a>(define&nbsp;(cdr&nbsp;z)&nbsp;(z&nbsp;\'cdr))<br>\n<a name="%_idx_3216"></a>(define&nbsp;(set-car!&nbsp;z&nbsp;new-value)<br>\n&nbsp;&nbsp;((z&nbsp;\'set-car!)&nbsp;new-value)<br>\n&nbsp;&nbsp;z)<br>\n<a name="%_idx_3218"></a>(define&nbsp;(set-cdr!&nbsp;z&nbsp;new-value)<br>\n&nbsp;&nbsp;((z&nbsp;\'set-cdr!)&nbsp;new-value)<br>\n&nbsp;&nbsp;z)<br>\n</tt><p><p><p>\n\nAssignment is all that is needed, theoretically, to account for the\nbehavior of mutable data.  As soon as we admit <tt>set!</tt> to our\nlanguage, we raise all the issues, not only of assignment, but of\nmutable data in general.<a name="call_footnote_Temp_364" href="#footnote_Temp_364"><sup><small>21</small></sup></a><p>\n\n<p><a name="%_thm_3.20"></a>\n<b>Exercise 3.20.</b>&nbsp;&nbsp;Draw environment diagrams to illustrate the evaluation of the sequence\nof expressions<p>\n\n<p><p><tt>(define&nbsp;x&nbsp;(cons&nbsp;1&nbsp;2))<br>\n(define&nbsp;z&nbsp;(cons&nbsp;x&nbsp;x))<br>\n(set-car!&nbsp;(cdr&nbsp;z)&nbsp;17)<br>\n(car&nbsp;x)<br>\n<i>17</i><br>\n</tt><p><p>\nusing the procedural implementation of pairs given above.  (Compare\nexercise&nbsp;<a href="book-Z-H-21.html#%_thm_3.11">3.11</a>.)\n<p>\n\n<a name="%_sec_3.3.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.3.2">3.3.2&nbsp;&nbsp;Representing Queues</a></h3><p>\n\n\n<a name="%_idx_3220"></a>\nThe mutators <tt>set-car!</tt> and <tt>set-cdr!</tt> enable us to use\npairs to construct data structures that cannot be built with <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> alone.  This section shows how to use\npairs to represent a data structure called a queue.  Section&nbsp;<a href="#%_sec_3.3.3">3.3.3</a>\nwill show how to represent data structures called tables.<p>\n\nA <em>queue</em> is a sequence in which items are inserted at one end\n(called the <a name="%_idx_3222"></a><em>rear</em> of the queue) and deleted from the other end\n(the <a name="%_idx_3224"></a><em>front</em>).  Figure&nbsp;<a href="#%_fig_3.18">3.18</a> shows an initially empty\nqueue in which the items <tt>a</tt> and <tt>b</tt> are inserted.  Then <tt>a</tt> is removed, <tt>c</tt> and <tt>d</tt> are inserted, and <tt>b</tt> is\nremoved.  Because items are always removed in the order in which they\nare inserted, a queue is sometimes called a <a name="%_idx_3226"></a><em>FIFO</em> (first in,\nfirst out) buffer.<p>\n\n<a name="%_fig_3.18"></a><p><div align=left><table width=100%><tr><td><table border=0><tr><td valign=top >Operation </td><td valign=top >Resulting Queue  </td></tr>\n<tr><td valign=top ><tt>(define q (make-queue))</tt> </td><td valign=top ></td></tr>\n<tr><td valign=top ><tt>(insert-queue! q \'a)</tt> </td><td valign=top ><tt>a</tt></td></tr>\n<tr><td valign=top ><tt>(insert-queue! q \'b)</tt> </td><td valign=top ><tt>a b</tt></td></tr>\n<tr><td valign=top ><tt>(delete-queue! q)</tt> </td><td valign=top ><tt>b</tt></td></tr>\n<tr><td valign=top ><tt>(insert-queue! q \'c)</tt> </td><td valign=top ><tt>b c</tt></td></tr>\n<tr><td valign=top ><tt>(insert-queue! q \'d)</tt> </td><td valign=top ><tt>b c d</tt></td></tr>\n<tr><td valign=top ><tt>(delete-queue! q)</tt> </td><td valign=top ><tt>c d</tt>\n</td></tr></table>\n</td></tr><caption align=bottom><div align=left><b>Figure 3.18:</b>&nbsp;&nbsp;Queue operations.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_idx_3228"></a><a name="%_idx_3230"></a>In terms of data abstraction, we can regard a queue as defined by the\nfollowing set of operations:\n<p><ul>\n<li>a constructor:<br>\n<a name="%_idx_3232"></a><tt>(make-queue)</tt><br>\nreturns an empty queue (a queue containing no items).<p>\n\n<li>two selectors:<br>\n<a name="%_idx_3234"></a><tt>(empty-queue? &lt;<em>queue</em>&gt;)</tt><br>\ntests if the queue is empty.<br>\n\n<a name="%_idx_3236"></a><tt>(front-queue &lt;<em>queue</em>&gt;)</tt><br>\nreturns the object at the front of\nthe queue, signaling an error if the queue is empty; it does not\nmodify the queue.<p>\n\n<li>two mutators:<br>\n<a name="%_idx_3238"></a><tt>(insert-queue! &lt;<em>queue</em>&gt; &lt;<em>item</em>&gt;)</tt><br>\ninserts the item at the rear of the queue and returns the modified\nqueue as its value.<br>\n\n<a name="%_idx_3240"></a><tt>(delete-queue! &lt;<em>queue</em>&gt;)</tt><br>\nremoves the item at the\nfront of the queue and returns the modified queue as its value,\nsignaling an error if the queue is empty before the deletion.\n</ul><p><p>\n\nBecause a queue is a sequence of items, we could certainly represent\nit as an ordinary list; the front of the queue would be the <tt>car</tt>\nof the list, inserting an item in the queue would amount to appending\na new element at the end of the list, and deleting an item from the\nqueue would just be taking the <tt>cdr</tt> of the list.  However, this\nrepresentation is inefficient, because in order to insert an item we\nmust scan the list until we reach the end.  Since the only method we\nhave for scanning a list is by successive <tt>cdr</tt> operations, this\nscanning requires <img src="book-Z-G-D-3.gif" border="0">(<em>n</em>) steps for a list of <em>n</em> items.  A simple\nmodification to the list representation overcomes this disadvantage by\nallowing the queue operations to be implemented so that they require\n<img src="book-Z-G-D-3.gif" border="0">(1) steps; that is, so that the number of steps\nneeded is independent of the length of the queue.<p>\n\nThe difficulty with the list representation arises from the need to\nscan to find the end of the list.  The reason we need to scan is that,\nalthough the standard way of representing a list as a chain of pairs\nreadily provides us with a pointer to the beginning of the list, it\ngives us no easily accessible pointer to the end.  The modification\nthat avoids the drawback is to represent the queue as a list, together\nwith an additional pointer that indicates the final pair in the list.\nThat way, when we go to insert an item, we can consult the rear\npointer and so avoid scanning the list.<p>\n\nA queue is represented, then, as a pair of pointers, <tt>front-ptr</tt>\nand <tt>rear-ptr</tt>, which indicate, respectively, the first and last\npairs in an ordinary list.  Since we would like the queue to be an\nidentifiable object, we can use <tt>cons</tt> to combine the two\npointers.  Thus, the queue itself will be the <tt>cons</tt> of the two\npointers.  Figure&nbsp;<a href="#%_fig_3.19">3.19</a> illustrates this\nrepresentation.<p>\n\n<a name="%_fig_3.19"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-19.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.19:</b>&nbsp;&nbsp;Implementation of a queue as a list with front and rear\npointers.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nTo define the queue operations we use the following procedures, which\nenable us to select and to modify the front and rear pointers of a\nqueue:<p>\n\n<p><p><tt><a name="%_idx_3242"></a>(define&nbsp;(front-ptr&nbsp;queue)&nbsp;(car&nbsp;queue))<br>\n<a name="%_idx_3244"></a>(define&nbsp;(rear-ptr&nbsp;queue)&nbsp;(cdr&nbsp;queue))<br>\n<a name="%_idx_3246"></a>(define&nbsp;(set-front-ptr!&nbsp;queue&nbsp;item)&nbsp;(set-car!&nbsp;queue&nbsp;item))<br>\n<a name="%_idx_3248"></a>(define&nbsp;(set-rear-ptr!&nbsp;queue&nbsp;item)&nbsp;(set-cdr!&nbsp;queue&nbsp;item))<br>\n</tt><p><p><p>\n\nNow we can implement the actual queue operations.  We will consider a\nqueue to be empty if its front pointer is the empty list:<p>\n\n\n<p><p><tt><a name="%_idx_3250"></a>(define&nbsp;(empty-queue?&nbsp;queue)&nbsp;(null?&nbsp;(front-ptr&nbsp;queue)))<br>\n</tt><p><p>\nThe <tt>make-queue</tt> constructor returns, as an initially empty queue,\na pair whose <tt>car</tt> and <tt>cdr</tt> are both the empty list:<p>\n\n\n<p><p><tt><a name="%_idx_3252"></a>(define&nbsp;(make-queue)&nbsp;(cons&nbsp;\'()&nbsp;\'()))<br>\n</tt><p><p>\nTo select the item at the front of the queue, we return the <tt>car</tt>\nof the pair indicated by the front pointer:<p>\n\n\n<p><p><tt><a name="%_idx_3254"></a>(define&nbsp;(front-queue&nbsp;queue)<br>\n&nbsp;&nbsp;(if&nbsp;(empty-queue?&nbsp;queue)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;FRONT&nbsp;called&nbsp;with&nbsp;an&nbsp;empty&nbsp;queue&quot;&nbsp;queue)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;(front-ptr&nbsp;queue))))<br>\n</tt><p><p><p>\n\n\nTo insert an item in a queue, we follow the method whose result is\nindicated in figure&nbsp;<a href="#%_fig_3.20">3.20</a>.  We first create a new\npair whose <tt>car</tt> is the item to be inserted and whose <tt>cdr</tt> is\nthe empty list.  If the queue was initially empty, we set the front and\nrear pointers of the queue to this new pair.  Otherwise, we modify the\nfinal pair in the queue to point to the new pair, and also set the\nrear pointer to the new pair.<p>\n\n<a name="%_fig_3.20"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-20.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.20:</b>&nbsp;&nbsp;Result of using <tt>(insert-queue! q \'d)</tt> \non the queue of figure&nbsp;<a href="#%_fig_3.19">3.19</a>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n\n<p><p><tt><a name="%_idx_3256"></a>(define&nbsp;(insert-queue!&nbsp;queue&nbsp;item)<br>\n&nbsp;&nbsp;(let&nbsp;((new-pair&nbsp;(cons&nbsp;item&nbsp;\'())))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((empty-queue?&nbsp;queue)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-front-ptr!&nbsp;queue&nbsp;new-pair)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-rear-ptr!&nbsp;queue&nbsp;new-pair)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;(rear-ptr&nbsp;queue)&nbsp;new-pair)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-rear-ptr!&nbsp;queue&nbsp;new-pair)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue))))&nbsp;<br>\n</tt><p><p><p>\n\nTo delete the item at the front of the queue, we merely modify the\nfront pointer so that it now points at the second item in the queue,\nwhich can be found by following the <tt>cdr</tt> pointer of the first\nitem (see figure&nbsp;<a href="#%_fig_3.21">3.21</a>):<a name="call_footnote_Temp_366" href="#footnote_Temp_366"><sup><small>22</small></sup></a><p>\n\n<a name="%_fig_3.21"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-21.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.21:</b>&nbsp;&nbsp;Result of using <tt>(delete-queue! q)</tt> on \nthe queue of figure&nbsp;<a href="#%_fig_3.20">3.20</a>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<p><p><tt><a name="%_idx_3258"></a>(define&nbsp;(delete-queue!&nbsp;queue)<br>\n&nbsp;&nbsp;(cond&nbsp;((empty-queue?&nbsp;queue)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;DELETE!&nbsp;called&nbsp;with&nbsp;an&nbsp;empty&nbsp;queue&quot;&nbsp;queue))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-front-ptr!&nbsp;queue&nbsp;(cdr&nbsp;(front-ptr&nbsp;queue)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue)))&nbsp;<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_3.21"></a>\n<b>Exercise 3.21.</b>&nbsp;&nbsp;Ben Bitdiddle decides to test the queue implementation described\nabove.  He types in the procedures to the Lisp interpreter and\nproceeds to try them out:<p>\n\n<p><p><tt>(define&nbsp;q1&nbsp;(make-queue))<br>\n(insert-queue!&nbsp;q1&nbsp;\'a)<br>\n<i>((a)&nbsp;a)</i><br>\n(insert-queue!&nbsp;q1&nbsp;\'b)<br>\n<i>((a&nbsp;b)&nbsp;b)</i><br>\n(delete-queue!&nbsp;q1)<br>\n<i>((b)&nbsp;b)</i><br>\n(delete-queue!&nbsp;q1)<br>\n<i>(()&nbsp;b)</i><br>\n</tt><p><p>\n``It\'s all wrong!\'\' he complains.  ``The interpreter\'s response shows\nthat the last item is inserted into the queue twice.  And when I\ndelete both items, the second <tt>b</tt> is still there, so the queue\nisn\'t empty, even though it\'s supposed to be.\'\'  Eva Lu Ator suggests\nthat Ben has misunderstood what is happening.  ``It\'s not that the\nitems are going into the queue twice,\'\' she explains.  ``It\'s just\nthat the standard Lisp printer doesn\'t know how to make sense of the\nqueue representation.  If you want to see the queue printed correctly,\nyou\'ll have to define your own print procedure for queues.\'\' Explain\nwhat Eva Lu is talking about.  In particular, show why Ben\'s examples\nproduce the printed results that they do.  Define a procedure <a name="%_idx_3260"></a><tt>print-queue</tt> that takes a queue as input and prints the sequence of\nitems in the queue.\n<p><p>\n\n<p><a name="%_thm_3.22"></a>\n<b>Exercise 3.22.</b>&nbsp;&nbsp;<a name="%_idx_3262"></a>Instead of representing a queue as a pair of pointers, we can build a\nqueue as a procedure with local state.  The local state will consist\nof pointers to the beginning and the end of an ordinary list.  Thus,\nthe <tt>make-queue</tt> procedure will have the form<p>\n\n<p><p><tt>(define&nbsp;(make-queue)<br>\n&nbsp;&nbsp;(let&nbsp;((front-ptr&nbsp;<tt>...</tt>)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rear-ptr&nbsp;<tt>...</tt>))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>definitions&nbsp;of&nbsp;internal&nbsp;procedures</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)&nbsp;<tt>...</tt>)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dispatch))<br>\n</tt><p><p>\nComplete the definition of <tt>make-queue</tt> and provide\nimplementations of the queue operations using this representation.\n<p><p>\n\n<p><a name="%_thm_3.23"></a>\n<b>Exercise 3.23.</b>&nbsp;&nbsp;<a name="%_idx_3264"></a><a name="%_idx_3266"></a>A <em>deque</em> (``double-ended queue\'\') is a sequence in which items\ncan be inserted and deleted at either the front or the rear.\nOperations on deques are the constructor <tt>make-deque</tt>, the predicate <tt>empty-deque?</tt>, selectors <tt>front-deque</tt> and <tt>rear-deque</tt>, and mutators <tt>front-insert-deque!</tt>, <tt>rear-insert-deque!</tt>, <tt>front-delete-deque!</tt>, and <tt>rear-delete-deque!</tt>.  Show how to represent deques using pairs, and\ngive implementations of the operations.<a name="call_footnote_Temp_370" href="#footnote_Temp_370"><sup><small>23</small></sup></a>\nAll operations should be accomplished in <img src="book-Z-G-D-3.gif" border="0">(1) steps.\n<p>\n\n<a name="%_sec_3.3.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.3.3">3.3.3&nbsp;&nbsp;Representing Tables</a></h3><p>\n\n\n<a name="%_idx_3268"></a>\n<a name="%_idx_3270"></a>When we studied various ways of representing sets in chapter&nbsp;2, we\nmentioned in section&nbsp;<a href="book-Z-H-16.html#%_sec_2.3.3">2.3.3</a> the task of\nmaintaining a table of records indexed by identifying keys.  In the\nimplementation of data-directed programming in\nsection&nbsp;<a href="book-Z-H-17.html#%_sec_2.4.3">2.4.3</a>, we made extensive use of\ntwo-dimensional tables, in which information is stored and retrieved\nusing two keys.  Here we see how to build tables as mutable list\nstructures.<p>\n\n<a name="%_idx_3272"></a>We first consider a one-dimensional table, in which each value is\nstored under a single key.  We implement the table as a list of\nrecords, each of which is implemented as a pair consisting of a key\nand the associated value. The records are glued together to form a\nlist by pairs whose <tt>car</tt>s point to successive records.  These\ngluing pairs are called the <a name="%_idx_3274"></a><em>backbone</em> of the table.  In order to\nhave a place that we can change when we add a new record to the table,\nwe build the table as a <a name="%_idx_3276"></a><a name="%_idx_3278"></a><em>headed list</em>.  A headed list has a\nspecial backbone pair at the beginning, which holds a dummy\n``record\'\' -- in this case the arbitrarily chosen symbol <tt>*table*</tt>.\nFigure&nbsp;<a href="#%_fig_3.22">3.22</a> shows the box-and-pointer diagram for the table<p>\n\n<p><p><tt>a:&nbsp;&nbsp;1<br>\nb:&nbsp;&nbsp;2<br>\nc:&nbsp;&nbsp;3<br>\n</tt><p><p><p>\n\n<a name="%_fig_3.22"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-22.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.22:</b>&nbsp;&nbsp;A table represented as a headed list.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nTo extract information from a table we use the <tt>lookup</tt>\nprocedure, which takes a key as argument and returns the associated\nvalue (or false if there is no value stored under that key).\n<tt>Lookup</tt> is defined in terms of the <tt>assoc</tt> operation, which\nexpects a key and a list of records as arguments.  Note that <tt>assoc</tt> never sees the dummy record.  <tt>Assoc</tt> returns the record\nthat has the given key as its <tt>car</tt>.<a name="call_footnote_Temp_371" href="#footnote_Temp_371"><sup><small>24</small></sup></a>\n<tt>Lookup</tt> then\nchecks to see that the resulting record returned by <tt>assoc</tt> is not\nfalse, and returns the value (the <tt>cdr</tt>) of the record.<p>\n\n<p><p><tt><a name="%_idx_3280"></a>(define&nbsp;(lookup&nbsp;key&nbsp;table)<br>\n&nbsp;&nbsp;(let&nbsp;((record&nbsp;(assoc&nbsp;key&nbsp;(cdr&nbsp;table))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;record<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;record)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false)))<br>\n<a name="%_idx_3282"></a>(define&nbsp;(assoc&nbsp;key&nbsp;records)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;records)&nbsp;false)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal?&nbsp;key&nbsp;(caar&nbsp;records))&nbsp;(car&nbsp;records))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(assoc&nbsp;key&nbsp;(cdr&nbsp;records)))))<br>\n</tt><p><p><p>\n\nTo insert a value in a table under a specified key, we first use <tt>assoc</tt> to see if there is already a record in the table with this key.\nIf not, we form a new record by <tt>cons</tt>ing the key with the value,\nand insert this at the head of the table\'s list of records, after the\ndummy record.  If there already is a record with this key, we set the\n<tt>cdr</tt> of this record to the designated new value.  The header of\nthe table provides us with a fixed location to modify in order to\ninsert the new record.<a name="call_footnote_Temp_372" href="#footnote_Temp_372"><sup><small>25</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_3284"></a>(define&nbsp;(insert!&nbsp;key&nbsp;value&nbsp;table)<br>\n&nbsp;&nbsp;(let&nbsp;((record&nbsp;(assoc&nbsp;key&nbsp;(cdr&nbsp;table))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;record<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;record&nbsp;value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;table<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(cons&nbsp;key&nbsp;value)&nbsp;(cdr&nbsp;table)))))<br>\n&nbsp;&nbsp;\'ok)<br>\n</tt><p><p><p>\n\nTo construct a new table, we simply create a list containing the\nsymbol <tt>*table*</tt>:<p>\n\n<p><p><tt><a name="%_idx_3286"></a>(define&nbsp;(make-table)<br>\n&nbsp;&nbsp;(list&nbsp;\'*table*))<br>\n</tt><p><p>\n\n<a name="%_sec_Temp_373"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_373">Two-dimensional tables</a></h4><p>\n\n<a name="%_idx_3288"></a>\nIn a two-dimensional table, each value is indexed by two keys.  We can\nconstruct such a table as a one-dimensional table in which each key\nidentifies a subtable.\nFigure&nbsp;<a href="#%_fig_3.23">3.23</a> shows the box-and-pointer diagram for the table\n<p><p><tt>math:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;+:&nbsp;&nbsp;43<br>\n&nbsp;&nbsp;&nbsp;&nbsp;-:&nbsp;&nbsp;45<br>\n&nbsp;&nbsp;&nbsp;&nbsp;*:&nbsp;&nbsp;42<br>\nletters:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;a:&nbsp;&nbsp;97<br>\n&nbsp;&nbsp;&nbsp;&nbsp;b:&nbsp;&nbsp;98<br>\n</tt><p><p>\nwhich has two subtables.  (The subtables don\'t need a\nspecial header symbol, since the key that identifies the subtable\nserves this purpose.)<p>\n\n<a name="%_fig_3.23"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-23.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.23:</b>&nbsp;&nbsp;A two-dimensional table.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nWhen we look up an item, we use the first key\nto identify the correct subtable.  Then we use the second key to\nidentify the record within the subtable.<p>\n\n<p><p><tt><a name="%_idx_3290"></a>(define&nbsp;(lookup&nbsp;key-1&nbsp;key-2&nbsp;table)<br>\n&nbsp;&nbsp;(let&nbsp;((subtable&nbsp;(assoc&nbsp;key-1&nbsp;(cdr&nbsp;table))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;subtable<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((record&nbsp;(assoc&nbsp;key-2&nbsp;(cdr&nbsp;subtable))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;record<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;record)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false)))<br>\n</tt><p><p><p>\n\nTo insert a new item under a pair of keys, we use <tt>assoc</tt> to see if\nthere is a subtable stored under the first key.  If not, we build a\nnew subtable containing the single record (<tt>key-2</tt>, <tt>value</tt>)\nand insert it into the table under the first key.  If a subtable\nalready exists for the first key, we insert the new record into this\nsubtable, using the insertion method for one-dimensional tables\ndescribed above:<p>\n\n<p><p><tt><a name="%_idx_3292"></a>(define&nbsp;(insert!&nbsp;key-1&nbsp;key-2&nbsp;value&nbsp;table)<br>\n&nbsp;&nbsp;(let&nbsp;((subtable&nbsp;(assoc&nbsp;key-1&nbsp;(cdr&nbsp;table))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;subtable<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((record&nbsp;(assoc&nbsp;key-2&nbsp;(cdr&nbsp;subtable))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;record<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;record&nbsp;value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;subtable<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(cons&nbsp;key-2&nbsp;value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;subtable)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;table<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(list&nbsp;key-1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;key-2&nbsp;value))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;table)))))<br>\n&nbsp;&nbsp;\'ok)<br>\n</tt><p><p>\n\n<a name="%_sec_Temp_374"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_374">Creating local tables</a></h4><p>\n\n<a name="%_idx_3294"></a>\nThe <tt>lookup</tt> and <tt>insert!</tt> operations defined above take the\ntable as an argument.  This enables us to use programs that access\nmore than one table.  Another way to deal with multiple tables is to\nhave separate <tt>lookup</tt> and <tt>insert!</tt> procedures for each\ntable.  We can do this by representing a table procedurally, as an\nobject that maintains an internal table as part of its local state.\nWhen sent an appropriate message, this ``table object\'\' supplies the\nprocedure with which to operate on the internal table.  Here is a\ngenerator for two-dimensional tables represented in this fashion:<p>\n\n<p><p><tt><a name="%_idx_3296"></a>(define&nbsp;(make-table)<br>\n&nbsp;&nbsp;(let&nbsp;((local-table&nbsp;(list&nbsp;\'*table*)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(lookup&nbsp;key-1&nbsp;key-2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((subtable&nbsp;(assoc&nbsp;key-1&nbsp;(cdr&nbsp;local-table))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;subtable<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((record&nbsp;(assoc&nbsp;key-2&nbsp;(cdr&nbsp;subtable))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;record<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;record)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(insert!&nbsp;key-1&nbsp;key-2&nbsp;value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((subtable&nbsp;(assoc&nbsp;key-1&nbsp;(cdr&nbsp;local-table))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;subtable<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((record&nbsp;(assoc&nbsp;key-2&nbsp;(cdr&nbsp;subtable))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;record<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;record&nbsp;value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;subtable<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(cons&nbsp;key-2&nbsp;value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;subtable)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;local-table<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(list&nbsp;key-1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;key-2&nbsp;value))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;local-table)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'ok)&nbsp;&nbsp;&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;m&nbsp;\'lookup-proc)&nbsp;lookup)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'insert-proc!)&nbsp;insert!)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;operation&nbsp;--&nbsp;TABLE&quot;&nbsp;m))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dispatch))<br>\n</tt><p><p><p>\n\nUsing <tt>make-table</tt>, we could implement the <tt>get</tt> and <tt>put</tt>\noperations used in section&nbsp;<a href="book-Z-H-17.html#%_sec_2.4.3">2.4.3</a> for data-directed\nprogramming, as follows:<p>\n\n<p><p><tt><a name="%_idx_3298"></a>(define&nbsp;operation-table&nbsp;(make-table))<br>\n<a name="%_idx_3300"></a>(define&nbsp;get&nbsp;(operation-table&nbsp;\'lookup-proc))<br>\n<a name="%_idx_3302"></a>(define&nbsp;put&nbsp;(operation-table&nbsp;\'insert-proc!))<br>\n</tt><p><p>\n<tt>Get</tt> takes as arguments two keys, and <tt>put</tt> takes\nas arguments two keys and a value.  Both operations access the same\nlocal table, which is encapsulated within the object created by the\ncall to <tt>make-table</tt>.\n\n\n<p><a name="%_thm_3.24"></a>\n<b>Exercise 3.24.</b>&nbsp;&nbsp;<a name="%_idx_3304"></a><a name="%_idx_3306"></a>In the table implementations above, the keys are tested for equality\nusing <tt>equal?</tt> (called by <tt>assoc</tt>).  This is not always the appropriate test.  For\ninstance, we might have a table with numeric keys in which we don\'t\nneed an exact match to the number we\'re looking up,\nbut only a number within some tolerance of it.\nDesign a table constructor <tt>make-table</tt> that takes as an argument a <tt>same-key?</tt> procedure\nthat will be used to test ``equality\'\' of keys.  <tt>Make-table</tt> should\nreturn a <tt>dispatch</tt> procedure that can be used to access\nappropriate <tt>lookup</tt> and <tt>insert!</tt> procedures for a local\ntable.\n\n<p><p>\n\n<p><a name="%_thm_3.25"></a>\n<b>Exercise 3.25.</b>&nbsp;&nbsp;<a name="%_idx_3308"></a>Generalizing one- and two-dimensional tables, show how to implement a\ntable in which values are stored under an arbitrary number of keys and\ndifferent values may be stored under different numbers of keys.  The\n<tt>lookup</tt> and <tt>insert!</tt> procedures should take as input a list\nof keys used to access the table.\n<p><p>\n\n<p><a name="%_thm_3.26"></a>\n<b>Exercise 3.26.</b>&nbsp;&nbsp;<a name="%_idx_3310"></a><a name="%_idx_3312"></a>To search a table as implemented above, one needs to scan through the\nlist of records.  This is basically the unordered list representation of\nsection&nbsp;<a href="book-Z-H-16.html#%_sec_2.3.3">2.3.3</a>.  For large tables, it may be more\nefficient to structure the table in a different manner.  Describe a\ntable implementation where the (key, value) records are organized\nusing a binary tree, assuming that keys can be ordered in some way\n(e.g., numerically or alphabetically).  (Compare\nexercise&nbsp;<a href="book-Z-H-16.html#%_thm_2.66">2.66</a> of chapter&nbsp;2.)\n<p><p>\n\n\n<p><a name="%_thm_3.27"></a>\n<b>Exercise 3.27.</b>&nbsp;&nbsp;<a name="%_idx_3314"></a><a name="%_idx_3316"></a><a name="%_idx_3318"></a><a name="%_idx_3320"></a><em>Memoization</em> (also called <em>tabulation</em>) is a technique that\nenables a procedure to record, in a local table, values that have\npreviously been computed.  This technique can make a vast difference\nin the performance of a program.  A memoized procedure maintains a\ntable in which values of previous calls are stored\nusing as keys the arguments that produced the values.  When the\nmemoized procedure is asked to compute a value, it first checks the\ntable to see if the value is already there and, if so, just returns\nthat value.  Otherwise, it computes the new value in the ordinary way\nand stores this in the table.  As an example of memoization, recall\nfrom section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a> the exponential process for\ncomputing Fibonacci numbers:<p>\n\n\n<p><p><tt><a name="%_idx_3322"></a>(define&nbsp;(fib&nbsp;n)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;n&nbsp;0)&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;n&nbsp;1)&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(+&nbsp;(fib&nbsp;(-&nbsp;n&nbsp;1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fib&nbsp;(-&nbsp;n&nbsp;2))))))<br>\n</tt><p><p>\nThe memoized version of the same procedure is<p>\n\n\n<p><p><tt><a name="%_idx_3324"></a>(define&nbsp;memo-fib<br>\n&nbsp;&nbsp;(memoize&nbsp;(lambda&nbsp;(n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((=&nbsp;n&nbsp;0)&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;n&nbsp;1)&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(+&nbsp;(memo-fib&nbsp;(-&nbsp;n&nbsp;1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(memo-fib&nbsp;(-&nbsp;n&nbsp;2))))))))<br>\n</tt><p><p>\nwhere the memoizer is defined as\n<p><p><tt><a name="%_idx_3326"></a>(define&nbsp;(memoize&nbsp;f)<br>\n&nbsp;&nbsp;(let&nbsp;((table&nbsp;(make-table)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((previously-computed-result&nbsp;(lookup&nbsp;x&nbsp;table)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;previously-computed-result<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((result&nbsp;(f&nbsp;x)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(insert!&nbsp;x&nbsp;result&nbsp;table)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result))))))<br>\n</tt><p><p>\nDraw an environment diagram to analyze the computation of <tt>(memo-fib 3)</tt>.  Explain why <tt>memo-fib</tt> computes the <em>n</em>th\nFibonacci number in a number of steps proportional to <em>n</em>.\nWould the scheme still\nwork if we had simply defined <tt>memo-fib</tt> to be <tt>(memoize\nfib)</tt>?\n\n<p>\n\n<a name="%_sec_3.3.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.3.4">3.3.4&nbsp;&nbsp;A Simulator for Digital Circuits</a></h3><p>\n\n\n<a name="%_idx_3328"></a>\nDesigning complex digital systems, such as computers, is an important\nengineering activity.  Digital systems are constructed by\ninterconnecting simple elements.  Although the behavior of these\nindividual elements is simple, networks of them can have very complex\nbehavior.  Computer simulation of proposed circuit designs is an\nimportant tool used by digital systems engineers.  In this section we\ndesign a system for performing digital logic simulations.  This system\ntypifies a kind of program called an <a name="%_idx_3330"></a><a name="%_idx_3332"></a><em>event-driven simulation</em>, in\nwhich actions (``events\'\') trigger further events that happen at a\nlater time, which in turn trigger more events, and so so.<p>\n\n\nOur computational model of a circuit will be composed of objects that\ncorrespond to the elementary components from which the circuit is\nconstructed.  There are <a name="%_idx_3334"></a><em>wires</em>, which carry <a name="%_idx_3336"></a><a name="%_idx_3338"></a><em>digital signals</em>.  A\ndigital signal may at any moment have only one of two possible values,\n0 and 1.  There are also various types of digital <a name="%_idx_3340"></a><em>function\nboxes</em>, which connect wires carrying input signals to other output\nwires.  Such boxes produce output signals computed from their input\nsignals.  The output signal is <a name="%_idx_3342"></a>delayed by a time that depends on the\ntype of the function box.  For example, an <a name="%_idx_3344"></a><em>inverter</em> is a\nprimitive function box that inverts its input.  If the\ninput signal to an inverter changes to 0, then one inverter-delay\nlater the inverter will change its output signal to 1.  If the input\nsignal to an inverter changes to 1, then one inverter-delay later the\ninverter will change its output signal to 0.  We draw an inverter\nsymbolically as in figure&nbsp;<a href="#%_fig_3.24">3.24</a>.  An <a name="%_idx_3346"></a><em>and-gate</em>,\nalso shown in figure&nbsp;<a href="#%_fig_3.24">3.24</a>, is a primitive function\nbox with two inputs and one output.  It drives its output signal to a\nvalue that is the <a name="%_idx_3348"></a><em>logical and</em> of the inputs.  That is, if both\nof its input signals become&nbsp;1, then one and-gate-delay time later the\nand-gate will force its output signal to be 1; otherwise the output\nwill be 0.  An <a name="%_idx_3350"></a><em>or-gate</em> is a similar two-input primitive function\nbox that drives its output signal to a value that is the <a name="%_idx_3352"></a><em>logical\nor</em> of the inputs.  That is, the output will become 1 if at least one\nof the input signals is 1; otherwise the output will become 0.<p>\n\n<a name="%_fig_3.24"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-24.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.24:</b>&nbsp;&nbsp;Primitive functions in the digital logic simulator.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nWe can connect primitive functions together to construct more complex\nfunctions.  To accomplish this we wire the outputs of some\nfunction boxes to the inputs of other function boxes.  For example,\nthe <a name="%_idx_3354"></a><a name="%_idx_3356"></a><em>half-adder</em> circuit shown in figure&nbsp;<a href="#%_fig_3.25">3.25</a> consists of an\nor-gate, two and-gates, and an inverter.  It takes two input signals,\nA and B, and has two output signals, S and C.  S will become 1\nwhenever precisely one of A and B is&nbsp;1, and C will become 1 whenever A\nand B are both 1.  We can see from the figure that, because of the\ndelays involved, the outputs may be generated at different times.\nMany of the difficulties in the design of digital circuits arise from\nthis fact.<p>\n\n<a name="%_fig_3.25"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-25.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.25:</b>&nbsp;&nbsp;A half-adder circuit.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nWe will now build a program for modeling the digital logic circuits we\nwish to study.  The program will construct computational objects\nmodeling the wires, which will ``hold\'\' the signals.  Function boxes\nwill be modeled by procedures that enforce the correct relationships\namong the signals.<p>\n\n<a name="%_idx_3358"></a>One basic element of our simulation will be a procedure <tt>make-wire</tt>, which constructs wires.  For example, we can construct six\nwires as follows:<p>\n\n<p><p><tt>(define&nbsp;a&nbsp;(make-wire))<br>\n(define&nbsp;b&nbsp;(make-wire))<br>\n(define&nbsp;c&nbsp;(make-wire))<br>\n<br>\n(define&nbsp;d&nbsp;(make-wire))<br>\n(define&nbsp;e&nbsp;(make-wire))<br>\n(define&nbsp;s&nbsp;(make-wire))<br>\n</tt><p><p>\nWe attach a function box to a set of wires by calling a procedure that\nconstructs that kind of box.  The arguments to the constructor\nprocedure are the wires to be attached to the box.  For example, given\nthat we can construct and-gates, or-gates, and inverters, we can wire\ntogether the half-adder shown in figure&nbsp;<a href="#%_fig_3.25">3.25</a>:<p>\n\n<p><p><tt>(or-gate&nbsp;a&nbsp;b&nbsp;d)<br>\n<i>ok</i><br>\n<br>\n(and-gate&nbsp;a&nbsp;b&nbsp;c)<br>\n<i>ok</i><br>\n<br>\n(inverter&nbsp;c&nbsp;e)<br>\n<i>ok</i><br>\n<br>\n(and-gate&nbsp;d&nbsp;e&nbsp;s)<br>\n<i>ok</i><br>\n</tt><p><p><p>\n\nBetter yet, we can explicitly name this operation by defining a procedure <tt>half-adder</tt> that constructs this circuit, given the four\nexternal wires to be attached to the half-adder:<p>\n\n<p><p><tt><a name="%_idx_3360"></a>(define&nbsp;(half-adder&nbsp;a&nbsp;b&nbsp;s&nbsp;c)<br>\n&nbsp;&nbsp;(let&nbsp;((d&nbsp;(make-wire))&nbsp;(e&nbsp;(make-wire)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(or-gate&nbsp;a&nbsp;b&nbsp;d)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(and-gate&nbsp;a&nbsp;b&nbsp;c)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(inverter&nbsp;c&nbsp;e)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(and-gate&nbsp;d&nbsp;e&nbsp;s)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\'ok))<br>\n</tt><p><p>\nThe advantage of making this definition is that we can use\n<tt>half-adder</tt> itself as a building block in creating more complex\ncircuits.  Figure&nbsp;<a href="#%_fig_3.26">3.26</a>, for example, shows a <a name="%_idx_3362"></a><a name="%_idx_3364"></a><em>full-adder</em> composed of two half-adders and an or-gate.<a name="call_footnote_Temp_379" href="#footnote_Temp_379"><sup><small>26</small></sup></a> We can construct a full-adder\nas follows:<p>\n\n<p><p><tt><a name="%_idx_3366"></a>(define&nbsp;(full-adder&nbsp;a&nbsp;b&nbsp;c-in&nbsp;sum&nbsp;c-out)<br>\n&nbsp;&nbsp;(let&nbsp;((s&nbsp;(make-wire))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c1&nbsp;(make-wire))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c2&nbsp;(make-wire)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(half-adder&nbsp;b&nbsp;c-in&nbsp;s&nbsp;c1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(half-adder&nbsp;a&nbsp;s&nbsp;sum&nbsp;c2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(or-gate&nbsp;c1&nbsp;c2&nbsp;c-out)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\'ok))<br>\n</tt><p><p>\nHaving defined <tt>full-adder</tt> as a procedure, we can now use it as a\nbuilding block for creating still more complex circuits.  (For\nexample, see exercise&nbsp;<a href="#%_thm_3.30">3.30</a>.)<p>\n\n<a name="%_fig_3.26"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-26.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.26:</b>&nbsp;&nbsp;A full-adder circuit.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nIn essence, our simulator provides us with the tools to construct a\nlanguage of circuits.  If we adopt the general perspective on\nlanguages with which we approached the study of Lisp in\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1">1.1</a>,\nwe can say that the primitive function boxes form the primitive\nelements of the language, that wiring boxes together provides a means\nof combination, and that specifying wiring patterns as procedures\nserves as a means of abstraction.<p>\n\n<a name="%_sec_Temp_380"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_380">Primitive function boxes</a></h4><p>\n\n<a name="%_idx_3368"></a>\nThe primitive function boxes implement the ``forces\'\' by which a\nchange in the signal on one wire influences the signals on other\nwires.  To build function boxes, we use the following operations on\nwires:<p>\n\n<p><ul>\n<li><tt>(get-signal &lt;<em>wire</em>&gt;)</tt><br>\n<a name="%_idx_3370"></a>returns the current value of the signal on the wire.<p>\n\n<li><tt>(set-signal! &lt;<em>wire</em>&gt; &lt;<em>new value</em>&gt;)</tt><br>\n<a name="%_idx_3372"></a>changes the value of the signal on the wire to the new value.<p>\n\n<li><tt>(add-action! &lt;<em>wire</em>&gt; &lt;<em>procedure of no arguments</em>&gt;)</tt><br>\n<a name="%_idx_3374"></a>asserts that the designated procedure should be run whenever the\nsignal on the wire changes value.  Such procedures are the vehicles by\nwhich changes in the signal value on the wire are communicated to\nother wires.\n</ul><p>\n<a name="%_idx_3376"></a>In addition, we will make use of a procedure <tt>after-delay</tt> that\ntakes a time delay and a procedure to be run and executes the\ngiven procedure after the given delay.<p>\n\nUsing these procedures, we can define the primitive digital logic\nfunctions.  To connect an input to an output through an inverter, we\nuse <tt>add-action!</tt> to associate with the input wire a procedure\nthat will be run whenever the signal on the input wire changes value.\nThe procedure computes the <tt>logical-not</tt> of the input signal, and\nthen, after one <tt>inverter-delay</tt>, sets the output signal to be\nthis new value:<p>\n\n<p><p><tt><a name="%_idx_3378"></a>(define&nbsp;(inverter&nbsp;input&nbsp;output)<br>\n&nbsp;&nbsp;(define&nbsp;(invert-input)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((new-value&nbsp;(logical-not&nbsp;(get-signal&nbsp;input))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(after-delay&nbsp;inverter-delay<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-signal!&nbsp;output&nbsp;new-value)))))<br>\n&nbsp;&nbsp;(add-action!&nbsp;input&nbsp;invert-input)<br>\n&nbsp;&nbsp;\'ok)<br>\n<a name="%_idx_3380"></a>(define&nbsp;(logical-not&nbsp;s)<br>\n&nbsp;&nbsp;(cond&nbsp;((=&nbsp;s&nbsp;0)&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;s&nbsp;1)&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Invalid&nbsp;signal&quot;&nbsp;s))))<br>\n</tt><p><p><p>\n\nAn and-gate is a little more complex.  The action procedure must be run if\neither of the inputs to the gate changes.  It computes the <tt>logical-and</tt> (using a procedure analogous to <tt>logical-not</tt>) of the\nvalues of the signals on the input wires and sets up a change to the\nnew value to occur on the output wire after one <tt>and-gate-delay</tt>.<p>\n\n<p><p><tt><a name="%_idx_3382"></a>(define&nbsp;(and-gate&nbsp;a1&nbsp;a2&nbsp;output)<br>\n&nbsp;&nbsp;(define&nbsp;(and-action-procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((new-value<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(logical-and&nbsp;(get-signal&nbsp;a1)&nbsp;(get-signal&nbsp;a2))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(after-delay&nbsp;and-gate-delay<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-signal!&nbsp;output&nbsp;new-value)))))<br>\n&nbsp;&nbsp;(add-action!&nbsp;a1&nbsp;and-action-procedure)<br>\n&nbsp;&nbsp;(add-action!&nbsp;a2&nbsp;and-action-procedure)<br>\n&nbsp;&nbsp;\'ok)<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_3.28"></a>\n<b>Exercise 3.28.</b>&nbsp;&nbsp;<a name="%_idx_3384"></a>Define an or-gate as a primitive function box.  Your <tt>or-gate</tt>\nconstructor should be similar to <tt>and-gate</tt>.\n<p><p>\n\n<p><a name="%_thm_3.29"></a>\n<b>Exercise 3.29.</b>&nbsp;&nbsp;<a name="%_idx_3386"></a>Another way to construct an or-gate is as a compound digital logic\ndevice, built from and-gates and inverters.  Define a procedure <tt>or-gate</tt> that accomplishes this.  What is the delay time of the\nor-gate in terms of <tt>and-gate-delay</tt> and <tt>inverter-delay</tt>?\n<p><p>\n\n<p><a name="%_thm_3.30"></a>\n<b>Exercise 3.30.</b>&nbsp;&nbsp;Figure&nbsp;<a href="#%_fig_3.27">3.27</a> shows a <a name="%_idx_3388"></a><a name="%_idx_3390"></a><em>ripple-carry adder</em> formed by stringing\ntogether <em>n</em> full-adders.  This is the simplest form of parallel adder\nfor adding two <em>n</em>-bit binary numbers.  The inputs A<sub>1</sub>, A<sub>2</sub>,\nA<sub>3</sub>, <tt>...</tt>, A<sub><em>n</em></sub> and B<sub>1</sub>, B<sub>2</sub>, B<sub>3</sub>, <tt>...</tt>,\nB<sub><em>n</em></sub> are the two binary numbers to be added (each A<sub><em>k</em></sub> and B<sub><em>k</em></sub>\nis a 0 or a 1).  The circuit generates S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>,\n<tt>...</tt>, S<sub><em>n</em></sub>, the <em>n</em> bits of the sum, and C, the carry from\nthe addition.  Write a procedure <tt>ripple-carry-adder</tt> that\ngenerates this circuit.  The procedure should take as arguments three\nlists of <em>n</em> wires each -- the A<sub><em>k</em></sub>, the B<sub><em>k</em></sub>, and the S<sub><em>k</em></sub> -- and\nalso another wire C.  The major drawback of the ripple-carry adder is\nthe need to wait for the carry signals to propagate.  What is the\ndelay needed to obtain the complete output from an <em>n</em>-bit\nripple-carry adder, expressed in terms of the delays for and-gates,\nor-gates, and inverters?\n\n<p><p>\n\n<a name="%_fig_3.27"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-27.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.27:</b>&nbsp;&nbsp;A ripple-carry adder for <em>n</em>-bit numbers.</div></caption><tr><td>\n\n</td></tr></table></div><p>\n\n<a name="%_sec_Temp_384"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_384">Representing wires</a></h4><p>\n\n<a name="%_idx_3392"></a>\nA wire in our simulation will be a computational object with two local\nstate variables: a <tt>signal-value</tt> (initially taken to be 0) and a\ncollection of <tt>action-procedures</tt> to be run when the signal\nchanges value.  We implement the wire, using message-passing style, as\n<a name="%_idx_3394"></a>a collection of local procedures together with a <tt>dispatch</tt>\nprocedure that selects the appropriate local operation, just as we did\nwith the simple bank-account object in section\n&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:<p>\n\n<p><p><tt><a name="%_idx_3396"></a>(define&nbsp;(make-wire)<br>\n&nbsp;&nbsp;(let&nbsp;((signal-value&nbsp;0)&nbsp;(action-procedures&nbsp;\'()))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(set-my-signal!&nbsp;new-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;(=&nbsp;signal-value&nbsp;new-value))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;signal-value&nbsp;new-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call-each&nbsp;action-procedures))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'done))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(accept-action-procedure!&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;action-procedures&nbsp;(cons&nbsp;proc&nbsp;action-procedures))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(proc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;m&nbsp;\'get-signal)&nbsp;signal-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'set-signal!)&nbsp;set-my-signal!)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'add-action!)&nbsp;accept-action-procedure!)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;operation&nbsp;--&nbsp;WIRE&quot;&nbsp;m))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dispatch))<br>\n</tt><p><p>\nThe local procedure <tt>set-my-signal!</tt> tests whether the new signal\nvalue changes the signal on the wire.  If so, it runs each of the\naction procedures, using the following procedure <tt>call-each</tt>,\nwhich calls each of the items in a list of no-argument procedures:<p>\n\n<p><p><tt><a name="%_idx_3398"></a>(define&nbsp;(call-each&nbsp;procedures)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;procedures)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'done<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((car&nbsp;procedures))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call-each&nbsp;(cdr&nbsp;procedures)))))<br>\n</tt><p><p>\nThe local procedure <tt>accept-action-procedure!</tt> adds the given\nprocedure to the list of procedures to be run, and then runs the new\nprocedure once.  (See exercise&nbsp;<a href="#%_thm_3.31">3.31</a>.)<p>\n\nWith the local <tt>dispatch</tt> procedure set up as specified, we can\nprovide the following procedures to access the local operations on\nwires:<a name="call_footnote_Temp_385" href="#footnote_Temp_385"><sup><small>27</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_3404"></a>(define&nbsp;(get-signal&nbsp;wire)<br>\n&nbsp;&nbsp;(wire&nbsp;\'get-signal))<br>\n<a name="%_idx_3406"></a>(define&nbsp;(set-signal!&nbsp;wire&nbsp;new-value)<br>\n&nbsp;&nbsp;((wire&nbsp;\'set-signal!)&nbsp;new-value))<br>\n<a name="%_idx_3408"></a>(define&nbsp;(add-action!&nbsp;wire&nbsp;action-procedure)<br>\n&nbsp;&nbsp;((wire&nbsp;\'add-action!)&nbsp;action-procedure))<br>\n</tt><p><p><p>\n\nWires, which have time-varying signals and may be incrementally\nattached to devices, are typical of mutable objects.  We have modeled\nthem as procedures with local state variables that are modified by\nassignment.  When a new wire is created, a new set of state variables\nis allocated (by the <tt>let</tt> expression in <tt>make-wire</tt>) and a\nnew <tt>dispatch</tt> procedure is constructed and returned, capturing\nthe environment with the new state variables.<p>\n\nThe wires are shared among the various devices that have been\nconnected to them.  Thus, a change made by an interaction with one\ndevice will affect all the other devices attached to the wire.  The\nwire communicates the change to its neighbors by calling the action\nprocedures provided to it when the connections were established.\n\n<a name="%_sec_Temp_386"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_386">The agenda</a></h4><p>\n\n<a name="%_idx_3410"></a>\nThe only thing needed to complete the simulator is <tt>after-delay</tt>.\nThe idea here is that we maintain a data structure, called an <em>agenda</em>, that contains a schedule of things to do.  The following\noperations are defined for agendas:<p>\n\n<p><ul>\n<li><a name="%_idx_3412"></a><tt>(make-agenda)</tt><br>\nreturns a new empty agenda.<p>\n\n<li><a name="%_idx_3414"></a><tt>(empty-agenda? &lt;<em>agenda</em>&gt;)</tt><br>\nis true if the specified agenda is empty.<p>\n\n<li><a name="%_idx_3416"></a><tt>(first-agenda-item &lt;<em>agenda</em>&gt;)</tt><br>\nreturns the first item on the agenda.<p>\n\n<li><a name="%_idx_3418"></a><tt>(remove-first-agenda-item! &lt;<em>agenda</em>&gt;)</tt><br>\nmodifies the agenda by removing the first item.<p>\n\n<li><a name="%_idx_3420"></a><tt>(add-to-agenda! &lt;<em>time</em>&gt; &lt;<em>action</em>&gt; &lt;<em>agenda</em>&gt;)</tt><br>\nmodifies the agenda by adding the given action procedure to be run at\nthe specified time.<p>\n\n<li><a name="%_idx_3422"></a><tt>(current-time &lt;<em>agenda</em>&gt;)</tt><br>\nreturns the current simulation time.\n</ul><p><p>\n\nThe particular agenda that we use is denoted by\n<tt>the-agenda</tt>.  The procedure <tt>after-delay</tt> adds new\nelements to <tt>the-agenda</tt>:<p>\n\n<p><p><tt><a name="%_idx_3424"></a>(define&nbsp;(after-delay&nbsp;delay&nbsp;action)<br>\n&nbsp;&nbsp;(add-to-agenda!&nbsp;(+&nbsp;delay&nbsp;(current-time&nbsp;the-agenda))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-agenda))<br>\n</tt><p><p><p>\n\nThe simulation is driven by the procedure <tt>propagate</tt>, which\noperates on <tt>the-agenda</tt>, executing each procedure on the agenda\nin sequence.  In general, as the simulation runs, new items will be\nadded to the agenda, and <tt>propagate</tt> will continue the simulation\nas long as there are items on the agenda:<p>\n\n<p><p><tt><a name="%_idx_3426"></a>(define&nbsp;(propagate)<br>\n&nbsp;&nbsp;(if&nbsp;(empty-agenda?&nbsp;the-agenda)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'done<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((first-item&nbsp;(first-agenda-item&nbsp;the-agenda)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(first-item)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(remove-first-agenda-item!&nbsp;the-agenda)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(propagate))))<br>\n</tt><p><p>\n<p>\n\n<a name="%_sec_Temp_387"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_387">A sample simulation</a></h4><p>\n\n<a name="%_idx_3428"></a><a name="%_idx_3430"></a>\nThe following procedure, which places a ``probe\'\' on a wire, shows the\nsimulator in action.  The probe tells the wire that, whenever its\nsignal changes value, it should print the new signal value, together\nwith the current time and a name that identifies the wire:<p>\n\n<p><p><tt><a name="%_idx_3432"></a>(define&nbsp;(probe&nbsp;name&nbsp;wire)<br>\n&nbsp;&nbsp;(add-action!&nbsp;wire<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;name)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;&quot;&nbsp;&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;(current-time&nbsp;the-agenda))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;&quot;&nbsp;&nbsp;New-value&nbsp;=&nbsp;&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;(get-signal&nbsp;wire)))))<br>\n</tt><p><p><p>\n\nWe begin by initializing the agenda and specifying delays for the\nprimitive function boxes:<p>\n\n<p><p><tt>(define&nbsp;the-agenda&nbsp;(make-agenda))<br>\n(define&nbsp;inverter-delay&nbsp;2)<br>\n(define&nbsp;and-gate-delay&nbsp;3)<br>\n(define&nbsp;or-gate-delay&nbsp;5)<br>\n</tt><p><p>\nNow we define four wires, placing probes on two of them:<p>\n\n\n<p><p><tt>(define&nbsp;input-1&nbsp;(make-wire))<br>\n(define&nbsp;input-2&nbsp;(make-wire))<br>\n(define&nbsp;sum&nbsp;(make-wire))<br>\n(define&nbsp;carry&nbsp;(make-wire))<br>\n(probe&nbsp;\'sum&nbsp;sum)<br>\n<i>sum&nbsp;0&nbsp;&nbsp;New-value&nbsp;=&nbsp;0</i><br>\n(probe&nbsp;\'carry&nbsp;carry)<br>\n<i>carry&nbsp;0&nbsp;&nbsp;New-value&nbsp;=&nbsp;0</i><br>\n</tt><p><p>\nNext we connect the wires in a half-adder circuit (as in\nfigure&nbsp;<a href="#%_fig_3.25">3.25</a>), set the signal on <tt>input-1</tt> to 1,\nand run the simulation:<p>\n\n\n<p><p><tt>(half-adder&nbsp;input-1&nbsp;input-2&nbsp;sum&nbsp;carry)<br>\n<i>ok</i><br>\n(set-signal!&nbsp;input-1&nbsp;1)<br>\n<i>done</i><br>\n(propagate)<br>\n<i>sum&nbsp;8&nbsp;&nbsp;New-value&nbsp;=&nbsp;1</i><br>\n<i>done</i><br>\n</tt><p><p>\nThe <tt>sum</tt> signal changes to 1 at time 8.  We are now eight time\nunits from the beginning of the simulation.  At this point, we can set\nthe signal on <tt>input-2</tt> to 1 and allow the values to propagate:<p>\n\n\n<p><p><tt>(set-signal!&nbsp;input-2&nbsp;1)<br>\n<i>done</i><br>\n(propagate)<br>\n<i>carry&nbsp;11&nbsp;&nbsp;New-value&nbsp;=&nbsp;1</i><br>\n<i>sum&nbsp;16&nbsp;&nbsp;New-value&nbsp;=&nbsp;0</i><br>\n<i>done</i><br>\n</tt><p><p>\nThe <tt>carry</tt> changes to 1 at time 11 and the <tt>sum</tt> changes to 0\nat time 16.\n\n\n<p><a name="%_thm_3.31"></a>\n<b>Exercise 3.31.</b>&nbsp;&nbsp;\n<a name="%_idx_3434"></a>The internal procedure <tt>accept-action-procedure!</tt> defined in <tt>make-wire</tt> specifies that when a new action procedure is added to\na wire, the procedure is immediately run.  Explain why this initialization\nis necessary.  In particular, trace through the half-adder example in\nthe paragraphs above and say how the system\'s response would differ if\nwe had defined <tt>accept-action-procedure!</tt> as<p>\n\n\n<p><p><tt>(define&nbsp;(accept-action-procedure!&nbsp;proc)<br>\n&nbsp;&nbsp;(set!&nbsp;action-procedures&nbsp;(cons&nbsp;proc&nbsp;action-procedures)))<br>\n</tt><p><p>\n<p><p>\n\n<a name="%_sec_Temp_389"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_389">Implementing the agenda</a></h4><p>\n\n<a name="%_idx_3436"></a>\nFinally, we give details of the agenda data structure, which holds the\nprocedures that are scheduled for future execution.<p>\n\nThe agenda is made up of <a name="%_idx_3438"></a><em>time segments</em>.  Each time segment is a\npair consisting of a number (the time) and a <a name="%_idx_3440"></a>queue (see\nexercise&nbsp;<a href="#%_thm_3.32">3.32</a>) that holds the procedures that are\nscheduled to be run during that time segment.<p>\n\n<p><p><tt><a name="%_idx_3442"></a>(define&nbsp;(make-time-segment&nbsp;time&nbsp;queue)<br>\n&nbsp;&nbsp;(cons&nbsp;time&nbsp;queue))<br>\n<a name="%_idx_3444"></a>(define&nbsp;(segment-time&nbsp;s)&nbsp;(car&nbsp;s))<br>\n<a name="%_idx_3446"></a>(define&nbsp;(segment-queue&nbsp;s)&nbsp;(cdr&nbsp;s))<br>\n</tt><p><p>\nWe will operate on the time-segment queues using the queue operations\ndescribed in section&nbsp;<a href="#%_sec_3.3.2">3.3.2</a>.<p>\n\n<a name="%_idx_3448"></a>The agenda itself is a one-dimensional table of time segments.  It\ndiffers from the tables described in section&nbsp;<a href="#%_sec_3.3.3">3.3.3</a> in that\nthe segments will be sorted in order of increasing time.  In addition,\nwe store the <a name="%_idx_3450"></a><em>current time</em> (i.e., the time of the last action\nthat was processed) at the head of the agenda.  A newly constructed\nagenda has no time segments and has a current time of 0:<a name="call_footnote_Temp_390" href="#footnote_Temp_390"><sup><small>28</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_3456"></a>(define&nbsp;(make-agenda)&nbsp;(list&nbsp;0))<br>\n<a name="%_idx_3458"></a>(define&nbsp;(current-time&nbsp;agenda)&nbsp;(car&nbsp;agenda))<br>\n<a name="%_idx_3460"></a>(define&nbsp;(set-current-time!&nbsp;agenda&nbsp;time)<br>\n&nbsp;&nbsp;(set-car!&nbsp;agenda&nbsp;time))<br>\n<a name="%_idx_3462"></a>(define&nbsp;(segments&nbsp;agenda)&nbsp;(cdr&nbsp;agenda))<br>\n<a name="%_idx_3464"></a>(define&nbsp;(set-segments!&nbsp;agenda&nbsp;segments)<br>\n&nbsp;&nbsp;(set-cdr!&nbsp;agenda&nbsp;segments))<br>\n<a name="%_idx_3466"></a>(define&nbsp;(first-segment&nbsp;agenda)&nbsp;(car&nbsp;(segments&nbsp;agenda)))<br>\n<a name="%_idx_3468"></a>(define&nbsp;(rest-segments&nbsp;agenda)&nbsp;(cdr&nbsp;(segments&nbsp;agenda)))<br>\n</tt><p><p><p>\n\nAn agenda is empty if it has no time segments:\n\n<p><p><tt><a name="%_idx_3470"></a>(define&nbsp;(empty-agenda?&nbsp;agenda)<br>\n&nbsp;&nbsp;(null?&nbsp;(segments&nbsp;agenda)))<br>\n</tt><p><p>\n<p>\n\n\nTo add an action to an agenda, we first check if the agenda is empty.\nIf so, we create a time segment for the action and install this in\nthe agenda.  Otherwise, we scan the agenda, examining the time of each\nsegment.  If we find a segment for our appointed time, we add the\naction to the associated queue.  If we reach a time later than the one\nto which we are appointed, we insert a new time segment into the\nagenda just before it.  If we reach the end of the agenda, we must\ncreate a new time segment at the end.<p>\n\n\n<p><p><tt><a name="%_idx_3472"></a>(define&nbsp;(add-to-agenda!&nbsp;time&nbsp;action&nbsp;agenda)<br>\n&nbsp;&nbsp;(define&nbsp;(belongs-before?&nbsp;segments)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(null?&nbsp;segments)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&nbsp;time&nbsp;(segment-time&nbsp;(car&nbsp;segments)))))<br>\n&nbsp;&nbsp;(define&nbsp;(make-new-time-segment&nbsp;time&nbsp;action)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((q&nbsp;(make-queue)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(insert-queue!&nbsp;q&nbsp;action)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-time-segment&nbsp;time&nbsp;q)))<br>\n&nbsp;&nbsp;(define&nbsp;(add-to-segments!&nbsp;segments)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;(segment-time&nbsp;(car&nbsp;segments))&nbsp;time)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(insert-queue!&nbsp;(segment-queue&nbsp;(car&nbsp;segments))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((rest&nbsp;(cdr&nbsp;segments)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(belongs-before?&nbsp;rest)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segments<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(make-new-time-segment&nbsp;time&nbsp;action)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;segments)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-to-segments!&nbsp;rest)))))<br>\n&nbsp;&nbsp;(let&nbsp;((segments&nbsp;(segments&nbsp;agenda)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(belongs-before?&nbsp;segments)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-segments!<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;agenda<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(make-new-time-segment&nbsp;time&nbsp;action)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;segments))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-to-segments!&nbsp;segments))))<br>\n</tt><p><p><p>\n\nThe procedure that removes the first item from the agenda deletes the\nitem at the front of the queue in the first time segment.  If this\ndeletion makes the time segment empty, we remove it from the list of\nsegments:<a name="call_footnote_Temp_391" href="#footnote_Temp_391"><sup><small>29</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_3478"></a>(define&nbsp;(remove-first-agenda-item!&nbsp;agenda)<br>\n&nbsp;&nbsp;(let&nbsp;((q&nbsp;(segment-queue&nbsp;(first-segment&nbsp;agenda))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(delete-queue!&nbsp;q)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(empty-queue?&nbsp;q)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-segments!&nbsp;agenda&nbsp;(rest-segments&nbsp;agenda)))))<br>\n</tt><p><p><p>\n\nThe first agenda item is found at the head of the queue in the first\ntime segment.  Whenever we extract an item, we also update the current\ntime:<a name="call_footnote_Temp_392" href="#footnote_Temp_392"><sup><small>30</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_3480"></a>(define&nbsp;(first-agenda-item&nbsp;agenda)<br>\n&nbsp;&nbsp;(if&nbsp;(empty-agenda?&nbsp;agenda)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Agenda&nbsp;is&nbsp;empty&nbsp;--&nbsp;FIRST-AGENDA-ITEM&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((first-seg&nbsp;(first-segment&nbsp;agenda)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-current-time!&nbsp;agenda&nbsp;(segment-time&nbsp;first-seg))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(front-queue&nbsp;(segment-queue&nbsp;first-seg)))))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_3.32"></a>\n<b>Exercise 3.32.</b>&nbsp;&nbsp;The procedures to be run during each time segment of the agenda are\nkept in a queue.  Thus, the procedures for each segment are called in\nthe order in which they were added to the agenda (first in, first\nout).  Explain why this order must be used.  In particular, trace the\nbehavior of an and-gate whose inputs change from 0,1 to 1,0 in the\nsame segment and say how the behavior would differ if we stored a\nsegment\'s procedures in an ordinary list, adding and removing\nprocedures only at the front (last in, first out).\n\n<p>\n    \n<a name="%_sec_3.3.5"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.3.5">3.3.5&nbsp;&nbsp;Propagation of Constraints</a></h3><p>\n\n\n<a name="%_idx_3482"></a><a name="%_idx_3484"></a>\nComputer programs are traditionally organized as\none-directional computations, which perform operations on prespecified\narguments to produce desired outputs.  On the other hand, we often\nmodel systems in terms of relations among quantities.  For example, a\nmathematical model of a mechanical structure might include the\ninformation that the deflection <em>d</em> of a metal rod is related to the\nforce <em>F</em> on the rod, the length <em>L</em> of the rod, the cross-sectional\narea <em>A</em>, and the elastic modulus <em>E</em> via the equation\n<p><div align=left><img src="ch3-Z-G-28.gif" border="0"></div><p>\nSuch an equation is not one-directional.  Given any four of the\nquantities, we can use it to compute the fifth.  Yet translating the\nequation into a traditional computer language would force us to choose\none of the quantities to be computed in terms of the other four.\nThus, a procedure for computing the area <em>A</em> could not be used to\ncompute the deflection <em>d</em>, even though the computations of <em>A</em> and\n<em>d</em> arise from the same equation.<a name="call_footnote_Temp_394" href="#footnote_Temp_394"><sup><small>31</small></sup></a><p>\n\n<a name="%_idx_3508"></a>In this section, we sketch the design of a language that enables us to\nwork in terms of relations themselves.  The primitive elements of the\nlanguage are <a name="%_idx_3510"></a><a name="%_idx_3512"></a><em>primitive constraints</em>, which state that certain\nrelations hold between quantities.  For example, <tt>(adder a b c)</tt>\nspecifies that the quantities <em>a</em>, <em>b</em>, and <em>c</em> must be related by the\nequation <em>a</em> + <em>b</em> = <em>c</em>, <tt>(multiplier&nbsp;x&nbsp;y&nbsp;z)</tt> expresses the constraint\n<em>x</em><em>y</em>  =  <em>z</em>, and <tt>(constant&nbsp;3.14&nbsp;x)</tt> says that the value of <em>x</em> must\nbe 3.14.<p>\n\n\nOur language provides a means of combining primitive constraints in\norder to express more complex relations.  We combine constraints by\nconstructing <a name="%_idx_3514"></a><em>constraint networks</em>, in which constraints are\njoined by <a name="%_idx_3516"></a><em>connectors</em>.  A connector is an object that ``holds\'\' a\nvalue that may participate in one or more constraints.  For example,\nwe know that the relationship between Fahrenheit and Celsius\ntemperatures is<p>\n\n<p><div align=left><img src="ch3-Z-G-29.gif" border="0"></div><p><p>\n\nSuch a constraint can be thought of as a network consisting of\nprimitive adder, multiplier, and constant constraints\n(figure&nbsp;<a href="#%_fig_3.28">3.28</a>).  In the figure, we see on the left a\nmultiplier box with three terminals, labeled <em>m</em>1, <em>m</em>2, and <em>p</em>.\nThese connect the multiplier to the rest of the network as follows:\nThe <em>m</em>1 terminal is linked to a connector <em>C</em>, which will hold the\nCelsius temperature.  The <em>m</em>2 terminal is linked to a connector\n<em>w</em>, which is also linked to a constant box that holds 9.  The <em>p</em>\nterminal, which the multiplier box constrains to be the product of\n<em>m</em>1 and <em>m</em>2, is linked to the <em>p</em> terminal\nof another multiplier box, whose <em>m</em>2 is connected to a constant 5 and\nwhose <em>m</em>1 is connected to one of the terms in a sum.<p>\n\n<a name="%_fig_3.28"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-30.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.28:</b>&nbsp;&nbsp;The relation 9<em>C</em>  =  5(<em>F</em>  -  32)\nexpressed as a constraint network.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nComputation by such a network proceeds as follows: When a connector is\ngiven a value (by the user or by a constraint box to which it is\nlinked), it awakens all of its associated constraints (except for the\nconstraint that just awakened it) to inform them that it has a value.\nEach awakened constraint box then polls its connectors to see if there\nis enough information to determine a value for a connector.  If so,\nthe box sets that connector, which then awakens all of its associated\nconstraints, and so on.  For instance, in conversion between\nCelsius and Fahrenheit, <em>w</em>, <em>x</em>, and <em>y</em> are immediately set by\nthe constant boxes to 9, 5, and 32, respectively.  The connectors\nawaken the multipliers and the adder, which determine that there is\nnot enough information to proceed.  If the user (or some other part of\nthe network) sets <em>C</em> to a value (say 25), the leftmost multiplier\nwill be awakened, and it will set <em>u</em> to 25 &middot;  9 = 225.  Then <em>u</em>\nawakens the second multiplier, which sets <em>v</em> to 45, and <em>v</em> awakens\nthe adder, which sets <em>F</em> to 77.<p>\n\n\n<a name="%_sec_Temp_395"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_395">Using the constraint system</a></h4><p>\n\nTo use the constraint system to carry out the temperature computation\noutlined above, we first create two connectors, <tt>C</tt> and <tt>F</tt>,\nby calling the constructor <tt>make-connector</tt>, and link <tt>C</tt> and\n<tt>F</tt> in an appropriate network:<p>\n\n<p><p><tt>(define&nbsp;C&nbsp;(make-connector))<br>\n(define&nbsp;F&nbsp;(make-connector))<br>\n(celsius-fahrenheit-converter&nbsp;C&nbsp;F)<br>\n<i>ok</i><br>\n</tt><p><p>\nThe procedure that creates the network is defined as follows:<p>\n\n<p><p><tt><a name="%_idx_3518"></a>(define&nbsp;(celsius-fahrenheit-converter&nbsp;c&nbsp;f)<br>\n&nbsp;&nbsp;(let&nbsp;((u&nbsp;(make-connector))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(v&nbsp;(make-connector))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(w&nbsp;(make-connector))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x&nbsp;(make-connector))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(y&nbsp;(make-connector)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(multiplier&nbsp;c&nbsp;w&nbsp;u)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(multiplier&nbsp;v&nbsp;x&nbsp;u)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(adder&nbsp;v&nbsp;y&nbsp;f)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(constant&nbsp;9&nbsp;w)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(constant&nbsp;5&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(constant&nbsp;32&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\'ok))<br>\n</tt><p><p>\nThis procedure creates the internal connectors <tt>u</tt>, <tt>v</tt>, <tt>w</tt>, <tt>x</tt>, and <tt>y</tt>, and links them as shown in\nfigure&nbsp;<a href="#%_fig_3.28">3.28</a> using the primitive constraint\nconstructors <tt>adder</tt>, <tt>multiplier</tt>, and <tt>constant</tt>.  Just\nas with the digital-circuit simulator of\nsection&nbsp;<a href="#%_sec_3.3.4">3.3.4</a>, expressing these combinations of\nprimitive elements in terms of procedures automatically provides our\nlanguage with a means of abstraction for compound objects.<p>\n\nTo watch the network in action, we can place probes on the connectors\n<tt>C</tt> and <tt>F</tt>, using a <tt>probe</tt> procedure similar to the one\nwe used to monitor wires in section&nbsp;<a href="#%_sec_3.3.4">3.3.4</a>.\nPlacing a probe on a connector will cause a message to be printed\nwhenever the connector is given a value:<p>\n\n\n<p><p><tt>(probe&nbsp;&quot;Celsius&nbsp;temp&quot;&nbsp;C)<br>\n(probe&nbsp;&quot;Fahrenheit&nbsp;temp&quot;&nbsp;F)<br>\n</tt><p><p>\nNext we set the value of <tt>C</tt> to 25.  (The third argument to <tt>set-value!</tt> tells <tt>C</tt> that this directive comes from the <tt>user</tt>.)<p>\n\n\n<p><p><tt>(set-value!&nbsp;C&nbsp;25&nbsp;\'user)<br>\n<i>Probe:&nbsp;Celsius&nbsp;temp&nbsp;=&nbsp;25</i><br>\n<i>Probe:&nbsp;Fahrenheit&nbsp;temp&nbsp;=&nbsp;77</i><br>\n<i>done</i><br>\n</tt><p><p>\nThe probe on <tt>C</tt> awakens and reports the value.  <tt>C</tt> also\npropagates its value through the network as described above.  This\nsets <tt>F</tt> to 77, which is reported by the probe on <tt>F</tt>.<p>\n\nNow we can try to set <tt>F</tt> to a new value, say 212:<p>\n\n\n<p><p><tt>(set-value!&nbsp;F&nbsp;212&nbsp;\'user)<br>\n<i>Error!&nbsp;Contradiction&nbsp;(77&nbsp;212)</i><br>\n</tt><p><p>\nThe connector complains that it has sensed a contradiction: Its value\nis 77, and someone is trying to set it to 212.  If we really want to\nreuse the network with new values, we can tell <tt>C</tt> to forget its\nold value:<p>\n\n\n<p><p><tt>(forget-value!&nbsp;C&nbsp;\'user)<br>\n<i>Probe:&nbsp;Celsius&nbsp;temp&nbsp;=&nbsp;?</i><br>\n<i>Probe:&nbsp;Fahrenheit&nbsp;temp&nbsp;=&nbsp;?</i><br>\n<i>done</i><br>\n</tt><p><p>\n<tt>C</tt> finds that the <tt>user</tt>, who set its value originally, is\nnow retracting that value, so <tt>C</tt> agrees to lose its value, as\nshown by the probe, and informs the rest of the network of this fact.\nThis information eventually propagates to <tt>F</tt>, which now finds\nthat it has no reason for continuing to believe that its own value is\n77.  Thus, <tt>F</tt> also gives up its value, as shown by the probe.<p>\n\nNow that <tt>F</tt> has no value, we are free to set it to 212:<p>\n\n<p><p><tt>(set-value!&nbsp;F&nbsp;212&nbsp;\'user)<br>\n<i>Probe:&nbsp;Fahrenheit&nbsp;temp&nbsp;=&nbsp;212</i><br>\n<i>Probe:&nbsp;Celsius&nbsp;temp&nbsp;=&nbsp;100</i><br>\n<i>done</i><br>\n</tt><p><p>\nThis new value, when propagated through the network, forces <tt>C</tt> to\nhave a value of 100, and this is registered by the probe on <tt>C</tt>.\nNotice that the very same network is being used to compute <tt>C</tt>\ngiven <tt>F</tt> and to compute <tt>F</tt> given&nbsp;<tt>C</tt>.  This\nnondirectionality of computation is the distinguishing feature of\nconstraint-based systems.<p>\n\n<a name="%_sec_Temp_396"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_396">Implementing the constraint system</a></h4><p>\n\nThe constraint system is implemented via procedural objects with local\nstate, in a manner very similar to the digital-circuit simulator of\nsection&nbsp;<a href="#%_sec_3.3.4">3.3.4</a>.  Although the primitive objects\nof the constraint system are somewhat more complex, the overall system\nis simpler, since there is no concern about agendas and logic delays.<p>\n\n<a name="%_idx_3520"></a>The basic operations on connectors are the following:\n<p><ul>\n<li><a name="%_idx_3522"></a><tt>(has-value? &lt;<em>connector</em>&gt;)</tt><br>\ntells whether the connector has a value.<p>\n\n<li><a name="%_idx_3524"></a><tt>(get-value &lt;<em>connector</em>&gt;)</tt><br>\nreturns the connector\'s current value.<p>\n\n<li><a name="%_idx_3526"></a><tt>(set-value! &lt;<em>connector</em>&gt; &lt;<em>new-value</em>&gt; &lt;<em>informant</em>&gt;)</tt><br>\nindicates that the informant is requesting the connector to set its\nvalue to the new value.<p>\n\n<li><a name="%_idx_3528"></a><tt>(forget-value! &lt;<em>connector</em>&gt; &lt;<em>retractor</em>&gt;)</tt><br>\ntells the connector that the retractor is requesting it to forget its value.<p>\n\n<li><a name="%_idx_3530"></a><tt>(connect &lt;<em>connector</em>&gt; &lt;<em>new-constraint</em>&gt;)</tt><br>\ntells the connector to participate in the new constraint.\n</ul><p><p>\n\nThe connectors communicate with the constraints by means of the\nprocedures <tt>inform-about-value</tt>, which tells the given\nconstraint that the connector has a value, and <tt>inform-about-no-value</tt>, which tells the constraint that the connector\nhas lost its value.<p>\n\n<tt>Adder</tt> constructs an adder constraint among summand connectors\n<tt>a1</tt> and <tt>a2</tt> and a <tt>sum</tt> connector.  An adder is\nimplemented as a procedure with local state (the procedure <tt>me</tt>\nbelow):<p>\n\n<p><p><tt><a name="%_idx_3532"></a>(define&nbsp;(adder&nbsp;a1&nbsp;a2&nbsp;sum)<br>\n&nbsp;&nbsp;(define&nbsp;(process-new-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((and&nbsp;(has-value?&nbsp;a1)&nbsp;(has-value?&nbsp;a2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-value!&nbsp;sum<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(get-value&nbsp;a1)&nbsp;(get-value&nbsp;a2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;me))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(has-value?&nbsp;a1)&nbsp;(has-value?&nbsp;sum))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-value!&nbsp;a2<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;(get-value&nbsp;sum)&nbsp;(get-value&nbsp;a1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;me))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(has-value?&nbsp;a2)&nbsp;(has-value?&nbsp;sum))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-value!&nbsp;a1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;(get-value&nbsp;sum)&nbsp;(get-value&nbsp;a2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;me))))<br>\n&nbsp;&nbsp;(define&nbsp;(process-forget-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(forget-value!&nbsp;sum&nbsp;me)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(forget-value!&nbsp;a1&nbsp;me)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(forget-value!&nbsp;a2&nbsp;me)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(process-new-value))<br>\n&nbsp;&nbsp;(define&nbsp;(me&nbsp;request)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;request&nbsp;\'I-have-a-value)&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(process-new-value))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;request&nbsp;\'I-lost-my-value)&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(process-forget-value))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;ADDER&quot;&nbsp;request))))<br>\n&nbsp;&nbsp;(connect&nbsp;a1&nbsp;me)<br>\n&nbsp;&nbsp;(connect&nbsp;a2&nbsp;me)<br>\n&nbsp;&nbsp;(connect&nbsp;sum&nbsp;me)<br>\n&nbsp;&nbsp;me)<br>\n</tt><p><p>\n<tt>Adder</tt> connects the new adder to the designated connectors and\nreturns it as its value.  The procedure <tt>me</tt>, which represents the\nadder, acts as a dispatch to the local procedures.  The following\n``syntax interfaces\'\' (see footnote&nbsp;<a href="#footnote_Temp_385">27</a> in\nsection&nbsp;<a href="#%_sec_3.3.4">3.3.4</a>) are used in conjunction with the\ndispatch:<p>\n\n<p><p><tt><a name="%_idx_3534"></a>(define&nbsp;(inform-about-value&nbsp;constraint)<br>\n&nbsp;&nbsp;(constraint&nbsp;\'I-have-a-value))<br>\n<a name="%_idx_3536"></a>(define&nbsp;(inform-about-no-value&nbsp;constraint)<br>\n&nbsp;&nbsp;(constraint&nbsp;\'I-lost-my-value))<br>\n</tt><p><p>\nThe adder\'s local procedure <tt>process-new-value</tt> is called when the\nadder is informed that one of its connectors has a value. The adder\nfirst checks to see if both <tt>a1</tt> and <tt>a2</tt> have values. If so,\nit tells <tt>sum</tt> to set its value to the sum of the two addends.\nThe <tt>informant</tt> argument to <tt>set-value!</tt> is <tt>me</tt>, which is\nthe adder object itself.  If <tt>a1</tt> and <tt>a2</tt> do not both have\nvalues, then the adder checks to see if perhaps <tt>a1</tt> and <tt>sum</tt>\nhave values.  If so, it sets <tt>a2</tt> to the difference of these two.\nFinally, if <tt>a2</tt> and <tt>sum</tt> have values, this gives the adder\nenough information to set <tt>a1</tt>.  If the adder is told that one of\nits connectors has lost a value, it requests that all of its\nconnectors now lose their values.  (Only those values that were set by\nthis adder are actually lost.)  Then it runs <tt>process-new-value</tt>.\nThe reason for this last step is that one or more connectors may still\nhave a value (that is, a connector may have had a value that was not\noriginally set by the adder), and these values may need to be\npropagated back through the adder.<p>\n\nA multiplier is very similar to an adder. It will set its <tt>product</tt> to 0 if either of the factors is 0, even if the other factor\nis not known.<p>\n\n<p><p><tt><a name="%_idx_3538"></a>(define&nbsp;(multiplier&nbsp;m1&nbsp;m2&nbsp;product)<br>\n&nbsp;&nbsp;(define&nbsp;(process-new-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((or&nbsp;(and&nbsp;(has-value?&nbsp;m1)&nbsp;(=&nbsp;(get-value&nbsp;m1)&nbsp;0))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(has-value?&nbsp;m2)&nbsp;(=&nbsp;(get-value&nbsp;m2)&nbsp;0)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-value!&nbsp;product&nbsp;0&nbsp;me))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(has-value?&nbsp;m1)&nbsp;(has-value?&nbsp;m2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-value!&nbsp;product<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(get-value&nbsp;m1)&nbsp;(get-value&nbsp;m2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;me))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(has-value?&nbsp;product)&nbsp;(has-value?&nbsp;m1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-value!&nbsp;m2<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;(get-value&nbsp;product)&nbsp;(get-value&nbsp;m1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;me))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(has-value?&nbsp;product)&nbsp;(has-value?&nbsp;m2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-value!&nbsp;m1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;(get-value&nbsp;product)&nbsp;(get-value&nbsp;m2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;me))))<br>\n&nbsp;&nbsp;(define&nbsp;(process-forget-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(forget-value!&nbsp;product&nbsp;me)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(forget-value!&nbsp;m1&nbsp;me)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(forget-value!&nbsp;m2&nbsp;me)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(process-new-value))<br>\n&nbsp;&nbsp;(define&nbsp;(me&nbsp;request)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;request&nbsp;\'I-have-a-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(process-new-value))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;request&nbsp;\'I-lost-my-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(process-forget-value))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;MULTIPLIER&quot;&nbsp;request))))<br>\n&nbsp;&nbsp;(connect&nbsp;m1&nbsp;me)<br>\n&nbsp;&nbsp;(connect&nbsp;m2&nbsp;me)<br>\n&nbsp;&nbsp;(connect&nbsp;product&nbsp;me)<br>\n&nbsp;&nbsp;me)<br>\n</tt><p><p>\nA <tt>constant</tt> constructor simply sets the value of the designated\nconnector.  Any <tt>I-have-a-value</tt> or <tt>I-lost-my-value</tt> message\nsent to the constant box will produce an error.<p>\n\n<p><p><tt><a name="%_idx_3540"></a>(define&nbsp;(constant&nbsp;value&nbsp;connector)<br>\n&nbsp;&nbsp;(define&nbsp;(me&nbsp;request)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;CONSTANT&quot;&nbsp;request))<br>\n&nbsp;&nbsp;(connect&nbsp;connector&nbsp;me)<br>\n&nbsp;&nbsp;(set-value!&nbsp;connector&nbsp;value&nbsp;me)<br>\n&nbsp;&nbsp;me)<br>\n</tt><p><p>\nFinally, a probe prints a message about the setting or unsetting of\nthe designated connector:<p>\n\n<p><p><tt><a name="%_idx_3542"></a>(define&nbsp;(probe&nbsp;name&nbsp;connector)<br>\n&nbsp;&nbsp;(define&nbsp;(print-probe&nbsp;value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(newline)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;&quot;Probe:&nbsp;&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;name)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;&quot;&nbsp;=&nbsp;&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;value))<br>\n&nbsp;&nbsp;(define&nbsp;(process-new-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(print-probe&nbsp;(get-value&nbsp;connector)))<br>\n&nbsp;&nbsp;(define&nbsp;(process-forget-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(print-probe&nbsp;&quot;?&quot;))<br>\n&nbsp;&nbsp;(define&nbsp;(me&nbsp;request)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;request&nbsp;\'I-have-a-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(process-new-value))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;request&nbsp;\'I-lost-my-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(process-forget-value))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;PROBE&quot;&nbsp;request))))<br>\n&nbsp;&nbsp;(connect&nbsp;connector&nbsp;me)<br>\n&nbsp;&nbsp;me)<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_397"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_397">Representing connectors</a></h4><p>\n\n<a name="%_idx_3544"></a>\nA connector is represented as a procedural object with local state\nvariables <tt>value</tt>, the current value of the connector; <tt>informant</tt>, the object that set the connector\'s value; and <tt>constraints</tt>, a list of the constraints in which the connector\nparticipates.<p>\n\n<p><p><tt><a name="%_idx_3546"></a>(define&nbsp;(make-connector)<br>\n&nbsp;&nbsp;(let&nbsp;((value&nbsp;false)&nbsp;(informant&nbsp;false)&nbsp;(constraints&nbsp;\'()))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(set-my-value&nbsp;newval&nbsp;setter)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((not&nbsp;(has-value?&nbsp;me))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;value&nbsp;newval)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;informant&nbsp;setter)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for-each-except&nbsp;setter<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inform-about-value<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraints))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((not&nbsp;(=&nbsp;value&nbsp;newval))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Contradiction&quot;&nbsp;(list&nbsp;value&nbsp;newval)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;\'ignored)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(forget-my-value&nbsp;retractor)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;retractor&nbsp;informant)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;informant&nbsp;false)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for-each-except&nbsp;retractor<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inform-about-no-value<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constraints))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'ignored))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(connect&nbsp;new-constraint)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;(memq&nbsp;new-constraint&nbsp;constraints))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;constraints&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;new-constraint&nbsp;constraints)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(has-value?&nbsp;me)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(inform-about-value&nbsp;new-constraint))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'done)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(me&nbsp;request)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;request&nbsp;\'has-value?)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;informant&nbsp;true&nbsp;false))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;request&nbsp;\'value)&nbsp;value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;request&nbsp;\'set-value!)&nbsp;set-my-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;request&nbsp;\'forget)&nbsp;forget-my-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;request&nbsp;\'connect)&nbsp;connect)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;operation&nbsp;--&nbsp;CONNECTOR&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;me))<br>\n</tt><p><p><p>\n\n\nThe connector\'s local procedure <tt>set-my-value</tt> is called when\nthere is a request to set the connector\'s value.  If the connector\ndoes not currently have a value, it will set its value and remember as\n<tt>informant</tt> the constraint that requested the value to be\nset.<a name="call_footnote_Temp_398" href="#footnote_Temp_398"><sup><small>32</small></sup></a>\nThen the connector will notify all of its participating\nconstraints except the constraint that requested the value to be set.\nThis is accomplished using the following iterator, which applies a\ndesignated procedure to all items in a list except a given one:<p>\n\n<p><p><tt><a name="%_idx_3548"></a>(define&nbsp;(for-each-except&nbsp;exception&nbsp;procedure&nbsp;list)<br>\n&nbsp;&nbsp;(define&nbsp;(loop&nbsp;items)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;items)&nbsp;\'done)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;(car&nbsp;items)&nbsp;exception)&nbsp;(loop&nbsp;(cdr&nbsp;items)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(procedure&nbsp;(car&nbsp;items))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(cdr&nbsp;items)))))<br>\n&nbsp;&nbsp;(loop&nbsp;list))<br>\n</tt><p><p><p>\n\nIf a connector is asked to forget its value, it runs the local\nprocedure <tt>forget-my-value</tt>, which first checks to make sure that\nthe request is coming from the same object that set the value\noriginally.  If so, the connector informs its associated constraints\nabout the loss of the value.<p>\n\nThe local procedure <tt>connect</tt> adds the designated new constraint\nto the list of constraints if it is not already in that list.  Then,\nif the connector has a value, it informs the new constraint of this\nfact.<p>\n\nThe connector\'s procedure <tt>me</tt> serves as a dispatch to the other\ninternal procedures and also represents the connector as an object.\nThe following procedures provide a syntax interface for the dispatch:<p>\n\n<p><p><tt><a name="%_idx_3550"></a>(define&nbsp;(has-value?&nbsp;connector)<br>\n&nbsp;&nbsp;(connector&nbsp;\'has-value?))<br>\n<a name="%_idx_3552"></a>(define&nbsp;(get-value&nbsp;connector)<br>\n&nbsp;&nbsp;(connector&nbsp;\'value))<br>\n<a name="%_idx_3554"></a>(define&nbsp;(set-value!&nbsp;connector&nbsp;new-value&nbsp;informant)<br>\n&nbsp;&nbsp;((connector&nbsp;\'set-value!)&nbsp;new-value&nbsp;informant))<br>\n<a name="%_idx_3556"></a>(define&nbsp;(forget-value!&nbsp;connector&nbsp;retractor)<br>\n&nbsp;&nbsp;((connector&nbsp;\'forget)&nbsp;retractor))<br>\n<a name="%_idx_3558"></a>(define&nbsp;(connect&nbsp;connector&nbsp;new-constraint)<br>\n&nbsp;&nbsp;((connector&nbsp;\'connect)&nbsp;new-constraint))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_3.33"></a>\n<b>Exercise 3.33.</b>&nbsp;&nbsp;Using primitive multiplier, adder, and constant constraints, define a\nprocedure <a name="%_idx_3560"></a><tt>averager</tt> that takes three connectors <tt>a</tt>, <tt>b</tt>,\nand <tt>c</tt> as inputs and establishes the constraint that the value of\n<tt>c</tt> is the average of the values of <tt>a</tt> and <tt>b</tt>.\n<p><p>\n\n<p><a name="%_thm_3.34"></a>\n<b>Exercise 3.34.</b>&nbsp;&nbsp;<a name="%_idx_3562"></a>Louis Reasoner wants to build a squarer, a constraint device with two\nterminals such that the value of connector <tt>b</tt> on the second\nterminal will always be the square of the value <tt>a</tt> on the first\nterminal.  He proposes the following simple device made from a\nmultiplier:<p>\n\n\n<p><p><tt>(define&nbsp;(squarer&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(multiplier&nbsp;a&nbsp;a&nbsp;b))<br>\n</tt><p><p>\nThere is a serious flaw in this idea.  Explain.\n\n<p><p>\n\n<p><a name="%_thm_3.35"></a>\n<b>Exercise 3.35.</b>&nbsp;&nbsp;<a name="%_idx_3564"></a>Ben Bitdiddle tells Louis that one way to avoid the trouble in\nexercise&nbsp;<a href="#%_thm_3.34">3.34</a> is to define a squarer as a new\nprimitive constraint.  Fill in the missing portions in Ben\'s outline\nfor a procedure to implement such a constraint:<p>\n\n\n<p><p><tt>(define&nbsp;(squarer&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(define&nbsp;(process-new-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(has-value?&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;(get-value&nbsp;b)&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;square&nbsp;less&nbsp;than&nbsp;0&nbsp;--&nbsp;SQUARER&quot;&nbsp;(get-value&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>alternative1</em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>alternative2</em>&gt;))<br>\n&nbsp;&nbsp;(define&nbsp;(process-forget-value)&nbsp;&lt;<em>body1</em>&gt;)<br>\n&nbsp;&nbsp;(define&nbsp;(me&nbsp;request)&nbsp;&lt;<em>body2</em>&gt;)<br>\n&nbsp;&nbsp;&lt;<em>rest&nbsp;of&nbsp;definition</em>&gt;<br>\n&nbsp;&nbsp;me)<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_3.36"></a>\n<b>Exercise 3.36.</b>&nbsp;&nbsp;Suppose we evaluate the following sequence of expressions in the\nglobal environment:<p>\n\n\n<p><p><tt>(define&nbsp;a&nbsp;(make-connector))<br>\n(define&nbsp;b&nbsp;(make-connector))<br>\n(set-value!&nbsp;a&nbsp;10&nbsp;\'user)<br>\n</tt><p><p>\nAt some time during evaluation of the <tt>set-value!</tt>, the following\nexpression from the connector\'s local procedure is evaluated:<p>\n\n\n<p><p><tt>(for-each-except&nbsp;setter&nbsp;inform-about-value&nbsp;constraints)<br>\n</tt><p><p>\nDraw an environment diagram showing the environment in which the above\nexpression is evaluated.\n<p><p>\n\n\n<p><a name="%_thm_3.37"></a>\n<b>Exercise 3.37.</b>&nbsp;&nbsp;The <tt>celsius-fahrenheit-converter</tt> procedure is cumbersome when\ncompared with a more expression-oriented style of definition, such as<p>\n\n\n<p><p><tt><a name="%_idx_3566"></a>(define&nbsp;(celsius-fahrenheit-converter&nbsp;x)<br>\n&nbsp;&nbsp;(c+&nbsp;(c*&nbsp;(c/&nbsp;(cv&nbsp;9)&nbsp;(cv&nbsp;5))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cv&nbsp;32)))<br>\n(define&nbsp;C&nbsp;(make-connector))<br>\n(define&nbsp;F&nbsp;(celsius-fahrenheit-converter&nbsp;C))<br>\n</tt><p><p>\nHere <tt>c+</tt>, <tt>c*</tt>, etc. are the ``constraint\'\' versions of the\narithmetic operations.  For example, <tt>c+</tt> takes two connectors as\narguments and returns a connector that is related to these by an adder\nconstraint:\n<p>\n\n\n<p><p><tt>(define&nbsp;(c+&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(let&nbsp;((z&nbsp;(make-connector)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(adder&nbsp;x&nbsp;y&nbsp;z)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;z))<br>\n</tt><p><p>\nDefine analogous procedures <tt>c-</tt>, <tt>c*</tt>, <tt>c/</tt>, and <tt>cv</tt>\n(constant value) that enable us to define compound constraints as in\nthe converter example above.<a name="call_footnote_Temp_404" href="#footnote_Temp_404"><sup><small>33</small></sup></a>\n<p>\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_349" href="#call_footnote_Temp_349"><sup><small>16</small></sup></a> <tt>Set-car!</tt> and <tt>set-cdr!</tt> return implementation-dependent\n<a name="%_idx_3148"></a><a name="%_idx_3150"></a><a name="%_idx_3152"></a><a name="%_idx_3154"></a>values.  Like <tt>set!</tt>, they should be used only for their effect.\n\n<p><a name="footnote_Temp_350" href="#call_footnote_Temp_350"><sup><small>17</small></sup></a> We see from this that mutation operations on lists\ncan create ``garbage\'\' that is not part of any accessible structure.\nWe will see in section&nbsp;<a href="book-Z-H-33.html#%_sec_5.3.2">5.3.2</a> that Lisp memory-management\nsystems include a <a name="%_idx_3156"></a><em>garbage collector</em>, which identifies and\nrecycles the memory space used by unneeded pairs.\n\n<p><a name="footnote_Temp_351" href="#call_footnote_Temp_351"><sup><small>18</small></sup></a> <tt>Get-new-pair</tt> is one of the operations that must be implemented as\npart of the memory management required by a Lisp implementation.  We\nwill discuss this in section&nbsp;<a href="book-Z-H-33.html#%_sec_5.3.1">5.3.1</a>.\n\n<p><a name="footnote_Temp_356" href="#call_footnote_Temp_356"><sup><small>19</small></sup></a> The two pairs\nare distinct because each call to <tt>cons</tt> returns a new pair.  The\nsymbols are shared; in Scheme there is a unique symbol with any given\n<a name="%_idx_3184"></a>name.  Since Scheme provides no way to mutate a symbol, this sharing is\nundetectable.  Note also that the sharing is what enables us to\ncompare symbols using <tt>eq?</tt>, which simply checks equality of\npointers.\n\n<p><a name="footnote_Temp_357" href="#call_footnote_Temp_357"><sup><small>20</small></sup></a> The\nsubtleties of dealing with sharing of mutable data objects reflect the\nunderlying issues of ``sameness\'\' and ``change\'\' that were raised in\nsection&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a>.  We mentioned there that\nadmitting change to our language requires that a compound object must\nhave an ``identity\'\' that is something different from the pieces from\nwhich it is composed.  In Lisp, we consider this ``identity\'\' to be\nthe quality that is tested by <tt>eq?</tt>, i.e., by equality of\npointers.  Since in most Lisp implementations a pointer is\nessentially a memory address, we are ``solving the problem\'\' of\ndefining the identity of objects by stipulating that a data object\n``itself\'\' is the information stored in some particular set of memory\nlocations in the computer.  This suffices for simple Lisp programs,\nbut is hardly a general way to resolve the issue of ``sameness\'\' in\ncomputational models.\n\n<p><a name="footnote_Temp_364" href="#call_footnote_Temp_364"><sup><small>21</small></sup></a> On the other hand, from the\nviewpoint of implementation, assignment requires us to modify the\nenvironment, which is itself a mutable data structure.  Thus,\nassignment and mutation are equipotent: Each can be implemented in\nterms of the other.\n\n<p><a name="footnote_Temp_366" href="#call_footnote_Temp_366"><sup><small>22</small></sup></a> If the first item is\nthe final item in the queue, the front pointer will be the empty list after\nthe deletion, which will mark the queue as empty; we needn\'t worry\nabout updating the rear pointer, which will still point to the deleted\nitem, because <tt>empty-queue?</tt> looks only at the front pointer.\n\n<p><a name="footnote_Temp_370" href="#call_footnote_Temp_370"><sup><small>23</small></sup></a> Be careful not to\nmake the interpreter try to print a structure that contains cycles.\n(See exercise&nbsp;<a href="#%_thm_3.13">3.13</a>.)\n\n<p><a name="footnote_Temp_371" href="#call_footnote_Temp_371"><sup><small>24</small></sup></a> Because <tt>assoc</tt>\nuses <tt>equal?</tt>, it can recognize keys that are symbols, numbers,\nor list structure.\n\n<p><a name="footnote_Temp_372" href="#call_footnote_Temp_372"><sup><small>25</small></sup></a> Thus, the first backbone pair is the\nobject that represents the table ``itself\'\'; that is, a pointer to the\ntable is a pointer to this pair.  This same backbone pair always\nstarts the table.  If we did not arrange things in this way, <tt>insert!</tt> would have to return a new value for the start of the table\nwhen it added a new record.\n\n<p><a name="footnote_Temp_379" href="#call_footnote_Temp_379"><sup><small>26</small></sup></a> A\nfull-adder is a basic circuit element used in adding two binary\nnumbers.  Here A and B are the bits at corresponding positions in the\ntwo numbers to be added, and C<sub><em>i</em><em>n</em></sub> is the carry bit from the\naddition one place to the right.  The circuit generates SUM, which is\nthe sum bit in the corresponding position, and C<sub><em>o</em><em>u</em><em>t</em></sub>, which is the\ncarry bit to be propagated to the left.\n\n<p><a name="footnote_Temp_385" href="#call_footnote_Temp_385"><sup><small>27</small></sup></a> These procedures are simply syntactic sugar that allow\n<a name="%_idx_3400"></a><a name="%_idx_3402"></a>us to use ordinary procedural syntax to access the local procedures of\nobjects.  It is striking that we can interchange the role of\n``procedures\'\' and ``data\'\' in such a simple way.  For example, if we\nwrite <tt>(wire \'get-signal)</tt> we think of <tt>wire</tt> as a procedure\nthat is called with the message <tt>get-signal</tt> as input.\nAlternatively, writing <tt>(get-signal wire)</tt> encourages us to think\nof <tt>wire</tt> as a data object that is the input to a procedure <tt>get-signal</tt>.  The truth of the matter is that, in a language in which\nwe can deal with procedures as objects, there is no fundamental\ndifference between ``procedures\'\' and ``data,\'\' and we can choose our\nsyntactic sugar to allow us to program in whatever style we choose.\n\n\n<p><a name="footnote_Temp_390" href="#call_footnote_Temp_390"><sup><small>28</small></sup></a> The\nagenda is a <a name="%_idx_3452"></a><a name="%_idx_3454"></a>headed list, like the tables in section&nbsp;<a href="#%_sec_3.3.3">3.3.3</a>,\nbut since the list is headed by the time, we do not need an additional\ndummy header (such as the <tt>*table*</tt> symbol used with tables).\n\n<p><a name="footnote_Temp_391" href="#call_footnote_Temp_391"><sup><small>29</small></sup></a> Observe that the <tt>if</tt> expression in\nthis procedure has no\n&lt;<em>alternative</em>&gt; expression.  Such a ``one-armed <tt>if</tt> statement\'\'\n<a name="%_idx_3474"></a><a name="%_idx_3476"></a>is used to decide whether to do something, rather than to select\nbetween two expressions.  An <tt>if</tt> expression returns an\nunspecified value if the predicate is false and there is no\n&lt;<em>alternative</em>&gt;.\n\n<p><a name="footnote_Temp_392" href="#call_footnote_Temp_392"><sup><small>30</small></sup></a> In this way, the current time will always be the time\nof the action most recently processed.  Storing this time at the head\nof the agenda ensures that it will still be available even if the\nassociated time segment has been deleted.\n\n<p><a name="footnote_Temp_394" href="#call_footnote_Temp_394"><sup><small>31</small></sup></a> Constraint propagation\nfirst appeared in the incredibly forward-looking <a name="%_idx_3486"></a>SKETCHPAD system of\n<a name="%_idx_3488"></a>Ivan Sutherland (1963).  A beautiful constraint-propagation system\nbased on the <a name="%_idx_3490"></a>Smalltalk language was developed by <a name="%_idx_3492"></a>Alan Borning (1977)\nat <a name="%_idx_3494"></a>Xerox Palo Alto Research Center.  Sussman, Stallman, and Steele\n<a name="%_idx_3496"></a><a name="%_idx_3498"></a><a name="%_idx_3500"></a><a name="%_idx_3502"></a><a name="%_idx_3504"></a><a name="%_idx_3506"></a>applied constraint propagation to electrical circuit analysis (Sussman\nand Stallman 1975; Sussman and Steele 1980). TK!Solver (Konopasek and\nJayaraman 1984) is an extensive modeling environment based on\nconstraints.\n\n<p><a name="footnote_Temp_398" href="#call_footnote_Temp_398"><sup><small>32</small></sup></a> The <tt>setter</tt> might not be a constraint.  In our\ntemperature example, we used <tt>user</tt> as the <tt>setter</tt>.\n\n<p><a name="footnote_Temp_404" href="#call_footnote_Temp_404"><sup><small>33</small></sup></a> The expression-oriented format\nis convenient because it avoids the need to name the intermediate\nexpressions in a computation.  Our original formulation of the\n<a name="%_idx_3568"></a><a name="%_idx_3570"></a><a name="%_idx_3572"></a><a name="%_idx_3574"></a><a name="%_idx_3576"></a>constraint language is cumbersome in the same way that many languages\nare cumbersome when dealing with operations on compound data.  For\nexample, if we wanted to compute the product (<em>a</em> + <em>b</em>) &middot; (<em>c</em> + <em>d</em>), where the\nvariables represent vectors, we could work in ``imperative style,\'\'\nusing procedures that set the values of designated vector arguments\nbut do not themselves return vectors as values:\n<p><p><tt>(v-sum&nbsp;a&nbsp;b&nbsp;temp1)<br>\n(v-sum&nbsp;c&nbsp;d&nbsp;temp2)<br>\n(v-prod&nbsp;temp1&nbsp;temp2&nbsp;answer)<br>\n</tt><p><p>\nAlternatively, we could deal with expressions, using\nprocedures that return vectors as values, and thus avoid\nexplicitly mentioning <tt>temp1</tt> and <tt>temp2</tt>:\n<p><p><tt>(define&nbsp;answer&nbsp;(v-prod&nbsp;(v-sum&nbsp;a&nbsp;b)&nbsp;(v-sum&nbsp;c&nbsp;d)))<br>\n</tt><p><p>\nSince Lisp allows us to return compound objects as values of\nprocedures, we can transform our imperative-style constraint language\ninto an expression-oriented style as shown in this exercise.  In\nlanguages that are impoverished in handling compound objects, such as\nAlgol, Basic, and Pascal (unless one explicitly uses Pascal pointer\nvariables), one is usually stuck with the imperative style when\nmanipulating compound objects.  Given the advantage of the\nexpression-oriented format, one might ask if there is any reason to\nhave implemented the system in imperative style, as we did in this\nsection.  One reason is that the non-expression-oriented constraint\nlanguage provides a handle on constraint objects (e.g., the value of\nthe <tt>adder</tt> procedure) as well as on connector objects.  This is\nuseful if we wish to extend the system with new operations that\ncommunicate with constraints directly rather than only indirectly via\noperations on connectors.  Although it is easy to implement the\nexpression-oriented style in terms of the imperative implementation,\nit is very difficult to do the converse.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_3.4"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_3.4">3.4&nbsp;&nbsp;Concurrency: Time Is of the Essence</a></h2><p>\n\n\n<a name="%_idx_3578"></a>\nWe\'ve seen the power of computational objects with local state as\ntools for modeling.  Yet, as section&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a>\nwarned, this power extracts a price: the loss of referential\ntransparency, giving rise to a thicket of questions about sameness and\nchange, and the need to abandon the substitution model of evaluation in\nfavor of the more intricate environment model.<p>\n\n<a name="%_idx_3580"></a>The central issue lurking beneath the complexity of state, sameness,\nand change is that by introducing assignment we are forced to admit\n<em>time</em> into our computational models.  Before we introduced\nassignment, all our programs were timeless, in the sense that any\nexpression that has a value always has the same value.  In contrast,\nrecall the example of modeling withdrawals from a bank account\nand returning the resulting balance,\nintroduced at the beginning of\nsection&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:<p>\n\n<p><p><tt>(withdraw&nbsp;25)<br>\n<i>75</i><br>\n(withdraw&nbsp;25)<br>\n<i>50</i><br>\n</tt><p><p>\nHere successive evaluations of the same expression yield different\nvalues.  This behavior arises from the fact that the execution of\nassignment statements (in this case, assignments to the variable <tt>balance</tt>) delineates <em>moments in time</em> when values change.  The\nresult of evaluating an expression depends not only on the expression\nitself, but also on whether the evaluation occurs before or after\nthese moments.  Building models in terms of computational objects with\nlocal state forces us to confront time as an essential concept in\nprogramming.<p>\n\nWe can go further in structuring computational models to match our\nperception of the physical world.  Objects in the world do not change\none at a time in sequence.  Rather we perceive them as acting <em>concurrently</em> -- all at once.  So it is often natural to model systems\nas collections of computational processes that execute concurrently.\nJust as we can make our programs modular by organizing models in\nterms of objects with separate local state, it is often appropriate to\ndivide computational models into parts that evolve separately and\nconcurrently.  Even if the programs are to be executed on a sequential\ncomputer, the practice of writing programs as if they were to be\nexecuted concurrently forces the programmer to avoid inessential\ntiming constraints and thus makes programs more modular.<p>\n\nIn addition to making programs more modular, concurrent computation\ncan provide a speed advantage over sequential computation.  Sequential\ncomputers execute only one operation at a time, so the amount of time\nit takes to perform a task is proportional to the total number of\noperations performed.<a name="call_footnote_Temp_405" href="#footnote_Temp_405"><sup><small>34</small></sup></a>\nHowever, if it is possible to decompose a problem into pieces that are\nrelatively independent and need to communicate only rarely, it may be\npossible to allocate pieces to separate computing processors,\nproducing a speed advantage proportional to the number of processors\navailable.<p>\n\nUnfortunately, the complexities introduced by assignment become even\nmore problematic in the presence of concurrency.  The fact of\nconcurrent execution, either because the world operates in parallel or\nbecause our computers do, entails additional complexity in our\nunderstanding of time.<p>\n\n<a name="%_sec_3.4.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.4.1">3.4.1&nbsp;&nbsp;The Nature of Time in Concurrent Systems</a></h3><p>\n\n\n<a name="%_idx_3584"></a>\nOn the surface, time seems straightforward.  It\nis an ordering imposed on events.<a name="call_footnote_Temp_406" href="#footnote_Temp_406"><sup><small>35</small></sup></a>\nFor any events <em>A</em> and <em>B</em>, either <em>A</em> occurs before <em>B</em>, <em>A</em>&nbsp;and&nbsp;<em>B</em>\nare simultaneous, or <em>A</em> occurs after <em>B</em>.  For instance,\nreturning to the bank account example, suppose that Peter withdraws\n$10 and Paul withdraws $25 from a <a name="%_idx_3588"></a>joint account that initially\ncontains $100, leaving $65 in the account.  Depending on the order\nof the two withdrawals, the sequence of balances in the account is\neither $100 <img src="book-Z-G-D-15.gif" border="0"> $90 <img src="book-Z-G-D-15.gif" border="0"> $65 or\n$100 <img src="book-Z-G-D-15.gif" border="0"> $75 <img src="book-Z-G-D-15.gif" border="0"> $65.  In a computer implementation\nof the banking system, this changing sequence of balances could be\nmodeled by successive assignments to a variable <tt>balance</tt>.<p>\n\nIn complex situations, however, such a view can be problematic.\nSuppose that Peter and Paul, and other people besides, are\naccessing the same bank account through a network of banking machines\ndistributed all over the world.  The actual sequence of balances in\nthe account will depend critically on the detailed timing of the\naccesses and the details of the communication among the machines.<p>\n\n<a name="%_idx_3590"></a>This indeterminacy in the order of events can pose serious problems in\nthe design of concurrent systems.  For instance, suppose that the\nwithdrawals made by Peter and Paul are implemented as two separate\nprocesses sharing a common variable <tt>balance</tt>, each process\nspecified by the procedure given in\nsection&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:\n\n<p><p><tt><a name="%_idx_3592"></a>(define&nbsp;(withdraw&nbsp;amount)<br>\n&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;))<br>\n</tt><p><p>\nIf the two processes operate independently, then Peter might test the\nbalance and attempt to withdraw a legitimate amount.  However, Paul\nmight withdraw some funds in between the time that Peter checks the\nbalance and the time Peter completes the withdrawal, thus invalidating\nPeter\'s test.<p>\n\nThings can be worse still.  Consider the expression\n\n<p><p><tt>(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n</tt><p><p>\nexecuted as part of each withdrawal process.  This consists of three\nsteps: (1) accessing the value of the <tt>balance</tt> variable; (2)\ncomputing the new balance; (3) setting <tt>balance</tt> to this new\nvalue.  If Peter and Paul\'s withdrawals execute this statement\nconcurrently, then the two withdrawals might interleave the order in\nwhich they access <tt>balance</tt> and set it to the new value.<p>\n\n\nThe timing diagram in figure&nbsp;<a href="#%_fig_3.29">3.29</a> depicts an order of\nevents where <tt>balance</tt> starts at 100, Peter withdraws 10,\nPaul withdraws 25, and yet the final value of <tt>balance</tt> is 75.  As\nshown in the diagram, the reason for this anomaly is that Paul\'s\nassignment of 75 to <tt>balance</tt> is made under the assumption that\nthe value of <tt>balance</tt> to be decremented is 100.  That assumption,\nhowever, became invalid when Peter changed <tt>balance</tt> to 90.  This\nis a catastrophic failure for the banking system, because the total\namount of money in the system is not conserved.  Before the transactions,\nthe total amount of money was $100.  Afterwards, Peter has $10, Paul\nhas $25, and the bank has $75.<a name="call_footnote_Temp_407" href="#footnote_Temp_407"><sup><small>36</small></sup></a><p>\n\n\n<a name="%_idx_3596"></a><a name="%_idx_3598"></a>The general phenomenon illustrated\nhere is that several processes may share  a\ncommon state variable.  What makes this complicated is that more than\none process may be trying to manipulate the shared state at the same\ntime.  For the bank account example, during each transaction, each\ncustomer should be able to act as if the other customers did not\nexist.  When a customer changes the balance in a way that depends on\nthe balance, he must be able to assume that, just before the moment of\nchange, the balance is still what he thought it was.<p>\n\n\n<a name="%_sec_Temp_408"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_408">Correct behavior of concurrent programs</a></h4><p>\n\n<a name="%_idx_3600"></a>\nThe above example typifies the subtle bugs that can creep into\nconcurrent programs.  The root of this complexity lies in the\nassignments to variables that are shared among the different\nprocesses.  We already know that we must be careful in writing\nprograms that use <tt>set!</tt>, because the results of a computation\ndepend on the order in which the assignments occur.<a name="call_footnote_Temp_409" href="#footnote_Temp_409"><sup><small>37</small></sup></a>\nWith concurrent processes we must be especially careful about\nassignments, because we may not be able to control the order of the\nassignments made by the different processes.  If several such changes\nmight be made concurrently (as with two depositors accessing a joint\naccount) we need some way to ensure that our system behaves correctly.\nFor example, in the case of withdrawals from a joint bank account, we\nmust ensure that money is conserved.\nTo make concurrent programs behave correctly, we may have to\nplace some restrictions on concurrent execution.<p>\n\n<a name="%_fig_3.29"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-31.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.29:</b>&nbsp;&nbsp;Timing diagram showing how interleaving the order of events\nin two banking withdrawals can lead to an incorrect final balance.</div></caption><tr><td>\n<a name="%_idx_3602"></a>\n</td></tr></table></div><p>\n\nOne possible restriction on concurrency would\nstipulate that no two operations that\nchange any shared state variables can occur at the same time.  This is an\nextremely stringent requirement.  For distributed banking, it would\nrequire the system designer to ensure that only one transaction could\nproceed at a time.  This would be both inefficient and overly\nconservative.  Figure&nbsp;<a href="#%_fig_3.30">3.30</a> shows Peter and\nPaul sharing a bank account, where Paul has a private account as well.\nThe diagram illustrates two withdrawals from the shared account\n(one by Peter and one by Paul) and a deposit to Paul\'s private account.<a name="call_footnote_Temp_410" href="#footnote_Temp_410"><sup><small>38</small></sup></a>\nThe two withdrawals from the shared account must not be\nconcurrent (since both access and update the same account), and Paul\'s\ndeposit and withdrawal must not be concurrent (since both access and\nupdate the amount in Paul\'s wallet).\nBut there should be no problem\npermitting Paul\'s deposit to his private account to proceed\nconcurrently with Peter\'s withdrawal from the shared account.<p>\n\n<a name="%_fig_3.30"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-32.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.30:</b>&nbsp;&nbsp;Concurrent deposits and withdrawals from a joint account\nin Bank1 and a private account in Bank2.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nA less stringent restriction on concurrency would ensure that a\nconcurrent system produces the same result\nas if the processes had run sequentially in some order.\nThere are two important aspects to this requirement.\nFirst, it does not require the processes to actually run sequentially,\nbut only to produce results that are the same <em>as if</em> they had run\nsequentially.  For the example in\nfigure&nbsp;<a href="#%_fig_3.30">3.30</a>, the designer of the bank account\nsystem can safely allow Paul\'s deposit and Peter\'s withdrawal to\nhappen concurrently, because the net result will be the same as if the\ntwo operations had happened sequentially.  Second, there may be more\nthan one possible ``correct\'\' result produced by a concurrent program,\nbecause we require only that the result be the same as for <em>some</em>\nsequential order.\nFor example, suppose that Peter and Paul\'s joint account starts out\nwith $100, and Peter deposits $40 while Paul concurrently withdraws\nhalf the money in the account.\nThen sequential execution could result in the account balance being\neither $70 or $90 (see exercise&nbsp;<a href="#%_thm_3.38">3.38</a>).<a name="call_footnote_Temp_411" href="#footnote_Temp_411"><sup><small>39</small></sup></a><p>\n\nThere are still weaker requirements for correct execution of\nconcurrent programs.  A program for simulating <a name="%_idx_3606"></a>diffusion (say, the\nflow of heat in an object) might consist of a large number of\nprocesses, each one representing a small volume of space, that update\ntheir values concurrently.  Each process repeatedly changes its\nvalue to the average of its own value and its neighbors\' values.\nThis algorithm\nconverges to the right answer independent of the order in which the\noperations are done; there is no need for any restrictions on\nconcurrent use of the shared values.<p>\n\n<p><a name="%_thm_3.38"></a>\n<b>Exercise 3.38.</b>&nbsp;&nbsp;Suppose that Peter, Paul, and Mary share a joint bank account that\ninitially contains $100.  Concurrently, Peter deposits $10, Paul\nwithdraws $20, and Mary withdraws half the money in the account, by\nexecuting the following commands:\n<table border=0><tr><td valign=top >Peter: </td><td valign=top ><tt>(set! balance (+ balance 10))</tt></td></tr>\n<tr><td valign=top >Paul: </td><td valign=top ><tt>(set! balance (- balance 20))</tt></td></tr>\n<tr><td valign=top >Mary: </td><td valign=top ><tt>(set! balance (- balance (/ balance 2)))</tt>\n</td></tr></table><p>\n\n<p><p>a. List all the different possible values for <tt>balance</tt> after these\nthree transactions have been completed, assuming that the banking\nsystem forces the three processes to run sequentially in some order.<p>\n\n<p><p>b. What are some other values\nthat could be produced if the system allows the processes to be interleaved?\nDraw timing diagrams like the one in figure&nbsp;<a href="#%_fig_3.29">3.29</a> to\nexplain how these values can occur.\n\n<p>\n\n<a name="%_sec_3.4.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.4.2">3.4.2&nbsp;&nbsp;Mechanisms for Controlling Concurrency</a></h3><p>\n\n<a name="%_idx_3608"></a>\nWe\'ve seen that the difficulty in dealing with concurrent processes is\nrooted in the need to consider the interleaving of the order of events\nin the different processes.  For example, suppose we have two\nprocesses, one with three ordered events (<em>a</em>,<em>b</em>,<em>c</em>) and one with three\nordered events (<em>x</em>,<em>y</em>,<em>z</em>).  If the two processes run concurrently, with\nno constraints on how their execution is interleaved, then there are\n20 different possible orderings for the events that are consistent\nwith the individual orderings for the two processes:\n<p><div align=left><img src="ch3-Z-G-33.gif" border="0"></div><p>\nAs programmers designing this system, we would have to consider the\neffects of each of these 20 orderings and check that each behavior is\nacceptable.  Such an approach rapidly becomes unwieldy as the numbers\nof processes and events increase.<p>\n\nA more practical approach to the design of concurrent systems is to\ndevise general mechanisms that allow us to constrain the interleaving\nof concurrent processes so that we can be sure that the program\nbehavior is correct.  Many mechanisms have been developed for this\npurpose.  In this section, we describe one of them, the <em>serializer</em>.<p>\n\n<a name="%_sec_Temp_413"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_413">Serializing access to shared state</a></h4><p>\n\n<a name="%_idx_3610"></a>\nSerialization implements the following idea: Processes will execute\nconcurrently, but there will be certain collections of procedures that\ncannot be executed concurrently.  More precisely, serialization creates\ndistinguished sets of procedures such that only one execution of a\nprocedure in each serialized set is permitted to happen at a time.\nIf some procedure in the set is being executed, then a process that\nattempts to execute any procedure in the set will be forced to wait\nuntil the first execution has finished.<p>\n\nWe can use serialization to control access to shared variables.\nFor example, if we want to update a shared variable based on the\nprevious value of that variable, we put the access to the previous\nvalue of the variable and the assignment of the new value to the\nvariable in the same procedure.  We then ensure that no other\nprocedure that assigns to the variable can run concurrently with this\nprocedure by serializing all of these procedures with the same\nserializer.  This guarantees that the value of the variable cannot be\nchanged between an access and the corresponding assignment.<p>\n\n<a name="%_sec_Temp_414"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_414">Serializers in Scheme</a></h4><p>\n\nTo make the above mechanism more concrete, suppose that we have\nextended Scheme to include a procedure called <a name="%_idx_3612"></a><tt>parallel-execute</tt>:<p>\n\n<p><p><tt>(parallel-execute&nbsp;&lt;<em>p<sub>1</sub></em>&gt;&nbsp;&lt;<em>p<sub>2</sub></em>&gt;&nbsp;<tt>...</tt> &lt;<em>p<sub><em>k</em></sub></em>&gt;)<br>\n</tt><p><p>\nEach &lt;<em>p</em>&gt; must be a procedure of no arguments.  <tt>Parallel-execute</tt>\ncreates a separate process for each\n&lt;<em>p</em>&gt;, which applies &lt;<em>p</em>&gt; (to no arguments).  These processes all\nrun concurrently.<a name="call_footnote_Temp_415" href="#footnote_Temp_415"><sup><small>40</small></sup></a><p>\n\nAs an example of how this is used, consider<p>\n\n<p><p><tt>(define&nbsp;x&nbsp;10)<br>\n<br>\n(parallel-execute&nbsp;(lambda&nbsp;()&nbsp;(set!&nbsp;x&nbsp;(*&nbsp;x&nbsp;x)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;x&nbsp;1))))<br>\n</tt><p><p>\nThis creates two concurrent processes -- <em>P</em><sub>1</sub>, which sets <tt>x</tt> to\n<tt>x</tt> times <tt>x</tt>, and <em>P</em><sub>2</sub>, which increments <tt>x</tt>.  After\nexecution is complete, <tt>x</tt> will be left with one of five possible\nvalues, depending on the interleaving of the events of <em>P</em><sub>1</sub> and\n<em>P</em><sub>2</sub>:\n<table border=0><tr><td valign=top >101: </td><td valign=top ><em>P</em><sub>1</sub> sets <tt>x</tt> to 100 and then <em>P</em><sub>2</sub> increments <tt>x</tt> to 101.</td></tr>\n<tr><td valign=top >121: </td><td valign=top ><em>P</em><sub>2</sub> increments <tt>x</tt> to 11 and then <em>P</em><sub>1</sub> sets <tt>x</tt> to\n<tt>x</tt> times <tt>x</tt>.</td></tr>\n<tr><td valign=top >110: </td><td valign=top ><em>P</em><sub>2</sub> changes <tt>x</tt> from 10 to 11 between the two times that\n<em>P</em><sub>1</sub> accesses the value of <tt>x</tt> during the evaluation of <tt>(* x x)</tt>.</td></tr>\n<tr><td valign=top >11:  </td><td valign=top ><em>P</em><sub>2</sub> accesses <tt>x</tt>, then <em>P</em><sub>1</sub> sets <tt>x</tt> to 100,\nthen <em>P</em><sub>2</sub> sets <tt>x</tt>.</td></tr>\n<tr><td valign=top >100: </td><td valign=top ><em>P</em><sub>1</sub> accesses <tt>x</tt> (twice), then <em>P</em><sub>2</sub> sets <tt>x</tt> to 11,\nthen <em>P</em><sub>1</sub> sets <tt>x</tt>.</td></tr>\n<tr><td valign=top ></td></tr></table><p>\n\n\nWe can constrain the concurrency by using serialized procedures,\nwhich are created by <em>serializers</em>. Serializers are constructed by <tt>make-serializer</tt>, whose implementation is given below.  A serializer\ntakes a procedure as argument and returns a serialized procedure that\nbehaves like the original procedure.  All calls to a given serializer\nreturn serialized procedures in the same set.<p>\n\nThus, in contrast to the example above, executing<p>\n\n\n<p><p><tt>(define&nbsp;x&nbsp;10)<br>\n<br>\n(define&nbsp;s&nbsp;(make-serializer))<br>\n<br>\n(parallel-execute&nbsp;(s&nbsp;(lambda&nbsp;()&nbsp;(set!&nbsp;x&nbsp;(*&nbsp;x&nbsp;x))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s&nbsp;(lambda&nbsp;()&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;x&nbsp;1)))))<br>\n</tt><p><p>\ncan produce only two possible values for <tt>x</tt>, 101 or 121.  The\nother possibilities are eliminated, because the execution of <em>P</em><sub>1</sub> and\n<em>P</em><sub>2</sub> cannot be interleaved.<p>\n\nHere is a version of the <tt>make-account</tt> procedure from\nsection&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>, where the deposits and\nwithdrawals have been serialized:<p>\n\n\n<p><p><tt><a name="%_idx_3614"></a><a name="%_idx_3616"></a>(define&nbsp;(make-account&nbsp;balance)<br>\n&nbsp;&nbsp;(define&nbsp;(withdraw&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;))<br>\n&nbsp;&nbsp;(define&nbsp;(deposit&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;balance&nbsp;(+&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;(let&nbsp;((protected&nbsp;(make-serializer)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;m&nbsp;\'withdraw)&nbsp;(protected&nbsp;withdraw))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'deposit)&nbsp;(protected&nbsp;deposit))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'balance)&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;MAKE-ACCOUNT&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dispatch))<br>\n</tt><p><p>\nWith this implementation, two processes cannot be withdrawing from or\ndepositing into a single account concurrently.  This eliminates the source\nof the error illustrated in figure&nbsp;<a href="#%_fig_3.29">3.29</a>, where Peter\nchanges the account balance between the times when Paul accesses the\nbalance to compute the new value and when Paul actually performs the\nassignment.  On the other hand, each account has its own serializer,\nso that deposits and withdrawals for different accounts can proceed\nconcurrently.<p>\n\n\n<p><a name="%_thm_3.39"></a>\n<b>Exercise 3.39.</b>&nbsp;&nbsp;Which of the five possibilities in the parallel execution shown above\nremain if we instead serialize execution as follows:<p>\n\n\n<p><p><tt>(define&nbsp;x&nbsp;10)<br>\n<br>\n(define&nbsp;s&nbsp;(make-serializer))<br>\n<br>\n(parallel-execute&nbsp;(lambda&nbsp;()&nbsp;(set!&nbsp;x&nbsp;((s&nbsp;(lambda&nbsp;()&nbsp;(*&nbsp;x&nbsp;x))))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s&nbsp;(lambda&nbsp;()&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;x&nbsp;1)))))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_3.40"></a>\n<b>Exercise 3.40.</b>&nbsp;&nbsp;Give all possible values of <tt>x</tt> that can result from executing<p>\n\n\n<p><p><tt>(define&nbsp;x&nbsp;10)<br>\n<br>\n(parallel-execute&nbsp;(lambda&nbsp;()&nbsp;(set!&nbsp;x&nbsp;(*&nbsp;x&nbsp;x)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(set!&nbsp;x&nbsp;(*&nbsp;x&nbsp;x&nbsp;x))))<br>\n</tt><p><p>\nWhich of these possibilities remain if we instead use serialized\nprocedures:<p>\n\n\n<p><p><tt>(define&nbsp;x&nbsp;10)<br>\n<br>\n(define&nbsp;s&nbsp;(make-serializer))<br>\n<br>\n(parallel-execute&nbsp;(s&nbsp;(lambda&nbsp;()&nbsp;(set!&nbsp;x&nbsp;(*&nbsp;x&nbsp;x))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s&nbsp;(lambda&nbsp;()&nbsp;(set!&nbsp;x&nbsp;(*&nbsp;x&nbsp;x&nbsp;x)))))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_3.41"></a>\n<b>Exercise 3.41.</b>&nbsp;&nbsp;Ben Bitdiddle worries that it would be better to implement the bank\naccount as follows (where the commented line has been changed):<p>\n\n\n<p><p><tt><a name="%_idx_3618"></a>(define&nbsp;(make-account&nbsp;balance)<br>\n&nbsp;&nbsp;(define&nbsp;(withdraw&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;))<br>\n&nbsp;&nbsp;(define&nbsp;(deposit&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;balance&nbsp;(+&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;<em>;;&nbsp;continued&nbsp;on&nbsp;next&nbsp;page</em><br>\n<br>\n&nbsp;&nbsp;(let&nbsp;((protected&nbsp;(make-serializer)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;m&nbsp;\'withdraw)&nbsp;(protected&nbsp;withdraw))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'deposit)&nbsp;(protected&nbsp;deposit))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((protected&nbsp;(lambda&nbsp;()&nbsp;balance))))&nbsp;<em>;&nbsp;serialized</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;MAKE-ACCOUNT&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dispatch))<br>\n</tt><p><p>\nbecause allowing unserialized access to the bank balance can result in\nanomalous behavior.  Do you agree?  Is there any scenario that\ndemonstrates Ben\'s concern?\n<p><p>\n\n<p><a name="%_thm_3.42"></a>\n<b>Exercise 3.42.</b>&nbsp;&nbsp;Ben Bitdiddle suggests that it\'s a waste of time to create a new\nserialized procedure in response to every <tt>withdraw</tt> and <tt>deposit</tt> message.  He says that <tt>make-account</tt> could be changed so\nthat the calls to <tt>protected</tt> are done outside the <tt>dispatch</tt>\nprocedure.  That is, an account would return the same serialized\nprocedure (which was created at the same time as the account) each time\nit is asked for a withdrawal procedure.\n<p><p><tt><a name="%_idx_3620"></a>(define&nbsp;(make-account&nbsp;balance)<br>\n&nbsp;&nbsp;(define&nbsp;(withdraw&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;))<br>\n&nbsp;&nbsp;(define&nbsp;(deposit&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;balance&nbsp;(+&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;(let&nbsp;((protected&nbsp;(make-serializer)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((protected-withdraw&nbsp;(protected&nbsp;withdraw))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(protected-deposit&nbsp;(protected&nbsp;deposit)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;m&nbsp;\'withdraw)&nbsp;protected-withdraw)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'deposit)&nbsp;protected-deposit)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'balance)&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;MAKE-ACCOUNT&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch)))<br>\n</tt><p><p>\nIs this a safe change to make?  In particular, is there any difference in\nwhat concurrency is allowed by these two versions of <tt>make-account</tt> ?\n<p>\n\n<a name="%_sec_Temp_420"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_420">Complexity of using multiple shared resources</a></h4><p>\n\n<a name="%_idx_3622"></a><a name="%_idx_3624"></a>\nSerializers provide a powerful abstraction that helps isolate the\ncomplexities of concurrent programs so that they can be dealt with\ncarefully and (hopefully) correctly.  However, while using serializers\nis relatively straightforward when there is only a single shared\nresource (such as a single bank account), concurrent programming can\nbe treacherously difficult when there are multiple shared resources.<p>\n\nTo illustrate one of the difficulties that can arise, suppose we wish to swap\nthe balances in two bank accounts.  We access each account to find the\nbalance, compute the difference between the balances, withdraw this\ndifference from one account, and deposit it in the other account.  We\ncould implement this as follows:<a name="call_footnote_Temp_421" href="#footnote_Temp_421"><sup><small>41</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_3626"></a><a name="%_idx_3628"></a>(define&nbsp;(exchange&nbsp;account1&nbsp;account2)<br>\n&nbsp;&nbsp;(let&nbsp;((difference&nbsp;(-&nbsp;(account1&nbsp;\'balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(account2&nbsp;\'balance))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;((account1&nbsp;\'withdraw)&nbsp;difference)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;((account2&nbsp;\'deposit)&nbsp;difference)))<br>\n</tt><p><p><p>\n\nThis procedure works well when only a single process is trying to do\nthe exchange.  Suppose, however, that Peter and Paul both have access\nto accounts <em>a</em>1, <em>a</em>2, and <em>a</em>3, and that\nPeter exchanges <em>a</em>1 and\n<em>a</em>2 while Paul concurrently exchanges <em>a</em>1 and <em>a</em>3.\nEven with account deposits and withdrawals\nserialized for individual accounts (as in the <tt>make-account</tt>\nprocedure shown above in this section), <tt>exchange</tt> can still\nproduce incorrect results.  For example, Peter might compute the\ndifference in the balances for <em>a</em>1 and <em>a</em>2, but then Paul\nmight change the balance in <em>a</em>1 before Peter is able to complete\nthe exchange.<a name="call_footnote_Temp_422" href="#footnote_Temp_422"><sup><small>42</small></sup></a>\nFor correct behavior, we must arrange for the <tt>exchange</tt> procedure\nto lock out any other concurrent accesses to the accounts during the\nentire time of the exchange.<p>\n\nOne way we can accomplish this is by using both accounts\' serializers\nto serialize the entire <tt>exchange</tt> procedure.\nTo do this, we will arrange for access to an account\'s serializer.\nNote that we are deliberately\nbreaking the modularity of the bank-account object by exposing the\nserializer.  The following version of <tt>make-account</tt> is identical\nto the original version given in\nsection&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>, except that a serializer is\nprovided to protect the balance variable, and the serializer is\nexported via message passing:<p>\n\n<p><p><tt><a name="%_idx_3630"></a>(define&nbsp;(make-account-and-serializer&nbsp;balance)<br>\n&nbsp;&nbsp;(define&nbsp;(withdraw&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;))<br>\n&nbsp;&nbsp;(define&nbsp;(deposit&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;balance&nbsp;(+&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;(let&nbsp;((balance-serializer&nbsp;(make-serializer)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;m&nbsp;\'withdraw)&nbsp;withdraw)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'deposit)&nbsp;deposit)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'balance)&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'serializer)&nbsp;balance-serializer)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;MAKE-ACCOUNT&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dispatch))<br>\n</tt><p><p><p>\n\n\nWe can use this to do serialized deposits and withdrawals.  However,\nunlike our earlier serialized account, it is now the responsibility of\neach user of bank-account objects to explicitly manage the\nserialization, for example as follows:<a name="call_footnote_Temp_423" href="#footnote_Temp_423"><sup><small>43</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_3632"></a>(define&nbsp;(deposit&nbsp;account&nbsp;amount)<br>\n&nbsp;&nbsp;(let&nbsp;((s&nbsp;(account&nbsp;\'serializer))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(d&nbsp;(account&nbsp;\'deposit)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;((s&nbsp;d)&nbsp;amount)))<br>\n</tt><p><p><p>\n\nExporting the serializer in this way gives us enough flexibility to\nimplement a serialized exchange program.  We simply\nserialize the original\n<tt>exchange</tt> procedure with the serializers for both accounts:<p>\n\n<p><p><tt><a name="%_idx_3634"></a>(define&nbsp;(serialized-exchange&nbsp;account1&nbsp;account2)<br>\n&nbsp;&nbsp;(let&nbsp;((serializer1&nbsp;(account1&nbsp;\'serializer))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(serializer2&nbsp;(account2&nbsp;\'serializer)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;((serializer1&nbsp;(serializer2&nbsp;exchange))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;account1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;account2)))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_3.43"></a>\n<b>Exercise 3.43.</b>&nbsp;&nbsp;Suppose that the balances in three accounts start out as $10, $20,\nand $30, and that multiple processes run, exchanging the balances in\nthe accounts.  Argue that if the processes are run sequentially,\nafter any number of concurrent exchanges, the account balances should be \n$10, $20, and $30 in some order.\nDraw a timing diagram like the one in figure&nbsp;<a href="#%_fig_3.29">3.29</a> to\nshow how this condition can be violated if the exchanges are\nimplemented using the first version of the account-exchange program in\nthis section.  On the other hand, argue that even with this <tt>exchange</tt> program, the sum of the balances in the accounts will be\npreserved.  Draw a timing diagram to show how even this condition would\nbe violated if we did not serialize the transactions\non individual accounts.\n\n<p><p>\n\n<p><a name="%_thm_3.44"></a>\n<b>Exercise 3.44.</b>&nbsp;&nbsp;<a name="%_idx_3636"></a>Consider the problem of transferring an amount from one account to\nanother.  Ben Bitdiddle claims that this can be accomplished with the\nfollowing procedure, even if there are multiple people concurrently\ntransferring money among multiple accounts, using any account\nmechanism that serializes deposit and withdrawal transactions, for\nexample, the version of <tt>make-account</tt> in the text above.<p>\n\n\n<p><p><tt>(define&nbsp;(transfer&nbsp;from-account&nbsp;to-account&nbsp;amount)<br>\n&nbsp;&nbsp;((from-account&nbsp;\'withdraw)&nbsp;amount)<br>\n&nbsp;&nbsp;((to-account&nbsp;\'deposit)&nbsp;amount))<br>\n</tt><p><p>\nLouis Reasoner claims that there is a problem here, and that we need\nto use a more sophisticated method, such as the one required for\ndealing with the exchange problem.  Is Louis right?  If not, what is\nthe essential difference between the transfer problem and the exchange\nproblem?  (You should assume that the balance in <tt>from-account</tt>\nis at least <tt>amount</tt>.)\n<p><p>\n\n\n<p><a name="%_thm_3.45"></a>\n<b>Exercise 3.45.</b>&nbsp;&nbsp;Louis Reasoner thinks our bank-account system is unnecessarily complex and\nerror-prone now that deposits and withdrawals aren\'t automatically serialized.\nHe suggests that <tt>make-account-and-serializer</tt> should have\nexported the serializer (for use by such procedures as\n<tt>serialized-exchange</tt>) in addition to (rather than instead of)\nusing it to serialize accounts and deposits as <tt>make-account</tt> did.\nHe proposes to redefine accounts as follows:<p>\n\n\n<p><p><tt>(define&nbsp;(make-account-and-serializer&nbsp;balance)<br>\n&nbsp;&nbsp;(define&nbsp;(withdraw&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;=&nbsp;balance&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Insufficient&nbsp;funds&quot;))<br>\n&nbsp;&nbsp;(define&nbsp;(deposit&nbsp;amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;balance&nbsp;(+&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;balance)<br>\n&nbsp;&nbsp;(let&nbsp;((balance-serializer&nbsp;(make-serializer)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;m&nbsp;\'withdraw)&nbsp;(balance-serializer&nbsp;withdraw))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'deposit)&nbsp;(balance-serializer&nbsp;deposit))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'balance)&nbsp;balance)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'serializer)&nbsp;balance-serializer)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;MAKE-ACCOUNT&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dispatch))<br>\n</tt><p><p>\nThen deposits are handled as with the original <tt>make-account</tt>:\n<p><p><tt>(define&nbsp;(deposit&nbsp;account&nbsp;amount)<br>\n&nbsp;((account&nbsp;\'deposit)&nbsp;amount))<br>\n</tt><p><p>\nExplain what is wrong with Louis\'s reasoning.  In particular,\nconsider what happens when <tt>serialized-exchange</tt> is called.\n\n<p>\n\n<a name="%_sec_Temp_427"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_427">Implementing serializers</a></h4><p>\n\n<a name="%_idx_3638"></a>\nWe implement serializers in terms of a more primitive synchronization\nmechanism called a <a name="%_idx_3640"></a><em>mutex</em>.  A mutex is an object that supports\ntwo operations -- the mutex can be <a name="%_idx_3642"></a><em>acquired</em>, and the mutex can be\n<a name="%_idx_3644"></a><em>released</em>.  Once a mutex has been acquired, no other acquire\noperations on that mutex may proceed until the mutex is released.<a name="call_footnote_Temp_428" href="#footnote_Temp_428"><sup><small>44</small></sup></a> In our implementation, each\nserializer has an associated mutex.  Given a procedure <tt>p</tt>, the\nserializer returns a procedure that acquires the mutex, runs <tt>p</tt>,\nand then releases the mutex.  This ensures that only one of the\nprocedures produced by the serializer can be running at once, which is\nprecisely the serialization property that we need to guarantee.<p>\n\n<p><p><tt><a name="%_idx_3660"></a>(define&nbsp;(make-serializer)<br>\n&nbsp;&nbsp;(let&nbsp;((mutex&nbsp;(make-mutex)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(p)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(serialized-p&nbsp;.&nbsp;args)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mutex&nbsp;\'acquire)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((val&nbsp;(apply&nbsp;p&nbsp;args)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mutex&nbsp;\'release)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serialized-p)))<br>\n</tt><p><p><p>\n\nThe mutex is a mutable object (here we\'ll use a one-element\nlist, which we\'ll refer to as a <a name="%_idx_3662"></a><em>cell</em>) that can hold the value\ntrue or false.  When the value is false, the mutex is available to be\nacquired.  When the value is true, the mutex is unavailable, and any\nprocess that attempts to acquire the mutex must wait.<p>\n\nOur mutex constructor <tt>make-mutex</tt> begins by initializing the cell\ncontents to false.  To acquire the mutex, we test the cell.  If the\nmutex is available, we set the cell contents to true and proceed.\nOtherwise, we wait in a loop, attempting to acquire over and over\nagain, until we find that the mutex is available.<a name="call_footnote_Temp_429" href="#footnote_Temp_429"><sup><small>45</small></sup></a>  To release the\nmutex, we set the cell contents to false.<p>\n\n<p><p><tt><a name="%_idx_3668"></a>(define&nbsp;(make-mutex)<br>\n&nbsp;&nbsp;(let&nbsp;((cell&nbsp;(list&nbsp;false)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(the-mutex&nbsp;m)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;m&nbsp;\'acquire)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(test-and-set!&nbsp;cell)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(the-mutex&nbsp;\'acquire)))&nbsp;<em>;&nbsp;retry</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;m&nbsp;\'release)&nbsp;(clear!&nbsp;cell))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;the-mutex))<br>\n(define&nbsp;(clear!&nbsp;cell)<br>\n&nbsp;&nbsp;(set-car!&nbsp;cell&nbsp;false))<br>\n</tt><p><p><p>\n\n<tt>Test-and-set!</tt> tests the cell and returns the result of the\ntest.  In addition, if the test was false, <tt>test-and-set!</tt> sets\nthe cell contents to true before returning false.  We can express this\nbehavior as the following procedure:<p>\n\n<p><p><tt><a name="%_idx_3670"></a>(define&nbsp;(test-and-set!&nbsp;cell)<br>\n&nbsp;&nbsp;(if&nbsp;(car&nbsp;cell)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set-car!&nbsp;cell&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false)))<br>\n</tt><p><p><p>\n\nHowever, this implementation of <tt>test-and-set!</tt> does not suffice\nas it stands.  There is a crucial subtlety here, which is the\nessential place where concurrency control enters the system: The <tt>test-and-set!</tt> operation must be performed <a name="%_idx_3672"></a><em>atomically</em>.  That\nis, we must guarantee that, once a process has tested the cell and\nfound it to be false, the cell contents will actually be set to true\nbefore any other process can test the cell.  If we do not make this\nguarantee, then the mutex can fail in a way similar to the\nbank-account failure in figure&nbsp;<a href="#%_fig_3.29">3.29</a>.  (See\nexercise&nbsp;<a href="#%_thm_3.46">3.46</a>.)<p>\n\nThe actual implementation of <tt>test-and-set!</tt> depends on the\ndetails of how our system runs concurrent processes.  For example, we\nmight be executing concurrent processes on a sequential processor\nusing a <a name="%_idx_3674"></a>time-slicing mechanism that cycles through the processes,\npermitting each process to run for a short time before interrupting it\nand moving on to the next process.  In that case, <tt>test-and-set!</tt>\ncan work by disabling time slicing during the testing and setting.<a name="call_footnote_Temp_430" href="#footnote_Temp_430"><sup><small>46</small></sup></a>\nAlternatively, multiprocessing computers provide instructions that\nsupport atomic operations directly in hardware.<a name="call_footnote_Temp_431" href="#footnote_Temp_431"><sup><small>47</small></sup></a><p>\n\n<p><a name="%_thm_3.46"></a>\n<b>Exercise 3.46.</b>&nbsp;&nbsp;Suppose that we implement <tt>test-and-set!</tt>  using an ordinary\nprocedure as shown in the text, without attempting to make the operation\natomic.  Draw a timing diagram like the one in\nfigure&nbsp;<a href="#%_fig_3.29">3.29</a> to demonstrate how the mutex\nimplementation can fail by allowing two processes to acquire the mutex\nat the same time.\n\n<p><p>\n\n<p><a name="%_thm_3.47"></a>\n<b>Exercise 3.47.</b>&nbsp;&nbsp;<a name="%_idx_3692"></a>A semaphore (of size <em>n</em>) is a generalization of a mutex.  Like a\nmutex, a semaphore supports acquire and release operations, but it is\nmore general in that up to <em>n</em> processes can acquire it\nconcurrently.  Additional processes that attempt to acquire the\nsemaphore must wait for release operations.  Give implementations of\nsemaphores<p>\n\n<p><p>a. in terms of mutexes<p>\n\n<p><p>b. in terms of atomic <tt>test-and-set!</tt> operations.\n\n<p>\n\n<a name="%_sec_Temp_434"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_434">Deadlock</a></h4><p>\n\n<a name="%_idx_3694"></a><a name="%_idx_3696"></a>\nNow that we have seen how to implement serializers, we can see\nthat account exchanging still has a problem, even with the\n<tt>serialized-exchange</tt> procedure above.\nImagine that Peter attempts to exchange <em>a</em>1\nwith <em>a</em>2 while Paul concurrently attempts to exchange <em>a</em>2\nwith <em>a</em>1.  Suppose that Peter\'s process reaches the point where\nit has entered a serialized procedure protecting <em>a</em>1 and, just\nafter that, Paul\'s process enters a serialized procedure protecting\n<em>a</em>2.  Now Peter cannot proceed (to enter a serialized procedure\nprotecting <em>a</em>2) until Paul exits the serialized procedure\nprotecting <em>a</em>2.  Similarly, Paul cannot proceed until Peter exits\nthe serialized procedure protecting <em>a</em>1.  Each process is stalled\nforever, waiting for the other.  This situation is called a <em>deadlock</em>.  Deadlock is always a danger in systems that provide\nconcurrent access to multiple shared resources.<p>\n\n<a name="%_idx_3698"></a>One way to avoid the deadlock in this situation is to give each\naccount a unique identification number and rewrite <tt>serialized-exchange</tt> so\nthat a process will always attempt to enter a procedure protecting the\nlowest-numbered account first.  Although this method works well for\nthe exchange problem, there are other situations that require more\nsophisticated deadlock-avoidance techniques, or where deadlock cannot\nbe avoided at all.  (See exercises&nbsp;<a href="#%_thm_3.48">3.48</a>\nand&nbsp;<a href="#%_thm_3.49">3.49</a>.)<a name="call_footnote_Temp_435" href="#footnote_Temp_435"><sup><small>48</small></sup></a><p>\n\n<p><a name="%_thm_3.48"></a>\n<b>Exercise 3.48.</b>&nbsp;&nbsp;<a name="%_idx_3708"></a>Explain in detail why the deadlock-avoidance method described above,\n(i.e., the accounts are numbered, and each process attempts to acquire\nthe smaller-numbered account first) avoids deadlock in the exchange\nproblem.  Rewrite <tt>serialized-exchange</tt> to incorporate this idea.\n(You will\nalso need to modify <tt>make-account</tt> so that each account is created\nwith a number, which can be accessed by sending an appropriate\nmessage.)\n\n<p><p>\n\n<p><a name="%_thm_3.49"></a>\n<b>Exercise 3.49.</b>&nbsp;&nbsp;Give a scenario where the deadlock-avoidance mechanism described\nabove does not work.  (Hint: In the exchange problem, each process\nknows in advance which accounts it will need to get access to.  Consider a\nsituation where a process must get access to some shared resources before it\ncan know which additional shared resources it will require.)\n\n<p>\n<p>\n\n<a name="%_sec_Temp_438"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_438">Concurrency, time, and communication</a></h4><p>\n\nWe\'ve seen how programming concurrent systems requires controlling the\nordering of events when different processes access shared\nstate, and we\'ve seen how to achieve this control through judicious\nuse of serializers.  But the problems of concurrency\nlie deeper than this, because, from a fundamental point of view, it\'s\nnot always clear what is meant by ``shared state.\'\'<p>\n\nMechanisms such as <tt>test-and-set!</tt> require processes to examine a\nglobal shared flag at arbitrary times.  This is problematic and\ninefficient to implement in modern high-speed processors, where\ndue to optimization techniques such as pipelining and cached memory,\nthe contents of memory\nmay not be in a consistent state at every instant.  In contemporary\nmultiprocessing systems, therefore, the serializer paradigm is being\nsupplanted by new approaches to concurrency control.<a name="call_footnote_Temp_439" href="#footnote_Temp_439"><sup><small>49</small></sup></a><p>\n\n\nThe problematic aspects of shared state also arise\nin large, distributed systems.  For\ninstance, imagine a\ndistributed banking system where individual branch banks maintain\nlocal values for bank balances and periodically compare these with\nvalues maintained by other branches.  In such a system the value of\n``the account balance\'\' would be undetermined, except right after\nsynchronization.\nIf Peter deposits money in an account he holds\njointly with Paul, when should we say that the account balance has\nchanged -- when the balance in the local branch changes, or not until\nafter the synchronization?  \nAnd if Paul accesses the account from a\ndifferent branch, what are the reasonable constraints to place on the\nbanking system such that the behavior is ``correct\'\'?  \nThe only thing that might matter for\ncorrectness is the behavior observed by Peter and Paul individually\nand the ``state\'\' of the account immediately after synchronization.\nQuestions about the\n``real\'\' account balance or the order of events between synchronizations\nmay be irrelevant or meaningless.<a name="call_footnote_Temp_440" href="#footnote_Temp_440"><sup><small>50</small></sup></a><p>\n\n\n<a name="%_idx_3720"></a>The basic phenomenon here is that synchronizing different processes,\nestablishing shared state, or imposing an order on events requires\ncommunication among the processes.  In essence, any notion of time in\nconcurrency control must be intimately tied to communication.<a name="call_footnote_Temp_441" href="#footnote_Temp_441"><sup><small>51</small></sup></a>  It is\nintriguing that a similar connection between time and communication\nalso arises in the <a name="%_idx_3724"></a>Theory of Relativity, where the speed of light (the\nfastest signal that can be used to synchronize events) is a\nfundamental constant relating time and space.  The\ncomplexities we encounter in dealing with time and state in our\ncomputational models may in fact mirror a fundamental complexity of\nthe physical universe.\n<p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_405" href="#call_footnote_Temp_405"><sup><small>34</small></sup></a> Most real processors actually execute a few\noperations at a time, following a strategy called <a name="%_idx_3582"></a><em>pipelining</em>.  Although this technique greatly improves the effective\nutilization of the hardware, it is used only to speed up the execution\nof a sequential instruction stream, while retaining the behavior of\nthe sequential program.\n\n<p><a name="footnote_Temp_406" href="#call_footnote_Temp_406"><sup><small>35</small></sup></a> To quote some graffiti seen on a Cambridge\n<a name="%_idx_3586"></a>building wall: ``Time is a device that was invented to keep everything\nfrom happening at once.\'\'\n\n<p><a name="footnote_Temp_407" href="#call_footnote_Temp_407"><sup><small>36</small></sup></a> An even worse failure for this system\ncould occur if the two <tt>set!</tt> operations attempt to change the\nbalance simultaneously, in which case the actual data appearing in\nmemory might end up being a random combination of the information\nbeing written by the two processes.  Most computers have interlocks on\nthe primitive memory-write operations, which protect against such\nsimultaneous access.  Even this seemingly simple kind of protection,\nhowever, raises implementation challenges in the design of\nmultiprocessing computers, where elaborate <a name="%_idx_3594"></a><em>cache-coherence</em>\nprotocols are required to ensure that the various processors will\nmaintain a consistent view of memory contents, despite the fact that\ndata may be replicated (``cached\'\') among the different processors to\nincrease the speed of memory access.\n\n<p><a name="footnote_Temp_409" href="#call_footnote_Temp_409"><sup><small>37</small></sup></a> The factorial program in\nsection&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a> illustrates this for a single\nsequential process.\n\n<p><a name="footnote_Temp_410" href="#call_footnote_Temp_410"><sup><small>38</small></sup></a> The columns show the contents of Peter\'s wallet,\nthe joint account (in Bank1), Paul\'s wallet, and Paul\'s private account\n(in Bank2), before and after each withdrawal (W) and deposit (D).\nPeter withdraws $10 from Bank1; Paul deposits $5 in Bank2,\nthen withdraws $25 from Bank1.\n\n<p><a name="footnote_Temp_411" href="#call_footnote_Temp_411"><sup><small>39</small></sup></a> A more formal way to express this idea is to say that\nconcurrent programs are inherently <a name="%_idx_3604"></a><em>nondeterministic</em>. That\nis, they are described not by single-valued functions, but by\nfunctions whose results are sets of possible values.  In\nsection&nbsp;<a href="book-Z-H-28.html#%_sec_4.3">4.3</a> we will study a\nlanguage for expressing nondeterministic\ncomputations.\n\n<p><a name="footnote_Temp_415" href="#call_footnote_Temp_415"><sup><small>40</small></sup></a> <tt>Parallel-execute</tt> is not part of standard Scheme, but\nit can be implemented in MIT Scheme.  In our implementation, the\nnew concurrent processes also run concurrently with the original\nScheme process.  Also, in our implementation, the value returned\nby <tt>parallel-execute</tt> is a special control object that can be used\nto halt the newly created processes.\n\n<p><a name="footnote_Temp_421" href="#call_footnote_Temp_421"><sup><small>41</small></sup></a> We have simplified <tt>exchange</tt> by exploiting the fact\nthat our <tt>deposit</tt> message accepts negative amounts.  (This is a\nserious bug in our banking system!)\n\n<p><a name="footnote_Temp_422" href="#call_footnote_Temp_422"><sup><small>42</small></sup></a> If the account balances start out as $10,\n$20, and $30, then after any number of concurrent exchanges, the\nbalances should still be $10, $20, and\n$30 in some order.  Serializing the deposits to individual accounts is not\nsufficient to guarantee this.  See exercise&nbsp;<a href="#%_thm_3.43">3.43</a>.\n\n<p><a name="footnote_Temp_423" href="#call_footnote_Temp_423"><sup><small>43</small></sup></a> Exercise&nbsp;<a href="#%_thm_3.45">3.45</a> investigates why\ndeposits and withdrawals are no longer automatically serialized\nby the account.\n\n<p><a name="footnote_Temp_428" href="#call_footnote_Temp_428"><sup><small>44</small></sup></a> The term ``mutex\'\' is an abbreviation for <a name="%_idx_3646"></a><em>mutual\nexclusion</em>.  The general problem of arranging a mechanism that permits\nconcurrent processes to safely share resources is called the mutual\nexclusion problem.  Our mutex is a simple variant of the <a name="%_idx_3648"></a><em>semaphore</em> mechanism (see exercise&nbsp;<a href="#%_thm_3.47">3.47</a>), which was\nintroduced in the <a name="%_idx_3650"></a>``THE\'\' Multiprogramming System developed at the\n<a name="%_idx_3652"></a>Technological University of Eindhoven and named for the university\'s\ninitials in Dutch (Dijkstra 1968a).  The acquire and\nrelease operations were originally called <a name="%_idx_3654"></a><a name="%_idx_3656"></a><a name="%_idx_3658"></a>P and V, from the Dutch\nwords <em>passeren</em> (to pass) and <em>vrijgeven</em> (to release), in\nreference to the semaphores used on railroad systems.  Dijkstra\'s\nclassic exposition (1968b) was one of the first to clearly present the\nissues of concurrency control, and showed how to use semaphores to\nhandle a variety of concurrency problems.\n\n<p><a name="footnote_Temp_429" href="#call_footnote_Temp_429"><sup><small>45</small></sup></a> In most\ntime-shared operating systems, processes that are <a name="%_idx_3664"></a>blocked by a mutex do\n<a name="%_idx_3666"></a>not waste time ``busy-waiting\'\' as above.  Instead, the system\nschedules another process to run while the first is waiting, and the blocked\nprocess is awakened when the mutex becomes available.\n\n<p><a name="footnote_Temp_430" href="#call_footnote_Temp_430"><sup><small>46</small></sup></a> In MIT Scheme for a single processor, which uses a time-slicing\nmodel, <tt>test-and-set!</tt> can be implemented as follows:\n<a name="%_idx_3676"></a><a name="%_idx_3678"></a><p><p><tt><a name="%_idx_3680"></a>(define&nbsp;(test-and-set!&nbsp;cell)<br>\n&nbsp;&nbsp;(without-interrupts<br>\n&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(car&nbsp;cell)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set-car!&nbsp;cell&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false)))))<br>\n</tt><p><p>\n<tt>Without-interrupts</tt> disables\ntime-slicing interrupts while its procedure argument is being executed.\n\n<p><a name="footnote_Temp_431" href="#call_footnote_Temp_431"><sup><small>47</small></sup></a> There are many variants of such\n<a name="%_idx_3682"></a>instructions -- including test-and-set, test-and-clear, swap,\ncompare-and-exchange, load-reserve, and store-conditional -- whose\ndesign must be carefully matched to the machine\'s processor-memory\ninterface.\nOne issue that arises here is to determine what happens\nif two processes attempt to acquire the same resource\nat exactly the same time by using such an instruction.\nThis requires some mechanism\nfor making a decision about which process gets control.  Such a\nmechanism is called an <a name="%_idx_3684"></a><em>arbiter</em>.  Arbiters usually boil down to\nsome sort of hardware device.\nUnfortunately, it is possible to prove that one cannot physically\nconstruct a fair arbiter that works 100% of the time unless one\nallows the arbiter an arbitrarily long time to make its decision.  The\nfundamental phenomenon here was originally observed by the fourteenth-century\nFrench philosopher <a name="%_idx_3686"></a>Jean Buridan in his commentary on\n<a name="%_idx_3688"></a>Aristotle\'s <i>De caelo</i>.  Buridan argued that a perfectly rational\n<a name="%_idx_3690"></a>dog placed between two equally attractive sources of food will starve\nto death, because it is incapable of deciding which to go to first.\n\n<p><a name="footnote_Temp_435" href="#call_footnote_Temp_435"><sup><small>48</small></sup></a> The general technique for avoiding deadlock by numbering the\n<a name="%_idx_3700"></a>shared resources and acquiring them in order is due to <a name="%_idx_3702"></a><a name="%_idx_3704"></a><a name="%_idx_3706"></a>Havender\n(1968).  Situations where deadlock cannot be avoided require <em>deadlock-recovery</em> methods, which entail having processes ``back out\'\'\nof the deadlocked state and try again.  Deadlock-recovery\nmechanisms are widely used in database management systems, a topic that\nis treated in detail in Gray and Reuter 1993.\n\n<p><a name="footnote_Temp_439" href="#call_footnote_Temp_439"><sup><small>49</small></sup></a> One such alternative to serialization is called <a name="%_idx_3710"></a><em>barrier\nsynchronization</em>.  The programmer permits concurrent processes to\nexecute as they please, but establishes certain synchronization points\n(``barriers\'\') through which no process can proceed until all the\nprocesses have reached the barrier.  Modern processors provide machine\ninstructions that permit programmers to establish synchronization\npoints at places where consistency is required.  The <a name="%_idx_3712"></a>PowerPC<sup>\n<em>T</em><em>M</em></sup>, for example, includes for this purpose two instructions called\n<a name="%_idx_3714"></a>SYNC and <a name="%_idx_3716"></a>EIEIO (Enforced In-order Execution of Input/Output).\n\n<p><a name="footnote_Temp_440" href="#call_footnote_Temp_440"><sup><small>50</small></sup></a> This may seem like a strange point of view, but there are\n<a name="%_idx_3718"></a>systems that work this way.  International charges to credit-card\naccounts, for example, are normally cleared on a per-country basis,\nand the charges made in different countries are periodically\nreconciled.  Thus the account balance may be different in\ndifferent countries.\n\n<p><a name="footnote_Temp_441" href="#call_footnote_Temp_441"><sup><small>51</small></sup></a> For distributed\nsystems, this perspective was pursued by <a name="%_idx_3722"></a>Lamport (1978), who showed how\nto use communication to establish ``global clocks\'\' that can be used\nto establish orderings on events in distributed systems.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_3.5"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_3.5">3.5&nbsp;&nbsp;Streams</a></h2><p>\n\n\n<a name="%_idx_3726"></a>\nWe\'ve gained a good understanding of assignment as a tool in modeling,\nas well as an appreciation of the complex problems that assignment\nraises. It is time to ask whether we could have gone about things in a\ndifferent way, so as to avoid some of these problems.  In this\nsection, we explore an alternative approach to modeling state, based\non data structures called <em>streams</em>.  As we shall see, streams can\nmitigate some of the complexity of modeling state.<p>\n\nLet\'s step back and review where this complexity comes from.  In an\nattempt to model real-world phenomena, we made some apparently\nreasonable decisions: We modeled real-world objects with local state\nby computational objects with local variables.  We identified time\nvariation in the real world with time variation in the computer.  We\nimplemented the time variation of the states of the model objects in\nthe computer with assignments to the local variables of the model\nobjects.<p>\n\nIs there another approach?  Can we avoid identifying time in the\ncomputer with time in the modeled world?  Must we make the model\nchange with time in order to model phenomena in a changing world?\nThink about the issue in terms of mathematical functions.  We can\ndescribe the time-varying behavior of a quantity <em>x</em> as a function of\ntime <em>x</em>(<em>t</em>).  If we concentrate on <em>x</em> instant by instant, we think of\nit as a changing quantity.  Yet if we concentrate on the entire\ntime history of values, we do not emphasize change -- the function\nitself does not change.<a name="call_footnote_Temp_442" href="#footnote_Temp_442"><sup><small>52</small></sup></a><p>\n\nIf time is measured in discrete steps, then we can model a time function as\na (possibly infinite) sequence.  In this section, we will see how to\nmodel change in terms of sequences that represent the time histories\nof the systems being modeled.  To accomplish this, we introduce new\ndata structures called <em>streams</em>.  From an abstract point of view,\na stream is simply a sequence.  However, we will find that the\nstraightforward implementation of streams as lists (as in\nsection&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.1">2.2.1</a>) doesn\'t fully reveal\nthe power of stream processing.  As an alternative, we introduce the\ntechnique of <a name="%_idx_3730"></a><em>delayed evaluation</em>, which enables us to represent\nvery large (even infinite) sequences as streams.<p>\n\nStream processing lets us model systems that have state without ever\nusing assignment or mutable data.  This has important implications,\nboth theoretical and practical, because we can build models that avoid\nthe drawbacks inherent in introducing assignment.  On the other hand,\nthe stream framework raises difficulties of its own, and the question\nof which modeling technique leads to more modular and more easily\nmaintained systems remains open.<p>\n\n<a name="%_sec_3.5.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.5.1">3.5.1&nbsp;&nbsp;Streams Are Delayed Lists</a></h3><p>\n\n\n<a name="%_idx_3732"></a>\nAs we saw in section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>,\nsequences can serve as standard interfaces for combining program\nmodules.  We formulated powerful abstractions for manipulating\nsequences, such as <tt>map</tt>, <tt>filter</tt>, and <tt>accumulate</tt>, that\ncapture a wide variety of operations in a manner that is both succinct\nand elegant.<p>\n\nUnfortunately, if we represent sequences as lists, this elegance is\nbought at the price of severe inefficiency with respect to both the\ntime and space required by our computations.\nWhen we represent manipulations on sequences as transformations\nof lists, our programs must construct and copy data structures (which\nmay be huge) at every step of a process.<p>\n\nTo see why this is true, let us compare two programs for computing the\nsum of all the prime numbers in an interval.  The first program is\nwritten in standard iterative style:<a name="call_footnote_Temp_443" href="#footnote_Temp_443"><sup><small>53</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_3734"></a>(define&nbsp;(sum-primes&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;count&nbsp;accum)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((&gt;&nbsp;count&nbsp;b)&nbsp;accum)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((prime?&nbsp;count)&nbsp;(iter&nbsp;(+&nbsp;count&nbsp;1)&nbsp;(+&nbsp;count&nbsp;accum)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(iter&nbsp;(+&nbsp;count&nbsp;1)&nbsp;accum))))<br>\n&nbsp;&nbsp;(iter&nbsp;a&nbsp;0))<br>\n</tt><p><p>\nThe second program performs the same computation using the sequence\noperations of section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>:<p>\n\n<p><p><tt><a name="%_idx_3736"></a>(define&nbsp;(sum-primes&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(accumulate&nbsp;+<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(filter&nbsp;prime?&nbsp;(enumerate-interval&nbsp;a&nbsp;b))))<br>\n</tt><p><p><p>\n\nIn carrying out the computation, the first program needs to store only\nthe sum being accumulated.  In contrast, the filter in the second\nprogram cannot do any testing until <tt>enumerate-interval</tt> has\nconstructed a complete list of the numbers in the interval.  The\nfilter generates another list, which in turn is passed to <tt>accumulate</tt> before being collapsed to form a sum.  Such large\nintermediate storage is not needed by the first program, which we can\nthink of as enumerating the interval incrementally, adding each prime\nto the sum as it is generated.<p>\n\n\nThe inefficiency in using lists becomes painfully apparent if we use\nthe sequence paradigm to compute the second prime in the interval from\n10,000 to 1,000,000 by evaluating the expression<p>\n\n<p><p><tt>(car&nbsp;(cdr&nbsp;(filter&nbsp;prime?<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(enumerate-interval&nbsp;10000&nbsp;1000000))))<br>\n</tt><p><p>\nThis expression does find the second prime, but the computational\noverhead is outrageous.  We construct a list of almost a million\nintegers, filter this list by testing each element for primality, and\nthen ignore almost all of the result.  In a more traditional\nprogramming style, we would interleave the enumeration and the\nfiltering, and stop when we reached the second prime.<p>\n\n\nStreams are a clever idea that allows one to use sequence\nmanipulations without incurring the costs of manipulating sequences as\nlists.  With streams we can achieve the best of both worlds: We can\nformulate programs elegantly as sequence manipulations, while attaining the\nefficiency of incremental computation.  The basic idea is to arrange\nto construct a stream only partially, and to pass the partial\nconstruction to the program that consumes the stream.  If the consumer\nattempts to access a part of the stream that has not yet been\nconstructed, the stream will automatically construct just enough more\nof itself to produce the required part, thus preserving the illusion\nthat the entire stream exists.  In other words, although we will write\nprograms as if we were processing complete sequences, we design our\nstream implementation to automatically and transparently interleave\nthe construction of the stream with its use.<p>\n\nOn the surface, streams are just lists with different names for the\nprocedures that manipulate them.  There is a constructor,\n<a name="%_idx_3738"></a><tt>cons-stream</tt>, and two selectors, <a name="%_idx_3740"></a><tt>stream-car</tt> and <a name="%_idx_3742"></a><tt>stream-cdr</tt>, which satisfy the constraints\n<p><div align=left><img src="ch3-Z-G-34.gif" border="0"></div><p>\nThere is a distinguishable object, <a name="%_idx_3744"></a><a name="%_idx_3746"></a><a name="%_idx_3748"></a><tt>the-empty-stream</tt>, which\ncannot be the result of any <tt>cons-stream</tt> operation, and which can\nbe identified with the predicate <a name="%_idx_3750"></a><tt>stream-null?</tt>.<a name="call_footnote_Temp_444" href="#footnote_Temp_444"><sup><small>54</small></sup></a>\nThus we can make and use streams, in just the same way as we can make\nand use lists, to represent aggregate data arranged in a sequence.  In\nparticular, we can build stream analogs of the list operations from\nchapter&nbsp;2, such as <tt>list-ref</tt>, <tt>map</tt>, and <tt>for-each</tt>:<a name="call_footnote_Temp_445" href="#footnote_Temp_445"><sup><small>55</small></sup></a>\n<p><p><tt><a name="%_idx_3758"></a>(define&nbsp;(stream-ref&nbsp;s&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-car&nbsp;s)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-ref&nbsp;(stream-cdr&nbsp;s)&nbsp;(-&nbsp;n&nbsp;1))))<br>\n<a name="%_idx_3760"></a>(define&nbsp;(stream-map&nbsp;proc&nbsp;s)<br>\n&nbsp;&nbsp;(if&nbsp;(stream-null?&nbsp;s)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;(proc&nbsp;(stream-car&nbsp;s))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-map&nbsp;proc&nbsp;(stream-cdr&nbsp;s)))))<br>\n<a name="%_idx_3762"></a>(define&nbsp;(stream-for-each&nbsp;proc&nbsp;s)<br>\n&nbsp;&nbsp;(if&nbsp;(stream-null?&nbsp;s)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'done<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(proc&nbsp;(stream-car&nbsp;s))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-for-each&nbsp;proc&nbsp;(stream-cdr&nbsp;s)))))<br>\n</tt><p><p>\n<tt>Stream-for-each</tt> is useful for viewing streams:\n<p><p><tt><a name="%_idx_3764"></a>(define&nbsp;(display-stream&nbsp;s)<br>\n&nbsp;&nbsp;(stream-for-each&nbsp;display-line&nbsp;s))<br>\n<br>\n<a name="%_idx_3766"></a>(define&nbsp;(display-line&nbsp;x)<br>\n&nbsp;&nbsp;(newline)<br>\n&nbsp;&nbsp;(display&nbsp;x))<br>\n</tt><p><p><p>\n\nTo make the stream implementation automatically and transparently\ninterleave the construction of a stream with its use, we will arrange\nfor the <tt>cdr</tt> of a stream to be evaluated when it is accessed by\nthe <tt>stream-cdr</tt> procedure rather than when the stream is\nconstructed by <tt>cons-stream</tt>.  This implementation choice is\nreminiscent of our discussion of rational numbers in\nsection&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.2">2.1.2</a>, where we saw that we can\nchoose to implement rational numbers so that the reduction of\nnumerator and denominator to lowest terms is performed either at\nconstruction time or at selection time.  The two rational-number\nimplementations produce the same data abstraction, but the choice has\nan effect on efficiency.  There is a similar relationship between\nstreams and ordinary lists.  As a data abstraction, streams are the\nsame as lists.  The difference is the time at which the elements are\nevaluated.  With ordinary lists, both the <tt>car</tt> and the <tt>cdr</tt>\nare evaluated at construction time.  With streams, the <tt>cdr</tt> is\nevaluated at selection time.<p>\n\n<a name="%_idx_3768"></a><a name="%_idx_3770"></a>Our implementation of streams will be based on a special form called\n<tt>delay</tt>.  Evaluating <tt>(delay &lt;<em>exp</em>&gt;)</tt> does not\nevaluate the expression &lt;<em>exp</em>&gt;, but rather returns a so-called <a name="%_idx_3772"></a><em>delayed object</em>, which we can think of as a ``promise\'\' to evaluate\n&lt;<em>exp</em>&gt; at some future time.  As a companion to <tt>delay</tt>, there is\na procedure called <a name="%_idx_3774"></a><tt>force</tt> that takes a delayed object as\nargument and performs the evaluation -- in effect, forcing the\n<tt>delay</tt> to fulfill its promise.  We will see below how <tt>delay</tt>\nand <tt>force</tt> can be implemented, but first let us use these to\nconstruct streams.<p>\n\n<a name="%_idx_3776"></a><a name="%_idx_3778"></a><tt>Cons-stream</tt> is a special form defined so that<p>\n\n\n<p><p><tt>(cons-stream&nbsp;&lt;<em>a</em>&gt;&nbsp;&lt;<em>b</em>&gt;)<br>\n</tt><p><p>\nis equivalent to<p>\n\n\n<p><p><tt>(cons&nbsp;&lt;<em>a</em>&gt;&nbsp;(delay&nbsp;&lt;<em>b</em>&gt;))<br>\n</tt><p><p>\nWhat this means is that we will construct streams using pairs.  However,\nrather than placing the value of the rest of the stream\ninto the <tt>cdr</tt> of the\npair we will put there a promise to compute the rest if it is ever\nrequested.  <tt>Stream-car</tt> and <tt>stream-cdr</tt> can now be defined as\nprocedures:<p>\n\n<p><p><tt><a name="%_idx_3780"></a>(define&nbsp;(stream-car&nbsp;stream)&nbsp;(car&nbsp;stream))<br>\n<br>\n<a name="%_idx_3782"></a>(define&nbsp;(stream-cdr&nbsp;stream)&nbsp;(force&nbsp;(cdr&nbsp;stream)))<br>\n</tt><p><p>\n<tt>Stream-car</tt> selects the <tt>car</tt> of the pair; <tt>stream-cdr</tt>\nselects the <tt>cdr</tt> of the pair and evaluates the delayed expression\nfound there to obtain the rest of the stream.<a name="call_footnote_Temp_446" href="#footnote_Temp_446"><sup><small>56</small></sup></a>\n\n<a name="%_sec_Temp_447"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_447">The stream implementation in action</a></h4><p>\n\nTo see how this implementation behaves, let us analyze the\n``outrageous\'\' prime computation we saw above, reformulated in terms\nof streams:<p>\n\n<p><p><tt>(stream-car<br>\n&nbsp;(stream-cdr<br>\n&nbsp;&nbsp;(stream-filter&nbsp;prime?<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-enumerate-interval&nbsp;10000&nbsp;1000000))))<br>\n</tt><p><p>\nWe will see that it does indeed work efficiently.<p>\n\n\nWe begin by calling <tt>stream-enumerate-interval</tt> with\nthe arguments 10,000 and 1,000,000.  <tt>Stream-enumerate-interval</tt>\nis the stream analog of <tt>enumerate-interval</tt>\n(section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>):<p>\n\n<p><p><tt><a name="%_idx_3788"></a>(define&nbsp;(stream-enumerate-interval&nbsp;low&nbsp;high)<br>\n&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;low&nbsp;high)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-enumerate-interval&nbsp;(+&nbsp;low&nbsp;1)&nbsp;high))))<br>\n</tt><p><p>\nand thus the result returned by <tt>stream-enumerate-interval</tt>,\nformed by the <tt>cons-stream</tt>, is<a name="call_footnote_Temp_448" href="#footnote_Temp_448"><sup><small>57</small></sup></a><p>\n\n\n<p><p><tt>(cons&nbsp;10000<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(delay&nbsp;(stream-enumerate-interval&nbsp;10001&nbsp;1000000)))<br>\n</tt><p><p>\n\nThat is, <tt>stream-enumerate-interval</tt>\nreturns a stream represented as a pair whose <tt>car</tt>\nis 10,000 and whose <tt>cdr</tt> is a promise to enumerate more of the\ninterval if so requested.  This stream is now filtered for primes,\nusing the stream analog of the <tt>filter</tt> procedure\n(section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>):<p>\n\n\n<p><p><tt><a name="%_idx_3790"></a>(define&nbsp;(stream-filter&nbsp;pred&nbsp;stream)<br>\n&nbsp;&nbsp;(cond&nbsp;((stream-null?&nbsp;stream)&nbsp;the-empty-stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((pred&nbsp;(stream-car&nbsp;stream))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;(stream-car&nbsp;stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-filter&nbsp;pred<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-cdr&nbsp;stream))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(stream-filter&nbsp;pred&nbsp;(stream-cdr&nbsp;stream)))))<br>\n</tt><p><p>\n<tt>Stream-filter</tt> tests the <tt>stream-car</tt> of the stream (the <tt>car</tt> of the pair, which is 10,000).  Since this is not prime,\n<tt>stream-filter</tt> examines the <tt>stream-cdr</tt> of its input\nstream.  The call to <tt>stream-cdr</tt> forces evaluation of the delayed\n<tt>stream-enumerate-interval</tt>, which now returns<p>\n\n\n<p><p><tt>(cons&nbsp;10001<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(delay&nbsp;(stream-enumerate-interval&nbsp;10002&nbsp;1000000)))<br>\n</tt><p><p>\n<tt>Stream-filter</tt> now looks at the <tt>stream-car</tt> of this stream,\n10,001, sees that this is not prime either, forces another <tt>stream-cdr</tt>, and so on, until <tt>stream-enumerate-interval</tt> yields\nthe prime 10,007, whereupon <tt>stream-filter</tt>, according to its\ndefinition, returns<p>\n\n\n<p><p><tt>(cons-stream&nbsp;(stream-car&nbsp;stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-filter&nbsp;pred&nbsp;(stream-cdr&nbsp;stream)))<br>\n</tt><p><p>\nwhich in this case is<p>\n\n\n<p><p><tt>(cons&nbsp;10007<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(delay<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-filter<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prime?<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;10008<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(delay<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-enumerate-interval&nbsp;10009<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1000000))))))<br>\n</tt><p><p>\nThis result is now passed to <tt>stream-cdr</tt> in our\noriginal expression.  This forces the delayed <tt>stream-filter</tt>, which in turn keeps forcing the delayed <tt>stream-enumerate-interval</tt> until it finds the next prime, which is\n10,009.  Finally, the result passed to <tt>stream-car</tt> in our\noriginal expression is<p>\n\n<p><p><tt>(cons&nbsp;10009<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(delay<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-filter<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prime?<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;10010<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(delay<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-enumerate-interval&nbsp;10011<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1000000))))))<br>\n</tt><p><p>\n<tt>Stream-car</tt> returns 10,009, and the computation is complete.  Only as\nmany integers were tested for primality as were necessary to find the\nsecond prime, and the interval was enumerated only as far as was\nnecessary to feed the prime filter.<p>\n\nIn general, we can think of delayed evaluation as <a name="%_idx_3792"></a>``demand-driven\'\'\nprogramming, whereby each stage in the stream process is activated\nonly enough to satisfy the next stage.  What we have done is to\n<a name="%_idx_3794"></a>decouple the actual order of events in the computation from the\napparent structure of our procedures.  We write procedures as if the\nstreams existed ``all at once\'\' when, in reality, the computation is\nperformed incrementally, as in traditional programming styles.<p>\n\n<a name="%_sec_Temp_449"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_449">Implementing <tt>delay</tt> and <tt>force</tt></a></h4><p>\n\n<a name="%_idx_3796"></a>Although <tt>delay</tt> and <tt>force</tt> may seem like mysterious\noperations, their implementation is really quite straightforward.\n<tt>Delay</tt> must package an expression so that it can be evaluated\nlater on demand, and we can accomplish this simply by treating the\nexpression as the body of a procedure.  <tt>Delay</tt> can be a special\nform such that<p>\n\n<p><p><tt>(delay&nbsp;&lt;<em>exp</em>&gt;)<br>\n</tt><p><p>\nis syntactic sugar for<p>\n\n<p><p><tt>(lambda&nbsp;()&nbsp;&lt;<em>exp</em>&gt;)<br>\n</tt><p><p>\n<tt>Force</tt> simply calls the procedure (of no\narguments) produced by <tt>delay</tt>, so we can implement <tt>force</tt> as\na procedure:<p>\n\n<p><p><tt><a name="%_idx_3798"></a>(define&nbsp;(force&nbsp;delayed-object)<br>\n&nbsp;&nbsp;(delayed-object))<br>\n</tt><p><p><p>\n\n<a name="%_idx_3800"></a><a name="%_idx_3802"></a>This implementation suffices for <tt>delay</tt> and <tt>force</tt> to work\nas advertised, but there is an important optimization that we can\ninclude.  In many applications, we end up forcing the same delayed object\nmany times.  This can lead to serious inefficiency in recursive\nprograms involving streams.  (See\nexercise&nbsp;<a href="#%_thm_3.57">3.57</a>.)  The solution is to build\ndelayed objects so that the first time they are forced, they store the\nvalue that is computed.  Subsequent forcings will simply return the\nstored value without repeating the computation.  In other words, we\nimplement <tt>delay</tt> as a special-purpose memoized procedure similar\nto the one described in exercise&nbsp;<a href="book-Z-H-22.html#%_thm_3.27">3.27</a>.  One way to\naccomplish this is to use the following procedure, which takes as\nargument a procedure (of no arguments) and returns a memoized version\nof the procedure.  The first time the memoized procedure is run, it\nsaves the computed result.  On subsequent evaluations, it simply\nreturns the result.<p>\n\n<p><p><tt><a name="%_idx_3804"></a>(define&nbsp;(memo-proc&nbsp;proc)<br>\n&nbsp;&nbsp;(let&nbsp;((already-run?&nbsp;false)&nbsp;(result&nbsp;false))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(not&nbsp;already-run?)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(set!&nbsp;result&nbsp;(proc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;already-run?&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result))))<br>\n</tt><p><p>\n<tt>Delay</tt> is then defined so that <tt>(delay &lt;<em>exp</em>&gt;)</tt> is\nequivalent to<p>\n\n<p><p><tt>(memo-proc&nbsp;(lambda&nbsp;()&nbsp;&lt;<em>exp</em>&gt;))<br>\n</tt><p><p>\nand <tt>force</tt> is as defined previously.<a name="call_footnote_Temp_450" href="#footnote_Temp_450"><sup><small>58</small></sup></a><p>\n\n<p><a name="%_thm_3.50"></a>\n<b>Exercise 3.50.</b>&nbsp;&nbsp;Complete the following definition, which\ngeneralizes <tt>stream-map</tt> to allow procedures that\ntake multiple arguments, analogous to <tt>map</tt> in\nsection&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>, footnote&nbsp;<a href="book-Z-H-15.html#footnote_Temp_166">12</a>.<p>\n\n<p><p><tt><a name="%_idx_3824"></a>(define&nbsp;(stream-map&nbsp;proc&nbsp;.&nbsp;argstreams)<br>\n&nbsp;&nbsp;(if&nbsp;(&lt;<em>??</em>&gt;&nbsp;(car&nbsp;argstreams))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;<em>??</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;proc&nbsp;(map&nbsp;&lt;<em>??</em>&gt;&nbsp;argstreams))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;stream-map<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;proc&nbsp;(map&nbsp;&lt;<em>??</em>&gt;&nbsp;argstreams))))))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_3.51"></a>\n<b>Exercise 3.51.</b>&nbsp;&nbsp;<a name="%_idx_3826"></a>In order to take a closer look at delayed evaluation, we will use the\nfollowing procedure, which simply returns its argument after printing it:<p>\n\n\n<p><p><tt>(define&nbsp;(show&nbsp;x)<br>\n&nbsp;&nbsp;(display-line&nbsp;x)<br>\n&nbsp;&nbsp;x)<br>\n</tt><p><p>\nWhat does the interpreter print in response to evaluating each\nexpression in the following sequence?<a name="call_footnote_Temp_453" href="#footnote_Temp_453"><sup><small>59</small></sup></a><p>\n\n\n<p><p><tt>(define&nbsp;x&nbsp;(stream-map&nbsp;show&nbsp;(stream-enumerate-interval&nbsp;0&nbsp;10)))<br>\n(stream-ref&nbsp;x&nbsp;5)<br>\n(stream-ref&nbsp;x&nbsp;7)<br>\n</tt><p><p>\n<p>\n\n<p><a name="%_thm_3.52"></a>\n<b>Exercise 3.52.</b>&nbsp;&nbsp;<a name="%_idx_3830"></a>Consider the sequence of expressions<p>\n\n\n<p><p><tt>(define&nbsp;sum&nbsp;0)<br>\n(define&nbsp;(accum&nbsp;x)<br>\n&nbsp;&nbsp;(set!&nbsp;sum&nbsp;(+&nbsp;x&nbsp;sum))<br>\n&nbsp;&nbsp;sum)<br>\n(define&nbsp;seq&nbsp;(stream-map&nbsp;accum&nbsp;(stream-enumerate-interval&nbsp;1&nbsp;20)))<br>\n(define&nbsp;y&nbsp;(stream-filter&nbsp;even?&nbsp;seq))<br>\n(define&nbsp;z&nbsp;(stream-filter&nbsp;(lambda&nbsp;(x)&nbsp;(=&nbsp;(remainder&nbsp;x&nbsp;5)&nbsp;0))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq))<br>\n(stream-ref&nbsp;y&nbsp;7)<br>\n(display-stream&nbsp;z)<br>\n</tt><p><p>\nWhat is the value of <tt>sum</tt> after each of the above expressions is\nevaluated?  What is the printed response to evaluating the <tt>stream-ref</tt> and <tt>display-stream</tt> expressions?  Would these responses\ndiffer if we had implemented <tt>(delay&nbsp;&lt;<em>exp</em>&gt;)</tt> simply as\n<tt>(lambda () &lt;<em>exp</em>&gt;)</tt> without using the optimization provided by\n<tt>memo-proc</tt> ?  Explain.\n\n<p><p>\n\n<a name="%_sec_3.5.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.5.2">3.5.2&nbsp;&nbsp;Infinite Streams</a></h3><p>\n\n\n<a name="%_idx_3832"></a>\nWe have seen how to support the illusion of manipulating streams\nas complete entities even though, in actuality, we compute only\nas much of the stream as we need to access.  We can exploit this\ntechnique to represent sequences efficiently as streams, even if the\nsequences are very long.  What is more striking, we can use streams to\nrepresent sequences that are infinitely long.  For instance, consider\nthe following definition of the stream of positive integers:<p>\n\n<p><p><tt><a name="%_idx_3834"></a>(define&nbsp;(integers-starting-from&nbsp;n)<br>\n&nbsp;&nbsp;(cons-stream&nbsp;n&nbsp;(integers-starting-from&nbsp;(+&nbsp;n&nbsp;1))))<br>\n<br>\n<a name="%_idx_3836"></a>(define&nbsp;integers&nbsp;(integers-starting-from&nbsp;1))<br>\n</tt><p><p>\nThis makes sense because <tt>integers</tt> will be a pair whose <tt>car</tt>\nis 1 and whose <tt>cdr</tt> is a promise to produce the integers\nbeginning with 2.  This is an infinitely long stream, but in any given\ntime we can examine only a finite portion of it.  Thus, our programs\nwill never know that the entire infinite stream is not there.<p>\n\nUsing <tt>integers</tt> we can define other infinite streams, such as\nthe stream of integers that are not divisible by 7:<p>\n\n<p><p><tt><a name="%_idx_3838"></a>(define&nbsp;(divisible?&nbsp;x&nbsp;y)&nbsp;(=&nbsp;(remainder&nbsp;x&nbsp;y)&nbsp;0))<br>\n(define&nbsp;no-sevens<br>\n&nbsp;&nbsp;(stream-filter&nbsp;(lambda&nbsp;(x)&nbsp;(not&nbsp;(divisible?&nbsp;x&nbsp;7)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integers))<br>\n</tt><p><p>\nThen we can find integers not divisible by 7 simply by accessing\nelements of this stream:<p>\n\n<p><p><tt>(stream-ref&nbsp;no-sevens&nbsp;100)<br>\n<i>117</i><br>\n</tt><p><p>\n<p>\n\nIn analogy with <tt>integers</tt>, we can define the infinite stream of\nFibonacci numbers:<p>\n\n<p><p><tt>(define&nbsp;(fibgen&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(cons-stream&nbsp;a&nbsp;(fibgen&nbsp;b&nbsp;(+&nbsp;a&nbsp;b))))<br>\n<a name="%_idx_3840"></a>(define&nbsp;fibs&nbsp;(fibgen&nbsp;0&nbsp;1))<br>\n</tt><p><p>\n<tt>Fibs</tt> is a pair whose <tt>car</tt> is 0 and whose <tt>cdr</tt> is a\npromise to evaluate <tt>(fibgen 1 1)</tt>.  When we evaluate this delayed\n<tt>(fibgen 1 1)</tt>, it\nwill produce a pair whose <tt>car</tt> is 1 and whose <tt>cdr</tt> is a\npromise to evaluate <tt>(fibgen&nbsp;1&nbsp;2)</tt>, and so on.<p>\n\n<a name="%_idx_3842"></a>For a look at a more exciting infinite stream, we can generalize the\n<tt>no-sevens</tt> example to construct the infinite stream of prime\nnumbers, using a method known as the <a name="%_idx_3844"></a><em>sieve of\nEratosthenes</em>.<a name="call_footnote_Temp_455" href="#footnote_Temp_455"><sup><small>60</small></sup></a> We\nstart with the integers beginning with 2, which is the first prime.\nTo get the rest of the primes, we start by filtering the multiples of\n2 from the rest of the integers.  This leaves a stream beginning with\n3, which is the next prime.  Now we filter the multiples of 3 from the\nrest of this stream.  This leaves a stream beginning with 5, which is\nthe next prime, and so on.  In other words, we construct the primes by\na sieving process, described as follows: To sieve a stream <tt>S</tt>,\nform a stream whose first element is the first element of <tt>S</tt> and\nthe rest of which is obtained by filtering all multiples of the first element\nof <tt>S</tt> out of the rest of <tt>S</tt> and sieving the result. This\nprocess is readily described in terms of stream operations:<p>\n\n<p><p><tt><a name="%_idx_3852"></a>(define&nbsp;(sieve&nbsp;stream)<br>\n&nbsp;&nbsp;(cons-stream<br>\n&nbsp;&nbsp;&nbsp;(stream-car&nbsp;stream)<br>\n&nbsp;&nbsp;&nbsp;(sieve&nbsp;(stream-filter<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(not&nbsp;(divisible?&nbsp;x&nbsp;(stream-car&nbsp;stream))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-cdr&nbsp;stream)))))<br>\n<br>\n<a name="%_idx_3854"></a>(define&nbsp;primes&nbsp;(sieve&nbsp;(integers-starting-from&nbsp;2)))<br>\n</tt><p><p>\nNow to find a particular prime we need only ask for it:<p>\n\n<p><p><tt>(stream-ref&nbsp;primes&nbsp;50)<br>\n<i>233</i><br>\n</tt><p><p><p>\n\nIt is interesting to contemplate the signal-processing system set up\nby <tt>sieve</tt>, shown in the <a name="%_idx_3856"></a>``Henderson diagram\'\' in\nfigure&nbsp;<a href="#%_fig_3.31">3.31</a>.<a name="call_footnote_Temp_456" href="#footnote_Temp_456"><sup><small>61</small></sup></a>\nThe input stream feeds into an\n``un<tt>cons</tt>er\'\' that separates the first element of the stream from the\nrest of the stream.\nThe first element is used to construct a divisibility filter, through\nwhich the rest is passed, and the output of the filter is fed to\nanother sieve box.  Then the original first element is <tt>cons</tt>ed onto the\noutput of the internal sieve to form the output stream.  Thus, not\nonly is the stream infinite, but the signal processor is also\ninfinite, because the sieve contains a sieve within it.<p>\n\n<a name="%_fig_3.31"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-35.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.31:</b>&nbsp;&nbsp;The prime sieve viewed as a signal-processing system.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_sec_Temp_457"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_457">Defining streams implicitly</a></h4><p>\n\n<a name="%_idx_3860"></a>\nThe <tt>integers</tt> and <tt>fibs</tt> streams above were defined by\nspecifying ``generating\'\' procedures that explicitly compute the\nstream elements one by one. An alternative way to specify streams is\nto take advantage of delayed evaluation to define streams implicitly.\nFor example, the following expression defines the stream <tt>ones</tt> to\nbe an infinite stream of ones:<p>\n\n<p><p><tt><a name="%_idx_3862"></a>(define&nbsp;ones&nbsp;(cons-stream&nbsp;1&nbsp;ones))<br>\n</tt><p><p>\nThis works much like the definition of a recursive procedure: <tt>ones</tt> is a pair whose <tt>car</tt> is 1 and whose <tt>cdr</tt> is a promise\nto evaluate <tt>ones</tt>.  Evaluating the <tt>cdr</tt> gives us again a 1\nand a promise to evaluate <tt>ones</tt>, and so on.<p>\n\nWe can do more interesting things by manipulating streams with\noperations such as <tt>add-streams</tt>, which produces the elementwise\nsum of two given streams:<a name="call_footnote_Temp_458" href="#footnote_Temp_458"><sup><small>62</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_3864"></a>(define&nbsp;(add-streams&nbsp;s1&nbsp;s2)<br>\n&nbsp;&nbsp;(stream-map&nbsp;+&nbsp;s1&nbsp;s2))<br>\n</tt><p><p>\nNow we can define the integers as follows:<p>\n\n<p><p><tt><a name="%_idx_3866"></a>(define&nbsp;integers&nbsp;(cons-stream&nbsp;1&nbsp;(add-streams&nbsp;ones&nbsp;integers)))<br>\n</tt><p><p>\nThis defines <tt>integers</tt> to be a stream whose first element is 1\nand the rest of which is the sum of <tt>ones</tt> and <tt>integers</tt>.  Thus, the\nsecond element of <tt>integers</tt> is 1 plus the first element of <tt>integers</tt>,\nor 2; the third element of <tt>integers</tt> is 1 plus the second\nelement of <tt>integers</tt>, or 3; and so on.  This definition works\nbecause, at any point, enough of the <tt>integers</tt> stream has been\ngenerated so that we can feed it back into the definition to produce\nthe next integer.<p>\n\nWe can define the Fibonacci numbers in the same style:<p>\n\n<p><p><tt><a name="%_idx_3868"></a>(define&nbsp;fibs<br>\n&nbsp;&nbsp;(cons-stream&nbsp;0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-streams&nbsp;(stream-cdr&nbsp;fibs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fibs))))<br>\n</tt><p><p>\nThis definition says that <tt>fibs</tt> is a stream beginning with 0 and\n1, such that the rest of the stream can be generated by adding <tt>fibs</tt>\nto itself shifted by one place:<p>\n\n<table border=0><tr><td valign=top ></td><td valign=top ></td><td valign=top >1 </td><td valign=top >1 </td><td valign=top >2 </td><td valign=top >3 </td><td valign=top >5 </td><td valign=top >8 </td><td valign=top >13 </td><td valign=top >21 </td><td valign=top ><tt>...</tt> = <tt>(stream-cdr fibs)</tt></td></tr>\n<tr><td valign=top ></td><td valign=top ></td><td valign=top >0 </td><td valign=top >1 </td><td valign=top >1 </td><td valign=top >2 </td><td valign=top >3 </td><td valign=top >5 </td><td valign=top > 8 </td><td valign=top >13 </td><td valign=top ><tt>...</tt> = <tt>fibs</tt></td></tr>\n<tr><td valign=top >0 </td><td valign=top >1 </td><td valign=top >1 </td><td valign=top >2 </td><td valign=top >3 </td><td valign=top >5 </td><td valign=top >8 </td><td valign=top >13 </td><td valign=top >21 </td><td valign=top >34 </td><td valign=top ><tt>...</tt> = <tt>fibs</tt></td></tr>\n<tr><td valign=top ></td></tr></table><p>\n\n<tt>Scale-stream</tt> is another useful procedure in formulating such stream definitions.\nThis multiplies each item in a stream by a given\nconstant:<p>\n\n<p><p><tt><a name="%_idx_3870"></a>(define&nbsp;(scale-stream&nbsp;stream&nbsp;factor)<br>\n&nbsp;&nbsp;(stream-map&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;factor))&nbsp;stream))<br>\n</tt><p><p>\nFor example,<p>\n\n<p><p><tt>(define&nbsp;double&nbsp;(cons-stream&nbsp;1&nbsp;(scale-stream&nbsp;double&nbsp;2)))<br>\n</tt><p><p>\nproduces the stream of powers of 2: 1, 2, 4, 8, 16, 32, <tt>...</tt>.<p>\n\nAn alternate definition of the stream of primes can be given by\nstarting with the integers and filtering them by testing for\nprimality.  We will need the first prime, 2, to get started:<p>\n\n<p><p><tt><a name="%_idx_3872"></a>(define&nbsp;primes<br>\n&nbsp;&nbsp;(cons-stream<br>\n&nbsp;&nbsp;&nbsp;2<br>\n&nbsp;&nbsp;&nbsp;(stream-filter&nbsp;prime?&nbsp;(integers-starting-from&nbsp;3))))<br>\n</tt><p><p>\nThis definition is not so straightforward as it appears, because we\nwill test whether a number <em>n</em> is prime by checking whether <em>n</em> is\ndivisible by a prime (not by just any integer) less than or equal to\n<img src="book-Z-G-D-13.gif" border="0"><em>n</em>:<p>\n\n<p><p><tt><a name="%_idx_3874"></a>(define&nbsp;(prime?&nbsp;n)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;ps)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((&gt;&nbsp;(square&nbsp;(stream-car&nbsp;ps))&nbsp;n)&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((divisible?&nbsp;n&nbsp;(stream-car&nbsp;ps))&nbsp;false)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(iter&nbsp;(stream-cdr&nbsp;ps)))))<br>\n&nbsp;&nbsp;(iter&nbsp;primes))<br>\n</tt><p><p>\nThis is a recursive definition, since <tt>primes</tt> is defined in terms\nof the <tt>prime?</tt> predicate, which itself uses the <tt>primes</tt>\nstream.  The reason this procedure works is that, at any point, enough\nof the <tt>primes</tt> stream has been generated to test the primality of\nthe numbers we need to check next.  That is, for every <em>n</em> we test for\nprimality, either <em>n</em> is not prime (in which case there is a prime\nalready generated that divides it) or <em>n</em> is prime (in which case\nthere is a prime already generated -- i.e., a prime less than\n<em>n</em> -- that is greater than <img src="book-Z-G-D-13.gif" border="0"><em>n</em>).<a name="call_footnote_Temp_459" href="#footnote_Temp_459"><sup><small>63</small></sup></a>\n\n<p><a name="%_thm_3.53"></a>\n<b>Exercise 3.53.</b>&nbsp;&nbsp;Without running the program, describe the elements of the\nstream defined by\n<p><p><tt>(define&nbsp;s&nbsp;(cons-stream&nbsp;1&nbsp;(add-streams&nbsp;s&nbsp;s)))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_3.54"></a>\n<b>Exercise 3.54.</b>&nbsp;&nbsp;Define a procedure <a name="%_idx_3886"></a><a name="%_idx_3888"></a><a name="%_idx_3890"></a><tt>mul-streams</tt>, analogous to <tt>add-streams</tt>,\nthat produces the elementwise product of its two input streams.\nUse this together with the stream of <tt>integers</tt> to complete the\nfollowing definition of the stream whose <em>n</em>th element (counting from 0)\nis <em>n</em> + 1 factorial:\n\n<p><p><tt>(define&nbsp;factorials&nbsp;(cons-stream&nbsp;1&nbsp;(mul-streams&nbsp;&lt;<em>??</em>&gt;&nbsp;&lt;<em>??</em>&gt;)))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_3.55"></a>\n<b>Exercise 3.55.</b>&nbsp;&nbsp;Define a procedure <a name="%_idx_3892"></a><tt>partial-sums</tt> that takes as argument a\nstream <em>S</em> and returns the stream whose\nelements are <em>S</em><sub>0</sub>, <em>S</em><sub>0</sub> + <em>S</em><sub>1</sub>, <em>S</em><sub>0</sub> + <em>S</em><sub>1</sub> + <em>S</em><sub>2</sub>, <tt>...</tt>.  For example, <tt>(partial-sums integers)</tt> should be the stream\n1, 3, 6, 10, 15, <tt>...</tt>.\n\n<p><p>\n\n\n<p><a name="%_thm_3.56"></a>\n<b>Exercise 3.56.</b>&nbsp;&nbsp;A famous problem, first raised by <a name="%_idx_3894"></a>R. Hamming, is to enumerate, in\nascending order with no repetitions, all positive integers with no\nprime factors other than 2, 3, or 5.  One obvious way to do this is to\nsimply test each integer in turn to see whether it has any factors\nother than 2, 3, and 5.  But this is very inefficient, since, as the\nintegers get larger, fewer and fewer of them fit the requirement.  As\nan alternative, let us call the required stream of numbers <tt>S</tt> and\nnotice the following facts about it.\n<p><ul>\n<li><tt>S</tt> begins with 1.<p>\n\n<li>The elements of <tt>(scale-stream S 2)</tt> are also \nelements of <tt>S</tt>.<p>\n\n<li>The same is true for <tt>(scale-stream S 3)</tt> \nand <tt>(scale-stream 5 S)</tt>.<p>\n\n<li>These are all the elements of <tt>S</tt>.\n</ul><p><p>\n\n<a name="%_idx_3896"></a>Now all we have to do is combine elements from these sources.\nFor this we define a procedure <tt>merge</tt> that combines two ordered\nstreams into one ordered result stream, eliminating repetitions:<p>\n\n\n<p><p><tt><a name="%_idx_3898"></a>(define&nbsp;(merge&nbsp;s1&nbsp;s2)<br>\n&nbsp;&nbsp;(cond&nbsp;((stream-null?&nbsp;s1)&nbsp;s2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((stream-null?&nbsp;s2)&nbsp;s1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((s1car&nbsp;(stream-car&nbsp;s1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s2car&nbsp;(stream-car&nbsp;s2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((&lt;&nbsp;s1car&nbsp;s2car)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;s1car&nbsp;(merge&nbsp;(stream-cdr&nbsp;s1)&nbsp;s2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&gt;&nbsp;s1car&nbsp;s2car)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;s2car&nbsp;(merge&nbsp;s1&nbsp;(stream-cdr&nbsp;s2))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;s1car<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(merge&nbsp;(stream-cdr&nbsp;s1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-cdr&nbsp;s2)))))))))<br>\n</tt><p><p>\nThen the required stream may be constructed with <tt>merge</tt>, as\nfollows:<p>\n\n\n<p><p><tt>(define&nbsp;S&nbsp;(cons-stream&nbsp;1&nbsp;(merge&nbsp;&lt;<em>??</em>&gt;&nbsp;&lt;<em>??</em>&gt;)))<br>\n</tt><p><p>\nFill in the missing expressions in the places marked &lt;<em>??</em>&gt; above.\n\n<p><p>\n\n<p><a name="%_thm_3.57"></a>\n<b>Exercise 3.57.</b>&nbsp;&nbsp;<a name="%_idx_3900"></a>How many additions are performed when we compute the <em>n</em>th Fibonacci\nnumber using the definition of <tt>fibs</tt> based on the <tt>add-streams</tt> procedure?  Show that the number of additions would be\nexponentially greater if we had implemented\n<tt>(delay &lt;<em>exp</em>&gt;)</tt> simply as <tt>(lambda () &lt;<em>exp</em>&gt;)</tt>, \nwithout using the optimization provided by the <tt>memo-proc</tt>\nprocedure described in section&nbsp;<a href="#%_sec_3.5.1">3.5.1</a>.<a name="call_footnote_Temp_465" href="#footnote_Temp_465"><sup><small>64</small></sup></a>\n\n<p><p>\n\n<p><a name="%_thm_3.58"></a>\n<b>Exercise 3.58.</b>&nbsp;&nbsp;Give an interpretation of the stream computed by the following\nprocedure:<p>\n\n<p><p><tt>(define&nbsp;(expand&nbsp;num&nbsp;den&nbsp;radix)<br>\n&nbsp;&nbsp;(cons-stream<br>\n&nbsp;&nbsp;&nbsp;(quotient&nbsp;(*&nbsp;num&nbsp;radix)&nbsp;den)<br>\n&nbsp;&nbsp;&nbsp;(expand&nbsp;(remainder&nbsp;(*&nbsp;num&nbsp;radix)&nbsp;den)&nbsp;den&nbsp;radix)))<br>\n</tt><p><p>\n<a name="%_idx_3906"></a><a name="%_idx_3908"></a>(<tt>Quotient</tt> is a primitive that returns the integer quotient of\ntwo integers.)  What are the successive elements produced by <tt>(expand 1 7 10)</tt> ?  What is produced by <tt>(expand 3 8 10)</tt> ?\n<p><p>\n\n\n<p><a name="%_thm_3.59"></a>\n<b>Exercise 3.59.</b>&nbsp;&nbsp;<a name="%_idx_3910"></a><a name="%_idx_3912"></a>In section&nbsp;<a href="book-Z-H-18.html#%_sec_2.5.3">2.5.3</a> we saw how to implement a\npolynomial arithmetic system representing polynomials as lists of\nterms.  In a similar way, we can work with <em>power series</em>, such as<p>\n\n<a name="%_idx_3914"></a><p><div align=left><img src="ch3-Z-G-36.gif" border="0"></div><p><p>\n\n<a name="%_idx_3916"></a><p><div align=left><img src="ch3-Z-G-37.gif" border="0"></div><p><p>\n\n<a name="%_idx_3918"></a><p><div align=left><img src="ch3-Z-G-38.gif" border="0"></div><p><p>\n\nrepresented as infinite streams.\nWe will represent the series\n<em>a</em><sub>0</sub>  +  <em>a</em><sub>1</sub> <em>x</em>  +  <em>a</em><sub>2</sub> <em>x</em><sup>2</sup>  +  <em>a</em><sub>3</sub> <em>x</em><sup>3</sup>  +  <tt>&middot;&middot;&middot;</tt>\nas the stream whose elements are the coefficients <em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>3</sub>, <tt>...</tt>.<p>\n\n<p><p><a name="%_idx_3920"></a><a name="%_idx_3922"></a>a. The integral of the series <em>a</em><sub>0</sub>  +  <em>a</em><sub>1</sub> <em>x</em>  +  <em>a</em><sub>2</sub> <em>x</em><sup>2</sup>  +  <em>a</em><sub>3</sub> <em>x</em><sup>3</sup>  +  <tt>&middot;&middot;&middot;</tt>\nis the series\n<p><div align=left><img src="ch3-Z-G-39.gif" border="0"></div><p>\nwhere <em>c</em> is any constant.\nDefine a procedure <a name="%_idx_3924"></a><tt>integrate-series</tt> that takes as input a stream\n<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <tt>...</tt> representing a power series and returns the stream\n<em>a</em><sub>0</sub>, (1/2)<em>a</em><sub>1</sub>, (1/3)<em>a</em><sub>2</sub>, <tt>...</tt> of coefficients of\nthe non-constant terms of the integral of the series.\n(Since the result has no constant term, it doesn\'t represent a power\nseries; when we use <tt>integrate-series</tt>, we will <tt>cons</tt> on\nthe appropriate constant.) <p>\n\n<p><p>b. The function <em>x</em> <img src="book-Z-G-D-17.gif" border="0">  <em>e</em><sup><em>x</em></sup> is its own\nderivative.  This implies that <em>e</em><sup><em>x</em></sup> and the integral of <em>e</em><sup><em>x</em></sup> are the\nsame series, except for the constant term, which is <em>e</em><sup>0</sup>  = 1.\nAccordingly, we can generate the series for \n<em>e</em><sup><em>x</em></sup> as\n<p><p><tt>(define&nbsp;exp-series<br>\n&nbsp;&nbsp;(cons-stream&nbsp;1&nbsp;(integrate-series&nbsp;exp-series)))<br>\n</tt><p><p>\nShow how to generate the series for sine and cosine, starting from the facts\nthat the derivative of sine is cosine and the derivative of cosine is\nthe negative of sine:\n<p><p><tt>(define&nbsp;cosine-series<br>\n&nbsp;&nbsp;(cons-stream&nbsp;1&nbsp;&lt;<em>??</em>&gt;))<br>\n(define&nbsp;sine-series<br>\n&nbsp;&nbsp;(cons-stream&nbsp;0&nbsp;&lt;<em>??</em>&gt;))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_3.60"></a>\n<b>Exercise 3.60.</b>&nbsp;&nbsp;<a name="%_idx_3926"></a><a name="%_idx_3928"></a><a name="%_idx_3930"></a><a name="%_idx_3932"></a>With power series represented as streams of coefficients as in\nexercise&nbsp;<a href="#%_thm_3.59">3.59</a>, adding series is implemented by <tt>add-streams</tt>.  Complete the definition of the following procedure for\nmultiplying series:\n<p><p><tt>(define&nbsp;(mul-series&nbsp;s1&nbsp;s2)<br>\n&nbsp;&nbsp;(cons-stream&nbsp;&lt;<em>??</em>&gt;&nbsp;(add-streams&nbsp;&lt;<em>??</em>&gt;&nbsp;&lt;<em>??</em>&gt;)))<br>\n</tt><p><p>\nYou can test your procedure by verifying that\n<em>s</em><em>i</em><em>n</em><sup>2</sup> <em>x</em>  +  <em>c</em><em>o</em><em>s</em><sup>2</sup> <em>x</em>  =  1, using the series from exercise&nbsp;<a href="#%_thm_3.59">3.59</a>.\n\n<p><p>\n\n<p><a name="%_thm_3.61"></a>\n<b>Exercise 3.61.</b>&nbsp;&nbsp;Let <em>S</em> be a power series (exercise&nbsp;<a href="#%_thm_3.59">3.59</a>)\nwhose constant term is 1.  Suppose we want\nto find the power series 1/<em>S</em>, that is, the series <em>X</em> such that\n<em>S</em> &middot;  <em>X</em> =  1.  Write <em>S</em> = 1 + <em>S</em><sub><em>R</em></sub> where <em>S</em><sub><em>R</em></sub> is the part of <em>S</em> after\nthe constant term.  Then we can solve for <em>X</em> as follows:\n<p><div align=left><img src="ch3-Z-G-40.gif" border="0"></div><p>\nIn other words, <em>X</em> is the power series whose constant term is 1 and\nwhose higher-order terms are given by the negative of <em>S</em><sub><em>R</em></sub> times <em>X</em>.\nUse this idea to write a procedure <tt>invert-unit-series</tt> that computes 1/<em>S</em> for a power series <em>S</em> with\nconstant term 1.\nYou will need to use <tt>mul-series</tt> from exercise&nbsp;<a href="#%_thm_3.60">3.60</a>.\n\n<p><p>\n\n\n<p><a name="%_thm_3.62"></a>\n<b>Exercise 3.62.</b>&nbsp;&nbsp;<a name="%_idx_3934"></a><a name="%_idx_3936"></a><a name="%_idx_3938"></a>Use the results of exercises&nbsp;<a href="#%_thm_3.60">3.60</a>\nand&nbsp;<a href="#%_thm_3.61">3.61</a> to define a procedure <tt>div-series</tt>\nthat divides two power series.  <tt>Div-series</tt> should work for any\ntwo series, provided that the denominator series begins with a\nnonzero constant term.  (If the denominator has a zero constant term,\nthen <tt>div-series</tt> should signal an error.)\nShow how to use <tt>div-series</tt>\ntogether with the result of exercise&nbsp;<a href="#%_thm_3.59">3.59</a> to generate\n<a name="%_idx_3940"></a>the power series for tangent.\n<p>\n\n<a name="%_sec_3.5.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.5.3">3.5.3&nbsp;&nbsp;Exploiting the Stream Paradigm</a></h3><p>\n\n<p>\n\nStreams with delayed evaluation can be a powerful modeling tool,\nproviding many of the benefits of local state and assignment.\nMoreover, they avoid some of the theoretical tangles that accompany\nthe introduction of assignment into a programming language.<p>\n\n<a name="%_idx_3942"></a>The stream approach can be illuminating because it allows us to build\nsystems with different module boundaries than systems organized around\nassignment to state variables.  For example, we can think of an entire\ntime series (or signal) as a focus of interest, rather than the values\nof the state variables at individual moments.  This makes it\nconvenient to combine and compare components of state from different\nmoments.<p>\n\n<a name="%_sec_Temp_471"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_471">Formulating iterations as stream processes</a></h4><p>\n\n<a name="%_idx_3944"></a>\nIn section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a>, we introduced iterative\nprocesses, which proceed by updating state variables.  We know now\nthat we can represent state as a ``timeless\'\' stream of values rather\nthan as a set of variables to be updated.  Let\'s adopt this\nperspective in revisiting the square-root procedure from\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>.  Recall that the idea is to generate a\nsequence of better and better guesses for the square root of <em>x</em> by\napplying over and over again the procedure that improves guesses:<p>\n\n<p><p><tt>(define&nbsp;(sqrt-improve&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;(average&nbsp;guess&nbsp;(/&nbsp;x&nbsp;guess)))<br>\n</tt><p><p><p>\n\n<a name="%_idx_3946"></a>In our original <tt>sqrt</tt> procedure, we made these guesses be the\nsuccessive values of a state variable. Instead we can generate the\ninfinite stream of guesses, starting with an initial guess of 1:<a name="call_footnote_Temp_472" href="#footnote_Temp_472"><sup><small>65</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_3948"></a>(define&nbsp;(sqrt-stream&nbsp;x)<br>\n&nbsp;&nbsp;(define&nbsp;guesses<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;1.0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-map&nbsp;(lambda&nbsp;(guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt-improve&nbsp;guess&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guesses)))<br>\n&nbsp;&nbsp;guesses)<br>\n(display-stream&nbsp;(sqrt-stream&nbsp;2))<br>\n<i>1.</i><br>\n<i>1.5</i><br>\n<i>1.4166666666666665</i><br>\n<i>1.4142156862745097</i><br>\n<i>1.4142135623746899</i><br>\n<tt>...</tt></tt><p><p>\nWe can generate more and more terms of the stream to get better and\nbetter guesses.  If we like, we can write a procedure that keeps\ngenerating terms until the answer is good enough.  (See\nexercise&nbsp;<a href="#%_thm_3.64">3.64</a>.)<p>\n\n<a name="%_idx_3950"></a><a name="%_idx_3952"></a><a name="%_idx_3954"></a><a name="%_idx_3956"></a><a name="%_idx_3958"></a><a name="%_idx_3960"></a>Another iteration that we can treat in the same way is to generate an\napproximation to <img src="book-Z-G-D-9.gif" border="0">, based upon the alternating series that we saw\nin section&nbsp;<a href="book-Z-H-12.html#%_sec_1.3.1">1.3.1</a>:<p>\n\n<p><div align=left><img src="ch3-Z-G-41.gif" border="0"></div><p><p>\n\n\nWe first generate the stream of summands of the series (the reciprocals\nof the odd integers, with alternating signs).  Then we take the stream\nof sums of more and more terms (using the <tt>partial-sums</tt> procedure\nof exercise&nbsp;<a href="#%_thm_3.55">3.55</a>) and scale the result by 4:\n\n<p><p><tt>(define&nbsp;(pi-summands&nbsp;n)<br>\n&nbsp;&nbsp;(cons-stream&nbsp;(/&nbsp;1.0&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-map&nbsp;-&nbsp;(pi-summands&nbsp;(+&nbsp;n&nbsp;2)))))<br>\n<a name="%_idx_3962"></a>(define&nbsp;pi-stream<br>\n&nbsp;&nbsp;(scale-stream&nbsp;(partial-sums&nbsp;(pi-summands&nbsp;1))&nbsp;4))<br>\n(display-stream&nbsp;pi-stream)<br>\n<i>4.</i><br>\n<i>2.666666666666667</i><br>\n<i>3.466666666666667</i><br>\n<i>2.8952380952380956</i><br>\n<i>3.3396825396825403</i><br>\n<i>2.9760461760461765</i><br>\n<i>3.2837384837384844</i><br>\n<i>3.017071817071818</i><br>\n<tt>...</tt></tt><p><p>\nThis gives us a stream of better and better approximations to <img src="book-Z-G-D-9.gif" border="0">,\nalthough the approximations converge rather slowly.  Eight terms of\nthe sequence bound the value of <img src="book-Z-G-D-9.gif" border="0"> between 3.284 and 3.017.<p>\n\n<a name="%_idx_3964"></a>So far, our use of the stream of states approach is not much different\nfrom updating state variables.  But streams give us an opportunity to\ndo some interesting tricks.  For example, we can transform a stream\nwith a <a name="%_idx_3966"></a><em>sequence accelerator</em> that converts a sequence of\napproximations to a new sequence that converges to the same value as\nthe original, only faster.<p>\n\nOne such accelerator, due to the eighteenth-century Swiss mathematician\n<a name="%_idx_3968"></a>Leonhard Euler, works well with sequences that are partial sums of\nalternating series (series of terms with alternating signs).\nIn Euler\'s technique, if <em>S</em><sub><em>n</em></sub> is the <em>n</em>th term\nof the original sum sequence, then the accelerated sequence has terms\n<p><div align=left><img src="ch3-Z-G-42.gif" border="0"></div><p> \nThus, if the original sequence is represented as a stream of values,\nthe transformed sequence is given by<p>\n\n<p><p><tt><a name="%_idx_3970"></a>(define&nbsp;(euler-transform&nbsp;s)<br>\n&nbsp;&nbsp;(let&nbsp;((s0&nbsp;(stream-ref&nbsp;s&nbsp;0))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;<em>S</em><sub><em>n</em>-1</sub></em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s1&nbsp;(stream-ref&nbsp;s&nbsp;1))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;<em>S</em><sub><em>n</em></sub></em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s2&nbsp;(stream-ref&nbsp;s&nbsp;2)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;<em>S</em><sub><em>n</em>+1</sub></em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;(-&nbsp;s2&nbsp;(/&nbsp;(square&nbsp;(-&nbsp;s2&nbsp;s1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;s0&nbsp;(*&nbsp;-2&nbsp;s1)&nbsp;s2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(euler-transform&nbsp;(stream-cdr&nbsp;s)))))<br>\n</tt><p><p><p>\n\nWe can demonstrate Euler acceleration with our sequence of\napproximations to <img src="book-Z-G-D-9.gif" border="0">:<p>\n\n<p><p><tt>(display-stream&nbsp;(euler-transform&nbsp;pi-stream))<br>\n<i>3.166666666666667</i><br>\n<i>3.1333333333333337</i><br>\n<i>3.1452380952380956</i><br>\n<i>3.13968253968254</i><br>\n<i>3.1427128427128435</i><br>\n<i>3.1408813408813416</i><br>\n<i>3.142071817071818</i><br>\n<i>3.1412548236077655</i><br>\n<tt>...</tt></tt><p><p><p>\n\nEven better, we can accelerate the accelerated sequence, and\nrecursively accelerate that, and so on.  Namely, we create a stream of\nstreams (a structure we\'ll call a <a name="%_idx_3972"></a><em>tableau</em>) in which each stream\nis the transform of the preceding one:<p>\n\n<p><p><tt><a name="%_idx_3974"></a>(define&nbsp;(make-tableau&nbsp;transform&nbsp;s)<br>\n&nbsp;&nbsp;(cons-stream&nbsp;s<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-tableau&nbsp;transform<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(transform&nbsp;s))))<br>\n</tt><p><p>\nThe tableau has the form<p>\n\n<p><div align=left><img src="ch3-Z-G-43.gif" border="0"></div><p>\nFinally, we form a sequence by taking the first term in each row of\nthe tableau:<p>\n\n<p><p><tt><a name="%_idx_3976"></a>(define&nbsp;(accelerated-sequence&nbsp;transform&nbsp;s)<br>\n&nbsp;&nbsp;(stream-map&nbsp;stream-car<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-tableau&nbsp;transform&nbsp;s)))<br>\n</tt><p><p><p>\n\nWe can demonstrate this kind of ``super-acceleration\'\' of the <img src="book-Z-G-D-9.gif" border="0">\nsequence:<p>\n\n<p><p><tt>(display-stream&nbsp;(accelerated-sequence&nbsp;euler-transform<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi-stream))<br>\n<i>4.</i><br>\n<i>3.166666666666667</i><br>\n<i>3.142105263157895</i><br>\n<i>3.141599357319005</i><br>\n<i>3.1415927140337785</i><br>\n<i>3.1415926539752927</i><br>\n<i>3.1415926535911765</i><br>\n<i>3.141592653589778</i><br>\n<tt>...</tt></tt><p><p>\nThe result is impressive.  Taking eight terms of the sequence yields\nthe correct value of <img src="book-Z-G-D-9.gif" border="0"> to 14 decimal places.  If we had used only\nthe original <img src="book-Z-G-D-9.gif" border="0"> sequence, we would need to compute on the order of\n10<sup>13</sup> terms (i.e., expanding the series far enough so that the\nindividual terms are less then 10<sup>-13</sup>) to get that much accuracy!\n\nWe could have implemented these acceleration techniques without\nusing streams.  But the stream formulation is particularly elegant and\nconvenient because the entire sequence of states is available to us as a\ndata structure that can be manipulated with a uniform set of\noperations.<p>\n\n<p><a name="%_thm_3.63"></a>\n<b>Exercise 3.63.</b>&nbsp;&nbsp;Louis Reasoner asks why the <tt>sqrt-stream</tt> procedure was not\nwritten in the following more straightforward way, without\nthe local variable <tt>guesses</tt>:\n<p><p><tt>(define&nbsp;(sqrt-stream&nbsp;x)<br>\n&nbsp;&nbsp;(cons-stream&nbsp;1.0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-map&nbsp;(lambda&nbsp;(guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt-improve&nbsp;guess&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt-stream&nbsp;x))))<br>\n</tt><p><p>\nAlyssa P. Hacker replies that this version of the procedure is\nconsiderably less efficient because it performs redundant computation.\nExplain Alyssa\'s answer.  Would the two versions still differ in\nefficiency if our implementation of <tt>delay</tt> used only <tt>(lambda\n() &lt;<em>exp</em>&gt;)</tt> without using the optimization provided by <tt>memo-proc</tt> (section&nbsp;<a href="#%_sec_3.5.1">3.5.1</a>)?\n\n<p><p>\n\n<p><a name="%_thm_3.64"></a>\n<b>Exercise 3.64.</b>&nbsp;&nbsp;Write a procedure <a name="%_idx_3978"></a><tt>stream-limit</tt> that takes as arguments a stream\nand a number (the tolerance).  It should examine the stream until it\nfinds two successive elements that differ in absolute value by less\nthan the tolerance, and return the second of the two elements.  Using\nthis, we could compute square roots up to a given tolerance by\n<p><p><tt><a name="%_idx_3980"></a>(define&nbsp;(sqrt&nbsp;x&nbsp;tolerance)<br>\n&nbsp;&nbsp;(stream-limit&nbsp;(sqrt-stream&nbsp;x)&nbsp;tolerance))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_3.65"></a>\n<b>Exercise 3.65.</b>&nbsp;&nbsp;<a name="%_idx_3982"></a>Use the series\n<p><div align=left><img src="ch3-Z-G-44.gif" border="0"></div><p>\nto compute three sequences of approximations to the natural logarithm of 2,\nin the same way we did above for <img src="book-Z-G-D-9.gif" border="0">.\nHow rapidly do these sequences converge?\n<p>\n\n<a name="%_sec_Temp_476"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_476">Infinite streams of pairs</a></h4><p>\n\n<a name="%_idx_3984"></a><a name="%_idx_3986"></a><a name="%_idx_3988"></a>\nIn section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>, we saw how the sequence paradigm\nhandles traditional nested loops as processes defined on sequences of\npairs.  If we generalize this technique to infinite streams, then we\ncan write programs that are not easily represented as loops, because\nthe ``looping\'\' must range over an infinite set.<p>\n\n<a name="%_idx_3990"></a>For example, suppose we want to generalize the <tt>prime-sum-pairs</tt>\nprocedure of section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a> to produce the stream\nof pairs of <em>all</em> integers (<em>i</em>,<em>j</em>) with <em>i</em> <u>&lt;</u> <em>j</em> such that <em>i</em> + <em>j</em>\nis prime.  If <tt>int-pairs</tt> is the sequence of all pairs of integers (<em>i</em>,<em>j</em>)\nwith <em>i</em> <u>&lt;</u> <em>j</em>, then our required stream is simply<a name="call_footnote_Temp_477" href="#footnote_Temp_477"><sup><small>66</small></sup></a><p>\n\n<p><p><tt>(stream-filter&nbsp;(lambda&nbsp;(pair)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(prime?&nbsp;(+&nbsp;(car&nbsp;pair)&nbsp;(cadr&nbsp;pair))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int-pairs)<br>\n</tt><p><p><p>\n\nOur problem, then, is to produce the stream <tt>int-pairs</tt>.  More\ngenerally, suppose we have two streams <em>S</em>  =  (<em>S</em><sub><em>i</em></sub>) and <em>T</em>  =  (<em>T</em><sub><em>j</em></sub>),\nand imagine the infinite rectangular array\n<p><div align=left><img src="ch3-Z-G-45.gif" border="0"></div><p>\nWe wish to generate a stream that contains all the pairs in the array\nthat lie on or above the diagonal, i.e., the pairs\n<p><div align=left><img src="ch3-Z-G-46.gif" border="0"></div><p>\n(If we take both <em>S</em> and <em>T</em> to be the stream of integers, then this\nwill be our desired stream <tt>int-pairs</tt>.)  <p>\n\nCall the general stream of pairs <tt>(pairs S T)</tt>, and consider it to\nbe composed of three parts: the pair (<em>S</em><sub>0</sub>,<em>T</em><sub>0</sub>), the\nrest of the pairs in the first row, and the remaining pairs:<a name="call_footnote_Temp_478" href="#footnote_Temp_478"><sup><small>67</small></sup></a>\n<p><div align=left><img src="ch3-Z-G-47.gif" border="0"></div><p>\nObserve that the third piece in this decomposition (pairs that are not in the\nfirst row) is (recursively) the pairs formed from <tt>(stream-cdr S)</tt>\nand <tt>(stream-cdr T)</tt>.  Also note that the second piece (the rest\nof the first row) is\n<p><p><tt>(stream-map&nbsp;(lambda&nbsp;(x)&nbsp;(list&nbsp;(stream-car&nbsp;s)&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-cdr&nbsp;t))<br>\n</tt><p><p>\nThus we can form our stream of pairs as follows:\n<p><p><tt>(define&nbsp;(pairs&nbsp;s&nbsp;t)<br>\n&nbsp;&nbsp;(cons-stream<br>\n&nbsp;&nbsp;&nbsp;(list&nbsp;(stream-car&nbsp;s)&nbsp;(stream-car&nbsp;t))<br>\n&nbsp;&nbsp;&nbsp;(&lt;<em>combine-in-some-way</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-map&nbsp;(lambda&nbsp;(x)&nbsp;(list&nbsp;(stream-car&nbsp;s)&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-cdr&nbsp;t))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pairs&nbsp;(stream-cdr&nbsp;s)&nbsp;(stream-cdr&nbsp;t)))))<br>\n</tt><p><p><p>\n\n<a name="%_idx_3992"></a>In order to complete the procedure, we must choose some way to combine\nthe two inner streams.  One idea is to use the stream analog of the\n<tt>append</tt> procedure from section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.1">2.2.1</a>:<p>\n\n<p><p><tt><a name="%_idx_3994"></a>(define&nbsp;(stream-append&nbsp;s1&nbsp;s2)<br>\n&nbsp;&nbsp;(if&nbsp;(stream-null?&nbsp;s1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;(stream-car&nbsp;s1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-append&nbsp;(stream-cdr&nbsp;s1)&nbsp;s2))))<br>\n</tt><p><p>\nThis is unsuitable for infinite streams, however,\nbecause it takes all the elements from the first stream before\nincorporating the second stream.\nIn particular, if we try to generate all pairs of positive integers using<p>\n\n<p><p><tt>(pairs&nbsp;integers&nbsp;integers)<br>\n</tt><p><p>\nour stream of results will first try to run through all pairs with the\nfirst integer equal to 1, and hence will never produce pairs with any\nother value of the first integer.<p>\n\nTo handle infinite streams, we need to devise an order of combination\nthat ensures that every element will eventually be reached if we let\nour program run long enough.  An elegant way to accomplish this is\nwith the following <tt>interleave</tt> procedure:<a name="call_footnote_Temp_479" href="#footnote_Temp_479"><sup><small>68</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_4000"></a>(define&nbsp;(interleave&nbsp;s1&nbsp;s2)<br>\n&nbsp;&nbsp;(if&nbsp;(stream-null?&nbsp;s1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;(stream-car&nbsp;s1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(interleave&nbsp;s2&nbsp;(stream-cdr&nbsp;s1)))))<br>\n</tt><p><p>\nSince <tt>interleave</tt> takes elements alternately from the two streams,\nevery element of the second stream will eventually find its way into\nthe interleaved stream, even if the first stream is infinite.<p>\n\nWe can thus generate the required stream of pairs as\n<p><p><tt><a name="%_idx_4002"></a>(define&nbsp;(pairs&nbsp;s&nbsp;t)<br>\n&nbsp;&nbsp;(cons-stream<br>\n&nbsp;&nbsp;&nbsp;(list&nbsp;(stream-car&nbsp;s)&nbsp;(stream-car&nbsp;t))<br>\n&nbsp;&nbsp;&nbsp;(interleave<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(stream-map&nbsp;(lambda&nbsp;(x)&nbsp;(list&nbsp;(stream-car&nbsp;s)&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-cdr&nbsp;t))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(pairs&nbsp;(stream-cdr&nbsp;s)&nbsp;(stream-cdr&nbsp;t)))))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_3.66"></a>\n<b>Exercise 3.66.</b>&nbsp;&nbsp;Examine the stream <tt>(pairs integers integers)</tt>. Can you make any general\ncomments about the order in which the pairs are placed into the\nstream? For example, about how many pairs precede the pair (1,100)?\nthe pair (99,100)? the pair (100,100)? (If you can make precise\nmathematical statements here, all the better. But feel free to give\nmore qualitative answers if you find yourself getting bogged down.)\n<p><p>\n\n<p><a name="%_thm_3.67"></a>\n<b>Exercise 3.67.</b>&nbsp;&nbsp;Modify the <tt>pairs</tt> procedure so that <tt>(pairs integers\nintegers)</tt> will produce the stream of <em>all</em> pairs of integers\n(<em>i</em>,<em>j</em>) (without the condition <em>i</em> <u>&lt;</u> <em>j</em>).  Hint: You will need to\nmix in an additional stream.\n<p><p>\n\n<p><a name="%_thm_3.68"></a>\n<b>Exercise 3.68.</b>&nbsp;&nbsp;Louis Reasoner thinks that building a stream of pairs from three\nparts is unnecessarily complicated.  Instead of separating the\npair (<em>S</em><sub>0</sub>,<em>T</em><sub>0</sub>) from the rest of the pairs in the first row,\nhe proposes to work with the whole first row, as follows:\n<p><p><tt>(define&nbsp;(pairs&nbsp;s&nbsp;t)<br>\n&nbsp;&nbsp;(interleave<br>\n&nbsp;&nbsp;&nbsp;(stream-map&nbsp;(lambda&nbsp;(x)&nbsp;(list&nbsp;(stream-car&nbsp;s)&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t)<br>\n&nbsp;&nbsp;&nbsp;(pairs&nbsp;(stream-cdr&nbsp;s)&nbsp;(stream-cdr&nbsp;t))))<br>\n</tt><p><p>\nDoes this work?  Consider what happens if we evaluate\n<tt>(pairs integers integers)</tt> using Louis\'s definition of <tt>pairs</tt>.\n\n<p><p>\n\n<p><a name="%_thm_3.69"></a>\n<b>Exercise 3.69.</b>&nbsp;&nbsp;Write a procedure <tt>triples</tt> that takes three infinite\nstreams, <em>S</em>, <em>T</em>, and <em>U</em>, and produces the stream of triples\n(<em>S</em><sub><em>i</em></sub>,<em>T</em><sub><em>j</em></sub>,<em>U</em><sub><em>k</em></sub>) such that <em>i</em> <u>&lt;</u> <em>j</em> <u>&lt;</u> <em>k</em>.\nUse <tt>triples</tt> to\ngenerate the stream of all <a name="%_idx_4004"></a>Pythagorean triples of positive integers,\ni.e., the triples (<em>i</em>,<em>j</em>,<em>k</em>) such that <em>i</em> <u>&lt;</u> <em>j</em> and <em>i</em><sup>2</sup>  +  <em>j</em><sup>2</sup>  = <em>k</em><sup>2</sup>.\n\n<p><p>\n\n<p><a name="%_thm_3.70"></a>\n<b>Exercise 3.70.</b>&nbsp;&nbsp;<a name="%_idx_4006"></a><a name="%_idx_4008"></a>It would be nice to be able to generate streams in which the pairs\nappear in some useful order, rather than in the order that results\nfrom an <em>ad hoc</em> interleaving process.  We can use a technique\nsimilar to the <tt>merge</tt> procedure of exercise&nbsp;<a href="#%_thm_3.56">3.56</a>, if we\ndefine a way to say that one pair of integers is ``less than\'\'\nanother.  One way to do this is to define a ``weighting function\'\'\n<em>W</em>(<em>i</em>,<em>j</em>) and stipulate that (<em>i</em><sub>1</sub>,<em>j</em><sub>1</sub>) is less than (<em>i</em><sub>2</sub>,<em>j</em><sub>2</sub>) if\n<em>W</em>(<em>i</em><sub>1</sub>,<em>j</em><sub>1</sub>) &lt; <em>W</em>(<em>i</em><sub>2</sub>,<em>j</em><sub>2</sub>).  Write a procedure <tt>merge-weighted</tt>\nthat is like <tt>merge</tt>, except that <tt>merge-weighted</tt> takes an\nadditional argument <tt>weight</tt>, which is a procedure that computes\nthe weight of a pair, and is used to determine the order in which\nelements should appear in the resulting merged stream.<a name="call_footnote_Temp_485" href="#footnote_Temp_485"><sup><small>69</small></sup></a>\nUsing this,\ngeneralize <tt>pairs</tt> to a procedure <tt>weighted-pairs</tt> that\ntakes two streams, together with a procedure that computes a weighting\nfunction, and generates the stream of pairs, ordered according to\nweight.  Use your procedure to generate<p>\n\n<p><p>a. the stream of all pairs of positive integers (<em>i</em>,<em>j</em>) with <em>i</em> <u>&lt;</u>\n<em>j</em> ordered according to the sum <em>i</em>  +  <em>j</em><p>\n\n<p><p>b.  the stream of all pairs of positive integers (<em>i</em>,<em>j</em>) with <em>i</em> <u>&lt;</u>\n<em>j</em>, where neither <em>i</em> nor <em>j</em> is divisible by 2, 3, or 5, and the\npairs are ordered according to the sum 2 <em>i</em>  +  3 <em>j</em>  +  5 <em>i</em> <em>j</em>.\n\n<p><p>\n\n\n<p><a name="%_thm_3.71"></a>\n<b>Exercise 3.71.</b>&nbsp;&nbsp;<a name="%_idx_4010"></a>Numbers that can be expressed as the sum of two cubes in more than one\nway are sometimes called <em>Ramanujan numbers</em>, in honor of the\nmathematician Srinivasa Ramanujan.<a name="call_footnote_Temp_487" href="#footnote_Temp_487"><sup><small>70</small></sup></a>\nOrdered streams of pairs provide an elegant solution to the problem of\ncomputing these numbers.  To find a number that can be written as the\nsum of two cubes in two different ways, we need only generate the\nstream of pairs of integers (<em>i</em>,<em>j</em>) weighted according to the sum <em>i</em><sup>3</sup>\n +  <em>j</em><sup>3</sup> (see exercise&nbsp;<a href="#%_thm_3.70">3.70</a>),\nthen search the stream for two consecutive pairs with the same\nweight.  Write a procedure to generate the Ramanujan numbers.  The first\nsuch number is 1,729.  What are the next five?\n\n<p><p>\n\n<p><a name="%_thm_3.72"></a>\n<b>Exercise 3.72.</b>&nbsp;&nbsp;In a similar way to exercise&nbsp;<a href="#%_thm_3.71">3.71</a> generate\na stream of\nall numbers that can be written as the sum of two squares in three\ndifferent ways (showing how they can be so written).\n<p>\n\n<a name="%_sec_Temp_489"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_489">Streams as signals</a></h4><p>\n\n<a name="%_idx_4018"></a><a name="%_idx_4020"></a>\nWe began our discussion of streams by describing them as computational\nanalogs of the ``signals\'\' in signal-processing systems.  In fact, we\ncan use streams to model signal-processing systems in a very direct\nway, representing the values of a signal at successive time intervals\nas consecutive elements of a stream.  For instance, we can implement\nan <a name="%_idx_4022"></a><em>integrator</em> or <em>summer</em> that, for an input stream\n<em>x</em> = (<em>x</em><sub><em>i</em></sub>), an initial value <em>C</em>, and a small increment <em>d</em><em>t</em>,\naccumulates the sum\n<p><div align=left><img src="ch3-Z-G-48.gif" border="0"></div><p>\nand returns the stream of values <em>S</em> = (<em>S</em><sub><em>i</em></sub>).  The following <tt>integral</tt>\nprocedure is reminiscent of the ``implicit style\'\' definition of the\nstream of integers (section&nbsp;<a href="#%_sec_3.5.2">3.5.2</a>):<p>\n\n<p><p><tt><a name="%_idx_4024"></a>(define&nbsp;(integral&nbsp;integrand&nbsp;initial-value&nbsp;dt)<br>\n&nbsp;&nbsp;(define&nbsp;int<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;initial-value<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-streams&nbsp;(scale-stream&nbsp;integrand&nbsp;dt)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int)))<br>\n&nbsp;&nbsp;int)<br>\n</tt><p><p><p>\n\n<a name="%_fig_3.32"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-49.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.32:</b>&nbsp;&nbsp;The <tt>integral</tt> procedure viewed as a\nsignal-processing system.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nFigure&nbsp;<a href="#%_fig_3.32">3.32</a> is a picture of a signal-processing system that\ncorresponds to the <tt>integral</tt> procedure.  The input stream is\nscaled by <em>d</em><em>t</em> and passed through an adder, whose output is passed\nback through the same adder.  The self-reference in the definition of\n<tt>int</tt> is reflected in the figure by the feedback loop that\nconnects the output of the adder to one of the inputs.<p>\n\n<p><a name="%_thm_3.73"></a>\n<b>Exercise 3.73.</b>&nbsp;&nbsp;<a name="%_fig_3.33"></a><p><div align=left><table width=100%><tr><td><div align=center>&nbsp;<img src="ch3-Z-G-50.gif" border="0">\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n\n\n<em>v</em>  =  <em>v</em><sub>0</sub>  +  (1/<em>C</em>)<img src="book-Z-G-D-19.gif" border="0"><sub>0</sub><sup><em>t</em></sup><em>i</em> <em>d</em><em>t</em>  +  <em>R</em> <em>i</em>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>\n\n<p><p><img src="ch3-Z-G-51.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.33:</b>&nbsp;&nbsp;An RC circuit and the associated signal-flow diagram.</div></caption><tr><td>\n<a name="%_idx_4026"></a>\n</td></tr></table></div><p>\n<a name="%_idx_4028"></a><a name="%_idx_4030"></a><a name="%_idx_4032"></a>We can model electrical circuits using streams to represent the values\nof currents or voltages at a sequence of times.  For instance, suppose\nwe have an <em>RC circuit</em> consisting of a resistor of resistance <em>R</em>\nand a capacitor of capacitance <em>C</em> in series.  The voltage response\n<em>v</em> of the circuit to an injected current <em>i</em> is determined by the\nformula in figure&nbsp;<a href="#%_fig_3.33">3.33</a>, whose structure is shown by the accompanying\nsignal-flow diagram.<p>\n\nWrite a procedure <tt>RC</tt> that models this circuit.  <tt>RC</tt> should\ntake as inputs the values of <em>R</em>, <em>C</em>, and <em>d</em><em>t</em> and should return a\nprocedure that takes as inputs a stream representing the current <em>i</em>\nand an initial value for the capacitor voltage <em>v</em><sub>0</sub> and produces as\noutput the stream of voltages <em>v</em>.  For example, you should be able to\nuse <tt>RC</tt> to model an RC circuit with <em>R</em>  =  5 ohms, <em>C</em>  =  1 farad,\nand a 0.5-second time step by evaluating <tt>(define RC1 (RC 5 1\n0.5))</tt>.  This defines <tt>RC1</tt> as a procedure that takes a stream\nrepresenting the time sequence of currents and an initial capacitor\nvoltage and produces the output stream of voltages.\n\n<p>\n<p><a name="%_thm_3.74"></a>\n<b>Exercise 3.74.</b>&nbsp;&nbsp;<a name="%_idx_4034"></a><a name="%_idx_4036"></a>Alyssa P. Hacker is designing a system to process signals coming from\nphysical sensors.  One important feature she wishes to produce is a\nsignal that describes the <em>zero crossings</em> of the input signal.\nThat is, the resulting signal should be  + 1 whenever the input signal\nchanges from negative to positive,  - 1 whenever the input signal\nchanges from positive to negative, and 0 otherwise.  (Assume that the\nsign of a 0 input is positive.)  For example, a typical input signal\nwith its associated zero-crossing signal would be\n<p><p><tt><tt>...</tt>1&nbsp;&nbsp;2&nbsp;&nbsp;1.5&nbsp;&nbsp;1&nbsp;&nbsp;0.5&nbsp;&nbsp;-0.1&nbsp;&nbsp;-2&nbsp;&nbsp;-3&nbsp;&nbsp;-2&nbsp;&nbsp;-0.5&nbsp;&nbsp;0.2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;<tt>...</tt><tt>...</tt>&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;<tt>...</tt></tt><p><p>\nIn Alyssa\'s system, the signal from the sensor is represented as a\nstream <tt>sense-data</tt> and the stream <tt>zero-crossings</tt> is\nthe corresponding stream of zero crossings.  Alyssa first writes a\nprocedure <tt>sign-change-detector</tt> that takes two values as\narguments and compares the signs of the values to produce an\nappropriate 0, 1, or  - 1.  She then constructs her zero-crossing\nstream as follows:<p>\n\n<p><p><tt>(define&nbsp;(make-zero-crossings&nbsp;input-stream&nbsp;last-value)<br>\n&nbsp;&nbsp;(cons-stream<br>\n&nbsp;&nbsp;&nbsp;(sign-change-detector&nbsp;(stream-car&nbsp;input-stream)&nbsp;last-value)<br>\n&nbsp;&nbsp;&nbsp;(make-zero-crossings&nbsp;(stream-cdr&nbsp;input-stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-car&nbsp;input-stream))))<br>\n<br>\n(define&nbsp;zero-crossings&nbsp;(make-zero-crossings&nbsp;sense-data&nbsp;0))<br>\n</tt><p><p>\nAlyssa\'s boss, Eva Lu Ator, walks by and suggests that this program is\napproximately equivalent to the following one, which\nuses the generalized version\nof <tt>stream-map</tt> from exercise&nbsp;<a href="#%_thm_3.50">3.50</a>:<p>\n\n<p><p><tt>(define&nbsp;zero-crossings<br>\n&nbsp;&nbsp;(stream-map&nbsp;sign-change-detector&nbsp;sense-data&nbsp;&lt;<em>expression</em>&gt;))<br>\n</tt><p><p>\nComplete the program by supplying the indicated &lt;<em>expression</em>&gt;.\n\n<p>\n<p><a name="%_thm_3.75"></a>\n<b>Exercise 3.75.</b>&nbsp;&nbsp;<a name="%_idx_4038"></a><a name="%_idx_4040"></a><a name="%_idx_4042"></a><a name="%_idx_4044"></a>Unfortunately, Alyssa\'s zero-crossing detector in\nexercise&nbsp;<a href="#%_thm_3.74">3.74</a> proves to be insufficient, because the\nnoisy signal from the sensor leads to spurious zero crossings.  Lem E.\nTweakit, a hardware specialist, suggests that Alyssa smooth the signal\nto filter out the noise before extracting the zero crossings.  Alyssa\ntakes his advice and decides to extract the zero crossings from the\nsignal constructed by averaging each value of the sense data with the\nprevious value.  She explains the problem to her assistant, Louis\nReasoner, who attempts to implement the idea, altering Alyssa\'s program as\nfollows:<p>\n\n<p><p><tt>(define&nbsp;(make-zero-crossings&nbsp;input-stream&nbsp;last-value)<br>\n&nbsp;&nbsp;(let&nbsp;((avpt&nbsp;(/&nbsp;(+&nbsp;(stream-car&nbsp;input-stream)&nbsp;last-value)&nbsp;2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;(sign-change-detector&nbsp;avpt&nbsp;last-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-zero-crossings&nbsp;(stream-cdr&nbsp;input-stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avpt))))<br>\n</tt><p><p>\nThis does not correctly implement Alyssa\'s plan.\nFind the bug that Louis has installed\nand fix it without changing the structure of the program.  (Hint: You\nwill need to increase the number of arguments to <tt>make-zero-crossings</tt>.)\n\n<p>\n<p><a name="%_thm_3.76"></a>\n<b>Exercise 3.76.</b>&nbsp;&nbsp;<a name="%_idx_4046"></a><a name="%_idx_4048"></a><a name="%_idx_4050"></a><a name="%_idx_4052"></a>Eva Lu Ator has a criticism of Louis\'s approach in\nexercise&nbsp;<a href="#%_thm_3.75">3.75</a>.  The program he wrote is not modular,\nbecause it intermixes the operation of smoothing with the\nzero-crossing extraction.  For example, the extractor should not have\nto be changed if Alyssa finds a better way to condition her input\nsignal.  Help Louis by writing a procedure <tt>smooth</tt> that takes a\nstream as input and produces a stream in which each element is the\naverage of two successive input stream elements.  Then use <tt>smooth</tt> as a component to implement the zero-crossing detector in a\nmore modular style.\n<p>\n<a name="%_sec_3.5.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.5.4">3.5.4&nbsp;&nbsp;Streams and Delayed Evaluation</a></h3><p>\n\n\n<a name="%_idx_4054"></a><a name="%_idx_4056"></a>\nThe <tt>integral</tt> procedure at the end of the preceding section shows\nhow we can use streams to model signal-processing systems that contain\n<a name="%_idx_4058"></a>feedback loops.  The feedback loop for the adder shown in\nfigure&nbsp;<a href="#%_fig_3.32">3.32</a> is modeled by the fact that <tt>integral</tt>\'s\n<a name="%_idx_4060"></a>internal stream <tt>int</tt> is defined in terms of itself:<p>\n\n<p><p><tt>(define&nbsp;int<br>\n&nbsp;&nbsp;(cons-stream&nbsp;initial-value<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-streams&nbsp;(scale-stream&nbsp;integrand&nbsp;dt)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int)))<br>\n</tt><p><p>\nThe interpreter\'s ability to deal with such an implicit definition\ndepends on the <tt>delay</tt> that is incorporated into <tt>cons-stream</tt>.  Without this <tt>delay</tt>, the interpreter could not\nconstruct <tt>int</tt> before evaluating both arguments to <tt>cons-stream</tt>, which would require that <tt>int</tt> already be defined.\nIn general, <tt>delay</tt> is crucial for using streams to model\nsignal-processing systems that contain loops.  Without <tt>delay</tt>,\nour models would have to be formulated so that the inputs to any\nsignal-processing component would be fully evaluated before the output\ncould be produced.  This would outlaw loops.<p>\n\nUnfortunately, stream models of systems with loops\nmay require uses of <tt>delay</tt> beyond the ``hidden\'\' <tt>delay</tt>\nsupplied by <tt>cons-stream</tt>.  For instance,\nfigure&nbsp;<a href="#%_fig_3.34">3.34</a> shows a signal-processing system for\nsolving the <a name="%_idx_4062"></a>differential equation <em>d</em><em>y</em>/<em>d</em><em>t</em> = <em>f</em>(<em>y</em>) where <em>f</em> is a given\nfunction.  The figure shows a mapping component, which\napplies <em>f</em> to its input signal, linked in a feedback loop to an\nintegrator in a manner very similar to that of the analog computer\ncircuits that are actually used to solve such equations.<p>\n\n<a name="%_fig_3.34"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-52.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.34:</b>&nbsp;&nbsp;An ``analog computer circuit\'\' that solves the\nequation\n<em>d</em><em>y</em>/<em>d</em><em>t</em> = <em>f</em>(<em>y</em>).</div></caption><tr><td>\n<a name="%_idx_4064"></a>\n</td></tr></table></div><p><p>\n\nAssuming we are given an initial value <em>y</em><sub>0</sub> for <em>y</em>, we\ncould try to model this system using the procedure<p>\n\n<p><p><tt><a name="%_idx_4066"></a>(define&nbsp;(solve&nbsp;f&nbsp;y0&nbsp;dt)<br>\n&nbsp;&nbsp;(define&nbsp;y&nbsp;(integral&nbsp;dy&nbsp;y0&nbsp;dt))<br>\n&nbsp;&nbsp;(define&nbsp;dy&nbsp;(stream-map&nbsp;f&nbsp;y))<br>\n&nbsp;&nbsp;y)<br>\n</tt><p><p>\nThis procedure does not work, because in the first line of <tt>solve</tt>\nthe call to <tt>integral</tt> requires that the input <tt>dy</tt> be\ndefined, which does not happen until the second line of <tt>solve</tt>.<p>\n\nOn the other hand, the intent of our definition does make sense,\nbecause we can, in principle, begin to generate the <tt>y</tt> stream\nwithout knowing <tt>dy</tt>.  Indeed, <tt>integral</tt> and many other\nstream operations have properties similar to those of <tt>cons-stream</tt>, in that we can generate part of the answer given only\npartial information about the arguments.  For <tt>integral</tt>, the\nfirst element of the output stream is the specified <tt>initial-value</tt>.  Thus, we can generate the first element of the output\nstream without evaluating the integrand <tt>dy</tt>.  Once we know the\nfirst element of <tt>y</tt>, the <tt>stream-map</tt> in the second line of\n<tt>solve</tt> can begin working to generate the first element of <tt>dy</tt>, which will produce the next element of <tt>y</tt>, and so on.<p>\n\nTo take advantage of this idea, we will redefine <tt>integral</tt> to\nexpect the integrand stream to be a <a name="%_idx_4068"></a><a name="%_idx_4070"></a><a name="%_idx_4072"></a><em>delayed argument</em>.  <tt>Integral</tt> will <tt>force</tt> the integrand to be evaluated only when it\nis required to generate more than the first element of the output stream:<p>\n\n<p><p><tt><a name="%_idx_4074"></a>(define&nbsp;(integral&nbsp;delayed-integrand&nbsp;initial-value&nbsp;dt)<br>\n&nbsp;&nbsp;(define&nbsp;int<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;initial-value<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((integrand&nbsp;(force&nbsp;delayed-integrand)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-streams&nbsp;(scale-stream&nbsp;integrand&nbsp;dt)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int))))<br>\n&nbsp;&nbsp;int)<br>\n</tt><p><p>\nNow we can implement our <tt>solve</tt> procedure by delaying the\nevaluation of <tt>dy</tt> in the definition of <tt>y</tt>:<a name="call_footnote_Temp_494" href="#footnote_Temp_494"><sup><small>71</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_4076"></a>(define&nbsp;(solve&nbsp;f&nbsp;y0&nbsp;dt)<br>\n&nbsp;&nbsp;(define&nbsp;y&nbsp;(integral&nbsp;(delay&nbsp;dy)&nbsp;y0&nbsp;dt))<br>\n&nbsp;&nbsp;(define&nbsp;dy&nbsp;(stream-map&nbsp;f&nbsp;y))<br>\n&nbsp;&nbsp;y)<br>\n</tt><p><p>\nIn general, every caller of <tt>integral</tt> must now <tt>delay</tt> the\nintegrand argument.  We can demonstrate that the <tt>solve</tt> procedure\nworks by approximating <a name="%_idx_4078"></a><em>e</em> <img src="book-Z-G-D-20.gif" border="0">  2.718 by computing the value at\n<em>y</em> = 1 of the solution to the differential equation <em>d</em><em>y</em>/<em>d</em><em>t</em> = <em>y</em> with\ninitial condition <em>y</em>(0) = 1:<p>\n\n<p><p><tt>(stream-ref&nbsp;(solve&nbsp;(lambda&nbsp;(y)&nbsp;y)&nbsp;1&nbsp;0.001)&nbsp;1000)<br>\n<i>2.716924</i></tt><p><p><p>\n\n<p><a name="%_thm_3.77"></a>\n<b>Exercise 3.77.</b>&nbsp;&nbsp;The <tt>integral</tt> procedure used above was analogous to the\n``implicit\'\' definition of the infinite stream of integers in\nsection&nbsp;<a href="#%_sec_3.5.2">3.5.2</a>.  Alternatively, we can give a\ndefinition of <tt>integral</tt> that is more like <tt>integers-starting-from</tt> (also in section&nbsp;<a href="#%_sec_3.5.2">3.5.2</a>):<p>\n\n<p><p><tt><a name="%_idx_4080"></a>(define&nbsp;(integral&nbsp;integrand&nbsp;initial-value&nbsp;dt)<br>\n&nbsp;&nbsp;(cons-stream&nbsp;initial-value<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(stream-null?&nbsp;integrand)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(integral&nbsp;(stream-cdr&nbsp;integrand)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(*&nbsp;dt&nbsp;(stream-car&nbsp;integrand))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initial-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dt))))<br>\n</tt><p><p>\nWhen used in systems with loops, this procedure has the same problem\nas does our original version of <tt>integral</tt>.  Modify the procedure\nso that it expects the <tt>integrand</tt> as a delayed argument and hence\ncan be used in the <tt>solve</tt> procedure shown above.\n<p><p>\n\n<p><a name="%_thm_3.78"></a>\n<b>Exercise 3.78.</b>&nbsp;&nbsp;<a name="%_fig_3.35"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-53.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.35:</b>&nbsp;&nbsp;Signal-flow diagram for the solution to a second-order\nlinear differential equation.</div></caption><tr><td>\n\n</td></tr></table></div><p>\n<a name="%_idx_4082"></a>Consider the problem of designing a signal-processing system to study\nthe homogeneous second-order linear differential equation\n<p><div align=left><img src="ch3-Z-G-54.gif" border="0"></div><p>\nThe output stream, modeling <em>y</em>, is generated by a network that\ncontains a loop. This is because the value of <em>d</em><sup>2</sup><em>y</em>/<em>d</em><em>t</em><sup>2</sup> depends\nupon the values of <em>y</em> and <em>d</em><em>y</em>/<em>d</em><em>t</em> and both of these are determined by\nintegrating <em>d</em><sup>2</sup><em>y</em>/<em>d</em><em>t</em><sup>2</sup>.  The diagram we would like to encode is\nshown in figure&nbsp;<a href="#%_fig_3.35">3.35</a>.  Write a procedure <tt>solve-2nd</tt> that\ntakes as arguments the constants <em>a</em>, <em>b</em>, and <em>d</em><em>t</em> and the initial\nvalues <em>y</em><sub>0</sub> and <em>d</em><em>y</em><sub>0</sub> for <em>y</em> and <em>d</em><em>y</em>/<em>d</em><em>t</em> and generates the\nstream of successive values of <em>y</em>.\n\n<p><p>\n\n<p><a name="%_thm_3.79"></a>\n<b>Exercise 3.79.</b>&nbsp;&nbsp;<a name="%_idx_4084"></a>Generalize the <tt>solve-2nd</tt> procedure of exercise&nbsp;<a href="#%_thm_3.78">3.78</a> so\nthat it can be used to solve general second-order differential\nequations <em>d</em><sup>2</sup> <em>y</em>/<em>d</em><em>t</em><sup>2</sup> = <em>f</em>(<em>d</em><em>y</em>/<em>d</em><em>t</em>,  <em>y</em>).\n<p><p>\n\n<p><a name="%_thm_3.80"></a>\n<b>Exercise 3.80.</b>&nbsp;&nbsp;<a name="%_idx_4086"></a><a name="%_idx_4088"></a><a name="%_idx_4090"></a>A <em>series RLC circuit</em> consists of a resistor, a capacitor, and an\ninductor connected in series, as shown in figure&nbsp;<a href="#%_fig_3.36">3.36</a>.\nIf <em>R</em>, <em>L</em>, and <em>C</em> are the resistance, inductance, and capacitance,\nthen the relations between voltage (<em>v</em>) and current (<em>i</em>)\nfor the three components are described by the equations\n<p><div align=left><img src="ch3-Z-G-55.gif" border="0"></div><p>\n<p>\n\nand the circuit connections dictate the relations\n<p><div align=left><img src="ch3-Z-G-56.gif" border="0"></div><p>\nCombining these equations shows that the state of the circuit\n(summarized by <em>v</em><sub><em>C</em></sub>, the voltage across the capacitor, and <em>i</em><sub><em>L</em></sub>, the\ncurrent in the inductor)\nis described by the pair of differential equations\n<p><div align=left><img src="ch3-Z-G-57.gif" border="0"></div><p>\nThe signal-flow diagram representing this system of differential\nequations is shown in figure&nbsp;<a href="#%_fig_3.37">3.37</a>.\n<a name="%_fig_3.36"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-58.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.36:</b>&nbsp;&nbsp;A series RLC circuit.</div></caption><tr><td>\n\n</td></tr></table></div><p>\n<a name="%_fig_3.37"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-59.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.37:</b>&nbsp;&nbsp;A signal-flow diagram for the solution\nto a series RLC circuit.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nWrite a procedure <tt>RLC</tt> that takes as arguments the parameters\n<em>R</em>, <em>L</em>, and <em>C</em> of the circuit and the time increment <em>d</em><em>t</em>.  In a\nmanner similar to that of the <tt>RC</tt> procedure of\nexercise&nbsp;<a href="#%_thm_3.73">3.73</a>, <tt>RLC</tt> should produce a procedure\nthat takes the initial values of the state variables, <em>v</em><sub><em>C</em><sub>0</sub></sub> and\n<em>i</em><sub><em>L</em><sub>0</sub></sub>, and produces a pair (using <tt>cons</tt>) of the streams of\nstates <em>v</em><sub><em>C</em></sub> and <em>i</em><sub><em>L</em></sub>.  Using <tt>RLC</tt>, generate the pair of\nstreams that models the behavior of a series RLC circuit with <em>R</em>  =  1\nohm, <em>C</em> =  0.2 farad, <em>L</em>  =  1 henry, <em>d</em><em>t</em>  =  0.1 second, and initial\nvalues <em>i</em><sub><em>L</em><sub>0</sub></sub>  =  0 amps and <em>v</em><sub><em>C</em><sub>0</sub></sub>  =  10 volts.\n<p>\n<p>\n\n<a name="%_sec_Temp_499"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_499">Normal-order evaluation</a></h4><p>\n\n<a name="%_idx_4092"></a><a name="%_idx_4094"></a>\nThe examples in this section illustrate how the explicit use of <tt>delay</tt> and <tt>force</tt> provides great programming flexibility, but the\nsame examples also show how this can make our programs more complex.\nOur new <tt>integral</tt> procedure, for instance, gives us the power to\nmodel systems with loops, but we must now remember that <tt>integral</tt>\nshould be called with a delayed integrand, and every procedure that\nuses <tt>integral</tt> must be aware of this.  In effect, we have created\ntwo classes of procedures: ordinary procedures and procedures that\ntake delayed arguments.  In general, creating separate classes of\nprocedures forces us to create separate classes of higher-order\nprocedures as well.<a name="call_footnote_Temp_500" href="#footnote_Temp_500"><sup><small>72</small></sup></a><p>\n\nOne way to avoid the need for two different classes of procedures is\nto make all procedures take delayed arguments.  We could adopt a model\nof evaluation in which all arguments to procedures are automatically\ndelayed and arguments are forced only when they are actually needed\n(for example, when they are required by a primitive operation).  This\nwould transform our language to use normal-order evaluation, which we\nfirst described when we introduced the substitution model for\nevaluation in section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a>.  Converting to\nnormal-order evaluation provides a uniform and elegant way to simplify\nthe use of delayed evaluation, and this would be a natural strategy to\nadopt if we were concerned only with stream processing.  In\nsection&nbsp;<a href="book-Z-H-27.html#%_sec_4.2">4.2</a>, after we have studied the evaluator, we\nwill see how to transform our language in just this way.\nUnfortunately, including delays in procedure calls wreaks havoc with\nour ability to design programs that depend on the order of events,\nsuch as programs that use assignment, mutate data, or perform input or\noutput.  Even the single <tt>delay</tt> in <tt>cons-stream</tt> can cause\ngreat confusion, as illustrated by exercises&nbsp;<a href="#%_thm_3.51">3.51</a>\nand&nbsp;<a href="#%_thm_3.52">3.52</a>.  As far as anyone knows, mutability and delayed\nevaluation do not mix well in programming languages, and devising ways\nto deal with both of these at once is an active area of research.\n\n<a name="%_sec_3.5.5"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.5.5">3.5.5&nbsp;&nbsp;Modularity of Functional Programs and Modularity of Objects</a></h3><p>\n\n\n<a name="%_idx_4116"></a><a name="%_idx_4118"></a>\nAs we saw in section&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.2">3.1.2</a>, one of the\nmajor benefits of introducing assignment is that we can increase the\nmodularity of our systems by encapsulating, or ``hiding,\'\' parts of\nthe state of a large system within local variables.  Stream models can\nprovide an equivalent modularity without the use of assignment.  As an\n<a name="%_idx_4120"></a><a name="%_idx_4122"></a>illustration, we can reimplement the Monte Carlo estimation of <img src="book-Z-G-D-9.gif" border="0">,\nwhich we examined in section&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.2">3.1.2</a>, from a\nstream-processing point of view.<p>\n\n\nThe key modularity issue was that we wished to hide the internal state\nof a random-number generator from programs that used random numbers.\nWe began with a procedure <tt>rand-update</tt>, whose successive values\nfurnished our supply of random numbers, and used this to produce a\nrandom-number generator:<p>\n\n\n<p><p><tt>(define&nbsp;rand<br>\n&nbsp;&nbsp;(let&nbsp;((x&nbsp;random-init))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;x&nbsp;(rand-update&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)))<br>\n</tt><p><p><p>\n\nIn the stream formulation there is no random-number generator <em>per\nse</em>, just a stream of random numbers produced by successive calls to\n<tt>rand-update</tt>:<p>\n\n\n<p><p><tt><a name="%_idx_4124"></a><a name="%_idx_4126"></a>(define&nbsp;random-numbers<br>\n&nbsp;&nbsp;(cons-stream&nbsp;random-init<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-map&nbsp;rand-update&nbsp;random-numbers)))<br>\n</tt><p><p>\nWe use this to construct the stream of outcomes of the Ces&agrave;ro\nexperiment performed on consecutive pairs in the <tt>random-numbers</tt>\nstream:<p>\n\n<p><p><tt><a name="%_idx_4128"></a>(define&nbsp;cesaro-stream<br>\n&nbsp;&nbsp;(map-successive-pairs&nbsp;(lambda&nbsp;(r1&nbsp;r2)&nbsp;(=&nbsp;(gcd&nbsp;r1&nbsp;r2)&nbsp;1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random-numbers))<br>\n<br>\n<a name="%_idx_4130"></a>(define&nbsp;(map-successive-pairs&nbsp;f&nbsp;s)<br>\n&nbsp;&nbsp;(cons-stream<br>\n&nbsp;&nbsp;&nbsp;(f&nbsp;(stream-car&nbsp;s)&nbsp;(stream-car&nbsp;(stream-cdr&nbsp;s)))<br>\n&nbsp;&nbsp;&nbsp;(map-successive-pairs&nbsp;f&nbsp;(stream-cdr&nbsp;(stream-cdr&nbsp;s)))))<br>\n</tt><p><p>\nThe <tt>cesaro-stream</tt> is now fed to a <tt>monte-carlo</tt> procedure,\nwhich produces a stream of estimates of probabilities.  The results\nare then converted into a stream of estimates of <img src="book-Z-G-D-9.gif" border="0">.  This version\nof the program doesn\'t need a parameter telling how many trials to\nperform.  Better estimates of <img src="book-Z-G-D-9.gif" border="0"> (from performing more experiments)\nare obtained by looking farther into the <tt>pi</tt> stream:<p>\n\n<p><p><tt><a name="%_idx_4132"></a>(define&nbsp;(monte-carlo&nbsp;experiment-stream&nbsp;passed&nbsp;failed)<br>\n&nbsp;&nbsp;(define&nbsp;(next&nbsp;passed&nbsp;failed)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;passed&nbsp;(+&nbsp;passed&nbsp;failed))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(monte-carlo<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-cdr&nbsp;experiment-stream)&nbsp;passed&nbsp;failed)))<br>\n&nbsp;&nbsp;(if&nbsp;(stream-car&nbsp;experiment-stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(next&nbsp;(+&nbsp;passed&nbsp;1)&nbsp;failed)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(next&nbsp;passed&nbsp;(+&nbsp;failed&nbsp;1))))<br>\n<br>\n(define&nbsp;pi<br>\n&nbsp;&nbsp;(stream-map&nbsp;(lambda&nbsp;(p)&nbsp;(sqrt&nbsp;(/&nbsp;6&nbsp;p)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(monte-carlo&nbsp;cesaro-stream&nbsp;0&nbsp;0)))<br>\n</tt><p><p>\n<a name="%_idx_4134"></a>There is considerable modularity in this approach, because we still\ncan formulate a general <tt>monte-carlo</tt> procedure that can deal with\narbitrary experiments.  Yet there is no assignment or local state.<p>\n\n<p><a name="%_thm_3.81"></a>\n<b>Exercise 3.81.</b>&nbsp;&nbsp;<a name="%_idx_4136"></a>Exercise&nbsp;<a href="book-Z-H-20.html#%_thm_3.6">3.6</a>\ndiscussed generalizing the random-number generator to\nallow one to reset the random-number sequence so as to produce\nrepeatable sequences of ``random\'\' numbers.  Produce a stream\nformulation of this same generator that operates on an input stream of\nrequests to <tt>generate</tt> a new random number or to <tt>reset</tt> the\nsequence to a specified value and that produces the desired stream of\nrandom numbers.  Don\'t use assignment in your solution.\n<p><p>\n\n<p><a name="%_thm_3.82"></a>\n<b>Exercise 3.82.</b>&nbsp;&nbsp;<a name="%_idx_4138"></a><a name="%_idx_4140"></a><a name="%_idx_4142"></a>Redo exercise&nbsp;<a href="book-Z-H-20.html#%_thm_3.5">3.5</a> on Monte Carlo\nintegration in terms of streams.  The stream version of <tt>estimate-integral</tt> will not have an argument telling how many trials\nto perform.  Instead, it will produce a stream of estimates based on\nsuccessively more trials.\n<p><p>\n\n<a name="%_sec_Temp_503"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_503">A functional-programming view of time</a></h4><p>\n\n<a name="%_idx_4144"></a><a name="%_idx_4146"></a>\nLet us now return to the issues of objects and state that were raised\nat the beginning of this chapter and examine them in a new light.  We\nintroduced assignment and mutable objects to provide a mechanism for\nmodular construction of programs that model systems with state.\nWe constructed computational\nobjects with local state variables and used assignment to modify these\nvariables.  We modeled the temporal behavior of the objects in the\nworld by the temporal behavior of the corresponding computational\nobjects.<p>\n\nNow we have seen that streams provide an alternative way to model\nobjects with local state.  We can model a changing quantity, such as\nthe local state of some object, using a stream that represents the\ntime history of successive states.  In essence, we represent time\nexplicitly, using streams, so that we decouple time in our simulated\nworld from the sequence of events that take place during evaluation.\nIndeed, because of the presence of <tt>delay</tt> there may be little\nrelation between simulated time in the model and the order of events\nduring the evaluation.<p>\n\nIn order to contrast these two approaches to modeling, let us\nreconsider the implementation of a ``withdrawal processor\'\' that\n<a name="%_idx_4148"></a>monitors the balance in a bank account.  In\nsection&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a> we implemented a simplified\nversion of such a processor:<p>\n\n<p><p><tt><a name="%_idx_4150"></a>(define&nbsp;(make-simplified-withdraw&nbsp;balance)<br>\n&nbsp;&nbsp;(lambda&nbsp;(amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;balance))<br>\n</tt><p><p>\nCalls to <tt>make-simplified-withdraw</tt> produce computational objects,\neach with a local state variable <tt>balance</tt> that is decremented by\nsuccessive calls to the object.  The object takes an <tt>amount</tt> as\nan argument and returns the new balance.  We can imagine the user of a\nbank account typing a sequence of inputs to such an object and\nobserving the sequence of returned values shown on a display screen.<p>\n\nAlternatively, we can model a withdrawal processor as a procedure that\ntakes as input a balance and a stream of amounts to withdraw and\nproduces the stream of successive balances in the account:<p>\n\n<p><p><tt><a name="%_idx_4152"></a>(define&nbsp;(stream-withdraw&nbsp;balance&nbsp;amount-stream)<br>\n&nbsp;&nbsp;(cons-stream<br>\n&nbsp;&nbsp;&nbsp;balance<br>\n&nbsp;&nbsp;&nbsp;(stream-withdraw&nbsp;(-&nbsp;balance&nbsp;(stream-car&nbsp;amount-stream))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-cdr&nbsp;amount-stream))))<br>\n</tt><p><p>\n<tt>Stream-withdraw</tt> implements a well-defined mathematical function whose\noutput is fully determined by its input.  Suppose, however, that the\ninput <tt>amount-stream</tt> is the stream of successive values typed by\nthe user and that the resulting stream of balances is displayed.\nThen, from the perspective of the user who is typing values and\nwatching results, the stream process has the same behavior as the\nobject created by <tt>make-simplified-withdraw</tt>.  However, with the\nstream version, there is no assignment, no local state variable, and\nconsequently none of the theoretical difficulties that we encountered\n<a name="%_idx_4154"></a>in section&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a>.  Yet the system has state!<p>\n\nThis is really remarkable.  Even though <tt>stream-withdraw</tt> implements a\nwell-defined mathematical function whose behavior does not change, the\nuser\'s perception here is one of interacting with a system that has a\nchanging state.  One way to resolve this paradox is to realize that it\nis the user\'s temporal existence that imposes state on the system.  If\nthe user could step back from the interaction and think in terms of\nstreams of balances rather than individual transactions, the system\nwould appear stateless.<a name="call_footnote_Temp_504" href="#footnote_Temp_504"><sup><small>73</small></sup></a><p>\n\nFrom the point of view of one part of a complex process, the other\nparts appear to change with time.  They have hidden time-varying local\nstate.  If we wish to write programs that model this kind of natural\ndecomposition in our world (as we see it from our viewpoint as a part of\nthat world) with\nstructures in our computer, we make computational objects that are not\nfunctional -- they must change with time.  We model state with local\nstate variables, and we model the changes of state with assignments to\nthose variables.  By doing this we make the time of execution of a\ncomputation model time in the world that we are part of, and thus we\nget ``objects\'\' in our computer.<p>\n\nModeling with objects is powerful and intuitive, largely because this\nmatches the perception of interacting with a world of which we are\npart.  However, as we\'ve seen repeatedly throughout this chapter,\nthese models raise thorny problems of constraining the order of events\nand of synchronizing multiple processes.  The possibility of avoiding\nthese problems has stimulated the development of <a name="%_idx_4158"></a><a name="%_idx_4160"></a><em>functional\nprogramming languages</em>, which do not include any provision for\nassignment or mutable data.  In such a language, all procedures\nimplement well-defined mathematical functions of their arguments,\nwhose behavior does not change.  The functional approach is extremely\n<a name="%_idx_4162"></a><a name="%_idx_4164"></a>attractive for dealing with concurrent systems.<a name="call_footnote_Temp_505" href="#footnote_Temp_505"><sup><small>74</small></sup></a><p>\n\nOn the other hand, if we look closely, we can see time-related\nproblems creeping into functional models as well.  One particularly\ntroublesome area arises when we wish to design interactive systems,\nespecially ones that model interactions between independent entities.\nFor instance, consider once more the implementation a banking system\nthat permits joint bank accounts.  In a conventional system using\nassignment and objects, we would model the fact that Peter and Paul\nshare an account by having both Peter and Paul send their transaction\nrequests to the same bank-account object, as we saw in\nsection&nbsp;<a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a>.\nFrom the stream point of view, where there are no ``objects\'\' <em>per\nse</em>, we have already indicated that a bank account can be modeled as a\nprocess that operates on a stream of transaction requests to produce a\nstream of responses.  Accordingly, we could model the fact that Peter\nand Paul have a joint bank account by merging Peter\'s stream of\ntransaction requests with Paul\'s stream of requests and feeding the\nresult to the bank-account stream process, as shown in\nfigure&nbsp;<a href="#%_fig_3.38">3.38</a>.<p>\n\n<a name="%_fig_3.38"></a><p><div align=left><table width=100%><tr><td><img src="ch3-Z-G-60.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 3.38:</b>&nbsp;&nbsp;A joint bank account, modeled by merging two streams of\ntransaction requests.</div></caption><tr><td>\n\n<a name="%_idx_4176"></a></td></tr></table></div><p><p>\n\n<a name="%_idx_4178"></a>The trouble with this formulation is in the notion of <em>merge</em>.  It\nwill not do to merge the two streams by simply taking alternately one\nrequest from Peter and one request from Paul. Suppose Paul accesses\nthe account only very rarely.  We could hardly force Peter to wait for\nPaul to access the account before he could issue a second transaction.\nHowever such a merge is implemented, it must interleave the two\ntransaction streams in some way that is constrained by ``real\ntime\'\' as perceived by Peter and Paul, in the sense that, if Peter and\nPaul meet, they can agree that certain transactions were processed\nbefore the meeting, and other transactions were processed after the\nmeeting.<a name="call_footnote_Temp_506" href="#footnote_Temp_506"><sup><small>75</small></sup></a>\nThis is precisely the same constraint that we had to deal with in\nsection&nbsp;<a href="book-Z-H-23.html#%_sec_3.4.1">3.4.1</a>, where we found the need to introduce\nexplicit synchronization to ensure a ``correct\'\' order of events in\nconcurrent processing of objects with state.  Thus, in an attempt to\nsupport the functional style, the need to merge inputs from different\nagents reintroduces the same problems that the functional style was\nmeant to eliminate.<p>\n\nWe began this chapter with the goal of building computational models\nwhose structure matches our perception of the real world we are trying\nto model.  We can model the world as a collection of separate,\ntime-bound, interacting objects with state, or we can model the world\nas a single, timeless, stateless unity.  Each view has powerful\nadvantages, but neither view alone is completely satisfactory.  A\ngrand unification has yet to emerge.<a name="call_footnote_Temp_507" href="#footnote_Temp_507"><sup><small>76</small></sup></a>\n<p>\n\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_442" href="#call_footnote_Temp_442"><sup><small>52</small></sup></a> Physicists sometimes adopt this view by introducing the\n<a name="%_idx_3728"></a>``world lines\'\' of particles as a device for reasoning about motion.\nWe\'ve also already mentioned\n(section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>) that this is the\nnatural way to think about signal-processing systems.  We will explore\napplications of streams to signal processing in\nsection&nbsp;<a href="#%_sec_3.5.3">3.5.3</a>.\n\n<p><a name="footnote_Temp_443" href="#call_footnote_Temp_443"><sup><small>53</small></sup></a> Assume that we have a\npredicate <tt>prime?</tt> (e.g., as in section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.6">1.2.6</a>) that\ntests for primality.\n\n<p><a name="footnote_Temp_444" href="#call_footnote_Temp_444"><sup><small>54</small></sup></a> In the MIT implementation, <a name="%_idx_3752"></a><a name="%_idx_3754"></a><a name="%_idx_3756"></a><tt>the-empty-stream</tt> is the\nsame as the empty list <tt>\'()</tt>, and <tt>stream-null?</tt> is the same\nas <tt>null?</tt>.\n\n<p><a name="footnote_Temp_445" href="#call_footnote_Temp_445"><sup><small>55</small></sup></a> This should bother you.  The fact that we are defining such\nsimilar procedures for streams and lists indicates that we are missing some\nunderlying abstraction.  Unfortunately, in order to exploit this\nabstraction, we will need to exert finer control over the process of\nevaluation than we can at present.  We will discuss this point further\nat the end of section&nbsp;<a href="#%_sec_3.5.4">3.5.4</a>.\nIn section&nbsp;<a href="book-Z-H-27.html#%_sec_4.2">4.2</a>, we\'ll develop a framework that\nunifies lists and streams.\n\n<p><a name="footnote_Temp_446" href="#call_footnote_Temp_446"><sup><small>56</small></sup></a> Although <tt>stream-car</tt> and\n<a name="%_idx_3784"></a><a name="%_idx_3786"></a><tt>stream-cdr</tt> can be defined as procedures, <tt>cons-stream</tt> must\nbe a special form.  If <tt>cons-stream</tt> were a procedure, then,\naccording to our model of evaluation, evaluating <tt>(cons-stream\n&lt;<em>a</em>&gt; &lt;<em>b</em>&gt;)</tt> would automatically cause &lt;<em>b</em>&gt; to be evaluated, which is\nprecisely what we do not want to happen.  For the same reason, <tt>delay</tt> must be a special form, though <tt>force</tt> can be an ordinary\nprocedure.\n\n<p><a name="footnote_Temp_448" href="#call_footnote_Temp_448"><sup><small>57</small></sup></a> The numbers shown here do\nnot really appear in the delayed expression.  What actually appears is\nthe original expression, in an environment in which the variables are\nbound to the appropriate numbers.  For example, <tt>(+ low 1)</tt> with\n<tt>low</tt> bound to 10,000 actually appears where <tt>10001</tt> is\nshown.\n\n<p><a name="footnote_Temp_450" href="#call_footnote_Temp_450"><sup><small>58</small></sup></a> There are many\npossible implementations of streams other than the one described in\nthis section.  Delayed evaluation, which is the key to making streams\npractical, was inherent in <a name="%_idx_3806"></a><a name="%_idx_3808"></a>Algol 60\'s <em>call-by-name</em>\nparameter-passing method.  The use of this mechanism to implement\nstreams was first described by <a name="%_idx_3810"></a>Landin (1965).  Delayed evaluation for\nstreams was introduced into Lisp by <a name="%_idx_3812"></a><a name="%_idx_3814"></a>Friedman and Wise (1976). In their\nimplementation, <tt>cons</tt> always delays evaluating its arguments, so\nthat lists automatically behave as streams.  The memoizing\noptimization is also known as <a name="%_idx_3816"></a><a name="%_idx_3818"></a><a name="%_idx_3820"></a><a name="%_idx_3822"></a><em>call-by-need</em>.  The Algol community\nwould refer to our original delayed objects as <em>call-by-name\nthunks</em> and to the optimized versions as <em>call-by-need thunks</em>.\n\n<p><a name="footnote_Temp_453" href="#call_footnote_Temp_453"><sup><small>59</small></sup></a> Exercises such as&nbsp;<a href="#%_thm_3.51">3.51</a> and&nbsp;<a href="#%_thm_3.52">3.52</a>\nare valuable for testing our understanding of how <tt>delay</tt> works.\nOn the other hand, intermixing delayed evaluation with printing -- and,\neven worse, with assignment -- is extremely confusing, and instructors\nof courses on computer languages have traditionally tormented their\nstudents with examination questions such as the ones in this section.\nNeedless to say, writing programs that depend on such subtleties is\n<a name="%_idx_3828"></a>odious programming style.  Part of the power of stream processing is\nthat it lets us ignore the order in which events actually happen in\nour programs.  Unfortunately, this is precisely what we cannot afford\nto do in the presence of assignment, which forces us to be concerned\nwith time and change.\n\n<p><a name="footnote_Temp_455" href="#call_footnote_Temp_455"><sup><small>60</small></sup></a> Eratosthenes, a third-century <font size=-2>B</font>.<font size=-2>C</font>.\n<a name="%_idx_3846"></a><a name="%_idx_3848"></a>Alexandrian Greek philosopher, is famous for giving the first accurate\nestimate of the circumference of the Earth, which he computed by\nobserving shadows cast at noon on the day of the summer solstice.\nEratosthenes\'s sieve method, although ancient, has formed the basis\nfor special-purpose hardware ``sieves\'\' that, until recently, were the\nmost powerful tools in existence for locating large primes.  Since the\n70s, however, these methods have been superseded by outgrowths of the\n<a name="%_idx_3850"></a>probabilistic techniques discussed in section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.6">1.2.6</a>.\n\n<p><a name="footnote_Temp_456" href="#call_footnote_Temp_456"><sup><small>61</small></sup></a> We have named these figures after <a name="%_idx_3858"></a>Peter Henderson, who\nwas the first person to show us diagrams of this sort as a way of\nthinking about stream processing.  Each solid line represents a stream\nof values being transmitted.  The dashed line from the <tt>car</tt> to\nthe <tt>cons</tt> and the <tt>filter</tt> indicates that this is a single\nvalue rather than a stream.\n\n<p><a name="footnote_Temp_458" href="#call_footnote_Temp_458"><sup><small>62</small></sup></a> This uses the generalized version\nof <tt>stream-map</tt> from exercise&nbsp;<a href="#%_thm_3.50">3.50</a>.\n\n<p><a name="footnote_Temp_459" href="#call_footnote_Temp_459"><sup><small>63</small></sup></a> This last point is\nvery subtle and relies on the fact that <em>p</em><sub><em>n</em>+1</sub> <u>&lt;</u> <em>p</em><sub><em>n</em></sub><sup>2</sup>.\n(Here, <em>p</em><sub><em>k</em></sub> denotes the <em>k</em>th prime.)  Estimates such as these are\nvery difficult to establish.  The ancient proof by <a name="%_idx_3876"></a>Euclid that there\nare an infinite number of primes shows that <em>p</em><sub><em>n</em>+1</sub><u>&lt;</u> <em>p</em><sub>1</sub> <em>p</em><sub>2</sub> \n<tt>&middot;&middot;&middot;</tt>   <em>p</em><sub><em>n</em></sub>  + 1, and no substantially better result was proved\nuntil 1851, when the Russian mathematician P. L. Chebyshev established\n<a name="%_idx_3878"></a><a name="%_idx_3880"></a><a name="%_idx_3882"></a><a name="%_idx_3884"></a>that <em>p</em><sub><em>n</em>+1</sub><u>&lt;</u> 2<em>p</em><sub><em>n</em></sub> for all <em>n</em>.  This result, originally\nconjectured in 1845, is known as <em>Bertrand\'s hypothesis</em>.  A proof\ncan be found in section 22.3 of Hardy and Wright 1960.\n\n<p><a name="footnote_Temp_465" href="#call_footnote_Temp_465"><sup><small>64</small></sup></a> This exercise shows how call-by-need is closely related to\n<a name="%_idx_3902"></a><a name="%_idx_3904"></a>ordinary memoization as described in exercise&nbsp;<a href="book-Z-H-22.html#%_thm_3.27">3.27</a>.\nIn that exercise, we used assignment to explicitly construct a local\ntable.  Our call-by-need stream optimization effectively constructs\nsuch a table automatically, storing values in the previously forced\nparts of the stream.\n\n<p><a name="footnote_Temp_472" href="#call_footnote_Temp_472"><sup><small>65</small></sup></a> We can\'t use <tt>let</tt> to bind the local variable\n<tt>guesses</tt>, because the value of <tt>guesses</tt> depends on <tt>guesses</tt> itself.  Exercise&nbsp;<a href="#%_thm_3.63">3.63</a> addresses why\nwe want a local variable here.\n\n<p><a name="footnote_Temp_477" href="#call_footnote_Temp_477"><sup><small>66</small></sup></a> As in section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>,\nwe represent a pair of integers as a list rather than a Lisp pair.\n\n<p><a name="footnote_Temp_478" href="#call_footnote_Temp_478"><sup><small>67</small></sup></a> See exercise&nbsp;<a href="#%_thm_3.68">3.68</a> for some insight\ninto why we chose this decomposition.\n\n<p><a name="footnote_Temp_479" href="#call_footnote_Temp_479"><sup><small>68</small></sup></a> The precise statement of the\nrequired property on the order of combination is as follows: There\nshould be a function <em>f</em> of two arguments such that the pair\ncorresponding to element&nbsp;<em>i</em> of the first stream and element&nbsp;<em>j</em> of\nthe second stream will appear as element number <em>f</em>(<em>i</em>,<em>j</em>) of the output\nstream.  The trick of using <tt>interleave</tt> to accomplish this was\nshown to us by <a name="%_idx_3996"></a>David Turner, who employed it in the language <a name="%_idx_3998"></a>KRC\n(Turner 1981).\n\n<p><a name="footnote_Temp_485" href="#call_footnote_Temp_485"><sup><small>69</small></sup></a> We will require that the weighting function be such that\nthe weight of a pair increases as we move out along a row or down\nalong a column of the array of pairs.\n\n<p><a name="footnote_Temp_487" href="#call_footnote_Temp_487"><sup><small>70</small></sup></a> To quote from G. H. Hardy\'s obituary of\n<a name="%_idx_4012"></a><a name="%_idx_4014"></a><a name="%_idx_4016"></a>Ramanujan (Hardy 1921): ``It was Mr. Littlewood (I believe) who remarked that\n`every positive integer was one of his friends.\'  I remember once\ngoing to see him when he was lying ill at Putney.  I had ridden in\ntaxi-cab No. 1729, and remarked that the number seemed to me a rather\ndull one, and that I hoped it was not an unfavorable omen.  `No,\' he\nreplied, `it is a very interesting number; it is the smallest number\nexpressible as the sum of two cubes in two different ways.\' \'\'\nThe trick of using weighted pairs to generate the Ramanujan numbers\nwas shown to us by Charles Leiserson.\n\n<p><a name="footnote_Temp_494" href="#call_footnote_Temp_494"><sup><small>71</small></sup></a> This procedure is not guaranteed to work in all Scheme\nimplementations, although for any implementation there is a simple\nvariation that will work.  The problem has to do with subtle\ndifferences in the ways that Scheme implementations handle internal\ndefinitions.  (See section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.6">4.1.6</a>.)\n\n<p><a name="footnote_Temp_500" href="#call_footnote_Temp_500"><sup><small>72</small></sup></a> This is a small reflection, in Lisp, of the difficulties\nthat conventional strongly typed languages such as <a name="%_idx_4096"></a><a name="%_idx_4098"></a><a name="%_idx_4100"></a><a name="%_idx_4102"></a><a name="%_idx_4104"></a>Pascal have in\ncoping with higher-order procedures.  In such languages, the\nprogrammer must specify the data types of the arguments and the result\nof each procedure: number, logical value, sequence, and so on.\nConsequently, we could not express an abstraction such as ``map a\ngiven procedure <tt>proc</tt> over all the elements in a sequence\'\' by a\nsingle higher-order procedure such as <tt>stream-map</tt>.  Rather, we\nwould need a different mapping procedure for each different\ncombination of argument and result data types that might be specified\nfor a <tt>proc</tt>.  Maintaining a practical notion of ``data type\'\' in\nthe presence of higher-order procedures raises many difficult issues.\nOne way of dealing with this problem is illustrated by the language ML\n<a name="%_idx_4106"></a><a name="%_idx_4108"></a><a name="%_idx_4110"></a><a name="%_idx_4112"></a>(Gordon, Milner, and Wadsworth 1979), whose ``polymorphic data types\'\'\ninclude templates for higher-order transformations between data types.\nMoreover, data types for most procedures in ML are never explicitly\ndeclared by the programmer.  Instead, ML includes a <a name="%_idx_4114"></a><em>type-inferencing</em> mechanism that uses information in the environment\nto deduce the data types for newly defined procedures.\n\n<p><a name="footnote_Temp_504" href="#call_footnote_Temp_504"><sup><small>73</small></sup></a> Similarly in physics, when we observe a moving particle, we\nsay that the position (state) of the particle is changing.  However,\nfrom the perspective of the particle\'s <a name="%_idx_4156"></a>world line in space-time there\nis no change involved.\n\n<p><a name="footnote_Temp_505" href="#call_footnote_Temp_505"><sup><small>74</small></sup></a> John Backus, the inventor of Fortran, gave high\n<a name="%_idx_4166"></a><a name="%_idx_4168"></a><a name="%_idx_4170"></a><a name="%_idx_4172"></a><a name="%_idx_4174"></a>visibility to functional programming when he was awarded\nthe ACM Turing award in 1978.  His acceptance speech (Backus 1978)\nstrongly advocated the functional approach.  A good overview of\nfunctional programming is given in Henderson 1980 and in Darlington,\nHenderson, and Turner 1982.\n\n<p><a name="footnote_Temp_506" href="#call_footnote_Temp_506"><sup><small>75</small></sup></a> Observe that, for any two streams, there is in general more than one\n<a name="%_idx_4180"></a><a name="%_idx_4182"></a>acceptable order of interleaving.  Thus, technically, ``merge\'\' is a\nrelation rather than a function -- the answer is not a deterministic\nfunction of the inputs.  We already mentioned\n(footnote&nbsp;<a href="book-Z-H-23.html#footnote_Temp_411">39</a>) that nondeterminism is\nessential when dealing with concurrency.  The merge relation\nillustrates the same essential nondeterminism, from the functional\nperspective.  In section&nbsp;<a href="book-Z-H-28.html#%_sec_4.3">4.3</a>, we\nwill look at nondeterminism from yet another point of view.\n\n<p><a name="footnote_Temp_507" href="#call_footnote_Temp_507"><sup><small>76</small></sup></a> The object model approximates the world by\ndividing it into separate pieces.  The functional model does not\nmodularize along object boundaries.  The object model is useful when\n<a name="%_idx_4184"></a>the unshared state of the ``objects\'\' is much larger than the state\nthat they share.  An example of a place where the object viewpoint\nfails is <a name="%_idx_4186"></a>quantum\nmechanics, where thinking of things as individual particles leads to\nparadoxes and confusions.  Unifying the object view with the\nfunctional view may have little to do with programming, but rather\nwith fundamental epistemological issues.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_chap_4"></a>\n<h1 class=chapter>\n<div class=chapterheading><a href="book-Z-H-4.html#%_toc_%_chap_4">Chapter 4</a></div><p>\n<a href="book-Z-H-4.html#%_toc_%_chap_4">Metalinguistic Abstraction</a></h1><p>\n\n<p>\n<div align=right> \n<table width=60%><tr><td>\n<span class=epigraph>\n<p>\n\n<tt>...</tt> It\'s in words that the magic\nis -- Abracadabra, Open Sesame, and the rest -- but the magic words in\none story aren\'t magical in the next.  The real magic is to understand\nwhich words work, and when, and for what; the trick is to learn the\ntrick.<br>\n<tt>...</tt> And those words are made from the letters of our\nalphabet: a couple-dozen squiggles we can draw with the pen.  This is\nthe key!  And the treasure, too, if we can only get our hands on it!\nIt\'s as if -- as if the key to the treasure <em>is</em> the treasure!<p>\n\n<a name="%_idx_4188"></a>John Barth, <em>Chimera</em><p>\n\n</span>\n</td></tr></table>\n</div>\n\n<p><p>\n\nIn our study of program design, we have seen that expert programmers\ncontrol the complexity of their designs with the same general\ntechniques used by designers of all complex systems.  They combine\nprimitive elements to form compound objects, they abstract compound\nobjects to form higher-level building blocks, and they preserve\nmodularity by adopting appropriate large-scale views of system\nstructure.  In illustrating these techniques, we have used Lisp as a\nlanguage for describing processes and for constructing computational\ndata objects and processes to model complex phenomena in the real\nworld.  However, as we confront increasingly complex problems, we will\nfind that Lisp, or indeed any fixed programming language, is not\nsufficient for our needs.  We must constantly turn to new languages in\norder to express our ideas more effectively.  Establishing new\nlanguages is a powerful strategy for controlling complexity in\nengineering design; we can often enhance our ability to deal with a\ncomplex problem by adopting a new language that enables us to describe\n(and hence to think about) the problem in a different way, using\nprimitives, means of combination, and means of abstraction that are\nparticularly well suited to the problem at hand.<a name="call_footnote_Temp_508" href="#footnote_Temp_508"><sup><small>1</small></sup></a><p>\n\n<a name="%_idx_4190"></a><a name="%_idx_4192"></a>Programming is endowed with a multitude of languages.  There are\nphysical languages, such as the machine languages for particular\ncomputers.  These languages are concerned with the representation of\ndata and control in terms of individual bits of storage and primitive\nmachine instructions.  The machine-language programmer is concerned\nwith using the given hardware to erect systems and utilities for the\nefficient implementation of resource-limited computations.  High-level\nlanguages, erected on a machine-language substrate, hide concerns\nabout the representation of data as collections of bits and the\nrepresentation of programs as sequences of primitive instructions.\nThese languages have means of combination and abstraction, such as\nprocedure definition, that are appropriate to the larger-scale\norganization of systems.<p>\n\n<a name="%_idx_4194"></a><a name="%_idx_4196"></a><em>Metalinguistic abstraction</em> -- establishing new\nlanguages -- plays an important role in all branches of engineering\ndesign.  It is particularly important to computer programming, because\nin programming not only can we formulate new languages but we can also\nimplement these languages by constructing evaluators.  An <a name="%_idx_4198"></a><em>evaluator</em> (or <em>interpreter</em>) for a programming language is a procedure\nthat, when applied to an expression of the language, performs the\nactions required to evaluate that expression.<p>\n\nIt is no exaggeration to regard this as the most fundamental idea in\nprogramming:\n<blockquote>\nThe evaluator, which determines the meaning of expressions in a\nprogramming language, is just another program.\n</blockquote>\nTo appreciate this point is to change our images of ourselves as\nprogrammers.  We come to see ourselves as designers of languages,\nrather than only users of languages designed by others.<p>\n\n\nIn fact, we can regard almost any program as the evaluator for some\nlanguage.  For instance, the polynomial manipulation system of\nsection&nbsp;<a href="book-Z-H-18.html#%_sec_2.5.3">2.5.3</a> embodies the rules of polynomial\narithmetic and implements them in terms of operations on\nlist-structured data.  If we augment this system with procedures to\nread and print polynomial expressions, we have the core of a\nspecial-purpose language for dealing with problems in symbolic\nmathematics.  The digital-logic simulator of\nsection&nbsp;<a href="book-Z-H-22.html#%_sec_3.3.4">3.3.4</a> and the constraint propagator of\nsection&nbsp;<a href="book-Z-H-22.html#%_sec_3.3.5">3.3.5</a> are legitimate languages in their own\nright, each with its own primitives, means of combination, and means\nof abstraction.  Seen from this perspective, the technology for coping\nwith large-scale computer systems merges with the technology for\nbuilding new computer languages, and <a name="%_idx_4200"></a>computer science itself becomes\nno more (and no less) than the discipline of constructing appropriate\ndescriptive languages.<p>\n\nWe now embark on a tour of the technology by which languages are\nestablished in terms of other languages.  In this chapter we shall use\nLisp as a base, implementing evaluators as Lisp procedures.  <a name="%_idx_4202"></a>Lisp is\nparticularly well suited to this task, because of its ability to\nrepresent and manipulate symbolic expressions.  We will take the first\nstep in understanding how languages are implemented by building an\nevaluator for Lisp itself.  The language implemented by our evaluator\nwill be a subset of the Scheme dialect of Lisp that we use in this\nbook.  Although the evaluator described in this chapter is written for\na particular dialect of Lisp, it contains the essential structure of\nan evaluator for any expression-oriented language designed for writing\nprograms for a sequential machine.  (In fact, most language processors\ncontain, deep within them, a little ``Lisp\'\' evaluator.)  The\nevaluator has been simplified for the purposes of illustration and\ndiscussion, and some features have been left out that would be\nimportant to include in a production-quality Lisp system.\nNevertheless, this simple evaluator is adequate to execute most of the\nprograms in this book.<a name="call_footnote_Temp_509" href="#footnote_Temp_509"><sup><small>2</small></sup></a><p>\n\n\nAn important advantage of making the evaluator accessible as a Lisp\nprogram is that we can implement alternative evaluation rules by\ndescribing these as modifications to the evaluator program.  One place\nwhere we can use this power to good effect is to gain extra control\nover the ways in which computational models embody the notion of time,\nwhich was so central to the discussion in chapter&nbsp;3.  There, we\nmitigated some of the complexities of state and assignment by using\nstreams to decouple the representation of time in the world from time\nin the computer.  Our stream programs, however, were\nsometimes cumbersome, because they were constrained by\nthe applicative-order evaluation of Scheme.\nIn section&nbsp;<a href="book-Z-H-27.html#%_sec_4.2">4.2</a>, we\'ll change\nthe underlying language to provide for a more elegant approach, by modifying\nthe evaluator to provide for <em>normal-order evaluation</em>.<p>\n\nSection&nbsp;<a href="book-Z-H-28.html#%_sec_4.3">4.3</a> implements a more\nambitious linguistic change, whereby expressions have many values,\nrather than just a single value.  In this language of <em>nondeterministic computing</em>, it is natural to express processes that\ngenerate all possible values for expressions and then search for those\nvalues that satisfy certain constraints.  In terms of models of\ncomputation and time, this is like having time branch into a set of\n``possible futures\'\' and then searching for appropriate time lines.\nWith our nondeterministic evaluator, keeping track of multiple values\nand performing searches are handled automatically by the underlying\nmechanism of the language.<p>\n\nIn section&nbsp;<a href="book-Z-H-29.html#%_sec_4.4">4.4</a> we implement a <em>logic-programming</em> language in which knowledge is expressed in terms\nof relations, rather than in terms of computations with inputs and\noutputs.  Even though this makes the language drastically different\nfrom Lisp, or indeed from any conventional language, we will see that\nthe logic-programming evaluator shares the essential structure of the\nLisp evaluator.<p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_508" href="#call_footnote_Temp_508"><sup><small>1</small></sup></a> The same idea\nis pervasive throughout all of engineering.  For example, electrical\nengineers use many different languages for describing circuits.  Two\nof these are the language of electrical <em>networks</em> and the\nlanguage of electrical <em>systems</em>.  The network language emphasizes\nthe physical modeling of devices in terms of discrete electrical\nelements.  The primitive objects of the network language are primitive\nelectrical components such as resistors, capacitors, inductors, and\ntransistors, which are characterized in terms of physical variables\ncalled voltage and current.  When describing circuits in the network\nlanguage, the engineer is concerned with the physical characteristics\nof a design.  In contrast, the primitive objects of the system\nlanguage are signal-processing modules such as filters and amplifiers.\nOnly the functional behavior of the modules is relevant, and signals\nare manipulated without concern for their physical realization as\nvoltages and currents.  The system language is erected on the network\nlanguage, in the sense that the elements of signal-processing systems\nare constructed from electrical networks.  Here, however, the concerns\nare with the large-scale organization of electrical devices to solve a\ngiven application problem; the physical feasibility of the parts is\nassumed.  This layered collection of languages is another example of\nthe stratified design technique illustrated by the picture\nlanguage of section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.4">2.2.4</a>.\n\n<p><a name="footnote_Temp_509" href="#call_footnote_Temp_509"><sup><small>2</small></sup></a> The most important features that our evaluator leaves out\nare mechanisms for handling errors and supporting debugging.  For a\nmore extensive discussion of evaluators, see <a name="%_idx_4204"></a><a name="%_idx_4206"></a><a name="%_idx_4208"></a>Friedman, Wand, and Haynes\n1992, which gives an exposition of programming languages that proceeds\nvia a sequence of evaluators written in Scheme.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_4.1"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_4.1">4.1&nbsp;&nbsp;The Metacircular Evaluator</a></h2><p>\n\n\n<a name="%_idx_4210"></a>\nOur evaluator for Lisp will be implemented as a Lisp program.  It may\nseem circular to think about evaluating Lisp programs using an\nevaluator that is itself implemented in Lisp.  However, evaluation is\na process, so it is appropriate to describe the evaluation process\nusing Lisp, which, after all, is our tool for describing\nprocesses.<a name="call_footnote_Temp_510" href="#footnote_Temp_510"><sup><small>3</small></sup></a>  An evaluator that is written in the same language\n<a name="%_idx_4212"></a><a name="%_idx_4214"></a>that it evaluates is said to be <em>metacircular</em>.<p>\n\n\n<a name="%_idx_4216"></a><a name="%_idx_4218"></a>The metacircular evaluator is essentially a Scheme formulation of the\nenvironment model of evaluation described in\nsection&nbsp;<a href="book-Z-H-21.html#%_sec_3.2">3.2</a>.  Recall that the model has two\nbasic parts:<p>\n\n<blockquote>\n<p>1. To evaluate a combination (a compound expression other than a \nspecial form), evaluate the subexpressions and then apply the value of\nthe operator subexpression to the values of the operand\nsubexpressions.<p>\n\n<p>2. To apply a compound procedure to a set of arguments, evaluate the\nbody of the procedure in a new environment.  To construct this\nenvironment, extend the environment part of the procedure object by a\nframe in which the formal parameters of the procedure are bound to the\narguments to which the procedure is applied.\n</blockquote><p>\n\n<a name="%_idx_4220"></a>These two rules describe the essence of the evaluation process, a\nbasic cycle in which expressions to be evaluated in environments are\nreduced to procedures to be applied to arguments, which in turn are\nreduced to new expressions to be evaluated in new environments, and so\non, until we get down to symbols, whose values are looked\nup in the environment, and to primitive procedures, which are applied\ndirectly (see figure&nbsp;<a href="#%_fig_4.1">4.1</a>).<a name="call_footnote_Temp_511" href="#footnote_Temp_511"><sup><small>4</small></sup></a>\nThis evaluation cycle will be embodied by the interplay between the two\ncritical procedures in the evaluator, <tt>eval</tt> and <tt>apply</tt>,\nwhich are described in section&nbsp;<a href="#%_sec_4.1.1">4.1.1</a>\n(see figure&nbsp;<a href="#%_fig_4.1">4.1</a>).<p>\n\nThe implementation of the evaluator will depend upon procedures that\ndefine the <em>syntax</em> of the expressions to be evaluated.  We will\nuse <a name="%_idx_4224"></a>data abstraction to make the evaluator independent of the\nrepresentation of the language.  For example, rather than committing\nto a choice that an assignment is to be represented by a list\nbeginning with the symbol <tt>set!</tt> we use an abstract predicate\n<tt>assignment?</tt> to test for an assignment, and we use abstract\nselectors <tt>assignment-variable</tt> and <tt>assignment-value</tt> to\naccess the parts of an assignment.  Implementation of expressions will\nbe described in detail in section&nbsp;<a href="#%_sec_4.1.2">4.1.2</a>.\nThere are also operations, described in\nsection&nbsp;<a href="#%_sec_4.1.3">4.1.3</a>, that specify the\nrepresentation of procedures and environments.  For example, <tt>make-procedure</tt> constructs compound procedures, <tt>lookup-variable-value</tt> accesses the values of variables, and <tt>apply-primitive-procedure</tt> applies a primitive procedure to a given list\nof arguments.<p>\n\n<a name="%_sec_4.1.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.1">4.1.1&nbsp;&nbsp;The Core of the Evaluator</a></h3><p>\n\n\n<a name="%_idx_4226"></a>\n<a name="%_fig_4.1"></a><p><div align=left><table width=100%><tr><td><img src="ch4-Z-G-1.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 4.1:</b>&nbsp;&nbsp;The <tt>eval</tt>-<tt>apply</tt> cycle exposes the essence\nof a computer language.</div></caption><tr><td>\n<a name="%_idx_4228"></a>\n</td></tr></table></div><p><p>\n\nThe evaluation process can be described as the interplay between two\nprocedures: <tt>eval</tt> and <tt>apply</tt>.<p>\n\n<a name="%_sec_Temp_512"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_512">Eval</a></h4><p>\n\n<a name="%_idx_4230"></a><tt>Eval</tt> takes as arguments an expression and an environment.  It\nclassifies the expression and directs its evaluation.  <tt>Eval</tt> is\nstructured as a case analysis of the syntactic type of the expression\nto be evaluated.  In order to keep the procedure general, we express\nthe determination of the type of an expression abstractly, making no\ncommitment to any particular <a name="%_idx_4232"></a>representation for the various types of\nexpressions.  Each type of expression has a predicate that tests for\nit and an abstract means for selecting its parts.  This <a name="%_idx_4234"></a><a name="%_idx_4236"></a><em>abstract\nsyntax</em> makes it easy to see how we can change the syntax of the\nlanguage by using the same evaluator, but with a different collection of\nsyntax procedures.<p>\n\n<a name="%_sec_Temp_513"></a>\n<h5><a href="book-Z-H-4.html#%_toc_%_sec_Temp_513">Primitive expressions</a></h5><p>\n\n<p><ul>\n<li><a name="%_idx_4238"></a><a name="%_idx_4240"></a>For self-evaluating expressions, such as numbers, <tt>eval</tt> returns\nthe expression itself.<p>\n\n<li><tt>Eval</tt> must look up variables in the environment to find their values.\n</ul><p><p>\n\n<a name="%_sec_Temp_514"></a>\n<h5><a href="book-Z-H-4.html#%_toc_%_sec_Temp_514">Special forms</a></h5><p>\n\n<p><ul>\n<p>\n\n<li>For quoted expressions, <tt>eval</tt> returns the expression that was\nquoted.<p>\n\n<li>An assignment to (or a definition of) a variable must recursively call\n<tt>eval</tt> to compute the new value to be associated with the\nvariable.  The environment must be modified to change (or create) the\nbinding of the variable.<p>\n\n<li>An <tt>if</tt> expression requires special processing of its parts, so as to\nevaluate the consequent if the predicate is true, and otherwise to\nevaluate the alternative.<p>\n\n<li>A <tt>lambda</tt> expression must be transformed into an\napplicable procedure by packaging together the parameters and body\nspecified by the <tt>lambda</tt> expression with the environment of the\nevaluation.<p>\n\n<li>A <tt>begin</tt> expression requires evaluating its sequence of\nexpressions in the order in which they appear.<p>\n\n<li>A case analysis (<tt>cond</tt>) is transformed into a nest of <tt>if</tt>\nexpressions and then evaluated.\n</ul><p><p>\n\n\n<a name="%_sec_Temp_515"></a>\n<h5><a href="book-Z-H-4.html#%_toc_%_sec_Temp_515">Combinations</a></h5><p>\n\n<p><ul>\n<li>For a procedure application, <tt>eval</tt> must recursively\nevaluate the operator part and the operands of the combination.  The\nresulting procedure and arguments are passed to <tt>apply</tt>, which\nhandles the actual procedure application.\n</ul><p><p>\n\n<p><p><a name="%_idx_4242"></a>Here is the definition of <tt>eval</tt>:<p>\n\n\n<p><p><tt>(define&nbsp;(eval&nbsp;exp&nbsp;env)<br>\n&nbsp;&nbsp;(cond&nbsp;((self-evaluating?&nbsp;exp)&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((variable?&nbsp;exp)&nbsp;(lookup-variable-value&nbsp;exp&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((quoted?&nbsp;exp)&nbsp;(text-of-quotation&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((assignment?&nbsp;exp)&nbsp;(eval-assignment&nbsp;exp&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((definition?&nbsp;exp)&nbsp;(eval-definition&nbsp;exp&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((if?&nbsp;exp)&nbsp;(eval-if&nbsp;exp&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-procedure&nbsp;(lambda-parameters&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda-body&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((begin?&nbsp;exp)&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval-sequence&nbsp;(begin-actions&nbsp;exp)&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((cond?&nbsp;exp)&nbsp;(eval&nbsp;(cond-&gt;if&nbsp;exp)&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((application?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;(eval&nbsp;(operator&nbsp;exp)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-of-values&nbsp;(operands&nbsp;exp)&nbsp;env)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;expression&nbsp;type&nbsp;--&nbsp;EVAL&quot;&nbsp;exp))))<br>\n</tt><p><p>\n<p>\n\n<a name="%_idx_4244"></a><a name="%_idx_4246"></a>For clarity, <tt>eval</tt> has been implemented as a case analysis using\n<tt>cond</tt>.  The disadvantage of this is that our procedure handles\nonly a few distinguishable types of expressions, and no new ones can\nbe defined without editing the definition of <tt>eval</tt>.  In most Lisp\nimplementations, dispatching on the type of an expression is done in a\ndata-directed style.  This allows a user to add new types of\nexpressions that <tt>eval</tt> can distinguish, without modifying the\ndefinition of <tt>eval</tt> itself.\n(See exercise&nbsp;<a href="#%_thm_4.3">4.3</a>.)<p>\n\n<a name="%_sec_Temp_516"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_516">Apply</a></h4><p>\n\n<tt>Apply</tt> takes two arguments, a procedure and a list of arguments\nto which the procedure should be applied.  <tt>Apply</tt> classifies\nprocedures into two kinds: It calls <a name="%_idx_4248"></a><tt>apply-primitive-procedure</tt> to apply primitives; it applies compound\nprocedures by sequentially evaluating the expressions that\nmake up the body of the procedure.  The environment for the\nevaluation of the body of a compound procedure\nis constructed by extending the base environment carried by\nthe procedure to include a frame that binds the parameters of the\nprocedure to the arguments to which the procedure is to be applied.\nHere is the definition of <tt>apply</tt>:<p>\n\n<p><p><tt><a name="%_idx_4250"></a>(define&nbsp;(apply&nbsp;procedure&nbsp;arguments)<br>\n&nbsp;&nbsp;(cond&nbsp;((primitive-procedure?&nbsp;procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply-primitive-procedure&nbsp;procedure&nbsp;arguments))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((compound-procedure?&nbsp;procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval-sequence<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure-body&nbsp;procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(extend-environment<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure-parameters&nbsp;procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure-environment&nbsp;procedure))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Unknown&nbsp;procedure&nbsp;type&nbsp;--&nbsp;APPLY&quot;&nbsp;procedure))))<br>\n</tt><p><p><p>\n\n\n<a name="%_sec_Temp_517"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_517">Procedure arguments</a></h4><p>\n\nWhen <tt>eval</tt> processes a\nprocedure application, it uses <tt>list-of-values</tt> to produce the\nlist of arguments to which the procedure is to be applied. <tt>List-of-values</tt> takes as an argument the operands of the combination.\nIt evaluates each operand and returns a list of the corresponding\nvalues:<a name="call_footnote_Temp_518" href="#footnote_Temp_518"><sup><small>5</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_4256"></a>(define&nbsp;(list-of-values&nbsp;exps&nbsp;env)<br>\n&nbsp;&nbsp;(if&nbsp;(no-operands?&nbsp;exps)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(eval&nbsp;(first-operand&nbsp;exps)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-of-values&nbsp;(rest-operands&nbsp;exps)&nbsp;env))))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_519"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_519">Conditionals</a></h4><p>\n\n<tt>Eval-if</tt> evaluates the predicate part of an <tt>if</tt> expression\nin the given environment.  If\nthe result is true, <tt>eval-if</tt> evaluates the consequent, otherwise\nit evaluates the alternative:<p>\n\n<p><p><tt><a name="%_idx_4258"></a>(define&nbsp;(eval-if&nbsp;exp&nbsp;env)<br>\n&nbsp;&nbsp;(if&nbsp;(true?&nbsp;(eval&nbsp;(if-predicate&nbsp;exp)&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval&nbsp;(if-consequent&nbsp;exp)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval&nbsp;(if-alternative&nbsp;exp)&nbsp;env)))<br>\n</tt><p><p><p>\n\n<a name="%_idx_4260"></a>The use of <tt>true?</tt> in <tt>eval-if</tt> highlights the issue of the\nconnection between an implemented language and an implementation\nlanguage.  The <tt>if-predicate</tt> is evaluated in the language being\nimplemented and thus yields a value in that language.  The interpreter\npredicate <tt>true?</tt> translates that value into a value that can be\ntested by the <tt>if</tt> in the implementation language: The\nmetacircular representation of truth might not be the same as that of\nthe underlying Scheme.<a name="call_footnote_Temp_520" href="#footnote_Temp_520"><sup><small>6</small></sup></a><p>\n\n<a name="%_sec_Temp_521"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_521">Sequences</a></h4><p>\n\n<tt>Eval-sequence</tt> is used by <tt>apply</tt> to evaluate the sequence of\nexpressions in a procedure body and by <tt>eval</tt> to evaluate the\nsequence of expressions in a <tt>begin</tt>\nexpression.  It takes as arguments a sequence of expressions and an\nenvironment, and evaluates the expressions in the order in which they\noccur.  The value returned is the value of the final expression.<p>\n\n<p><p><tt><a name="%_idx_4264"></a>(define&nbsp;(eval-sequence&nbsp;exps&nbsp;env)<br>\n&nbsp;&nbsp;(cond&nbsp;((last-exp?&nbsp;exps)&nbsp;(eval&nbsp;(first-exp&nbsp;exps)&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(eval&nbsp;(first-exp&nbsp;exps)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval-sequence&nbsp;(rest-exps&nbsp;exps)&nbsp;env))))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_522"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_522">Assignments and definitions</a></h4><p>\n\nThe following procedure handles assignments to variables.  It calls\n<tt>eval</tt> to find the value to be assigned and transmits the variable\nand the resulting value to <tt>set-variable-value!</tt> to be installed\nin the designated environment.<p>\n\n<p><p><tt><a name="%_idx_4266"></a>(define&nbsp;(eval-assignment&nbsp;exp&nbsp;env)<br>\n&nbsp;&nbsp;(set-variable-value!&nbsp;(assignment-variable&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval&nbsp;(assignment-value&nbsp;exp)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env)<br>\n&nbsp;&nbsp;\'ok)<br>\n</tt><p><p>\nDefinitions of variables are handled in a similar\nmanner.<a name="call_footnote_Temp_523" href="#footnote_Temp_523"><sup><small>7</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_4268"></a>(define&nbsp;(eval-definition&nbsp;exp&nbsp;env)<br>\n&nbsp;&nbsp;(define-variable!&nbsp;(definition-variable&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval&nbsp;(definition-value&nbsp;exp)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env)<br>\n&nbsp;&nbsp;\'ok)<br>\n</tt><p><p>\nWe have chosen here to return the symbol <tt>ok</tt> as the value\nof an assignment or a definition.<a name="call_footnote_Temp_524" href="#footnote_Temp_524"><sup><small>8</small></sup></a><p>\n\n<p><a name="%_thm_4.1"></a>\n<b>Exercise 4.1.</b>&nbsp;&nbsp;<a name="%_idx_4270"></a><a name="%_idx_4272"></a>Notice that we cannot tell whether the metacircular evaluator\nevaluates operands from left to right or from right to left.  Its evaluation\norder is inherited from the underlying Lisp:\nIf the arguments to <tt>cons</tt> in <tt>list-of-values</tt>\nare evaluated from left to right, then <tt>list-of-values</tt> will\nevaluate operands from left to right; and \nif the arguments to <tt>cons</tt>\nare evaluated from right to left, then <tt>list-of-values</tt> will\nevaluate operands from right to left.<p>\n\nWrite a version of <tt>list-of-values</tt> that evaluates operands\nfrom left to right regardless of the order of evaluation in the underlying\nLisp.  Also write a version of <tt>list-of-values</tt> that evaluates operands\nfrom right to left.\n\n<p><p>\n\n<a name="%_sec_4.1.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.2">4.1.2&nbsp;&nbsp;Representing Expressions</a></h3><p>\n\n\n<a name="%_idx_4274"></a><a name="%_idx_4276"></a>\n<a name="%_idx_4278"></a>The evaluator is reminiscent of the symbolic differentiation program\ndiscussed in section&nbsp;<a href="book-Z-H-16.html#%_sec_2.3.2">2.3.2</a>.  Both\nprograms operate on symbolic expressions.  In both programs, the\nresult of operating on a compound expression is determined by\noperating recursively on the pieces of the expression and combining\nthe results in a way that depends on the type of the expression.  In\nboth programs we used <a name="%_idx_4280"></a>data abstraction to decouple the general rules\nof operation from the details of how expressions are represented.  In\nthe differentiation program this meant that the same differentiation\nprocedure could deal with algebraic expressions in prefix form, in\ninfix form, or in some other form.  For the evaluator, this means that\nthe syntax of the language being evaluated is determined solely by the\nprocedures that classify and extract pieces of expressions.<p>\n\n<p><p>Here is the specification of the syntax of our language:\n<p><p><p>\n\n&curren; The only self-evaluating items are numbers and\nstrings:<p>\n\n<p><p><tt><a name="%_idx_4282"></a>(define&nbsp;(self-evaluating?&nbsp;exp)<br>\n&nbsp;&nbsp;(cond&nbsp;((number?&nbsp;exp)&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((string?&nbsp;exp)&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;false)))<br>\n</tt><p><p>\n&curren; Variables are represented by symbols:<p>\n\n<p><p><tt><a name="%_idx_4284"></a>(define&nbsp;(variable?&nbsp;exp)&nbsp;(symbol?&nbsp;exp))<br>\n</tt><p><p>\n&curren; Quotations have the form <tt>(quote\n&lt;<em>text-of-quotation</em>&gt;)</tt>:<a name="call_footnote_Temp_526" href="#footnote_Temp_526"><sup><small>9</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_4286"></a>(define&nbsp;(quoted?&nbsp;exp)<br>\n&nbsp;&nbsp;(tagged-list?&nbsp;exp&nbsp;\'quote))<br>\n<br>\n<a name="%_idx_4288"></a>(define&nbsp;(text-of-quotation&nbsp;exp)&nbsp;(cadr&nbsp;exp))<br>\n</tt><p><p>\n<tt>Quoted?</tt> is defined in terms of the procedure <tt>tagged-list?</tt>, which identifies lists beginning with a designated\nsymbol:<p>\n\n<p><p><tt><a name="%_idx_4290"></a>(define&nbsp;(tagged-list?&nbsp;exp&nbsp;tag)<br>\n&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eq?&nbsp;(car&nbsp;exp)&nbsp;tag)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false))<br>\n</tt><p><p>\n&curren; Assignments have the form <tt>(set!\n&lt;<em>var</em>&gt; &lt;<em>value</em>&gt;)</tt>:<p>\n\n<p><p><tt><a name="%_idx_4292"></a>(define&nbsp;(assignment?&nbsp;exp)<br>\n&nbsp;&nbsp;(tagged-list?&nbsp;exp&nbsp;\'set!))<br>\n<a name="%_idx_4294"></a>(define&nbsp;(assignment-variable&nbsp;exp)&nbsp;(cadr&nbsp;exp))<br>\n<a name="%_idx_4296"></a>(define&nbsp;(assignment-value&nbsp;exp)&nbsp;(caddr&nbsp;exp))<br>\n</tt><p><p>\n&curren; Definitions have the form<p>\n\n<p><p><tt>(define&nbsp;&lt;<em>var</em>&gt;&nbsp;&lt;<em>value</em>&gt;)<br>\n</tt><p><p>\nor the form<p>\n\n<p><p><tt>(define&nbsp;(&lt;<em>var</em>&gt;&nbsp;&lt;<em>parameter<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>parameter<sub><em>n</em></sub></em>&gt;)<br>\n&nbsp;&nbsp;&lt;<em>body</em>&gt;)<br>\n</tt><p><p>\n<a name="%_idx_4298"></a><a name="%_idx_4300"></a>The latter form (standard procedure definition) is syntactic sugar for<p>\n\n<p><p><tt>(define&nbsp;&lt;<em>var</em>&gt;<br>\n&nbsp;&nbsp;(lambda&nbsp;(&lt;<em>parameter<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>parameter<sub><em>n</em></sub></em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>body</em>&gt;))<br>\n</tt><p><p>\nThe corresponding syntax procedures are the following:<p>\n\n<p><p><tt><a name="%_idx_4302"></a>(define&nbsp;(definition?&nbsp;exp)<br>\n&nbsp;&nbsp;(tagged-list?&nbsp;exp&nbsp;\'define))<br>\n<a name="%_idx_4304"></a>(define&nbsp;(definition-variable&nbsp;exp)<br>\n&nbsp;&nbsp;(if&nbsp;(symbol?&nbsp;(cadr&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cadr&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(caadr&nbsp;exp)))<br>\n<a name="%_idx_4306"></a>(define&nbsp;(definition-value&nbsp;exp)<br>\n&nbsp;&nbsp;(if&nbsp;(symbol?&nbsp;(cadr&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(caddr&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-lambda&nbsp;(cdadr&nbsp;exp)&nbsp;&nbsp;&nbsp;<em>;&nbsp;formal&nbsp;parameters</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cddr&nbsp;exp))))&nbsp;<em>;&nbsp;body</em><br>\n</tt><p><p>\n&curren; <tt>Lambda</tt> expressions are lists that begin with the\nsymbol <tt>lambda</tt>:<p>\n\n<p><p><tt><a name="%_idx_4308"></a>(define&nbsp;(lambda?&nbsp;exp)&nbsp;(tagged-list?&nbsp;exp&nbsp;\'lambda))<br>\n<a name="%_idx_4310"></a>(define&nbsp;(lambda-parameters&nbsp;exp)&nbsp;(cadr&nbsp;exp))<br>\n<a name="%_idx_4312"></a>(define&nbsp;(lambda-body&nbsp;exp)&nbsp;(cddr&nbsp;exp))<br>\n</tt><p><p>\nWe also provide a constructor for <tt>lambda</tt> expressions,\nwhich is used by <tt>definition-value</tt>, above:\n<p><p><tt><a name="%_idx_4314"></a>(define&nbsp;(make-lambda&nbsp;parameters&nbsp;body)<br>\n&nbsp;&nbsp;(cons&nbsp;\'lambda&nbsp;(cons&nbsp;parameters&nbsp;body)))<br>\n</tt><p><p>\n&curren; Conditionals begin with <tt>if</tt> and have a predicate, a\nconsequent, and an (optional) alternative.  If the expression has no\nalternative part, we provide <tt>false</tt> as the alternative.<a name="call_footnote_Temp_527" href="#footnote_Temp_527"><sup><small>10</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_4316"></a>(define&nbsp;(if?&nbsp;exp)&nbsp;(tagged-list?&nbsp;exp&nbsp;\'if))<br>\n<a name="%_idx_4318"></a>(define&nbsp;(if-predicate&nbsp;exp)&nbsp;(cadr&nbsp;exp))<br>\n<a name="%_idx_4320"></a>(define&nbsp;(if-consequent&nbsp;exp)&nbsp;(caddr&nbsp;exp))<br>\n<a name="%_idx_4322"></a>(define&nbsp;(if-alternative&nbsp;exp)<br>\n&nbsp;&nbsp;(if&nbsp;(not&nbsp;(null?&nbsp;(cdddr&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cadddr&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'false))<br>\n</tt><p><p>\nWe also provide a constructor for <tt>if</tt> expressions,\nto be used by <tt>cond-&gt;if</tt> to transform <tt>cond</tt> expressions\ninto <tt>if</tt> expressions:\n<p><p><tt><a name="%_idx_4324"></a>(define&nbsp;(make-if&nbsp;predicate&nbsp;consequent&nbsp;alternative)<br>\n&nbsp;&nbsp;(list&nbsp;\'if&nbsp;predicate&nbsp;consequent&nbsp;alternative))<br>\n</tt><p><p>\n&curren; <tt>Begin</tt> packages a sequence of expressions into a single\nexpression.  We include syntax operations on <tt>begin</tt> expressions\nto extract the actual sequence from the <tt>begin</tt> expression, as\nwell as selectors that return the first expression and the rest of the\nexpressions in the sequence.<a name="call_footnote_Temp_528" href="#footnote_Temp_528"><sup><small>11</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_4326"></a>(define&nbsp;(begin?&nbsp;exp)&nbsp;(tagged-list?&nbsp;exp&nbsp;\'begin))<br>\n<a name="%_idx_4328"></a>(define&nbsp;(begin-actions&nbsp;exp)&nbsp;(cdr&nbsp;exp))<br>\n<a name="%_idx_4330"></a>(define&nbsp;(last-exp?&nbsp;seq)&nbsp;(null?&nbsp;(cdr&nbsp;seq)))<br>\n<a name="%_idx_4332"></a>(define&nbsp;(first-exp&nbsp;seq)&nbsp;(car&nbsp;seq))<br>\n<a name="%_idx_4334"></a>(define&nbsp;(rest-exps&nbsp;seq)&nbsp;(cdr&nbsp;seq))<br>\n</tt><p><p>\nWe also include a constructor <tt>sequence-&gt;exp</tt> (for use by\n<tt>cond-&gt;if</tt>) that transforms a sequence into a single expression,\nusing <tt>begin</tt> if necessary:<p>\n\n<p><p><tt><a name="%_idx_4336"></a>(define&nbsp;(sequence-&gt;exp&nbsp;seq)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;seq)&nbsp;seq)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((last-exp?&nbsp;seq)&nbsp;(first-exp&nbsp;seq))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(make-begin&nbsp;seq))))<br>\n<a name="%_idx_4338"></a>(define&nbsp;(make-begin&nbsp;seq)&nbsp;(cons&nbsp;\'begin&nbsp;seq))<br>\n</tt><p><p>\n&curren; A procedure application is any compound expression\nthat is not one of the above expression types.  The <tt>car</tt> of the\nexpression is the operator, and the <tt>cdr</tt> is the list of operands:<p>\n\n<p><p><tt><a name="%_idx_4340"></a>(define&nbsp;(application?&nbsp;exp)&nbsp;(pair?&nbsp;exp))<br>\n<a name="%_idx_4342"></a>(define&nbsp;(operator&nbsp;exp)&nbsp;(car&nbsp;exp))<br>\n<a name="%_idx_4344"></a>(define&nbsp;(operands&nbsp;exp)&nbsp;(cdr&nbsp;exp))<br>\n<a name="%_idx_4346"></a>(define&nbsp;(no-operands?&nbsp;ops)&nbsp;(null?&nbsp;ops))<br>\n<a name="%_idx_4348"></a>(define&nbsp;(first-operand&nbsp;ops)&nbsp;(car&nbsp;ops))<br>\n<a name="%_idx_4350"></a>(define&nbsp;(rest-operands&nbsp;ops)&nbsp;(cdr&nbsp;ops))<br>\n</tt><p><p><p>\n\n\n<a name="%_sec_Temp_529"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_529">Derived expressions</a></h4><p>\n\n<a name="%_idx_4352"></a><a name="%_idx_4354"></a><a name="%_idx_4356"></a><a name="%_idx_4358"></a>\nSome special forms in our language can be defined in terms of\nexpressions involving other special forms, rather than being\nimplemented directly.  One example is <tt>cond</tt>, which can be\nimplemented as a nest of <tt>if</tt> expressions.  For example,\nwe can reduce the problem of evaluating the expression<p>\n\n<p><p><tt>(cond&nbsp;((&gt;&nbsp;x&nbsp;0)&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;x&nbsp;0)&nbsp;(display&nbsp;\'zero)&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(-&nbsp;x)))<br>\n</tt><p><p>\nto the problem of evaluating the following\nexpression involving <tt>if</tt> and <tt>begin</tt> expressions:<p>\n\n<p><p><tt>(if&nbsp;(&gt;&nbsp;x&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;x<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;x&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(display&nbsp;\'zero)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;x)))<br>\n</tt><p><p>\n\nImplementing the evaluation of <tt>cond</tt> in this way\nsimplifies the evaluator because it reduces the number of special\nforms for which the evaluation process must be explicitly specified.<p>\n\nWe include syntax procedures that extract the parts of a <tt>cond</tt>\nexpression, and a procedure <tt>cond-&gt;if</tt> that transforms <tt>cond</tt>\nexpressions into <tt>if</tt> expressions.  A case analysis begins with <tt>cond</tt> and has a list of predicate-action clauses.  A clause is an <tt>else</tt> clause if its predicate is the symbol <tt>else</tt>.<a name="call_footnote_Temp_530" href="#footnote_Temp_530"><sup><small>12</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_4360"></a>(define&nbsp;(cond?&nbsp;exp)&nbsp;(tagged-list?&nbsp;exp&nbsp;\'cond))<br>\n<a name="%_idx_4362"></a>(define&nbsp;(cond-clauses&nbsp;exp)&nbsp;(cdr&nbsp;exp))<br>\n<a name="%_idx_4364"></a>(define&nbsp;(cond-else-clause?&nbsp;clause)<br>\n&nbsp;&nbsp;(eq?&nbsp;(cond-predicate&nbsp;clause)&nbsp;\'else))<br>\n<a name="%_idx_4366"></a>(define&nbsp;(cond-predicate&nbsp;clause)&nbsp;(car&nbsp;clause))<br>\n<a name="%_idx_4368"></a>(define&nbsp;(cond-actions&nbsp;clause)&nbsp;(cdr&nbsp;clause))<br>\n<a name="%_idx_4370"></a>(define&nbsp;(cond-&gt;if&nbsp;exp)<br>\n&nbsp;&nbsp;(expand-clauses&nbsp;(cond-clauses&nbsp;exp)))<br>\n<br>\n<a name="%_idx_4372"></a>(define&nbsp;(expand-clauses&nbsp;clauses)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;clauses)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;no&nbsp;<tt>else</tt>&nbsp;clause</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((first&nbsp;(car&nbsp;clauses))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rest&nbsp;(cdr&nbsp;clauses)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(cond-else-clause?&nbsp;first)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;rest)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sequence-&gt;exp&nbsp;(cond-actions&nbsp;first))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;ELSE&nbsp;clause&nbsp;isn\'t&nbsp;last&nbsp;--&nbsp;COND-&gt;IF&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clauses))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-if&nbsp;(cond-predicate&nbsp;first)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sequence-&gt;exp&nbsp;(cond-actions&nbsp;first))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(expand-clauses&nbsp;rest))))))<br>\n</tt><p><p><p>\n\nExpressions (such as <tt>cond</tt>) that we choose to implement as syntactic\ntransformations are called <em>derived expressions</em>.\n<tt>Let</tt> expressions are also derived expressions\n(see exercise&nbsp;<a href="#%_thm_4.6">4.6</a>).<a name="call_footnote_Temp_531" href="#footnote_Temp_531"><sup><small>13</small></sup></a><p>\n\n<p><a name="%_thm_4.2"></a>\n<b>Exercise 4.2.</b>&nbsp;&nbsp;<a name="%_idx_4384"></a>Louis Reasoner plans to reorder the <tt>cond</tt> clauses\nin <tt>eval</tt> so that the clause for procedure applications appears\nbefore the clause for assignments.  He argues that this will make the\ninterpreter more efficient:  Since programs usually contain more\napplications than assignments, definitions, and so on,\nhis modified <tt>eval</tt> will usually check fewer\nclauses than the original <tt>eval</tt> before identifying the type of an\nexpression.<p>\n\n<p><p>a. What is wrong with Louis\'s plan?  (Hint: What will\nLouis\'s evaluator do with the expression <tt>(define x 3)</tt>?)<p>\n\n<p><p><a name="%_idx_4386"></a>b. Louis is upset that his plan didn\'t work.\nHe is willing to go to any lengths to make his evaluator\nrecognize procedure applications before it checks for most other\nkinds of expressions.\nHelp him by changing the syntax of the evaluated language so that\nprocedure applications start with <tt>call</tt>.  For example, instead of\n<tt>(factorial 3)</tt> we will now have to write <tt>(call factorial 3)</tt>\nand instead of <tt>(+ 1 2)</tt> we will have to write <tt>(call + 1 2)</tt>.\n\n<p><p>\n\n<p><a name="%_thm_4.3"></a>\n<b>Exercise 4.3.</b>&nbsp;&nbsp;<a name="%_idx_4388"></a><a name="%_idx_4390"></a><a name="%_idx_4392"></a>Rewrite <tt>eval</tt> so that the dispatch is done in data-directed\nstyle.  Compare this with the data-directed\ndifferentiation procedure of\nexercise&nbsp;<a href="book-Z-H-17.html#%_thm_2.73">2.73</a>.\n(You may use the <tt>car</tt> of a compound expression as the\ntype of the expression, as is appropriate for the syntax implemented\nin this section.)\n.\n<p><p>\n\n<p><a name="%_thm_4.4"></a>\n<b>Exercise 4.4.</b>&nbsp;&nbsp;<a name="%_idx_4394"></a><a name="%_idx_4396"></a><a name="%_idx_4398"></a>Recall the definitions of the special forms <tt>and</tt> and <tt>or</tt>\nfrom chapter&nbsp;1:\n<p><ul>\n<li><tt>and</tt>: The expressions are evaluated from\nleft to right.  If any expression evaluates to\nfalse, false is returned; any remaining expressions are not\nevaluated.  If all the expressions evaluate to true values, the value\nof the last expression is returned.  If there are no expressions then\ntrue is returned.<p>\n\n<li><tt>or</tt>: The expressions are evaluated from left to right.  If any\nexpression evaluates to a true value, that value is\nreturned; any remaining expressions are not evaluated.  If all\nexpressions evaluate to false, or if there are no expressions,\nthen false is returned.\n</ul><p>\nInstall <tt>and</tt> and <tt>or</tt> as new special forms for the evaluator\nby defining appropriate syntax procedures and evaluation\nprocedures <tt>eval-and</tt> and <tt>eval-or</tt>.  Alternatively, show how\nto implement <tt>and</tt> and <tt>or</tt> as derived expressions.\n<p><p>\n\n\n<p><a name="%_thm_4.5"></a>\n<b>Exercise 4.5.</b>&nbsp;&nbsp;<a name="%_idx_4400"></a><a name="%_idx_4402"></a><a name="%_idx_4404"></a>Scheme allows an additional syntax for <tt>cond</tt> clauses, <tt>(&lt;<em>test</em>&gt; =&gt; &lt;<em>recipient</em>&gt;)</tt>.  If &lt;<em>test</em>&gt;\nevaluates to a true value, then &lt;<em>recipient</em>&gt; is evaluated.  Its\nvalue must be a procedure of one argument; this procedure is then\ninvoked on the value of the &lt;<em>test</em>&gt;, and the result is returned as\nthe value of the <tt>cond</tt> expression.  For example<p>\n\n<p><p><tt>(cond&nbsp;((assoc&nbsp;\'b&nbsp;\'((a&nbsp;1)&nbsp;(b&nbsp;2)))&nbsp;=&gt;&nbsp;cadr)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;false))<br>\n</tt><p><p>\nreturns 2.\nModify the handling of <tt>cond</tt> so that it supports this extended\nsyntax.\n<p><p>\n\n<p><a name="%_thm_4.6"></a>\n<b>Exercise 4.6.</b>&nbsp;&nbsp;<a name="%_idx_4406"></a><tt>Let</tt> expressions are derived expressions, because<p>\n\n<p><p><tt>(let&nbsp;((&lt;<em>var<sub>1</sub></em>&gt;&nbsp;&lt;<em>exp<sub>1</sub></em>&gt;)&nbsp;<tt>...</tt> (&lt;<em>var<sub><em>n</em></sub></em>&gt;&nbsp;&lt;<em>exp<sub><em>n</em></sub></em>&gt;))<br>\n&nbsp;&nbsp;&lt;<em>body</em>&gt;)<br>\n</tt><p><p>\nis equivalent to<p>\n\n<p><p><tt>((lambda&nbsp;(&lt;<em>var<sub>1</sub></em>&gt;&nbsp;<tt>...</tt> &lt;<em>var<sub><em>n</em></sub></em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&lt;<em>body</em>&gt;)<br>\n&nbsp;&lt;<em>exp<sub>1</sub></em>&gt;<br>\n&nbsp;<img src="book-Z-G-D-18.gif" border="0"><br>\n&nbsp;&lt;<em>exp<sub><em>n</em></sub></em>&gt;)<br>\n</tt><p><p>\nImplement a syntactic transformation <tt>let-&gt;combination</tt> that\nreduces evaluating <tt>let</tt> expressions to evaluating combinations of\nthe type shown above, and add the appropriate clause to <tt>eval</tt> to\nhandle <tt>let</tt> expressions.\n\n<p><p>\n\n<p><a name="%_thm_4.7"></a>\n<b>Exercise 4.7.</b>&nbsp;&nbsp;<a name="%_idx_4408"></a><a name="%_idx_4410"></a><a name="%_idx_4412"></a><tt>Let*</tt> is similar to <tt>let</tt>, except that the bindings of the <tt>let</tt> variables are performed sequentially from left to right, and each\nbinding is made in an environment in which all of the preceding\nbindings are visible.  For example\n<p><p><tt>(let*&nbsp;((x&nbsp;3)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(y&nbsp;(+&nbsp;x&nbsp;2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(z&nbsp;(+&nbsp;x&nbsp;y&nbsp;5)))<br>\n&nbsp;&nbsp;(*&nbsp;x&nbsp;z))<br>\n</tt><p><p>\nreturns 39.  Explain how a <tt>let*</tt> expression can be rewritten as a\nset of nested <tt>let</tt> expressions, and write a procedure <tt>let*-&gt;nested-lets</tt> that performs this transformation.  If we\nhave already implemented <tt>let</tt> (exercise&nbsp;<a href="#%_thm_4.6">4.6</a>)\nand we want to\nextend the evaluator to handle <tt>let*</tt>, is it sufficient to add\na clause to <tt>eval</tt> whose action is\n<p><p><tt>(eval&nbsp;(let*-&gt;nested-lets&nbsp;exp)&nbsp;env)<br>\n</tt><p><p>\nor must we\nexplicitly expand <tt>let*</tt> in terms of non-derived expressions?\n<p><p>\n\n<p><a name="%_thm_4.8"></a>\n<b>Exercise 4.8.</b>&nbsp;&nbsp;<a name="%_idx_4414"></a><a name="%_idx_4416"></a><a name="%_idx_4418"></a><a name="%_idx_4420"></a>``Named <tt>let</tt>\'\' is a variant of <tt>let</tt> that has the form\n<p><p><tt>(let&nbsp;&lt;<em>var</em>&gt;&nbsp;&lt;<em>bindings</em>&gt;&nbsp;&lt;<em>body</em>&gt;)<br>\n</tt><p><p>\nThe &lt;<em>bindings</em>&gt; and &lt;<em>body</em>&gt; are just as in ordinary <tt>let</tt>, except that &lt;<em>var</em>&gt; is bound within &lt;<em>body</em>&gt; to a\nprocedure whose body is &lt;<em>body</em>&gt; and whose parameters are the\nvariables in the &lt;<em>bindings</em>&gt;.  Thus, one can repeatedly execute the\n&lt;<em>body</em>&gt; by invoking the procedure named &lt;<em>var</em>&gt;.  For example,\nthe iterative Fibonacci procedure (section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a>)\ncan be rewritten using named <tt>let</tt> as follows:\n<p><p><tt><a name="%_idx_4422"></a>(define&nbsp;(fib&nbsp;n)<br>\n&nbsp;&nbsp;(let&nbsp;fib-iter&nbsp;((a&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(count&nbsp;n))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;count&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fib-iter&nbsp;(+&nbsp;a&nbsp;b)&nbsp;a&nbsp;(-&nbsp;count&nbsp;1)))))<br>\n</tt><p><p>\nModify <tt>let-&gt;combination</tt> of exercise&nbsp;<a href="#%_thm_4.6">4.6</a> to\nalso support named <tt>let</tt>.\n<p><p>\n\n<p><a name="%_thm_4.9"></a>\n<b>Exercise 4.9.</b>&nbsp;&nbsp;<a name="%_idx_4424"></a><a name="%_idx_4426"></a>Many languages support a variety of iteration constructs, such as <tt>do</tt>, <tt>for</tt>, <tt>while</tt>, and <tt>until</tt>.  In Scheme,\niterative processes can be expressed in terms of ordinary procedure\ncalls, so special iteration constructs provide no essential gain in\ncomputational power.  On the other hand, such constructs are often\nconvenient.  Design some iteration constructs, give examples of their\nuse, and show how to implement them as derived expressions.\n<p><p>\n\n<p><a name="%_thm_4.10"></a>\n<b>Exercise 4.10.</b>&nbsp;&nbsp;<a name="%_idx_4428"></a><a name="%_idx_4430"></a>By using data abstraction, we were able to write an <tt>eval</tt>\nprocedure that is independent of the particular syntax of the language\nto be evaluated.  To illustrate this, design and implement a new\nsyntax for Scheme by modifying the procedures in this section, without\nchanging <tt>eval</tt> or <tt>apply</tt>.\n<p><p>\n\n<a name="%_sec_4.1.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.3">4.1.3&nbsp;&nbsp;Evaluator Data Structures</a></h3><p>\n\n<p>\n\nIn addition to defining the external syntax of expressions, the\nevaluator implementation must also define the data structures that the\nevaluator manipulates internally, as part of the execution of a\nprogram, such as the representation of procedures and environments and\nthe representation of true and false.<p>\n\n<a name="%_sec_Temp_541"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_541">Testing of predicates</a></h4><p>\n\n<a name="%_idx_4432"></a>For conditionals, we accept anything to be true that is not\nthe explicit <tt>false</tt> object.<p>\n\n<p><p><tt><a name="%_idx_4434"></a>(define&nbsp;(true?&nbsp;x)<br>\n&nbsp;&nbsp;(not&nbsp;(eq?&nbsp;x&nbsp;false)))<br>\n<a name="%_idx_4436"></a>(define&nbsp;(false?&nbsp;x)<br>\n&nbsp;&nbsp;(eq?&nbsp;x&nbsp;false))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_542"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_542">Representing procedures</a></h4><p>\n\n<a name="%_idx_4438"></a>\nTo handle primitives, we assume that we have available the\nfollowing procedures:<p>\n\n<p><ul>\n<li><a name="%_idx_4440"></a><tt>(apply-primitive-procedure &lt;<em>proc</em>&gt; &lt;<em>args</em>&gt;)</tt><br>\napplies the given primitive procedure to the argument values in the\nlist &lt;<em>args</em>&gt; and returns the result of the application.<p>\n\n<li><a name="%_idx_4442"></a><tt>(primitive-procedure? &lt;<em>proc</em>&gt;)</tt><br>\ntests whether &lt;<em>proc</em>&gt; is a primitive procedure.\n</ul><p><p>\n\nThese mechanisms for handling primitives are further described in\nsection&nbsp;<a href="#%_sec_4.1.4">4.1.4</a>.<p>\n\nCompound procedures are constructed from parameters, procedure\nbodies, and environments using the constructor <tt>make-procedure</tt>:<p>\n\n<p><p><tt><a name="%_idx_4444"></a>(define&nbsp;(make-procedure&nbsp;parameters&nbsp;body&nbsp;env)<br>\n&nbsp;&nbsp;(list&nbsp;\'procedure&nbsp;parameters&nbsp;body&nbsp;env))<br>\n<a name="%_idx_4446"></a>(define&nbsp;(compound-procedure?&nbsp;p)<br>\n&nbsp;&nbsp;(tagged-list?&nbsp;p&nbsp;\'procedure))<br>\n<a name="%_idx_4448"></a>(define&nbsp;(procedure-parameters&nbsp;p)&nbsp;(cadr&nbsp;p))<br>\n<a name="%_idx_4450"></a>(define&nbsp;(procedure-body&nbsp;p)&nbsp;(caddr&nbsp;p))<br>\n<a name="%_idx_4452"></a>(define&nbsp;(procedure-environment&nbsp;p)&nbsp;(cadddr&nbsp;p))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_543"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_543">Operations on Environments</a></h4><p>\n\n\n<a name="%_idx_4454"></a>\nThe evaluator needs operations for manipulating environments.  As\nexplained in section&nbsp;<a href="book-Z-H-21.html#%_sec_3.2">3.2</a>, an environment is a\nsequence of frames, where each frame is a table of bindings that\nassociate variables with their corresponding values.  We use\nthe following operations for manipulating environments:<p>\n\n<p><ul>\n<a name="%_idx_4456"></a><li><tt>(lookup-variable-value &lt;<em>var</em>&gt; &lt;<em>env</em>&gt;)</tt><br>\nreturns the value that is bound to the symbol &lt;<em>var</em>&gt; in the\nenvironment &lt;<em>env</em>&gt;, or signals an error if the variable is unbound.<p>\n\n<li><a name="%_idx_4458"></a><tt>(extend-environment &lt;<em>variables</em>&gt; &lt;<em>values</em>&gt; &lt;<em>base-env</em>&gt;)</tt><br>\nreturns a new environment, consisting of a new frame in which the\nsymbols in the list &lt;<em>variables</em>&gt; are bound to the corresponding\nelements in the list &lt;<em>values</em>&gt;, where the enclosing environment is\nthe environment &lt;<em>base-env</em>&gt;.<p>\n\n<li><a name="%_idx_4460"></a><tt>(define-variable! &lt;<em>var</em>&gt; &lt;<em>value</em>&gt; &lt;<em>env</em>&gt;)</tt><br>\nadds to the first frame in the environment &lt;<em>env</em>&gt; a new binding that\nassociates the variable &lt;<em>var</em>&gt; with the value &lt;<em>value</em>&gt;.<p>\n\n<li><a name="%_idx_4462"></a><tt>(set-variable-value! &lt;<em>var</em>&gt; &lt;<em>value</em>&gt; &lt;<em>env</em>&gt;)</tt><br>\nchanges the binding of the variable &lt;<em>var</em>&gt; in the environment &lt;<em>env</em>&gt;\nso that the variable is now bound to the value &lt;<em>value</em>&gt;, or signals\nan error if the variable is unbound.\n</ul><p><p>\n\n<a name="%_idx_4464"></a>To implement these operations we represent an environment as a list of\nframes.  The enclosing environment of an environment is the <tt>cdr</tt> of\nthe list.  The empty environment is simply the empty list.<p>\n\n<p><p><tt><a name="%_idx_4466"></a>(define&nbsp;(enclosing-environment&nbsp;env)&nbsp;(cdr&nbsp;env))<br>\n<a name="%_idx_4468"></a>(define&nbsp;(first-frame&nbsp;env)&nbsp;(car&nbsp;env))<br>\n(define&nbsp;the-empty-environment&nbsp;\'())<br>\n</tt><p><p>\nEach frame of an environment is represented as a pair of lists: a list\nof the variables bound in that frame and a list of the associated values.<a name="call_footnote_Temp_544" href="#footnote_Temp_544"><sup><small>14</small></sup></a>\n<p><p><tt><a name="%_idx_4470"></a>(define&nbsp;(make-frame&nbsp;variables&nbsp;values)<br>\n&nbsp;&nbsp;(cons&nbsp;variables&nbsp;values))<br>\n<a name="%_idx_4472"></a>(define&nbsp;(frame-variables&nbsp;frame)&nbsp;(car&nbsp;frame))<br>\n<a name="%_idx_4474"></a>(define&nbsp;(frame-values&nbsp;frame)&nbsp;(cdr&nbsp;frame))<br>\n<a name="%_idx_4476"></a>(define&nbsp;(add-binding-to-frame!&nbsp;var&nbsp;val&nbsp;frame)<br>\n&nbsp;&nbsp;(set-car!&nbsp;frame&nbsp;(cons&nbsp;var&nbsp;(car&nbsp;frame)))<br>\n&nbsp;&nbsp;(set-cdr!&nbsp;frame&nbsp;(cons&nbsp;val&nbsp;(cdr&nbsp;frame))))<br>\n</tt><p><p><p>\n\nTo extend an environment by a new frame that associates variables with\nvalues, we make a frame consisting of the list of variables and the\nlist of values, and we adjoin this to the environment.  We signal\nan error if the number of variables does not match the number of values.<p>\n\n\n<p><p><tt><a name="%_idx_4478"></a>(define&nbsp;(extend-environment&nbsp;vars&nbsp;vals&nbsp;base-env)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;(length&nbsp;vars)&nbsp;(length&nbsp;vals))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(make-frame&nbsp;vars&nbsp;vals)&nbsp;base-env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;(length&nbsp;vars)&nbsp;(length&nbsp;vals))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Too&nbsp;many&nbsp;arguments&nbsp;supplied&quot;&nbsp;vars&nbsp;vals)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Too&nbsp;few&nbsp;arguments&nbsp;supplied&quot;&nbsp;vars&nbsp;vals))))<br>\n</tt><p><p><p>\n\n\nTo look up a variable in an environment, we scan the list of variables\nin the first frame.  If we find the desired variable, we return\nthe corresponding element in the list of values.  If we do not find\nthe variable in the current frame, we search the enclosing environment,\nand so on.  If we reach the empty environment, we signal an ``unbound\nvariable\'\' error.<p>\n\n\n<p><p><tt><a name="%_idx_4480"></a>(define&nbsp;(lookup-variable-value&nbsp;var&nbsp;env)<br>\n&nbsp;&nbsp;(define&nbsp;(env-loop&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(scan&nbsp;vars&nbsp;vals)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;vars)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(env-loop&nbsp;(enclosing-environment&nbsp;env)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;var&nbsp;(car&nbsp;vars))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;vals))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(scan&nbsp;(cdr&nbsp;vars)&nbsp;(cdr&nbsp;vals)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;env&nbsp;the-empty-environment)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unbound&nbsp;variable&quot;&nbsp;var)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((frame&nbsp;(first-frame&nbsp;env)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(scan&nbsp;(frame-variables&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(frame-values&nbsp;frame)))))<br>\n&nbsp;&nbsp;(env-loop&nbsp;env))<br>\n</tt><p><p><p>\n\nTo set a variable to a new value in a specified environment, we scan\nfor the variable, just as in <tt>lookup-variable-value</tt>, and change\nthe corresponding value when we find it.<p>\n\n\n<p><p><tt><a name="%_idx_4482"></a>(define&nbsp;(set-variable-value!&nbsp;var&nbsp;val&nbsp;env)<br>\n&nbsp;&nbsp;(define&nbsp;(env-loop&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(scan&nbsp;vars&nbsp;vals)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;vars)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(env-loop&nbsp;(enclosing-environment&nbsp;env)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;var&nbsp;(car&nbsp;vars))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;vals&nbsp;val))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(scan&nbsp;(cdr&nbsp;vars)&nbsp;(cdr&nbsp;vals)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;env&nbsp;the-empty-environment)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unbound&nbsp;variable&nbsp;--&nbsp;SET!&quot;&nbsp;var)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((frame&nbsp;(first-frame&nbsp;env)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(scan&nbsp;(frame-variables&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(frame-values&nbsp;frame)))))<br>\n&nbsp;&nbsp;(env-loop&nbsp;env))<br>\n</tt><p><p><p>\n\nTo define a variable, we search the first frame for a binding for\nthe variable, and change the binding if it exists\n(just as in <tt>set-variable-value!</tt>).  If no such binding\nexists, we adjoin one to the first frame.<p>\n\n<p><p><tt><a name="%_idx_4484"></a>(define&nbsp;(define-variable!&nbsp;var&nbsp;val&nbsp;env)<br>\n&nbsp;&nbsp;(let&nbsp;((frame&nbsp;(first-frame&nbsp;env)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(scan&nbsp;vars&nbsp;vals)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;vars)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-binding-to-frame!&nbsp;var&nbsp;val&nbsp;frame))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;var&nbsp;(car&nbsp;vars))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;vals&nbsp;val))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(scan&nbsp;(cdr&nbsp;vars)&nbsp;(cdr&nbsp;vals)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(scan&nbsp;(frame-variables&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(frame-values&nbsp;frame))))<br>\n</tt><p><p><p>\n\n<a name="%_idx_4486"></a>The method described here is only one of many plausible ways to\nrepresent environments.  Since we used data abstraction to isolate the\nrest of the evaluator from the detailed choice of representation, we\ncould change the environment representation if we wanted to.  (See\nexercise&nbsp;<a href="#%_thm_4.11">4.11</a>.)  In a\nproduction-quality Lisp system, the speed of the evaluator\'s\nenvironment operations -- especially that of variable lookup -- has a\nmajor impact on the performance of the system.  The representation\ndescribed here, although conceptually simple, is not efficient and\nwould not ordinarily be used in a production system.<a name="call_footnote_Temp_545" href="#footnote_Temp_545"><sup><small>15</small></sup></a><p>\n\n<p><a name="%_thm_4.11"></a>\n<b>Exercise 4.11.</b>&nbsp;&nbsp;Instead of representing a frame as a pair of lists, we can represent a\nframe as a list of bindings, where each binding is a name-value pair.\nRewrite the environment operations to use this alternative\nrepresentation.\n\n<p><p>\n\n<p><a name="%_thm_4.12"></a>\n<b>Exercise 4.12.</b>&nbsp;&nbsp;The procedures <tt>set-variable-value!</tt>, <tt>define-variable!</tt>,\nand <tt>lookup-variable-value</tt> can be expressed in terms of\nmore abstract procedures for traversing the environment structure.\nDefine abstractions that capture the common patterns and redefine\nthe three procedures in terms of these abstractions.\n<p><p>\n\n<p><a name="%_thm_4.13"></a>\n<b>Exercise 4.13.</b>&nbsp;&nbsp;Scheme allows us to create new bindings for variables by means of <tt>define</tt>, but provides no way to get rid of bindings.  Implement for\nthe evaluator a special form <tt>make-unbound!</tt> that removes the\nbinding of a given symbol from the environment in which the\n<tt>make-unbound!</tt> expression is evaluated.\nThis problem is not completely specified.  For example,\nshould we remove only the binding in the first frame of the\nenvironment?  Complete the specification and justify any choices you\nmake.\n<p><p>\n\n<a name="%_sec_4.1.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.4">4.1.4&nbsp;&nbsp;Running the Evaluator as a Program</a></h3><p>\n\n\n<a name="%_idx_4492"></a>\nGiven the evaluator, we have in our hands a description\n(expressed in Lisp) of the process\nby which Lisp expressions are evaluated.  One advantage of expressing the\nevaluator as a program is that we can run the program.  This gives us,\nrunning within Lisp, a working model of how Lisp itself evaluates\nexpressions.  This can serve as a framework for experimenting with\nevaluation rules, as we shall do later in this chapter.<p>\n\n<a name="%_idx_4494"></a>Our evaluator program reduces expressions ultimately to the\napplication of primitive procedures.  Therefore, all that we need to\nrun the evaluator is to create a mechanism that calls on the underlying\nLisp system to model the application of primitive procedures.<p>\n\nThere must be a binding for each primitive procedure name, so that when\n<tt>eval</tt> evaluates the operator of an application of a primitive, it\nwill find an object to pass to <tt>apply</tt>.  We thus set up a <a name="%_idx_4496"></a><a name="%_idx_4498"></a>global\nenvironment that associates unique objects with the names of the\nprimitive procedures that can appear\nin the expressions we will be evaluating.  The\nglobal environment also includes bindings for the symbols <a name="%_idx_4500"></a><tt>true</tt> and\n<tt>false</tt>, so that they can be used as variables in expressions\nto be evaluated.<p>\n\n<p><p><tt><a name="%_idx_4502"></a>(define&nbsp;(setup-environment)<br>\n&nbsp;&nbsp;(let&nbsp;((initial-env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(extend-environment&nbsp;(primitive-procedure-names)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(primitive-procedure-objects)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-environment)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define-variable!&nbsp;\'true&nbsp;true&nbsp;initial-env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define-variable!&nbsp;\'false&nbsp;false&nbsp;initial-env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;initial-env))<br>\n<a name="%_idx_4504"></a>(define&nbsp;the-global-environment&nbsp;(setup-environment))<br>\n</tt><p><p><p>\n\nIt does not matter how we represent the primitive procedure objects,\nso long as <tt>apply</tt> can identify and apply them by using the\nprocedures <tt>primitive-procedure?</tt> and <tt>apply-primitive-procedure</tt>.  We have chosen to represent a primitive\nprocedure as a list beginning with the symbol <tt>primitive</tt> and\ncontaining a procedure in the underlying Lisp that implements that primitive.<p>\n\n<p><p><tt><a name="%_idx_4506"></a>(define&nbsp;(primitive-procedure?&nbsp;proc)<br>\n&nbsp;&nbsp;(tagged-list?&nbsp;proc&nbsp;\'primitive))<br>\n<br>\n<a name="%_idx_4508"></a>(define&nbsp;(primitive-implementation&nbsp;proc)&nbsp;(cadr&nbsp;proc))<br>\n</tt><p><p><p>\n\n<tt>Setup-environment</tt> will get the primitive names and implementation\nprocedures from a list:<a name="call_footnote_Temp_549" href="#footnote_Temp_549"><sup><small>16</small></sup></a><p>\n\n<p><p><tt>(define&nbsp;primitive-procedures<br>\n&nbsp;&nbsp;(list&nbsp;(list&nbsp;\'car&nbsp;car)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;\'cdr&nbsp;cdr)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;\'cons&nbsp;cons)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;\'null?&nbsp;null?)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>more&nbsp;primitives</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;))<br>\n<a name="%_idx_4510"></a>(define&nbsp;(primitive-procedure-names)<br>\n&nbsp;&nbsp;(map&nbsp;car<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primitive-procedures))<br>\n<br>\n(define&nbsp;(primitive-procedure-objects)<br>\n<a name="%_idx_4512"></a>&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(proc)&nbsp;(list&nbsp;\'primitive&nbsp;(cadr&nbsp;proc)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primitive-procedures))<br>\n</tt><p><p><p>\n\nTo apply a primitive procedure, we simply apply the implementation\nprocedure to the arguments, using the underlying Lisp system:<a name="call_footnote_Temp_550" href="#footnote_Temp_550"><sup><small>17</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_4514"></a>(define&nbsp;(apply-primitive-procedure&nbsp;proc&nbsp;args)<br>\n&nbsp;&nbsp;(apply-in-underlying-scheme<br>\n&nbsp;&nbsp;&nbsp;(primitive-implementation&nbsp;proc)&nbsp;args))<br>\n</tt><p><p><p>\n\n<a name="%_idx_4516"></a><a name="%_idx_4518"></a>For convenience in running the metacircular evaluator, we provide a <em>driver loop</em> that models the read-eval-print loop of the underlying\nLisp system.  It prints a <a name="%_idx_4520"></a><em>prompt</em>, reads an input expression,\nevaluates this expression in the global environment, and prints the\nresult.  We precede each printed result by an <em>output prompt</em> so\nas to distinguish the value of the expression from other\noutput that may be printed.<a name="call_footnote_Temp_551" href="#footnote_Temp_551"><sup><small>18</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_4530"></a>(define&nbsp;input-prompt&nbsp;&quot;;;;&nbsp;M-Eval&nbsp;input:&quot;)<br>\n(define&nbsp;output-prompt&nbsp;&quot;;;;&nbsp;M-Eval&nbsp;value:&quot;)<br>\n<a name="%_idx_4532"></a>(define&nbsp;(driver-loop)<br>\n&nbsp;&nbsp;(prompt-for-input&nbsp;input-prompt)<br>\n&nbsp;&nbsp;(let&nbsp;((input&nbsp;(read)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((output&nbsp;(eval&nbsp;input&nbsp;the-global-environment)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(announce-output&nbsp;output-prompt)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(user-print&nbsp;output)))<br>\n&nbsp;&nbsp;(driver-loop))<br>\n<a name="%_idx_4534"></a>(define&nbsp;(prompt-for-input&nbsp;string)<br>\n&nbsp;&nbsp;(newline)&nbsp;(newline)&nbsp;(display&nbsp;string)&nbsp;(newline))<br>\n<br>\n<a name="%_idx_4536"></a>(define&nbsp;(announce-output&nbsp;string)<br>\n&nbsp;&nbsp;(newline)&nbsp;(display&nbsp;string)&nbsp;(newline))<br>\n</tt><p><p>\nWe use a special printing procedure, <tt>user-print</tt>, to avoid printing the\nenvironment part of a compound procedure, which may be a very long list\n(or may even contain cycles).<p>\n\n<p><p><tt><a name="%_idx_4538"></a>(define&nbsp;(user-print&nbsp;object)<br>\n&nbsp;&nbsp;(if&nbsp;(compound-procedure?&nbsp;object)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;(list&nbsp;\'compound-procedure<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure-parameters&nbsp;object)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure-body&nbsp;object)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'&lt;procedure-env&gt;))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;object)))<br>\n</tt><p><p><p>\n\nNow all we need to do to run the evaluator is to initialize the\nglobal environment and start the driver loop.  Here is a sample\ninteraction:<p>\n\n<p><p><tt>(define&nbsp;the-global-environment&nbsp;(setup-environment))<br>\n(driver-loop)<br>\n<i>;;;&nbsp;M-Eval&nbsp;input:</i><br>\n(define&nbsp;(append&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append&nbsp;(cdr&nbsp;x)&nbsp;y))))<br>\n<i>;;;&nbsp;M-Eval&nbsp;value:</i><br>\n<i>ok</i><br>\n<i>;;;&nbsp;M-Eval&nbsp;input:</i><br>\n(append&nbsp;\'(a&nbsp;b&nbsp;c)&nbsp;\'(d&nbsp;e&nbsp;f))<br>\n<i>;;;&nbsp;M-Eval&nbsp;value:</i><br>\n<i>(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e&nbsp;f)</i><br>\n</tt><p><p><p>\n\n<p><a name="%_thm_4.14"></a>\n<b>Exercise 4.14.</b>&nbsp;&nbsp;Eva Lu Ator and Louis Reasoner are each experimenting with the\nmetacircular evaluator.  Eva types in the definition of <tt>map</tt>, and\nruns some test programs that use it.  They work fine.  Louis, in contrast,\nhas installed the system version of <tt>map</tt> as a primitive for the\nmetacircular evaluator.  When he tries it, things go terribly\nwrong.  Explain why Louis\'s <tt>map</tt> fails even though Eva\'s works.\n<p><p>\n\n<a name="%_sec_4.1.5"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.5">4.1.5&nbsp;&nbsp;Data as Programs</a></h3><p>\n\n\n<a name="%_idx_4540"></a><a name="%_idx_4542"></a>\nIn thinking about a Lisp program that evaluates Lisp expressions, an\nanalogy might be helpful.  One operational view of the meaning of a\nprogram is that a <a name="%_idx_4544"></a>program is a description of an abstract (perhaps\ninfinitely large) machine.  For example, consider the familiar\nprogram to compute factorials:<p>\n\n<p><p><tt>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1))&nbsp;n)))<br>\n</tt><p><p>\n<a name="%_idx_4546"></a>We may regard this program as the description of a machine containing\nparts that decrement, multiply, and test for equality, together with a\ntwo-position switch and another factorial machine. (The factorial\nmachine is infinite because it contains another factorial machine\nwithin it.)  Figure&nbsp;<a href="#%_fig_4.2">4.2</a> is a flow diagram for the\nfactorial machine, showing how the parts are wired together.<p>\n\n<a name="%_fig_4.2"></a><p><div align=left><table width=100%><tr><td><img src="ch4-Z-G-2.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 4.2:</b>&nbsp;&nbsp;The factorial program, viewed as an abstract machine.</div></caption><tr><td>\n\n</td></tr></table></div><p>              <p>\n\n\n<a name="%_idx_4548"></a>In a similar way, we can regard the evaluator as a very special\nmachine that takes as input a description of a machine.  Given this\ninput, the evaluator configures itself to emulate the machine\ndescribed.  For example, if we feed our evaluator the definition of\n<tt>factorial</tt>, as shown in figure&nbsp;<a href="#%_fig_4.3">4.3</a>, the\nevaluator will be able to compute factorials.<p>\n\n<a name="%_fig_4.3"></a><p><div align=left><table width=100%><tr><td><img src="ch4-Z-G-3.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 4.3:</b>&nbsp;&nbsp;The evaluator emulating a factorial machine.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_idx_4550"></a><a name="%_idx_4552"></a>From this perspective, our evaluator is seen to be a <em>universal machine</em>.\nIt mimics other machines when these are described as Lisp programs.<a name="call_footnote_Temp_553" href="#footnote_Temp_553"><sup><small>19</small></sup></a>\nThis is striking. Try to imagine an analogous evaluator for electrical\ncircuits.  This would be a circuit that takes as input a signal\nencoding the plans for some other circuit, such as a filter.  Given\nthis input, the circuit evaluator would then behave like a filter with\nthe same description.  Such a universal electrical circuit is\nalmost unimaginably complex.  It is remarkable that the program\nevaluator is a rather simple program.<a name="call_footnote_Temp_554" href="#footnote_Temp_554"><sup><small>20</small></sup></a><p>\n\nAnother striking aspect of the evaluator is that it acts as a bridge\nbetween the data objects that are manipulated by our programming\nlanguage and the programming language itself.  Imagine that the\nevaluator program (implemented in Lisp) is running, and that a user is\ntyping expressions to the evaluator and observing the results.  From\nthe perspective of the user, an input expression such as <tt>(* x x)</tt>\nis an expression in the programming language, which the evaluator\nshould execute.  From the perspective of the evaluator, however, the\nexpression is simply a list (in this case, a list of three symbols:\n<tt>*</tt>, <tt>x</tt>, and <tt>x</tt>) that is to be manipulated according to\na well-defined set of rules.<p>\n\nThat the user\'s programs are the evaluator\'s data need not be a source\nof confusion.  In fact, it is sometimes convenient to ignore this\ndistinction, and to give the user the ability to explicitly evaluate a\ndata object as a Lisp expression, by making <tt>eval</tt> available for\nuse in programs.  Many Lisp dialects provide a <a name="%_idx_4572"></a><a name="%_idx_4574"></a>primitive <tt>eval</tt>\nprocedure that takes as arguments an expression and an environment and\nevaluates the expression relative to the environment.<a name="call_footnote_Temp_555" href="#footnote_Temp_555"><sup><small>21</small></sup></a>\nThus,<p>\n\n<p><p><tt>(eval&nbsp;\'(*&nbsp;5&nbsp;5)&nbsp;user-initial-environment)<br>\n</tt><p><p>\nand\n<p><p><tt>(eval&nbsp;(cons&nbsp;\'*&nbsp;(list&nbsp;5&nbsp;5))&nbsp;user-initial-environment)<br>\n</tt><p><p>\nwill both return 25.<a name="call_footnote_Temp_556" href="#footnote_Temp_556"><sup><small>22</small></sup></a><p>\n\n\n<p><a name="%_thm_4.15"></a>\n<b>Exercise 4.15.</b>&nbsp;&nbsp;<a name="%_idx_4588"></a>Given a one-argument procedure <tt>p</tt> and an object <tt>a</tt>, <tt>p</tt>\nis said to ``halt\'\' on <tt>a</tt> if evaluating the expression <tt>(p\na)</tt> returns a value (as opposed to terminating with an error message\nor running forever).  Show that it is impossible to write a procedure\n<tt>halts?</tt> that correctly determines whether <tt>p</tt> halts on <tt>a</tt> for any procedure <tt>p</tt> and object <tt>a</tt>.  Use the following\nreasoning: If you had such a procedure <tt>halts?</tt>, you could\nimplement the following program:\n<p><p><tt>(define&nbsp;(run-forever)&nbsp;(run-forever))<br>\n<br>\n(define&nbsp;(try&nbsp;p)<br>\n&nbsp;&nbsp;(if&nbsp;(halts?&nbsp;p&nbsp;p)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(run-forever)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'halted))<br>\n</tt><p><p>\nNow consider evaluating the expression <tt>(try try)</tt> and show that\nany possible outcome (either halting or running forever) violates the\nintended behavior of <tt>halts?</tt>.<a name="call_footnote_Temp_558" href="#footnote_Temp_558"><sup><small>23</small></sup></a>\n\n<p><p>\n\n<a name="%_sec_4.1.6"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.6">4.1.6&nbsp;&nbsp;Internal Definitions</a></h3><p>\n\n\n<a name="%_idx_4598"></a><a name="%_idx_4600"></a>\n<a name="%_idx_4602"></a>Our environment model of evaluation and our metacircular evaluator execute\ndefinitions in sequence, extending the environment frame one\ndefinition at a time.  This is particularly convenient for interactive\nprogram development, in which the programmer needs to freely mix the\napplication of procedures with the definition of new procedures.\nHowever, if we think carefully about the internal definitions\nused to implement block structure (introduced in\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.8">1.1.8</a>), we will find that name-by-name extension\nof the environment may not be the best way to define local variables.<p>\n\nConsider a procedure with internal definitions, such as<p>\n\n<p><p><tt>(define&nbsp;(f&nbsp;x)<br>\n&nbsp;&nbsp;(define&nbsp;(even?&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(odd?&nbsp;(-&nbsp;n&nbsp;1))))<br>\n&nbsp;&nbsp;(define&nbsp;(odd?&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(even?&nbsp;(-&nbsp;n&nbsp;1))))<br>\n&nbsp;&nbsp;&lt;<em>rest&nbsp;of&nbsp;body&nbsp;of&nbsp;<tt>f</tt></em>&gt;)<br>\n</tt><p><p>\nOur intention here is that the name <tt>odd?</tt> in the body of the\nprocedure <tt>even?</tt> should refer to the procedure <tt>odd?</tt> that is\ndefined after <tt>even?</tt>.  The scope of the name <tt>odd?</tt> is the\nentire body of <tt>f</tt>, not just the portion of the body of <tt>f</tt>\nstarting at the point where the <tt>define</tt> for <tt>odd?</tt> occurs.\nIndeed, when we consider that <tt>odd?</tt> is itself defined in terms of\n<tt>even?</tt> -- so that <tt>even?</tt> and <tt>odd?</tt> are mutually\nrecursive procedures -- we see that the only satisfactory\ninterpretation of the two <tt>define</tt>s is to regard them as if the\nnames <tt>even?</tt> and <tt>odd?</tt> were being added to the environment\nsimultaneously.\nMore generally, in block structure, the scope of a local name is the\nentire procedure body in which the <tt>define</tt> is evaluated.<p>\n\n\nAs it happens, our interpreter will evaluate calls to <tt>f</tt>\ncorrectly, but for an ``accidental\'\' reason: Since the definitions of\nthe internal procedures come first, no calls to these procedures will\nbe evaluated until all of them have been defined.  Hence, <tt>odd?</tt>\nwill have been defined by the time <tt>even?</tt> is executed.  In fact,\nour sequential evaluation mechanism will give the same result as a\nmechanism that directly implements simultaneous definition for any\nprocedure in which the <a name="%_idx_4604"></a>internal definitions come first in a body and\nevaluation of the value expressions for the defined variables doesn\'t\nactually use any of the defined variables.\n(For an example of a procedure that doesn\'t obey these restrictions,\nso that sequential definition isn\'t equivalent to simultaneous definition,\nsee exercise&nbsp;<a href="#%_thm_4.19">4.19</a>.)<a name="call_footnote_Temp_559" href="#footnote_Temp_559"><sup><small>24</small></sup></a><p>\n\nThere is, however, a simple way to treat definitions so that\ninternally defined names have truly simultaneous scope -- just create\nall local variables that will be in the current environment before\nevaluating any of the value expressions.  One way to do this is by a\nsyntax transformation on <tt>lambda</tt> expressions.  Before evaluating\nthe body of a <tt>lambda</tt> expression, we <a name="%_idx_4606"></a><a name="%_idx_4608"></a>``scan out\'\' and eliminate\nall the internal definitions in the body.  The internally defined\nvariables will be created with a <tt>let</tt> and then set to their\nvalues by assignment.  For example, the procedure<p>\n\n<p><p><tt>(lambda&nbsp;&lt;<em>vars</em>&gt;<br>\n&nbsp;&nbsp;(define&nbsp;u&nbsp;&lt;<em>e1</em>&gt;)<br>\n&nbsp;&nbsp;(define&nbsp;v&nbsp;&lt;<em>e2</em>&gt;)<br>\n&nbsp;&nbsp;&lt;<em>e3</em>&gt;)<br>\n</tt><p><p>\nwould be transformed into<p>\n\n<p><p><tt>(lambda&nbsp;&lt;<em>vars</em>&gt;<br>\n&nbsp;&nbsp;(let&nbsp;((u&nbsp;\'*unassigned*)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(v&nbsp;\'*unassigned*))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;u&nbsp;&lt;<em>e1</em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;v&nbsp;&lt;<em>e2</em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>e3</em>&gt;))<br>\n</tt><p><p>\nwhere <tt>*unassigned*</tt> is a special symbol that causes looking up a\nvariable to signal an error if an attempt is made to use the value of\nthe not-yet-assigned variable.<p>\n\nAn alternative strategy for scanning out internal definitions is shown\nin exercise&nbsp;<a href="#%_thm_4.18">4.18</a>.  Unlike the transformation\nshown above, this enforces the restriction that the defined variables\'\nvalues can be evaluated without using any of the variables\' values.<a name="call_footnote_Temp_560" href="#footnote_Temp_560"><sup><small>25</small></sup></a><p>\n\n<p><a name="%_thm_4.16"></a>\n<b>Exercise 4.16.</b>&nbsp;&nbsp;In this exercise we implement the method just described for\ninterpreting internal definitions.\nWe assume that the evaluator supports <tt>let</tt>\n(see exercise&nbsp;<a href="#%_thm_4.6">4.6</a>).<p>\n\n<a name="%_idx_4612"></a>a.&nbsp;&nbsp;Change <tt>lookup-variable-value</tt>\n(section&nbsp;<a href="#%_sec_4.1.3">4.1.3</a>) to signal an error if\nthe value it finds is the symbol <tt>*unassigned*</tt>.<p>\n\n<a name="%_idx_4614"></a>b.&nbsp;&nbsp;Write a procedure <tt>scan-out-defines</tt> that takes a\nprocedure body and returns an equivalent one that has no internal\ndefinitions, by making the transformation described above.<p>\n\nc.&nbsp;&nbsp;Install <tt>scan-out-defines</tt> in the interpreter, either in <tt>make-procedure</tt> or in <tt>procedure-body</tt> (see\nsection&nbsp;<a href="#%_sec_4.1.3">4.1.3</a>).  Which place is better?\nWhy?\n\n<p><p>\n\n<p><a name="%_thm_4.17"></a>\n<b>Exercise 4.17.</b>&nbsp;&nbsp;Draw diagrams of the environment in effect when evaluating the\nexpression &lt;<em>e3</em>&gt; in the procedure in the text, comparing how this\nwill be structured when definitions are interpreted sequentially with\nhow it will be structured if definitions are scanned out as described.\nWhy is there an extra frame in the transformed program?  Explain why\nthis difference in environment structure can never make a difference\nin the behavior of a correct program.  Design a way to make the\ninterpreter implement the ``simultaneous\'\' scope rule for internal\ndefinitions without constructing the extra frame.\n<p><p>\n\n<p><a name="%_thm_4.18"></a>\n<b>Exercise 4.18.</b>&nbsp;&nbsp;Consider an alternative strategy for scanning out definitions that\ntranslates the example in the text to\n<p><p><tt>(lambda&nbsp;&lt;<em>vars</em>&gt;<br>\n&nbsp;&nbsp;(let&nbsp;((u&nbsp;\'*unassigned*)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(v&nbsp;\'*unassigned*))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((a&nbsp;&lt;<em>e1</em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b&nbsp;&lt;<em>e2</em>&gt;))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;u&nbsp;a)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;v&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>e3</em>&gt;))<br>\n</tt><p><p>\nHere <tt>a</tt> and <tt>b</tt> are meant to represent new variable names,\ncreated by the interpreter, that do not appear in the user\'s\nprogram.\nConsider the <tt>solve</tt> procedure from\nsection&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.4">3.5.4</a>:<p>\n\n<p><p><tt><a name="%_idx_4616"></a>(define&nbsp;(solve&nbsp;f&nbsp;y0&nbsp;dt)<br>\n&nbsp;&nbsp;(define&nbsp;y&nbsp;(integral&nbsp;(delay&nbsp;dy)&nbsp;y0&nbsp;dt))<br>\n&nbsp;&nbsp;(define&nbsp;dy&nbsp;(stream-map&nbsp;f&nbsp;y))<br>\n&nbsp;&nbsp;y)<br>\n</tt><p><p>\nWill this procedure work if internal definitions are scanned out as\nshown in this exercise?  What if they are scanned out as shown in the\ntext?  Explain.\n\n<p><p>\n\n<p><a name="%_thm_4.19"></a>\n<b>Exercise 4.19.</b>&nbsp;&nbsp;Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are arguing about\nthe desired result of evaluating the expression<p>\n\n<p><p><tt>(let&nbsp;((a&nbsp;1))<br>\n&nbsp;&nbsp;(define&nbsp;(f&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;b&nbsp;(+&nbsp;a&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;a&nbsp;5)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;a&nbsp;b))<br>\n&nbsp;&nbsp;(f&nbsp;10))<br>\n</tt><p><p>\nBen asserts that the result should be obtained using the sequential\nrule for <tt>define</tt>: <tt>b</tt> is defined to be 11, then <tt>a</tt> is\ndefined to be 5, so the result is 16.  Alyssa objects that mutual\nrecursion requires the simultaneous scope rule for internal procedure\ndefinitions, and that it is unreasonable to treat procedure names\ndifferently from other names.  Thus, she argues for the mechanism\nimplemented in exercise&nbsp;<a href="#%_thm_4.16">4.16</a>.  This would lead to\n<tt>a</tt> being unassigned at the time that the value for <tt>b</tt> is to\nbe computed.  Hence, in Alyssa\'s view the procedure should produce an\nerror.  Eva has a third opinion.  She says that if the definitions of\n<tt>a</tt> and <tt>b</tt> are truly meant to be simultaneous, then the value\n5 for <tt>a</tt> should be used in evaluating <tt>b</tt>.  Hence, in Eva\'s\nview <tt>a</tt> should be 5, <tt>b</tt> should be 15, and the result should\nbe 20.  Which (if any) of these viewpoints do you support?  Can you\ndevise a way to implement internal definitions so that they behave as\nEva prefers?<a name="call_footnote_Temp_565" href="#footnote_Temp_565"><sup><small>26</small></sup></a>\n\n<p><p>\n\n<p><a name="%_thm_4.20"></a>\n<b>Exercise 4.20.</b>&nbsp;&nbsp;<a name="%_idx_4618"></a><a name="%_idx_4620"></a>Because internal definitions look sequential but are actually\nsimultaneous, some people prefer to avoid them entirely, and use the\nspecial form <tt>letrec</tt> instead.  <tt>Letrec</tt> looks like <tt>let</tt>,\nso it is not surprising that the variables it binds are bound\nsimultaneously and have the same scope as each other.  The sample\nprocedure <tt>f</tt> above can be written without internal definitions,\nbut with exactly the same meaning, as<p>\n\n<p><p><tt>(define&nbsp;(f&nbsp;x)<br>\n&nbsp;&nbsp;(letrec&nbsp;((even?<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(odd?&nbsp;(-&nbsp;n&nbsp;1)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(odd?<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(even?&nbsp;(-&nbsp;n&nbsp;1))))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>rest&nbsp;of&nbsp;body&nbsp;of&nbsp;<tt>f</tt></em>&gt;))<br>\n</tt><p><p>\n<tt>Letrec</tt> expressions, which have the form\n<p><p><tt>(letrec&nbsp;((&lt;<em>var<sub>1</sub></em>&gt;&nbsp;&lt;<em>exp<sub>1</sub></em>&gt;)&nbsp;<tt>...</tt> (&lt;<em>var<sub><em>n</em></sub></em>&gt;&nbsp;&lt;<em>exp<sub><em>n</em></sub></em>&gt;))<br>\n&nbsp;&nbsp;&lt;<em>body</em>&gt;)<br>\n</tt><p><p>\nare a variation on <tt>let</tt> in which the expressions\n&lt;<em>exp<sub><em>k</em></sub></em>&gt; that provide the initial values for the variables &lt;<em>var<sub><em>k</em></sub></em>&gt;\nare evaluated in an environment that includes all the <tt>letrec</tt>\nbindings.  This permits recursion in the bindings, such as the mutual\nrecursion of <tt>even?</tt> and <tt>odd?</tt> in the example above, or\n<a name="%_idx_4622"></a>the evaluation of 10 factorial with<p>\n\n<p><p><tt>(letrec&nbsp;((fact<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;n&nbsp;(fact&nbsp;(-&nbsp;n&nbsp;1)))))))<br>\n&nbsp;&nbsp;(fact&nbsp;10))<br>\n</tt><p><p><p>\n\n<p><p>a. Implement <tt>letrec</tt> as a derived expression, by transforming\na <tt>letrec</tt> expression into a <tt>let</tt> expression as shown in\nthe text above or in exercise&nbsp;<a href="#%_thm_4.18">4.18</a>.\nThat is, the <tt>letrec</tt> variables should be created with a <tt>let</tt>\nand then be assigned their values with <tt>set!</tt>.<p>\n\n<p><p>b. Louis Reasoner is confused by all this fuss about internal\ndefinitions.  The way he sees it, if you don\'t like to use <tt>define</tt> inside a procedure, you can just use <tt>let</tt>.  Illustrate\nwhat is loose about his reasoning by drawing an environment diagram\nthat shows the environment in which the &lt;<em>rest of body of <tt>f</tt></em>&gt;\nis evaluated during evaluation of the expression <tt>(f 5)</tt>, with\n<tt>f</tt> defined as in this exercise.  Draw\nan environment diagram for the same evaluation, but with <tt>let</tt> in\nplace of <tt>letrec</tt> in the definition of <tt>f</tt>.\n\n<p><p>\n\n<p><a name="%_thm_4.21"></a>\n<b>Exercise 4.21.</b>&nbsp;&nbsp;<a name="%_idx_4624"></a>Amazingly, Louis\'s intuition in exercise&nbsp;<a href="#%_thm_4.20">4.20</a>\nis correct.  It is indeed possible to specify recursive procedures\nwithout using <tt>letrec</tt> (or even <tt>define</tt>), although the method\nfor accomplishing this is much more subtle than Louis imagined.  The\nfollowing expression computes 10 factorial by applying a recursive\n<a name="%_idx_4626"></a>factorial procedure:<a name="call_footnote_Temp_568" href="#footnote_Temp_568"><sup><small>27</small></sup></a>\n<p><p><tt>((lambda&nbsp;(n)<br>\n&nbsp;&nbsp;&nbsp;((lambda&nbsp;(fact)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fact&nbsp;fact&nbsp;n))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ft&nbsp;k)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;k&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;k&nbsp;(ft&nbsp;ft&nbsp;(-&nbsp;k&nbsp;1)))))))<br>\n&nbsp;10)<br>\n</tt><p><p><p>\n\n<p><p>a. Check (by evaluating the expression) that this really does compute\nfactorials.  Devise an analogous expression for computing Fibonacci numbers.<p>\n\n<p><p>b. Consider the following procedure, which includes mutually recursive\ninternal definitions:\n<p><p><tt>(define&nbsp;(f&nbsp;x)<br>\n&nbsp;&nbsp;(define&nbsp;(even?&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(odd?&nbsp;(-&nbsp;n&nbsp;1))))<br>\n&nbsp;&nbsp;(define&nbsp;(odd?&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(even?&nbsp;(-&nbsp;n&nbsp;1))))<br>\n&nbsp;&nbsp;(even?&nbsp;x))<br>\n</tt><p><p>\nFill in the missing expressions to complete an alternative definition\nof <tt>f</tt>, which uses neither internal definitions nor <tt>letrec</tt>:\n<p><p><tt>(define&nbsp;(f&nbsp;x)<br>\n&nbsp;&nbsp;((lambda&nbsp;(even?&nbsp;odd?)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(even?&nbsp;even?&nbsp;odd?&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ev?&nbsp;od?&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)&nbsp;true&nbsp;(od?&nbsp;&lt;??&gt;&nbsp;&lt;??&gt;&nbsp;&lt;??&gt;)))<br>\n&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ev?&nbsp;od?&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)&nbsp;false&nbsp;(ev?&nbsp;&lt;??&gt;&nbsp;&lt;??&gt;&nbsp;&lt;??&gt;)))))<br>\n</tt><p><p>\n<p><p>\n\n<a name="%_sec_4.1.7"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.7">4.1.7&nbsp;&nbsp;Separating Syntactic Analysis from Execution</a></h3><p>\n\n\n<a name="%_idx_4634"></a><a name="%_idx_4636"></a><a name="%_idx_4638"></a>\n<a name="%_idx_4640"></a><a name="%_idx_4642"></a>The evaluator implemented above is simple, but it is very\ninefficient, because the syntactic analysis of expressions is interleaved\nwith their execution.  Thus if a program is executed many times, its\nsyntax is analyzed many times.  Consider, for example, evaluating <tt>(factorial 4)</tt> using the following definition of <tt>factorial</tt>:<p>\n\n<p><p><tt>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1))&nbsp;n)))<br>\n</tt><p><p><p>\n\nEach time <tt>factorial</tt> is called, the evaluator must determine that\nthe body is an <tt>if</tt> expression and extract the predicate.\nOnly then can it evaluate the\npredicate and dispatch on its value.  Each time it evaluates the\nexpression <tt>(* (factorial (- n 1)) n)</tt>,\nor the subexpressions <tt>(factorial (- n 1))</tt> and <tt>(- n 1)</tt>,\nthe evaluator must perform\nthe case analysis in <tt>eval</tt> to determine that the expression is an\napplication, and must extract its operator and operands.  This\nanalysis is expensive.  Performing it repeatedly is wasteful.<p>\n\nWe can transform the evaluator to be significantly more efficient by\narranging things so that syntactic analysis is performed only\nonce.<a name="call_footnote_Temp_569" href="#footnote_Temp_569"><sup><small>28</small></sup></a> We split <tt>eval</tt>, which takes an\nexpression and an environment, into two parts.  The procedure <tt>analyze</tt> takes only the expression.  It performs the syntactic\nanalysis and returns a new procedure, the <a name="%_idx_4652"></a><em>execution procedure</em>, that\nencapsulates the work to be done in executing the analyzed\nexpression.  The execution procedure takes an environment as its\nargument and completes the evaluation.  This saves work because <tt>analyze</tt> will be called only once on an expression, while the\nexecution procedure may be called many times.<p>\n\nWith the separation into analysis and execution, <tt>eval</tt> now becomes<p>\n\n<p><p><tt><a name="%_idx_4654"></a>(define&nbsp;(eval&nbsp;exp&nbsp;env)<br>\n&nbsp;&nbsp;((analyze&nbsp;exp)&nbsp;env))<br>\n</tt><p><p><p>\n\nThe result of calling <tt>analyze</tt> is the execution procedure to\nbe applied to the environment.  The <tt>analyze</tt> procedure is\nthe same case analysis as performed by the original <tt>eval</tt> of\nsection&nbsp;<a href="#%_sec_4.1.1">4.1.1</a>, except that the procedures to\nwhich we dispatch perform only analysis, not full evaluation:<p>\n\n<p><p><tt><a name="%_idx_4656"></a>(define&nbsp;(analyze&nbsp;exp)<br>\n&nbsp;&nbsp;(cond&nbsp;((self-evaluating?&nbsp;exp)&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(analyze-self-evaluating&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((quoted?&nbsp;exp)&nbsp;(analyze-quoted&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((variable?&nbsp;exp)&nbsp;(analyze-variable&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((assignment?&nbsp;exp)&nbsp;(analyze-assignment&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((definition?&nbsp;exp)&nbsp;(analyze-definition&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((if?&nbsp;exp)&nbsp;(analyze-if&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda?&nbsp;exp)&nbsp;(analyze-lambda&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((begin?&nbsp;exp)&nbsp;(analyze-sequence&nbsp;(begin-actions&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((cond?&nbsp;exp)&nbsp;(analyze&nbsp;(cond-&gt;if&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((application?&nbsp;exp)&nbsp;(analyze-application&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;expression&nbsp;type&nbsp;--&nbsp;ANALYZE&quot;&nbsp;exp))))<br>\n</tt><p><p><p>\n\nHere is the simplest syntactic analysis procedure, which handles\nself-evaluating expressions.  It returns an execution procedure that\nignores its environment argument and just returns the expression:<p>\n\n<a name="%_idx_4658"></a><p><p><tt>(define&nbsp;(analyze-self-evaluating&nbsp;exp)<br>\n&nbsp;&nbsp;(lambda&nbsp;(env)&nbsp;exp))<br>\n</tt><p><p><p>\n\nFor a quoted expression, we can gain a little efficiency by\nextracting the text of the quotation only once, in the analysis phase,\nrather than in the execution phase.<p>\n\n<p><p><tt>(define&nbsp;(analyze-quoted&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((qval&nbsp;(text-of-quotation&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env)&nbsp;qval)))<br>\n</tt><p><p><p>\n\nLooking up a variable value must still be done in the execution phase,\nsince this depends upon knowing the environment.<a name="call_footnote_Temp_570" href="#footnote_Temp_570"><sup><small>29</small></sup></a><p>\n\n<p><p><tt>(define&nbsp;(analyze-variable&nbsp;exp)<br>\n&nbsp;&nbsp;(lambda&nbsp;(env)&nbsp;(lookup-variable-value&nbsp;exp&nbsp;env)))<br>\n</tt><p><p><p>\n\n<tt>Analyze-assignment</tt> also must defer actually setting the variable\nuntil the execution, when the environment has been supplied.  However,\nthe fact that the <tt>assignment-value</tt> expression can be\nanalyzed (recursively) during analysis is a major gain in efficiency,\nbecause the <tt>assignment-value</tt> expression will now be analyzed\nonly once.  The same holds true for definitions.<p>\n\n<p><p><tt>(define&nbsp;(analyze-assignment&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((var&nbsp;(assignment-variable&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vproc&nbsp;(analyze&nbsp;(assignment-value&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-variable-value!&nbsp;var&nbsp;(vproc&nbsp;env)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'ok)))<br>\n(define&nbsp;(analyze-definition&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((var&nbsp;(definition-variable&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vproc&nbsp;(analyze&nbsp;(definition-value&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-variable!&nbsp;var&nbsp;(vproc&nbsp;env)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'ok)))<br>\n</tt><p><p><p>\n\nFor <tt>if</tt> expressions, we extract and analyze the predicate,\nconsequent, and alternative at analysis time.<p>\n\n<p><p><tt>(define&nbsp;(analyze-if&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((pproc&nbsp;(analyze&nbsp;(if-predicate&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cproc&nbsp;(analyze&nbsp;(if-consequent&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(aproc&nbsp;(analyze&nbsp;(if-alternative&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(true?&nbsp;(pproc&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cproc&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(aproc&nbsp;env)))))<br>\n</tt><p><p><p>\n\nAnalyzing a <tt>lambda</tt> expression also achieves a major\ngain in efficiency: We analyze the <tt>lambda</tt> body only once, even though\nprocedures resulting from evaluation of the <tt>lambda</tt>\nmay be applied many times.<p>\n\n<p><p><tt>(define&nbsp;(analyze-lambda&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((vars&nbsp;(lambda-parameters&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bproc&nbsp;(analyze-sequence&nbsp;(lambda-body&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env)&nbsp;(make-procedure&nbsp;vars&nbsp;bproc&nbsp;env))))<br>\n</tt><p><p><p>\n\nAnalysis of a sequence of expressions (as in a <tt>begin</tt> or the body\nof a <tt>lambda</tt> expression) is more involved.<a name="call_footnote_Temp_571" href="#footnote_Temp_571"><sup><small>30</small></sup></a>\nEach expression\nin the sequence is analyzed, yielding an execution\nprocedure.  These execution procedures are combined to produce an\nexecution\nprocedure that takes an environment as argument and sequentially calls\neach individual execution procedure with the environment as argument.<p>\n\n<p><p><tt>(define&nbsp;(analyze-sequence&nbsp;exps)<br>\n&nbsp;&nbsp;(define&nbsp;(sequentially&nbsp;proc1&nbsp;proc2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env)&nbsp;(proc1&nbsp;env)&nbsp;(proc2&nbsp;env)))<br>\n&nbsp;&nbsp;(define&nbsp;(loop&nbsp;first-proc&nbsp;rest-procs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;rest-procs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first-proc<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(sequentially&nbsp;first-proc&nbsp;(car&nbsp;rest-procs))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;rest-procs))))<br>\n&nbsp;&nbsp;(let&nbsp;((procs&nbsp;(map&nbsp;analyze&nbsp;exps)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;procs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Empty&nbsp;sequence&nbsp;--&nbsp;ANALYZE&quot;))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(car&nbsp;procs)&nbsp;(cdr&nbsp;procs))))<br>\n</tt><p><p><p>\n\nTo analyze an application, we analyze the operator and operands and\nconstruct an execution procedure that\ncalls the operator execution procedure (to obtain the\nactual procedure to be applied) and the operand execution\nprocedures (to obtain the actual arguments).  We then pass these to <tt>execute-application</tt>, which is the analog of <tt>apply</tt> in\nsection&nbsp;<a href="#%_sec_4.1.1">4.1.1</a>.\n<tt>Execute-application</tt> differs from <tt>apply</tt> in that the procedure body for a compound procedure has already\nbeen analyzed, so there is no need to do further analysis.  Instead,\nwe just call the execution procedure for the body on the extended\nenvironment.\n<p><p><tt>(define&nbsp;(analyze-application&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((fproc&nbsp;(analyze&nbsp;(operator&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(aprocs&nbsp;(map&nbsp;analyze&nbsp;(operands&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(execute-application&nbsp;(fproc&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(aproc)&nbsp;(aproc&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aprocs)))))<br>\n<a name="%_idx_4660"></a>(define&nbsp;(execute-application&nbsp;proc&nbsp;args)<br>\n&nbsp;&nbsp;(cond&nbsp;((primitive-procedure?&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply-primitive-procedure&nbsp;proc&nbsp;args))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((compound-procedure?&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((procedure-body&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(extend-environment&nbsp;(procedure-parameters&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure-environment&nbsp;proc))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Unknown&nbsp;procedure&nbsp;type&nbsp;--&nbsp;EXECUTE-APPLICATION&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proc))))<br>\n</tt><p><p><p>\n\nOur new evaluator uses the same data structures, syntax\nprocedures, and run-time support procedures as in\nsections&nbsp;<a href="#%_sec_4.1.2">4.1.2</a>,\n&nbsp;<a href="#%_sec_4.1.3">4.1.3</a>, and&nbsp;<a href="#%_sec_4.1.4">4.1.4</a>.<p>\n\n<p><a name="%_thm_4.22"></a>\n<b>Exercise 4.22.</b>&nbsp;&nbsp;<a name="%_idx_4662"></a>Extend the evaluator in this section to support the special form <tt>let</tt>.\n(See exercise&nbsp;<a href="#%_thm_4.6">4.6</a>.)\n\n<p><p>\n\n<p><a name="%_thm_4.23"></a>\n<b>Exercise 4.23.</b>&nbsp;&nbsp;<a name="%_idx_4664"></a>Alyssa P. Hacker doesn\'t understand why <tt>analyze-sequence</tt> needs to be\nso complicated.  All the other analysis procedures\nare straightforward transformations of the corresponding evaluation\nprocedures (or <tt>eval</tt> clauses) in section&nbsp;<a href="#%_sec_4.1.1">4.1.1</a>.\nShe expected <tt>analyze-sequence</tt> to look like this:<p>\n\n\n<p><p><tt>(define&nbsp;(analyze-sequence&nbsp;exps)<br>\n&nbsp;&nbsp;(define&nbsp;(execute-sequence&nbsp;procs&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;(cdr&nbsp;procs))&nbsp;((car&nbsp;procs)&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;((car&nbsp;procs)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(execute-sequence&nbsp;(cdr&nbsp;procs)&nbsp;env))))<br>\n&nbsp;&nbsp;(let&nbsp;((procs&nbsp;(map&nbsp;analyze&nbsp;exps)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;procs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Empty&nbsp;sequence&nbsp;--&nbsp;ANALYZE&quot;))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env)&nbsp;(execute-sequence&nbsp;procs&nbsp;env))))<br>\n</tt><p><p>\nEva Lu Ator explains to Alyssa that the version in the text does more\nof the work of evaluating a sequence at analysis time.  Alyssa\'s\nsequence-execution procedure, rather than having the calls to the\nindividual execution procedures built in, loops through the procedures\nin order to call them: In effect, although the individual expressions\nin the sequence have been analyzed, the sequence itself has not been.<p>\n\nCompare the two versions of <tt>analyze-sequence</tt>.  For example,\nconsider the common case (typical of procedure bodies) where the\nsequence has just one expression.  What work will the execution\nprocedure produced by Alyssa\'s program do?  What about the execution\nprocedure produced by the program in the text above?  How do the two\nversions compare for a sequence with two expressions?\n\n<p><p>\n\n<p><a name="%_thm_4.24"></a>\n<b>Exercise 4.24.</b>&nbsp;&nbsp;Design and carry out some experiments to \ncompare the speed of the original metacircular evaluator\nwith the version in this section.  Use your results to estimate the fraction\nof time that is spent in analysis versus execution for various\nprocedures.\n<p><p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_510" href="#call_footnote_Temp_510"><sup><small>3</small></sup></a> Even so, there will remain important aspects of\nthe evaluation process that are not elucidated by our evaluator.  The\nmost important of these are the detailed mechanisms by which\nprocedures call other procedures and return values to their callers.\nWe will address these issues in chapter&nbsp;5, where we take a closer look\nat the evaluation process by implementing the evaluator as a simple\nregister machine.\n\n<p><a name="footnote_Temp_511" href="#call_footnote_Temp_511"><sup><small>4</small></sup></a> If we grant ourselves the ability to apply primitives,\n<a name="%_idx_4222"></a>then what remains for us to implement in the evaluator?  The job of\nthe evaluator is not to specify the primitives of the language, but rather\nto provide the connective tissue -- the means of combination and the\nmeans of abstraction -- that binds a collection of primitives to form a\nlanguage.  Specifically:\n<p><ul>\n<li>The evaluator enables us to deal with nested expressions.  For\nexample, although simply applying primitives\nwould suffice for evaluating\nthe expression <tt>(+ 1 6)</tt>, it is not adequate for handling <tt>(+ 1 (* 2\n3))</tt>.  As far as the primitive procedure <tt>+</tt> is concerned,\nits arguments must be numbers, and it would choke if we passed it the\nexpression <tt>(* 2 3)</tt> as an argument.  One important role of the\nevaluator is to choreograph procedure composition so that <tt>(* 2\n3)</tt> is reduced to 6 before being passed as an argument to <tt>+</tt>.<p>\n\n<li>The evaluator allows us to use variables.  For example, the\nprimitive procedure for addition has no way to deal with expressions such\nas <tt>(+ x 1)</tt>.  We need an evaluator to keep track of variables and\nobtain their values before invoking the primitive\nprocedures.<p>\n\n<li>The evaluator allows us to define compound procedures.  This\ninvolves keeping track of procedure definitions, knowing how to use\nthese definitions in evaluating expressions, and providing a mechanism\nthat enables procedures to accept arguments.<p>\n\n<li>The evaluator provides the special forms, which must be\nevaluated differently from procedure calls.\n</ul><p>\n\n<p><a name="footnote_Temp_518" href="#call_footnote_Temp_518"><sup><small>5</small></sup></a> We could have simplified the <tt>application?</tt> clause in <tt>eval</tt> by using <tt>map</tt>\n(and stipulating that <tt>operands</tt> returns a list) rather than\nwriting an explicit <tt>list-of-values</tt> procedure.  We chose not to\nuse <tt>map</tt> here to emphasize the fact that the <a name="%_idx_4252"></a><a name="%_idx_4254"></a>evaluator can be\nimplemented without any use of higher-order procedures\n(and thus could be written in a language that doesn\'t have\nhigher-order procedures), even though\nthe language that it supports will include higher-order procedures.\n\n<p><a name="footnote_Temp_520" href="#call_footnote_Temp_520"><sup><small>6</small></sup></a> In this case, the language being implemented and the\nimplementation language are the same.  Contemplation of the meaning of\n<a name="%_idx_4262"></a><tt>true?</tt> here yields expansion of consciousness without the abuse\nof substance.\n\n<p><a name="footnote_Temp_523" href="#call_footnote_Temp_523"><sup><small>7</small></sup></a> This implementation of <tt>define</tt> ignores a subtle\nissue in the handling of internal definitions, although it works\ncorrectly in most cases.  We will see what the problem is and how to\nsolve it in section&nbsp;<a href="#%_sec_4.1.6">4.1.6</a>.\n\n<p><a name="footnote_Temp_524" href="#call_footnote_Temp_524"><sup><small>8</small></sup></a> As we said when we\nintroduced <tt>define</tt> and <tt>set!</tt>, these values\nare implementation-dependent in Scheme -- that is, the implementor\ncan choose what value to return.\n\n<p><a name="footnote_Temp_526" href="#call_footnote_Temp_526"><sup><small>9</small></sup></a> As mentioned in\nsection&nbsp;<a href="book-Z-H-16.html#%_sec_2.3.1">2.3.1</a>, the evaluator sees a quoted expression as\na list beginning with <tt>quote</tt>, even if the\nexpression is typed with the quotation mark.  For example, the\nexpression <tt>\'a</tt> would be seen by the evaluator as <tt>(quote a)</tt>.\nSee exercise&nbsp;<a href="book-Z-H-16.html#%_thm_2.55">2.55</a>.\n\n<p><a name="footnote_Temp_527" href="#call_footnote_Temp_527"><sup><small>10</small></sup></a> The value of an <tt>if</tt> expression when the predicate\nis false and there is no alternative\nis unspecified in Scheme; we have chosen here to make it false.\nWe will support the use of the variables <tt>true</tt> and <tt>false</tt>\nin expressions to be evaluated by binding them in the global\nenvironment.  See section&nbsp;<a href="#%_sec_4.1.4">4.1.4</a>.\n\n\n<p><a name="footnote_Temp_528" href="#call_footnote_Temp_528"><sup><small>11</small></sup></a> These selectors for a list of expressions -- and the\ncorresponding ones for a list of operands -- are not intended as a data\nabstraction.  They are introduced as mnemonic names for the basic list\noperations in order to make it easier to understand the explicit-control\nevaluator in section&nbsp;<a href="book-Z-H-34.html#%_sec_5.4">5.4</a>.\n\n<p><a name="footnote_Temp_530" href="#call_footnote_Temp_530"><sup><small>12</small></sup></a> The value of a <tt>cond</tt> expression when all the predicates\nare false and there is no <tt>else</tt> clause\nis unspecified in Scheme; we have chosen here to make it false.\n\n<p><a name="footnote_Temp_531" href="#call_footnote_Temp_531"><sup><small>13</small></sup></a> Practical Lisp systems provide a\nmechanism that allows a user to add new derived expressions and\nspecify their implementation as syntactic transformations without\nmodifying the evaluator.  Such a user-defined transformation is called a\n<a name="%_idx_4374"></a><em>macro</em>.\nAlthough it is easy to add an elementary mechanism for defining macros,\nthe resulting language has subtle name-conflict problems.\nThere has been much research on mechanisms for macro definition\nthat do not cause these difficulties.  See,\n<a name="%_idx_4376"></a><a name="%_idx_4378"></a><a name="%_idx_4380"></a><a name="%_idx_4382"></a>for example, Kohlbecker 1986, Clinger and Rees 1991, and Hanson 1991.\n\n<p><a name="footnote_Temp_544" href="#call_footnote_Temp_544"><sup><small>14</small></sup></a> Frames are not really a data abstraction in the following code:\n<tt>Set-variable-value!</tt> and <tt>define-variable!</tt> use <tt>set-car!</tt>\nto directly modify the values in a frame.  The purpose of the frame\nprocedures is to make the environment-manipulation procedures easy to read.\n\n<p><a name="footnote_Temp_545" href="#call_footnote_Temp_545"><sup><small>15</small></sup></a> The drawback of this representation (as well as the variant in\nexercise&nbsp;<a href="#%_thm_4.11">4.11</a>) is that the evaluator\nmay have to search through many frames in order to find the binding\nfor a given variable.\n<a name="%_idx_4488"></a><a name="%_idx_4490"></a>(Such an approach is referred to as <em>deep binding</em>.) \nOne way to avoid\nthis inefficiency is to make use of a strategy called <em>lexical\naddressing</em>, which will be discussed in\nsection&nbsp;<a href="book-Z-H-35.html#%_sec_5.5.6">5.5.6</a>.\n\n<p><a name="footnote_Temp_549" href="#call_footnote_Temp_549"><sup><small>16</small></sup></a> Any procedure defined in the underlying Lisp can be used as\na primitive for the metacircular evaluator.  The name of a\nprimitive installed in the evaluator need not be the same as the name\nof its implementation in the underlying Lisp; the names are the same\nhere because the metacircular evaluator implements Scheme itself.\nThus, for example, we could put <tt>(list \'first car)</tt> or <tt>(list\n\'square (lambda (x) (* x x)))</tt> in the list of <tt>primitive-procedures</tt>.\n\n<p><a name="footnote_Temp_550" href="#call_footnote_Temp_550"><sup><small>17</small></sup></a> <tt>Apply-in-underlying-scheme</tt> is the <tt>apply</tt> procedure\nwe have used in earlier chapters.  The metacircular evaluator\'s <tt>apply</tt> procedure (section&nbsp;<a href="#%_sec_4.1.1">4.1.1</a>) models the\nworking of this primitive.  Having two different things called <tt>apply</tt> leads to a technical problem in running the metacircular\nevaluator, because defining the metacircular evaluator\'s <tt>apply</tt>\nwill mask the definition of the primitive.  One way around this is to\nrename the metacircular <tt>apply</tt> to avoid conflict with the name of\nthe primitive procedure.  We have assumed instead that we have saved a\nreference to the underlying <tt>apply</tt> by doing\n<p><p><tt>(define&nbsp;apply-in-underlying-scheme&nbsp;apply)<br>\n</tt><p><p>\nbefore defining the metacircular <tt>apply</tt>.  This allows us to\naccess the original version of <tt>apply</tt> under a different name.\n\n<p><a name="footnote_Temp_551" href="#call_footnote_Temp_551"><sup><small>18</small></sup></a> The primitive procedure <a name="%_idx_4522"></a><a name="%_idx_4524"></a><tt>read</tt> waits for input from the user,\nand returns the next complete expression that is typed.\nFor example, if the user types <tt>(+ 23 x)</tt>, <tt>read</tt> returns\na three-element list containing the symbol <tt>+</tt>, the number 23,\nand the symbol <tt>x</tt>.\n<a name="%_idx_4526"></a><a name="%_idx_4528"></a>If the user types <tt>\'x</tt>, <tt>read</tt> returns a two-element list\ncontaining the symbol <tt>quote</tt> and the symbol <tt>x</tt>.\n\n<p><a name="footnote_Temp_553" href="#call_footnote_Temp_553"><sup><small>19</small></sup></a> The fact that the machines are described in Lisp is\ninessential.  If we give our evaluator a Lisp program\nthat behaves as an evaluator for\nsome other language, say C, the Lisp evaluator will emulate the C\nevaluator, which in turn can emulate any machine described as a C\nprogram.  Similarly, writing a Lisp evaluator in C produces a C\nprogram that can execute any Lisp program.  The deep idea here is that\nany evaluator can emulate any other.  Thus, the notion of ``what can\nin principle be computed\'\' (ignoring practicalities of time and\nmemory required) is independent of the language or the computer, and\ninstead reflects an underlying notion of <a name="%_idx_4554"></a><em>computability</em>.  This\nwas first demonstrated in a clear way by <a name="%_idx_4556"></a>Alan M. Turing (1912-1954),\nwhose 1936 paper laid the foundations for theoretical <a name="%_idx_4558"></a>computer\nscience.  In the paper, Turing presented a simple computational\nmodel -- now known as a <a name="%_idx_4560"></a><em>Turing machine</em> -- and argued that any\n``effective process\'\' can be formulated as a program for such a\nmachine.  (This argument is known as the <a name="%_idx_4562"></a><em>Church-Turing thesis</em>.)\nTuring then implemented a universal machine, i.e., a Turing machine\nthat behaves as an evaluator for Turing-machine programs.  He used\nthis framework to demonstrate that there are well-posed problems that\ncannot be computed by Turing machines (see\nexercise&nbsp;<a href="#%_thm_4.15">4.15</a>), and so by implication cannot be\nformulated as ``effective processes.\'\'  Turing went on to make\nfundamental contributions to practical computer science as well.  For\nexample, he invented the idea of <a name="%_idx_4564"></a>structuring programs using\ngeneral-purpose subroutines.  See <a name="%_idx_4566"></a>Hodges 1983 for a biography of\nTuring.\n\n<p><a name="footnote_Temp_554" href="#call_footnote_Temp_554"><sup><small>20</small></sup></a> Some people find it\ncounterintuitive that an evaluator, which is implemented by a\nrelatively simple procedure, can emulate programs that are more\ncomplex than the evaluator itself.  The existence of a universal\nevaluator machine is a deep and wonderful property of computation.\n<a name="%_idx_4568"></a><em>Recursion theory</em>, a branch of mathematical logic, is concerned\nwith logical limits of computation.  <a name="%_idx_4570"></a>Douglas Hofstadter\'s beautiful\nbook <em>G&ouml;del, Escher, Bach</em> (1979) explores some of these ideas.\n\n<p><a name="footnote_Temp_555" href="#call_footnote_Temp_555"><sup><small>21</small></sup></a> Warning:\n<a name="%_idx_4576"></a>This <tt>eval</tt> primitive is not\nidentical to the <tt>eval</tt> procedure we implemented in\nsection&nbsp;<a href="#%_sec_4.1.1">4.1.1</a>, because it uses <em>actual</em>\nScheme environments rather than the sample environment structures we\nbuilt in section&nbsp;<a href="#%_sec_4.1.3">4.1.3</a>.  These actual\nenvironments cannot be manipulated by the user as ordinary lists; they\nmust be accessed via <tt>eval</tt> or other special operations.\n<a name="%_idx_4578"></a>Similarly, the <tt>apply</tt> primitive we saw earlier is not identical\nto the metacircular <tt>apply</tt>, because it uses actual Scheme procedures\nrather than the procedure objects we constructed in\nsections&nbsp;<a href="#%_sec_4.1.3">4.1.3</a> and&nbsp;<a href="#%_sec_4.1.4">4.1.4</a>.\n\n<p><a name="footnote_Temp_556" href="#call_footnote_Temp_556"><sup><small>22</small></sup></a> The MIT\n<a name="%_idx_4580"></a><a name="%_idx_4582"></a><a name="%_idx_4584"></a><a name="%_idx_4586"></a>implementation of Scheme includes <tt>eval</tt>, as well as a symbol <tt>user-initial-environment</tt> that is bound to the initial environment in\nwhich the user\'s input expressions are evaluated.\n\n<p><a name="footnote_Temp_558" href="#call_footnote_Temp_558"><sup><small>23</small></sup></a> Although we stipulated that <tt>halts?</tt> is given a procedure object,\nnotice that this reasoning still applies even if <tt>halts?</tt> can gain\naccess to the procedure\'s text and its environment.\n<a name="%_idx_4590"></a><a name="%_idx_4592"></a><a name="%_idx_4594"></a><a name="%_idx_4596"></a>This is Turing\'s celebrated <em>Halting Theorem</em>, which gave\nthe first clear example of a <em>non-computable</em> problem, i.e., a\nwell-posed task that cannot be carried out as a computational\nprocedure.\n\n<p><a name="footnote_Temp_559" href="#call_footnote_Temp_559"><sup><small>24</small></sup></a> Wanting programs to not depend on this evaluation\nmechanism is the reason for the ``management is not\nresponsible\'\' remark in footnote&nbsp;<a href="book-Z-H-10.html#footnote_Temp_45">28</a> of chapter&nbsp;1.\nBy insisting that internal definitions come first and do not use each\nother while the definitions are being evaluated, the IEEE standard\nfor Scheme leaves implementors some choice in the mechanism used to\nevaluate these definitions.  The choice of one evaluation rule rather\nthan another here may seem like a small issue, affecting only the\ninterpretation of ``badly formed\'\' programs.  However, we will see in\nsection&nbsp;<a href="book-Z-H-35.html#%_sec_5.5.6">5.5.6</a> that moving to a model of\nsimultaneous scoping for internal definitions avoids some nasty\ndifficulties that would otherwise arise in implementing a compiler.\n\n<p><a name="footnote_Temp_560" href="#call_footnote_Temp_560"><sup><small>25</small></sup></a> The IEEE standard for Scheme\nallows for different implementation strategies by specifying that it\nis up to the programmer to obey this restriction, not up to the\nimplementation to enforce it.  Some Scheme implementations, including\n<a name="%_idx_4610"></a>MIT Scheme, use the transformation shown above.  Thus, some programs\nthat don\'t obey this restriction will in fact run in such implementations.\n\n<p><a name="footnote_Temp_565" href="#call_footnote_Temp_565"><sup><small>26</small></sup></a> The MIT implementors of Scheme support Alyssa on\nthe following grounds: Eva is in principle correct -- the definitions\nshould be regarded as simultaneous.  But it seems difficult to\nimplement a general, efficient mechanism that does what Eva requires.\nIn the absence of such a mechanism, it is better to generate an error\nin the difficult cases of simultaneous definitions (Alyssa\'s notion)\nthan to produce an incorrect answer (as Ben would have it).\n\n<p><a name="footnote_Temp_568" href="#call_footnote_Temp_568"><sup><small>27</small></sup></a> This example illustrates a programming trick for\nformulating recursive procedures without using <tt>define</tt>.  The\n<a name="%_idx_4628"></a>most general trick of this sort is the <em>Y</em> <em>operator</em>, which can\nbe used to give a ``pure <img src="book-Z-G-D-6.gif" border="0">-calculus\'\' implementation of\n<a name="%_idx_4630"></a><a name="%_idx_4632"></a>recursion.  (See Stoy 1977 for details on the lambda calculus, and\nGabriel 1988 for an exposition of the <em>Y</em> operator in Scheme.)\n\n<p><a name="footnote_Temp_569" href="#call_footnote_Temp_569"><sup><small>28</small></sup></a> This technique is an integral part of the compilation\nprocess, which we shall discuss in chapter&nbsp;5.  Jonathan Rees wrote a Scheme\n<a name="%_idx_4644"></a><a name="%_idx_4646"></a><a name="%_idx_4648"></a><a name="%_idx_4650"></a>interpreter like this in about 1982 for the T project (Rees and Adams\n1982).  Marc Feeley (1986) (see also Feeley and Lapalme 1987)\nindependently invented this technique\nin his master\'s thesis.\n\n<p><a name="footnote_Temp_570" href="#call_footnote_Temp_570"><sup><small>29</small></sup></a> There is,\nhowever, an important part of the variable search that <em>can</em> be\ndone as part of the syntactic analysis.  As we will show in\nsection&nbsp;<a href="book-Z-H-35.html#%_sec_5.5.6">5.5.6</a>, one can determine the position\nin the environment structure where the value of the variable will be\nfound, thus obviating the need to scan the environment for the entry\nthat matches the variable.\n\n<p><a name="footnote_Temp_571" href="#call_footnote_Temp_571"><sup><small>30</small></sup></a> See exercise&nbsp;<a href="#%_thm_4.23">4.23</a> for some insight\ninto the processing of sequences.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_4.2"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_4.2">4.2&nbsp;&nbsp;Variations on a Scheme -- Lazy Evaluation</a></h2><p>\n\n\n<a name="%_idx_4666"></a><a name="%_idx_4668"></a>\n<a name="%_idx_4670"></a><a name="%_idx_4672"></a>Now that we have an evaluator expressed as a Lisp program, we can\nexperiment with alternative choices in language design simply by\nmodifying the evaluator.  Indeed, new languages are often invented by\nfirst writing an evaluator that embeds the new language within an\nexisting high-level language.  For example, if we wish to discuss some\naspect of a proposed modification to Lisp with another member of the\nLisp community, we can supply an evaluator that embodies\nthe change.  The recipient can then experiment with the new\nevaluator and send back comments as further modifications.  Not only\ndoes the high-level implementation base make it easier to test and\ndebug the evaluator; in addition, the embedding enables the designer\nto snarf<a name="call_footnote_Temp_575" href="#footnote_Temp_575"><sup><small>31</small></sup></a> features\nfrom the underlying language, just as our embedded Lisp evaluator\nuses primitives and control structure from the underlying Lisp.  Only\nlater (if ever) need the designer go to the trouble of building a\ncomplete implementation in a low-level language or in hardware.  In\nthis section and the next we explore some variations on Scheme that\nprovide significant additional expressive power.<p>\n\n<a name="%_sec_4.2.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.2.1">4.2.1&nbsp;&nbsp;Normal Order and Applicative Order</a></h3><p>\n\n<p>\n\n<a name="%_idx_4680"></a><a name="%_idx_4682"></a>In section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1">1.1</a>, where we began our discussion\nof models of evaluation, we noted that Scheme is an <em>applicative-order</em> language, namely, that all the arguments to Scheme\nprocedures are evaluated when the procedure is applied.  In\ncontrast, <em>normal-order</em> languages delay evaluation of procedure arguments\nuntil the actual argument values are needed.\nDelaying evaluation of procedure arguments until the\nlast possible moment (e.g., until they are required by a primitive\noperation) is called <a name="%_idx_4684"></a><em>lazy evaluation</em>.<a name="call_footnote_Temp_576" href="#footnote_Temp_576"><sup><small>32</small></sup></a>\nConsider the procedure<p>\n\n<p><p><tt>(define&nbsp;(try&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;a&nbsp;0)&nbsp;1&nbsp;b))<br>\n</tt><p><p>\nEvaluating <tt>(try 0 (/ 1 0))</tt> generates an error in Scheme.  With\nlazy evaluation, there would be no error.  Evaluating the expression\nwould return 1, because the argument <tt>(/ 1 0)</tt> would\nnever be evaluated.<p>\n\nAn example that exploits lazy evaluation is the \ndefinition of a procedure <tt>unless</tt><p>\n\n<p><p><tt>(define&nbsp;(unless&nbsp;condition&nbsp;usual-value&nbsp;exceptional-value)<br>\n&nbsp;&nbsp;(if&nbsp;condition&nbsp;exceptional-value&nbsp;usual-value))<br>\n</tt><p><p>\nthat can be used in expressions such as<p>\n\n<p><p><tt>(unless&nbsp;(=&nbsp;b&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(/&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(display&nbsp;&quot;exception:&nbsp;returning&nbsp;0&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0))<br>\n</tt><p><p>\nThis won\'t work in an applicative-order language because both the\nusual value and the exceptional value will be evaluated before\n<tt>unless</tt> is called (compare exercise&nbsp;<a href="book-Z-H-10.html#%_thm_1.6">1.6</a>).  An\nadvantage of lazy evaluation is that some procedures, such as <tt>unless</tt>, can do useful computation even if evaluation of some of their\narguments would produce errors or would not terminate.<p>\n\nIf the body of a procedure is entered before an argument has been\nevaluated we say that the procedure is <a name="%_idx_4686"></a><em>non-strict</em> in that\nargument.  If the argument is evaluated before the body of the\nprocedure is entered we say that the procedure is <a name="%_idx_4688"></a><em>strict</em> in that\nargument.<a name="call_footnote_Temp_577" href="#footnote_Temp_577"><sup><small>33</small></sup></a>\nIn a purely applicative-order language, all procedures are strict in\neach argument.  In a purely normal-order language, all compound\nprocedures are non-strict in each argument, and primitive procedures may be\neither strict or non-strict.  There are also languages (see\nexercise&nbsp;<a href="#%_thm_4.31">4.31</a>) that give programmers\ndetailed control over the strictness of the procedures they define.<p>\n\nA striking example of a procedure that can usefully be made non-strict\nis <tt>cons</tt> (or, in general, almost any constructor for data\nstructures).  One can do useful computation, combining elements to\nform data structures and operating on the resulting data structures,\neven if the values of the elements are not known.  It makes perfect\nsense, for instance, to compute the length of a list without knowing\nthe values of the individual elements in the list.  We will exploit\nthis idea in section&nbsp;<a href="#%_sec_4.2.3">4.2.3</a> to implement the\nstreams of chapter&nbsp;3 as lists formed of non-strict <tt>cons</tt>\npairs.<p>\n\n<p><a name="%_thm_4.25"></a>\n<b>Exercise 4.25.</b>&nbsp;&nbsp;Suppose that (in ordinary applicative-order Scheme) we define <tt>unless</tt>\nas shown above and then define <tt>factorial</tt> in terms of <tt>unless</tt> as<p>\n\n<p><p><tt>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(unless&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;n&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1))<br>\n</tt><p><p>\nWhat happens if we attempt to evaluate <tt>(factorial 5)</tt>?  Will our\ndefinitions work in a normal-order language?\n<p><p>\n\n<p><a name="%_thm_4.26"></a>\n<b>Exercise 4.26.</b>&nbsp;&nbsp;<a name="%_idx_4692"></a><a name="%_idx_4694"></a>Ben Bitdiddle and Alyssa P. Hacker disagree over the importance of\nlazy evaluation for implementing things such as <tt>unless</tt>.  Ben\npoints out that it\'s possible to implement <tt>unless</tt> in applicative\norder as a special form.\nAlyssa counters that, if one did that, <tt>unless</tt> would be merely\nsyntax, not a procedure that could be used in conjunction with\nhigher-order procedures.  Fill in the details on both sides of the\nargument.  Show how to implement <tt>unless</tt> as a derived expression\n(like <tt>cond</tt> or <tt>let</tt>),\nand give an example of a situation where it might be useful to have\n<tt>unless</tt> available as a procedure, rather than as a special form.\n\n<p><p>\n\n<a name="%_sec_4.2.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.2.2">4.2.2&nbsp;&nbsp;An Interpreter with Lazy Evaluation</a></h3><p>\n\nIn this section we will implement a normal-order language that is\nthe same as Scheme except that compound procedures are non-strict\nin each argument.  Primitive procedures will still be strict.\nIt is not difficult to modify the evaluator of\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a> so that the language it interprets behaves\nthis way.  Almost all the required changes center around procedure\napplication.<p>\n\nThe basic idea is that, when applying a procedure, the interpreter\nmust determine which arguments are to be\nevaluated and which are to be\ndelayed.  The delayed arguments are not\nevaluated; instead, they are transformed into objects called <a name="%_idx_4696"></a><em>thunk</em>s.<a name="call_footnote_Temp_580" href="#footnote_Temp_580"><sup><small>34</small></sup></a>\nThe thunk must contain the information required to produce the value\nof the argument when it is needed, as if it had been evaluated at\nthe time of the application.  Thus, the thunk must contain the\nargument expression and the environment in\nwhich the procedure application is being evaluated.<p>\n\n<a name="%_idx_4704"></a><a name="%_idx_4706"></a>The process of evaluating the expression in a thunk is called <em>forcing</em>.<a name="call_footnote_Temp_581" href="#footnote_Temp_581"><sup><small>35</small></sup></a>\nIn general, a thunk will be forced only when its value is needed:\nwhen it is passed to a primitive procedure that\nwill use the value of the thunk; when it is the\nvalue of a predicate of a conditional; and when it\nis the value of an operator that is about to be applied as a procedure.\nOne design choice we have available is whether or not to <a name="%_idx_4710"></a><em>memoize</em> thunks, as we did with delayed objects in\nsection&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.1">3.5.1</a>.  With memoization, the first time a\nthunk is forced, it stores the value that is computed.  Subsequent\nforcings simply return the stored value without repeating the\ncomputation.  We\'ll make our interpreter memoize, because this is\nmore efficient for many applications.  There are tricky\nconsiderations here, however.<a name="call_footnote_Temp_582" href="#footnote_Temp_582"><sup><small>36</small></sup></a><p>\n\n<a name="%_sec_Temp_583"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_583">Modifying the evaluator</a></h4><p>\n\nThe main difference between the lazy evaluator and the one in\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1">4.1</a> is in the handling of procedure\napplications in <tt>eval</tt> and <tt>apply</tt>.<p>\n\n<a name="%_idx_4720"></a>The <tt>application?</tt> clause of <tt>eval</tt> becomes<p>\n\n<p><p><tt>((application?&nbsp;exp)<br>\n&nbsp;(apply&nbsp;(actual-value&nbsp;(operator&nbsp;exp)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(operands&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env))<br>\n</tt><p><p>\nThis is almost the same as the <tt>application?</tt> clause of <tt>eval</tt>\nin section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>.  For lazy evaluation, however,\nwe call <tt>apply</tt> with the operand expressions, rather than the\narguments produced by evaluating them.  Since we will need the environment to\nconstruct thunks if the arguments are to be delayed, we must pass this as well.\nWe still evaluate the\noperator, because <tt>apply</tt> needs the actual procedure to be applied\nin order to dispatch on its type (primitive versus compound) and apply it.<p>\n\nWhenever we need the actual value of an expression, we use\n<p><p><tt><a name="%_idx_4722"></a>(define&nbsp;(actual-value&nbsp;exp&nbsp;env)<br>\n&nbsp;&nbsp;(force-it&nbsp;(eval&nbsp;exp&nbsp;env)))<br>\n</tt><p><p>\ninstead of just <tt>eval</tt>, so that if the expression\'s value\nis a thunk, it will be forced.<p>\n\nOur new version of <tt>apply</tt> is also almost the same as the\nversion in section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>.  The difference is\nthat <tt>eval</tt> has passed in unevaluated operand expressions:\nFor primitive procedures (which are strict), we evaluate all the\narguments before applying the primitive;\nfor compound procedures (which are non-strict) we delay all the\narguments before applying the procedure.<p>\n\n<p><p><tt><a name="%_idx_4724"></a>(define&nbsp;(apply&nbsp;procedure&nbsp;arguments&nbsp;env)<br>\n&nbsp;&nbsp;(cond&nbsp;((primitive-procedure?&nbsp;procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply-primitive-procedure<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;procedure<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-of-arg-values&nbsp;arguments&nbsp;env)))&nbsp;&nbsp;<em>;&nbsp;changed</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((compound-procedure?&nbsp;procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval-sequence<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure-body&nbsp;procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(extend-environment<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure-parameters&nbsp;procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-of-delayed-args&nbsp;arguments&nbsp;env)&nbsp;<em>;&nbsp;changed</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure-environment&nbsp;procedure))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Unknown&nbsp;procedure&nbsp;type&nbsp;--&nbsp;APPLY&quot;&nbsp;procedure))))<br>\n</tt><p><p>\nThe procedures that process the arguments are just like <tt>list-of-values</tt> from section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>, except that\n<tt>list-of-delayed-args</tt> delays the arguments instead of evaluating\nthem, and <tt>list-of-arg-values</tt> uses <tt>actual-value</tt> instead\nof <tt>eval</tt>:<p>\n\n<p><p><tt><a name="%_idx_4726"></a>(define&nbsp;(list-of-arg-values&nbsp;exps&nbsp;env)<br>\n&nbsp;&nbsp;(if&nbsp;(no-operands?&nbsp;exps)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(actual-value&nbsp;(first-operand&nbsp;exps)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-of-arg-values&nbsp;(rest-operands&nbsp;exps)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env))))<br>\n<a name="%_idx_4728"></a>(define&nbsp;(list-of-delayed-args&nbsp;exps&nbsp;env)<br>\n&nbsp;&nbsp;(if&nbsp;(no-operands?&nbsp;exps)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(delay-it&nbsp;(first-operand&nbsp;exps)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-of-delayed-args&nbsp;(rest-operands&nbsp;exps)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env))))<br>\n</tt><p><p><p>\n\nThe other place we must change the evaluator is in the handling of\n<tt>if</tt>, where we must use <tt>actual-value</tt> instead\nof <tt>eval</tt> to get the value of the predicate expression\nbefore testing whether it is true or false:<p>\n\n<p><p><tt><a name="%_idx_4730"></a>(define&nbsp;(eval-if&nbsp;exp&nbsp;env)<br>\n&nbsp;&nbsp;(if&nbsp;(true?&nbsp;(actual-value&nbsp;(if-predicate&nbsp;exp)&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval&nbsp;(if-consequent&nbsp;exp)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval&nbsp;(if-alternative&nbsp;exp)&nbsp;env)))<br>\n</tt><p><p><p>\n\n<a name="%_idx_4732"></a>Finally, we must change the <tt>driver-loop</tt>\nprocedure (section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.4">4.1.4</a>) to use <tt>actual-value</tt> instead\nof <tt>eval</tt>, so that if a delayed value\nis propagated back to the read-eval-print loop, it will be forced\nbefore being printed.  We also change the prompts to indicate that\nthis is the lazy evaluator:<p>\n\n<p><p><tt><a name="%_idx_4734"></a>(define&nbsp;input-prompt&nbsp;&quot;;;;&nbsp;L-Eval&nbsp;input:&quot;)<br>\n(define&nbsp;output-prompt&nbsp;&quot;;;;&nbsp;L-Eval&nbsp;value:&quot;)<br>\n<a name="%_idx_4736"></a>(define&nbsp;(driver-loop)<br>\n&nbsp;&nbsp;(prompt-for-input&nbsp;input-prompt)<br>\n&nbsp;&nbsp;(let&nbsp;((input&nbsp;(read)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((output<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(actual-value&nbsp;input&nbsp;the-global-environment)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(announce-output&nbsp;output-prompt)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(user-print&nbsp;output)))<br>\n&nbsp;&nbsp;(driver-loop))<br>\n</tt><p><p><p>\n\nWith these changes made, we can start the evaluator and test it.  The\nsuccessful evaluation of the <tt>try</tt> expression discussed in\nsection&nbsp;<a href="#%_sec_4.2.1">4.2.1</a> indicates that the interpreter is\nperforming lazy evaluation:<p>\n\n<p><p><tt>(define&nbsp;the-global-environment&nbsp;(setup-environment))<br>\n(driver-loop)<br>\n<i>;;;&nbsp;L-Eval&nbsp;input:</i><br>\n(define&nbsp;(try&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;a&nbsp;0)&nbsp;1&nbsp;b))<br>\n<i>;;;&nbsp;L-Eval&nbsp;value:</i><br>\n<i>ok</i><br>\n<i>;;;&nbsp;L-Eval&nbsp;input:</i><br>\n(try&nbsp;0&nbsp;(/&nbsp;1&nbsp;0))<br>\n<i>;;;&nbsp;L-Eval&nbsp;value:</i><br>\n<i>1</i><br>\n</tt><p><p><p>\n\n\n<a name="%_sec_Temp_584"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_584">Representing thunks</a></h4><p>\n\n<a name="%_idx_4738"></a>\nOur evaluator must arrange to create thunks when procedures are\napplied to arguments and to force these thunks later.  A thunk must\npackage an expression together with the environment, so that the\nargument can be produced later.\nTo force the thunk, we simply extract the expression and environment\nfrom the thunk and evaluate the expression in the environment.\nWe use <tt>actual-value</tt> rather than <tt>eval</tt> so that in case the\nvalue of the expression is itself a thunk, we will force that, and so\non, until we reach something that is not a thunk:<p>\n\n<p><p><tt><a name="%_idx_4740"></a>(define&nbsp;(force-it&nbsp;obj)<br>\n&nbsp;&nbsp;(if&nbsp;(thunk?&nbsp;obj)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(actual-value&nbsp;(thunk-exp&nbsp;obj)&nbsp;(thunk-env&nbsp;obj))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj))<br>\n</tt><p><p><p>\n\nOne easy way to package an expression with an environment is to make a\nlist containing the expression and the environment.\nThus, we create a thunk as follows:<p>\n\n<p><p><tt><a name="%_idx_4742"></a>(define&nbsp;(delay-it&nbsp;exp&nbsp;env)<br>\n&nbsp;&nbsp;(list&nbsp;\'thunk&nbsp;exp&nbsp;env))<br>\n<br>\n(define&nbsp;(thunk?&nbsp;obj)<br>\n&nbsp;&nbsp;(tagged-list?&nbsp;obj&nbsp;\'thunk))<br>\n<br>\n(define&nbsp;(thunk-exp&nbsp;thunk)&nbsp;(cadr&nbsp;thunk))<br>\n<br>\n(define&nbsp;(thunk-env&nbsp;thunk)&nbsp;(caddr&nbsp;thunk))<br>\n</tt><p><p><p>\n\nActually, what we want for our interpreter is not quite this, but\nrather thunks that have been memoized.\nWhen a thunk is forced, we will turn it into an evaluated thunk\nby replacing the stored expression with its value and\nchanging the <tt>thunk</tt> tag so that it can be recognized as\nalready evaluated.<a name="call_footnote_Temp_585" href="#footnote_Temp_585"><sup><small>37</small></sup></a><p>\n\n<p><p><tt>(define&nbsp;(evaluated-thunk?&nbsp;obj)<br>\n&nbsp;&nbsp;(tagged-list?&nbsp;obj&nbsp;\'evaluated-thunk))<br>\n<br>\n(define&nbsp;(thunk-value&nbsp;evaluated-thunk)&nbsp;(cadr&nbsp;evaluated-thunk))<br>\n<a name="%_idx_4748"></a>(define&nbsp;(force-it&nbsp;obj)<br>\n&nbsp;&nbsp;(cond&nbsp;((thunk?&nbsp;obj)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((result&nbsp;(actual-value<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(thunk-exp&nbsp;obj)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(thunk-env&nbsp;obj))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;obj&nbsp;\'evaluated-thunk)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;(cdr&nbsp;obj)&nbsp;result)&nbsp;&nbsp;<em>;&nbsp;replace&nbsp;<tt>exp</tt>&nbsp;with&nbsp;its&nbsp;value</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;(cdr&nbsp;obj)&nbsp;\'())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;forget&nbsp;unneeded&nbsp;<tt>env</tt></em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((evaluated-thunk?&nbsp;obj)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(thunk-value&nbsp;obj))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;obj)))<br>\n</tt><p><p>\nNotice that the same <tt>delay-it</tt> procedure works both with and\nwithout memoization.<p>\n\n<p><a name="%_thm_4.27"></a>\n<b>Exercise 4.27.</b>&nbsp;&nbsp;Suppose we type in the following definitions to the lazy evaluator:\n<p><p><tt>(define&nbsp;count&nbsp;0)<br>\n(define&nbsp;(id&nbsp;x)<br>\n&nbsp;&nbsp;(set!&nbsp;count&nbsp;(+&nbsp;count&nbsp;1))<br>\n&nbsp;&nbsp;x)<br>\n</tt><p><p>\nGive the missing values in the following sequence of\ninteractions, and explain your answers.<a name="call_footnote_Temp_587" href="#footnote_Temp_587"><sup><small>38</small></sup></a>\n<p><p><tt>(define&nbsp;w&nbsp;(id&nbsp;(id&nbsp;10)))<br>\n<i>;;;&nbsp;L-Eval&nbsp;input:</i><br>\ncount<br>\n<i>;;;&nbsp;L-Eval&nbsp;value:</i><br>\n&lt;<em>response</em>&gt;<br>\n<i>;;;&nbsp;L-Eval&nbsp;input:</i><br>\nw<br>\n<i>;;;&nbsp;L-Eval&nbsp;value:</i><br>\n&lt;<em>response</em>&gt;<br>\n<i>;;;&nbsp;L-Eval&nbsp;input:</i><br>\ncount<br>\n<i>;;;&nbsp;L-Eval&nbsp;value:</i><br>\n&lt;<em>response</em>&gt;<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_4.28"></a>\n<b>Exercise 4.28.</b>&nbsp;&nbsp;<tt>Eval</tt> uses <tt>actual-value</tt> rather than <tt>eval</tt>\nto evaluate the operator before passing it to <tt>apply</tt>,\nin order to force the value of the operator.\nGive an example that demonstrates the need for this forcing.\n<p><p>\n\n<p><a name="%_thm_4.29"></a>\n<b>Exercise 4.29.</b>&nbsp;&nbsp;Exhibit a program that you would expect to run much more slowly\nwithout memoization than with memoization.  Also, consider the\nfollowing interaction, where the <tt>id</tt> procedure is defined as in\nexercise&nbsp;<a href="#%_thm_4.27">4.27</a> and <tt>count</tt> starts at 0:\n<p><p><tt>(define&nbsp;(square&nbsp;x)<br>\n&nbsp;&nbsp;(*&nbsp;x&nbsp;x))<br>\n<i>;;;&nbsp;L-Eval&nbsp;input:</i><br>\n(square&nbsp;(id&nbsp;10))<br>\n<i>;;;&nbsp;L-Eval&nbsp;value:</i><br>\n&lt;<em>response</em>&gt;<br>\n<i>;;;&nbsp;L-Eval&nbsp;input:</i><br>\ncount<br>\n<i>;;;&nbsp;L-Eval&nbsp;value:</i><br>\n&lt;<em>response</em>&gt;<br>\n</tt><p><p>\nGive the responses both when the evaluator memoizes and when it does not.\n\n<p><p>\n\n<p><a name="%_thm_4.30"></a>\n<b>Exercise 4.30.</b>&nbsp;&nbsp;Cy D. Fect, a reformed C programmer, is worried that some side effects\nmay never take place, because the lazy evaluator doesn\'t force the\nexpressions in a sequence.\nSince the value of an expression in a sequence other than the last one\nis not used (the expression is there only for its effect, such as\nassigning to a variable or printing), there can be no subsequent use\nof this value (e.g., as an argument to a primitive procedure) that\nwill cause it to be forced.  Cy thus thinks that when evaluating\nsequences, we must force all expressions in the sequence except the\nfinal one.  He proposes to modify <tt>eval-sequence</tt> from\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a> to use <tt>actual-value</tt> rather\nthan <tt>eval</tt>:<p>\n\n<p><p><tt>(define&nbsp;(eval-sequence&nbsp;exps&nbsp;env)<br>\n&nbsp;&nbsp;(cond&nbsp;((last-exp?&nbsp;exps)&nbsp;(eval&nbsp;(first-exp&nbsp;exps)&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(actual-value&nbsp;(first-exp&nbsp;exps)&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval-sequence&nbsp;(rest-exps&nbsp;exps)&nbsp;env))))<br>\n</tt><p><p><p>\n\n<p><p>a. Ben Bitdiddle thinks Cy is wrong.\nHe shows Cy the <tt>for-each</tt> procedure described in\nexercise&nbsp;<a href="book-Z-H-15.html#%_thm_2.23">2.23</a>, which gives an important example of\na sequence with side effects:<p>\n\n<p><p><tt><a name="%_idx_4750"></a>(define&nbsp;(for-each&nbsp;proc&nbsp;items)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;items)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'done<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(proc&nbsp;(car&nbsp;items))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for-each&nbsp;proc&nbsp;(cdr&nbsp;items)))))<br>\n</tt><p><p>\nHe claims that the evaluator in the text (with the original <tt>eval-sequence</tt>) handles this correctly:<p>\n\n<p><p><tt><i>;;;&nbsp;L-Eval&nbsp;input:</i><br>\n(for-each&nbsp;(lambda&nbsp;(x)&nbsp;(newline)&nbsp;(display&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;57&nbsp;321&nbsp;88))<br>\n<i>57</i><br>\n<i>321</i><br>\n<i>88</i><br>\n<i>;;;&nbsp;L-Eval&nbsp;value:</i><br>\n<i>done</i><br>\n</tt><p><p>\nExplain why Ben is right about the behavior of <tt>for-each</tt>.<p>\n\n<p><p>b. Cy agrees that Ben is right about the <tt>for-each</tt> example,\nbut says that that\'s not the kind of program he was thinking about\nwhen he proposed his change to <tt>eval-sequence</tt>.\nHe defines the following two procedures in the lazy evaluator:<p>\n\n<p><p><tt>(define&nbsp;(p1&nbsp;x)<br>\n&nbsp;&nbsp;(set!&nbsp;x&nbsp;(cons&nbsp;x&nbsp;\'(2)))<br>\n&nbsp;&nbsp;x)<br>\n<br>\n(define&nbsp;(p2&nbsp;x)<br>\n&nbsp;&nbsp;(define&nbsp;(p&nbsp;e)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;e<br>\n&nbsp;&nbsp;&nbsp;&nbsp;x)<br>\n&nbsp;&nbsp;(p&nbsp;(set!&nbsp;x&nbsp;(cons&nbsp;x&nbsp;\'(2)))))<br>\n</tt><p><p>\nWhat are the values of <tt>(p1 1)</tt> and <tt>(p2 1)</tt> with the\noriginal <tt>eval-sequence</tt>?\nWhat would the values be with Cy\'s proposed change to <tt>eval-sequence</tt>?<p>\n\n<p><p>c. Cy also points out that changing <tt>eval-sequence</tt> as he proposes\ndoes not affect the behavior of the example in part a.\nExplain why this is true.<p>\n\n<p><p>d. How do you think sequences ought to be treated in the lazy evaluator?\nDo you like Cy\'s approach, the approach in the text, or some other approach?\n\n<p><p>\n\n<p><a name="%_thm_4.31"></a>\n<b>Exercise 4.31.</b>&nbsp;&nbsp;<a name="%_idx_4752"></a>The approach taken in this section is somewhat unpleasant, because it\nmakes an incompatible change to Scheme.  It might be nicer to\nimplement lazy evaluation as an <em>upward-compatible extension</em>,\nthat is, so that ordinary Scheme programs will work as before.  We can\ndo this by extending the syntax of procedure declarations to let the user\ncontrol whether or not arguments are to be delayed.  While we\'re at\nit, we may as well also give the user the choice between delaying with\nand without memoization.  For example, the definition\n<p><p><tt>(define&nbsp;(f&nbsp;a&nbsp;(b&nbsp;lazy)&nbsp;c&nbsp;(d&nbsp;lazy-memo))<br>\n&nbsp;&nbsp;<tt>...</tt>)<br>\n</tt><p><p>\nwould define <tt>f</tt> to be a procedure of four arguments, where the\nfirst and third arguments are evaluated when the procedure is called,\nthe second argument is delayed, and the fourth argument is both\ndelayed and memoized.  Thus, ordinary procedure definitions will\nproduce the same behavior as ordinary Scheme, while adding the <tt>lazy-memo</tt> declaration to each parameter of every compound procedure\nwill produce the behavior of the lazy evaluator defined in this\nsection. Design and implement the changes required to produce such an\nextension to Scheme.  You will have to implement new syntax procedures\nto handle the new syntax for <tt>define</tt>.  You must also arrange for\n<tt>eval</tt> or <tt>apply</tt> to determine when arguments are to be delayed, and to\nforce or delay arguments accordingly, and you must arrange for forcing\nto memoize or not, as appropriate.\n\n<p><p>\n\n<a name="%_sec_4.2.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.2.3">4.2.3&nbsp;&nbsp;Streams as Lazy Lists</a></h3><p>\n\n\n<a name="%_idx_4754"></a><a name="%_idx_4756"></a><a name="%_idx_4758"></a><a name="%_idx_4760"></a><a name="%_idx_4762"></a>\n<a name="%_idx_4764"></a><a name="%_idx_4766"></a><a name="%_idx_4768"></a><a name="%_idx_4770"></a>In section&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.1">3.5.1</a>, we showed how to implement streams\nas delayed lists.  We introduced special forms <tt>delay</tt> and <tt>cons-stream</tt>, which allowed us to construct a ``promise\'\' to compute\nthe <tt>cdr</tt> of a stream, without actually fulfilling that promise\nuntil later.  We could use this general technique of introducing\nspecial forms whenever we need more control over the evaluation process,\nbut this is awkward.  For one thing, a special form is not a\nfirst-class object like a procedure, so we cannot use it together with\nhigher-order procedures.<a name="call_footnote_Temp_592" href="#footnote_Temp_592"><sup><small>39</small></sup></a>  Additionally,\nwe were forced to create streams as a new kind of data object\nsimilar but not identical to lists, and this required us to\nreimplement many ordinary list operations (<tt>map</tt>, <tt>append</tt>, and\nso on) for use with streams.<p>\n\n\nWith lazy evaluation, streams and lists can be identical, so there is\nno need for special forms or for separate list and stream operations.\nAll we need to do is to arrange matters so that <tt>cons</tt> is\nnon-strict.  One way to accomplish this is to extend the lazy\nevaluator to allow for non-strict primitives, and to implement <tt>cons</tt> as one of these.  An easier way is to recall\n(section&nbsp;<a href="book-Z-H-14.html#%_sec_2.1.3">2.1.3</a>) that there is no fundamental need to\nimplement <tt>cons</tt> as a primitive at all.  Instead, we can represent\n<a name="%_idx_4772"></a>pairs as procedures:<a name="call_footnote_Temp_593" href="#footnote_Temp_593"><sup><small>40</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_4774"></a>(define&nbsp;(cons&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(lambda&nbsp;(m)&nbsp;(m&nbsp;x&nbsp;y)))<br>\n<a name="%_idx_4776"></a>(define&nbsp;(car&nbsp;z)<br>\n&nbsp;&nbsp;(z&nbsp;(lambda&nbsp;(p&nbsp;q)&nbsp;p)))<br>\n<a name="%_idx_4778"></a>(define&nbsp;(cdr&nbsp;z)<br>\n&nbsp;&nbsp;(z&nbsp;(lambda&nbsp;(p&nbsp;q)&nbsp;q)))<br>\n</tt><p><p><p>\n\nIn terms of these basic operations, the standard definitions of the\nlist operations will work with infinite lists (streams) as well as\nfinite ones, and the stream operations can be implemented as list operations.\nHere are some examples:<p>\n\n<p><p><tt><a name="%_idx_4780"></a>(define&nbsp;(list-ref&nbsp;items&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;items)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-ref&nbsp;(cdr&nbsp;items)&nbsp;(-&nbsp;n&nbsp;1))))<br>\n<a name="%_idx_4782"></a>(define&nbsp;(map&nbsp;proc&nbsp;items)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;items)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(proc&nbsp;(car&nbsp;items))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;proc&nbsp;(cdr&nbsp;items)))))<br>\n<a name="%_idx_4784"></a>(define&nbsp;(scale-list&nbsp;items&nbsp;factor)<br>\n&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;factor))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items))<br>\n<a name="%_idx_4786"></a>(define&nbsp;(add-lists&nbsp;list1&nbsp;list2)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;list1)&nbsp;list2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((null?&nbsp;list2)&nbsp;list1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(cons&nbsp;(+&nbsp;(car&nbsp;list1)&nbsp;(car&nbsp;list2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-lists&nbsp;(cdr&nbsp;list1)&nbsp;(cdr&nbsp;list2))))))<br>\n<a name="%_idx_4788"></a>(define&nbsp;ones&nbsp;(cons&nbsp;1&nbsp;ones))<br>\n<a name="%_idx_4790"></a>(define&nbsp;integers&nbsp;(cons&nbsp;1&nbsp;(add-lists&nbsp;ones&nbsp;integers)))<br>\n<i>;;;&nbsp;L-Eval&nbsp;input:</i><br>\n(list-ref&nbsp;integers&nbsp;17)<br>\n<i>;;;&nbsp;L-Eval&nbsp;value:</i><br>\n<i>18</i><br>\n</tt><p><p><p>\n\n\nNote that these lazy lists are even lazier than the streams of\nchapter&nbsp;3:  The <tt>car</tt> of the list, as well as the <tt>cdr</tt>, is\ndelayed.<a name="call_footnote_Temp_594" href="#footnote_Temp_594"><sup><small>41</small></sup></a>\nIn fact, even accessing the <tt>car</tt> or <tt>cdr</tt> of a lazy\npair need not force the value of a list element.  The value will be\nforced only when it is really needed -- e.g., for use as the\nargument of a primitive, or to be printed as an answer.<p>\n\nLazy pairs also help with the problem that arose with streams in\nsection&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.4">3.5.4</a>, where we found that\nformulating stream models of systems with loops may require us to\nsprinkle our programs with <a name="%_idx_4798"></a><a name="%_idx_4800"></a>explicit <tt>delay</tt> operations, beyond the\nones supplied by <tt>cons-stream</tt>.  With lazy evaluation, all\narguments to procedures are delayed uniformly.  For instance, we can\nimplement procedures to integrate lists and solve differential\nequations as we originally intended in\nsection&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.4">3.5.4</a>:<p>\n\n<p><p><tt><a name="%_idx_4802"></a>(define&nbsp;(integral&nbsp;integrand&nbsp;initial-value&nbsp;dt)<br>\n&nbsp;&nbsp;(define&nbsp;int<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;initial-value<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-lists&nbsp;(scale-list&nbsp;integrand&nbsp;dt)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int)))<br>\n&nbsp;&nbsp;int)<br>\n<a name="%_idx_4804"></a>(define&nbsp;(solve&nbsp;f&nbsp;y0&nbsp;dt)<br>\n&nbsp;&nbsp;(define&nbsp;y&nbsp;(integral&nbsp;dy&nbsp;y0&nbsp;dt))<br>\n&nbsp;&nbsp;(define&nbsp;dy&nbsp;(map&nbsp;f&nbsp;y))<br>\n&nbsp;&nbsp;y)<br>\n<i>;;;&nbsp;L-Eval&nbsp;input:</i><br>\n(list-ref&nbsp;(solve&nbsp;(lambda&nbsp;(x)&nbsp;x)&nbsp;1&nbsp;0.001)&nbsp;1000)<br>\n<i>;;;&nbsp;L-Eval&nbsp;value:</i><br>\n<i>2.716924</i></tt><p><p><p>\n\n<p><a name="%_thm_4.32"></a>\n<b>Exercise 4.32.</b>&nbsp;&nbsp;Give some examples that illustrate the difference between the streams\nof chapter&nbsp;3 and the ``lazier\'\' lazy lists described in this section.\nHow can you take advantage of this extra laziness?\n<p><p>\n\n<p><a name="%_thm_4.33"></a>\n<b>Exercise 4.33.</b>&nbsp;&nbsp;Ben Bitdiddle tests the lazy list implementation given above by\nevaluating the expression\n<p><p><tt>(car&nbsp;\'(a&nbsp;b&nbsp;c))<br>\n</tt><p><p>\nTo his surprise, this produces an error.  After some thought, he\nrealizes that the ``lists\'\' obtained by reading in quoted expressions\nare different from the lists manipulated by the new definitions of\n<tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt>.  Modify the evaluator\'s\ntreatment of quoted expressions so that quoted lists typed at the\ndriver loop will produce true lazy lists.\n\n<p><p>\n\n<p><a name="%_thm_4.34"></a>\n<b>Exercise 4.34.</b>&nbsp;&nbsp;Modify the driver loop for the evaluator so that lazy pairs and lists\nwill print in some reasonable way.  (What are you going to do about\ninfinite lists?)  You may also need to modify the representation of\nlazy pairs so that the evaluator can identify them in order\nto print them.\n\n<p><p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_575" href="#call_footnote_Temp_575"><sup><small>31</small></sup></a> Snarf: ``To grab, especially a large document or\n<a name="%_idx_4674"></a><a name="%_idx_4676"></a><a name="%_idx_4678"></a>file for the purpose of using it either with or without the owner\'s\npermission.\'\'  Snarf down: ``To snarf, sometimes with the connotation\nof absorbing, processing, or understanding.\'\'  (These definitions were\nsnarfed from Steele et al. 1983.  See also Raymond 1993.)\n\n<p><a name="footnote_Temp_576" href="#call_footnote_Temp_576"><sup><small>32</small></sup></a> The difference between the ``lazy\'\' terminology and\nthe ``normal-order\'\' terminology is somewhat fuzzy.  Generally, ``lazy\'\'\nrefers to the mechanisms of particular evaluators, while ``normal-order\'\'\nrefers to the semantics of languages, independent of any particular\nevaluation strategy.  But this is not a hard-and-fast distinction, and\nthe two terminologies are often used interchangeably.\n\n<p><a name="footnote_Temp_577" href="#call_footnote_Temp_577"><sup><small>33</small></sup></a> The ``strict\'\' versus ``non-strict\'\' terminology means essentially the\nsame thing as ``applicative-order\'\' versus ``normal-order,\'\' except that\nit refers to individual procedures and arguments rather than to the\nlanguage as a whole.  At a conference on programming languages you\nmight hear someone say, ``The normal-order language <a name="%_idx_4690"></a>Hassle has certain\nstrict primitives.  Other procedures take their arguments by lazy\nevaluation.\'\'\n\n<p><a name="footnote_Temp_580" href="#call_footnote_Temp_580"><sup><small>34</small></sup></a> The word <em>thunk</em> was invented by an informal\n<a name="%_idx_4698"></a><a name="%_idx_4700"></a><a name="%_idx_4702"></a>working group that was discussing the implementation of call-by-name\nin Algol 60.  They observed that most of the analysis of (``thinking\nabout\'\') the expression could be done at compile time; thus, at run\ntime, the expression would already have been ``thunk\'\' about (Ingerman\net al. 1960).\n\n<p><a name="footnote_Temp_581" href="#call_footnote_Temp_581"><sup><small>35</small></sup></a> This is analogous to the use of <tt>force</tt>\n<a name="%_idx_4708"></a>on the delayed objects that were introduced in chapter&nbsp;3 to represent\nstreams.  The critical difference between what we are\ndoing here and what we did in chapter&nbsp;3 is that we are building\ndelaying and forcing into the evaluator, and thus making this uniform\nand automatic throughout the language.\n\n<p><a name="footnote_Temp_582" href="#call_footnote_Temp_582"><sup><small>36</small></sup></a> Lazy evaluation combined with memoization is sometimes\n<a name="%_idx_4712"></a>referred to as <em>call-by-need</em> argument passing, in contrast to\n<em>call-by-name</em> argument passing.  <a name="%_idx_4714"></a><a name="%_idx_4716"></a>(Call-by-name, introduced in\nAlgol 60, is similar to non-memoized lazy evaluation.)\nAs language designers, we can build our evaluator to memoize,\nnot to memoize, or leave this an option for programmers\n(exercise&nbsp;<a href="#%_thm_4.31">4.31</a>).  As you might expect\nfrom chapter&nbsp;3, these choices raise issues that become both subtle and\nconfusing in the presence of assignments.  (See\nexercises&nbsp;<a href="#%_thm_4.27">4.27</a> and&nbsp;<a href="#%_thm_4.29">4.29</a>.)\n<a name="%_idx_4718"></a>An excellent article by Clinger (1982) attempts to clarify the\nmultiple dimensions of confusion that arise here.\n\n<p><a name="footnote_Temp_585" href="#call_footnote_Temp_585"><sup><small>37</small></sup></a> Notice that we also erase the <tt>env</tt> from the thunk once the\nexpression\'s value has been computed.  This makes no difference in the\nvalues returned by the interpreter.  It does help save space,\nhowever, because removing the reference from the thunk to the <tt>env</tt>\nonce it is no longer needed allows this structure to be\n<a name="%_idx_4744"></a><a name="%_idx_4746"></a><em>garbage-collected</em> and its\nspace recycled, as we will discuss in section&nbsp;<a href="book-Z-H-33.html#%_sec_5.3">5.3</a>.<p>\n\nSimilarly, we could have allowed unneeded environments in the memoized\ndelayed objects of section&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.1">3.5.1</a> to be garbage-collected,\nby having <tt>memo-proc</tt> do something like <tt>(set! proc \'())</tt>\nto discard the procedure <tt>proc</tt> (which includes the environment\nin which the <tt>delay</tt> was evaluated) after storing its value.\n\n<p><a name="footnote_Temp_587" href="#call_footnote_Temp_587"><sup><small>38</small></sup></a> This exercise\ndemonstrates that the interaction between lazy evaluation and side\neffects can be very confusing.  This is just what you might expect\nfrom the discussion in chapter&nbsp;3.\n\n<p><a name="footnote_Temp_592" href="#call_footnote_Temp_592"><sup><small>39</small></sup></a> This is precisely the issue with the <tt>unless</tt> procedure,\nas in exercise&nbsp;<a href="#%_thm_4.26">4.26</a>.\n\n<p><a name="footnote_Temp_593" href="#call_footnote_Temp_593"><sup><small>40</small></sup></a> This is the procedural representation described in\nexercise&nbsp;<a href="book-Z-H-14.html#%_thm_2.4">2.4</a>.  Essentially any procedural representation\n(e.g., a message-passing implementation) would do as well.  Notice\nthat we can install these definitions in the lazy evaluator simply by\ntyping them at the driver loop.  If we had originally included <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> as primitives in the global\nenvironment, they will be redefined.  (Also see\nexercises&nbsp;<a href="#%_thm_4.33">4.33</a> and&nbsp;<a href="#%_thm_4.34">4.34</a>.)\n\n<p><a name="footnote_Temp_594" href="#call_footnote_Temp_594"><sup><small>41</small></sup></a> This permits us to create delayed versions of more general kinds of\n<a name="%_idx_4792"></a>list structures, not just sequences.  Hughes 1990 discusses some\n<a name="%_idx_4794"></a><a name="%_idx_4796"></a>applications of ``lazy trees.\'\'\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_4.3"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_4.3">4.3&nbsp;&nbsp;Variations on a Scheme -- Nondeterministic Computing</a></h2><p>\n\n\n<a name="%_idx_4806"></a>\n<a name="%_idx_4808"></a>In this section, we extend the Scheme evaluator to support a\nprogramming paradigm called <em>nondeterministic computing</em> by\nbuilding into the evaluator a facility to support automatic search.\nThis is a much more profound change to the language than the\nintroduction of lazy evaluation in section&nbsp;<a href="book-Z-H-27.html#%_sec_4.2">4.2</a>.<p>\n\n<a name="%_idx_4810"></a>Nondeterministic computing, like stream processing, is useful for\n``generate and test\'\' applications.  Consider the task of starting with\ntwo lists of positive integers and finding a pair of integers -- one\nfrom the first list and one from the second list -- whose sum is prime.\nWe saw how to handle this with finite sequence operations in\nsection&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a> and with infinite streams in\nsection&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.3">3.5.3</a>.  Our approach was to generate\nthe sequence of all possible pairs and filter these to select the\npairs whose sum is prime.  Whether we actually generate the entire\nsequence of pairs first as in chapter&nbsp;2, or interleave the generating\nand filtering as in chapter&nbsp;3, is immaterial to the essential image of\nhow the computation is organized.<p>\n\n<a name="%_idx_4812"></a>The nondeterministic approach evokes a different image.  Imagine simply\nthat we choose (in some way) a number from the first list and a number\nfrom the second list and require (using some mechanism) that their sum\nbe prime.  This is expressed by following procedure:<p>\n\n<p><p><tt><a name="%_idx_4814"></a>(define&nbsp;(prime-sum-pair&nbsp;list1&nbsp;list2)<br>\n&nbsp;&nbsp;(let&nbsp;((a&nbsp;(an-element-of&nbsp;list1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b&nbsp;(an-element-of&nbsp;list2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(prime?&nbsp;(+&nbsp;a&nbsp;b)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;a&nbsp;b)))<br>\n</tt><p><p>\nIt might seem as if this procedure merely restates the problem,\nrather than specifying a way to solve it.  Nevertheless, this is\na legitimate nondeterministic program.<a name="call_footnote_Temp_598" href="#footnote_Temp_598"><sup><small>42</small></sup></a><p>\n\n\nThe key idea here is that expressions in a nondeterministic language\ncan have more than one possible value.  For instance,\n<tt>an-element-of</tt> might return any element of the given list.  Our\nnondeterministic program evaluator will work by automatically choosing\na possible value and keeping track of the choice.  If a subsequent\nrequirement is not met, the evaluator will try a different choice, and\nit will keep trying new choices until the evaluation succeeds, or\nuntil we run out of choices.  Just as the lazy evaluator freed the\nprogrammer from the details of how values are delayed and forced, the\nnondeterministic program evaluator will free the programmer from the\ndetails of how choices are made.<p>\n\n<a name="%_idx_4820"></a>It is instructive to contrast the different images of time evoked by\nnondeterministic evaluation and stream processing.  Stream processing\nuses lazy evaluation to decouple the time when the stream of possible\nanswers is assembled from the time when the actual stream elements are\nproduced.  The evaluator supports the illusion that all the possible\nanswers are laid out before us in a timeless sequence.  With\nnondeterministic evaluation, an expression represents the exploration\nof a set of possible worlds, each determined by a set of choices.\nSome of the possible worlds lead to dead ends, while others have\nuseful values.  The nondeterministic program evaluator supports the\nillusion that time branches, and that our programs have different\npossible execution histories.  When we reach a dead end, we can\nrevisit a previous choice point and proceed along a different branch.<p>\n\nThe nondeterministic program evaluator implemented below is called the\n<tt>amb</tt> evaluator because it is based on a new special form called\n<tt>amb</tt>.  We can type the above definition of <tt>prime-sum-pair</tt>\nat the <tt>amb</tt> evaluator driver loop (along with definitions of <tt>prime?</tt>, <tt>an-element-of</tt>, and <tt>require</tt>) and run the\nprocedure as follows:<p>\n\n<p><p><tt><i>;;;&nbsp;Amb-Eval&nbsp;input:</i><br>\n(prime-sum-pair&nbsp;\'(1&nbsp;3&nbsp;5&nbsp;8)&nbsp;\'(20&nbsp;35&nbsp;110))<br>\n<i>;;;&nbsp;Starting&nbsp;a&nbsp;new&nbsp;problem</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;value:</i><br>\n<i>(3&nbsp;20)</i><br>\n</tt><p><p>\nThe value returned was obtained after the evaluator repeatedly chose\nelements from each of the lists, until a successful choice was made.<p>\n\nSection&nbsp;<a href="#%_sec_4.3.1">4.3.1</a> introduces <tt>amb</tt> and explains how it\nsupports nondeterminism through the evaluator\'s automatic search\nmechanism.  Section <a href="#%_sec_4.3.2">4.3.2</a> presents examples of\nnondeterministic programs, and section&nbsp;<a href="#%_sec_4.3.3">4.3.3</a>\ngives the details of how to implement the <tt>amb</tt> evaluator by\nmodifying the ordinary Scheme evaluator.<p>\n\n<a name="%_sec_4.3.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.3.1">4.3.1&nbsp;&nbsp;Amb and Search</a></h3><p>\n\n<p>\n\n<a name="%_idx_4822"></a>To extend Scheme to support nondeterminism, we introduce a new special\nform called <tt>amb</tt>.<a name="call_footnote_Temp_599" href="#footnote_Temp_599"><sup><small>43</small></sup></a>\nThe expression <tt>(amb &lt;<em><em>e</em><sub>1</sub></em>&gt; &lt;<em><em>e</em><sub>2</sub></em>&gt; <tt>...</tt> &lt;<em><em>e</em><sub><em>n</em></sub></em>&gt;)</tt>\nreturns the value of one of the <em>n</em> expressions &lt;<em><em>e</em><sub><em>i</em></sub></em>&gt; ``ambiguously.\'\'\nFor example, the expression<p>\n\n<p><p><tt>(list&nbsp;(amb&nbsp;1&nbsp;2&nbsp;3)&nbsp;(amb&nbsp;\'a&nbsp;\'b))<br>\n</tt><p><p>\ncan have six possible values:\n<table border=0><tr><td valign=top ><tt>(1 a) </tt></td><td valign=top ><tt>(1 b) </tt></td><td valign=top ><tt>(2 a) </tt></td><td valign=top ><tt>(2 b) </tt></td><td valign=top ><tt>(3 a) </tt></td><td valign=top ><tt>(3 b)\n</tt></td></tr></table>\n<tt>Amb</tt> with a single choice produces an ordinary (single) value.<p>\n\n<a name="%_idx_4826"></a><tt>Amb</tt> with no choices -- the expression <tt>(amb)</tt> -- is an\nexpression with no acceptable values.  Operationally, we can think of\n<tt>(amb)</tt> as an expression that when evaluated causes the\ncomputation to ``fail\'\': The computation aborts and no value is\nproduced.  Using this idea, we can express the requirement that a\nparticular predicate expression <tt>p</tt> must be true as follows:<p>\n\n<p><p><tt><a name="%_idx_4828"></a>(define&nbsp;(require&nbsp;p)<br>\n&nbsp;&nbsp;(if&nbsp;(not&nbsp;p)&nbsp;(amb)))<br>\n</tt><p><p><p>\n\nWith <tt>amb</tt> and <tt>require</tt>, we can implement the <tt>an-element-of</tt> procedure used above:<p>\n\n<p><p><tt><a name="%_idx_4830"></a>(define&nbsp;(an-element-of&nbsp;items)<br>\n&nbsp;&nbsp;(require&nbsp;(not&nbsp;(null?&nbsp;items)))<br>\n&nbsp;&nbsp;(amb&nbsp;(car&nbsp;items)&nbsp;(an-element-of&nbsp;(cdr&nbsp;items))))<br>\n</tt><p><p>\n<tt>An-element-of</tt> fails if the list is empty.  Otherwise it\nambiguously returns either the first element of the list or an element\nchosen from the rest of the list.<p>\n\nWe can also express infinite ranges of choices.  The following\nprocedure potentially returns any integer greater than or equal to\nsome given&nbsp;<em>n</em>:<p>\n\n<p><p><tt><a name="%_idx_4832"></a>(define&nbsp;(an-integer-starting-from&nbsp;n)<br>\n&nbsp;&nbsp;(amb&nbsp;n&nbsp;(an-integer-starting-from&nbsp;(+&nbsp;n&nbsp;1))))<br>\n</tt><p><p>\nThis is like the stream procedure <tt>integers-starting-from</tt>\ndescribed in section&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.2">3.5.2</a>, but with an important\ndifference: The stream procedure returns an object that represents the\nsequence of all integers beginning with <em>n</em>, whereas the <tt>amb</tt>\nprocedure returns a single integer.<a name="call_footnote_Temp_600" href="#footnote_Temp_600"><sup><small>44</small></sup></a><p>\n\n<a name="%_idx_4834"></a>Abstractly, we can imagine that evaluating an <tt>amb</tt> expression\ncauses time to split into branches, where the computation continues on\neach branch with one of the possible values of the expression.  We say\nthat <tt>amb</tt> represents a <a name="%_idx_4836"></a><em>nondeterministic choice point</em>.\nIf we had a machine with a sufficient number of processors that could\nbe dynamically allocated, we could implement the search in a\nstraightforward way.  Execution would proceed as in a sequential\nmachine, until an <tt>amb</tt> expression is encountered.  At this point,\nmore processors would be allocated and initialized to continue all of\nthe parallel executions implied by the choice.  Each processor would\nproceed sequentially as if it were the only choice, until it either\nterminates by encountering a failure, or it further subdivides, or\nit finishes.<a name="call_footnote_Temp_601" href="#footnote_Temp_601"><sup><small>45</small></sup></a><p>\n\n<a name="%_idx_4840"></a>On the other hand, if we have a machine that can execute\nonly one process (or a few concurrent processes),\nwe must consider the alternatives sequentially.\nOne could imagine modifying an evaluator\nto pick at random a branch to follow whenever it encounters a choice\npoint.  Random choice, however, can easily lead to failing values.\nWe might try running the evaluator over and over, making random\nchoices and hoping to find a non-failing value, but it is better to <a name="%_idx_4842"></a><a name="%_idx_4844"></a><em>systematically search</em> all possible execution paths.\nThe <tt>amb</tt> evaluator that we will develop and work with in this section\nimplements a systematic search as follows: When the evaluator\nencounters an application of <tt>amb</tt>, it initially selects the first\nalternative.  This selection may itself lead to a further choice.  The\nevaluator will always initially choose the first alternative at each\nchoice point.  If a choice results in a failure, then the evaluator\n<a name="%_idx_4846"></a><a name="%_idx_4848"></a><a name="%_idx_4850"></a>automagically<a name="call_footnote_Temp_602" href="#footnote_Temp_602"><sup><small>46</small></sup></a> <a name="%_idx_4852"></a><em>backtracks</em>\nto the most recent choice point and tries the next\nalternative.  If it runs out of alternatives at any choice point, the\nevaluator will back up to the previous choice point and resume from\nthere.  This process leads to a search strategy known as <a name="%_idx_4854"></a><a name="%_idx_4856"></a><a name="%_idx_4858"></a><em>depth-first search</em> or <em>chronological backtracking</em>.<a name="call_footnote_Temp_603" href="#footnote_Temp_603"><sup><small>47</small></sup></a><p>\n\n<a name="%_sec_Temp_604"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_604">Driver loop</a></h4><p>\n\n<a name="%_idx_4908"></a>The driver loop for the <tt>amb</tt> evaluator\nhas some unusual properties.  It reads an\nexpression and prints the value of the first non-failing execution, as\nin the <tt>prime-sum-pair</tt> example shown above.  If we\nwant to see the value of the next successful execution, we can\nask the interpreter to backtrack and attempt to generate a second\nnon-failing execution.  This is signaled by typing the symbol <a name="%_idx_4910"></a><tt>try-again</tt>.  If any expression except <tt>try-again</tt> is given, the\ninterpreter will start a new problem, discarding the unexplored\nalternatives in the previous problem.  Here is a sample\ninteraction:<p>\n\n<p><p><tt><i>;;;&nbsp;Amb-Eval&nbsp;input:</i><br>\n(prime-sum-pair&nbsp;\'(1&nbsp;3&nbsp;5&nbsp;8)&nbsp;\'(20&nbsp;35&nbsp;110))<br>\n<i>;;;&nbsp;Starting&nbsp;a&nbsp;new&nbsp;problem</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;value:</i><br>\n<i>(3&nbsp;20)</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;input:</i><br>\ntry-again<br>\n<i>;;;&nbsp;Amb-Eval&nbsp;value:</i><br>\n<i>(3&nbsp;110)</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;input:</i><br>\ntry-again<br>\n<i>;;;&nbsp;Amb-Eval&nbsp;value:</i><br>\n<i>(8&nbsp;35)</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;input:</i><br>\ntry-again<br>\n<i>;;;&nbsp;There&nbsp;are&nbsp;no&nbsp;more&nbsp;values&nbsp;of</i><br>\n<i>(prime-sum-pair&nbsp;(quote&nbsp;(1&nbsp;3&nbsp;5&nbsp;8))&nbsp;(quote&nbsp;(20&nbsp;35&nbsp;110)))</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;input:</i><br>\n(prime-sum-pair&nbsp;\'(19&nbsp;27&nbsp;30)&nbsp;\'(11&nbsp;36&nbsp;58))<br>\n<i>;;;&nbsp;Starting&nbsp;a&nbsp;new&nbsp;problem</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;value:</i><br>\n<i>(30&nbsp;11)</i><br>\n</tt><p><p><p>\n\n<p><a name="%_thm_4.35"></a>\n<b>Exercise 4.35.</b>&nbsp;&nbsp;<a name="%_idx_4912"></a><a name="%_idx_4914"></a>Write a procedure <tt>an-integer-between</tt> that returns an integer\nbetween two given bounds.  This can be used to implement a\nprocedure that finds Pythagorean triples,\ni.e., triples of integers (<em>i</em>,<em>j</em>,<em>k</em>) between the given bounds such\nthat <em>i</em> <u>&lt;</u> <em>j</em> and <em>i</em><sup>2</sup>  +  <em>j</em><sup>2</sup>  = <em>k</em><sup>2</sup>, as follows:\n<p><p><tt>(define&nbsp;(a-pythagorean-triple-between&nbsp;low&nbsp;high)<br>\n&nbsp;&nbsp;(let&nbsp;((i&nbsp;(an-integer-between&nbsp;low&nbsp;high)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((j&nbsp;(an-integer-between&nbsp;i&nbsp;high)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((k&nbsp;(an-integer-between&nbsp;j&nbsp;high)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(=&nbsp;(+&nbsp;(*&nbsp;i&nbsp;i)&nbsp;(*&nbsp;j&nbsp;j))&nbsp;(*&nbsp;k&nbsp;k)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;i&nbsp;j&nbsp;k)))))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_4.36"></a>\n<b>Exercise 4.36.</b>&nbsp;&nbsp;<a name="%_idx_4916"></a><a name="%_idx_4918"></a>Exercise&nbsp;<a href="book-Z-H-24.html#%_thm_3.69">3.69</a> discussed how to generate\nthe stream of <em>all</em> Pythagorean triples, with no upper bound on the\nsize of the integers to be searched.  Explain why simply replacing\n<tt>an-integer-between</tt> by <tt>an-integer-starting-from</tt> in the procedure in\nexercise&nbsp;<a href="#%_thm_4.35">4.35</a> is not an adequate way to\ngenerate arbitrary Pythagorean triples.  Write a procedure that\nactually will accomplish this.  (That is, write a procedure for which\nrepeatedly typing <tt>try-again</tt> would in principle eventually\ngenerate all Pythagorean triples.)\n<p><p>\n\n<p><a name="%_thm_4.37"></a>\n<b>Exercise 4.37.</b>&nbsp;&nbsp;<a name="%_idx_4920"></a><a name="%_idx_4922"></a>Ben Bitdiddle claims that the following method for generating\nPythagorean triples is more efficient than the one in\nexercise&nbsp;<a href="#%_thm_4.35">4.35</a>.  Is he correct?  (Hint: Consider\nthe number of possibilities that must be explored.)<p>\n\n<p><p><tt>(define&nbsp;(a-pythagorean-triple-between&nbsp;low&nbsp;high)<br>\n&nbsp;&nbsp;(let&nbsp;((i&nbsp;(an-integer-between&nbsp;low&nbsp;high))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(hsq&nbsp;(*&nbsp;high&nbsp;high)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((j&nbsp;(an-integer-between&nbsp;i&nbsp;high)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((ksq&nbsp;(+&nbsp;(*&nbsp;i&nbsp;i)&nbsp;(*&nbsp;j&nbsp;j))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(&gt;=&nbsp;hsq&nbsp;ksq))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((k&nbsp;(sqrt&nbsp;ksq)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(integer?&nbsp;k))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;i&nbsp;j&nbsp;k))))))<br>\n</tt><p><p>\n<p><p>\n\n<a name="%_sec_4.3.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.3.2">4.3.2&nbsp;&nbsp;Examples of Nondeterministic Programs</a></h3><p>\n\n<p>\n\nSection&nbsp;<a href="#%_sec_4.3.3">4.3.3</a> describes the implementation of\nthe <tt>amb</tt> evaluator.  First, however, we give some examples of how\nit can be used.  The advantage of nondeterministic programming is that\nwe can suppress the details of how search is carried out, thereby\n<a name="%_idx_4924"></a>expressing our programs at a higher level of abstraction.<p>\n\n<a name="%_sec_Temp_608"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_608">Logic Puzzles</a></h4><p>\n\n<a name="%_idx_4926"></a><a name="%_idx_4928"></a><a name="%_idx_4930"></a>\n<a name="%_idx_4932"></a>The following puzzle (taken from Dinesman 1968) is typical of a large\nclass of simple logic puzzles:<p>\n\n<blockquote>\nBaker, Cooper, Fletcher, Miller, and Smith live on different floors of\nan apartment house that contains only five floors.  Baker does not\nlive on the top floor.  Cooper does not live on the bottom floor.\nFletcher does not live on either the top or the bottom floor.  Miller\nlives on a higher floor than does Cooper.  Smith does not live on a\nfloor adjacent to Fletcher\'s.  Fletcher does not live on a floor\nadjacent to Cooper\'s.  Where does everyone live?\n</blockquote><p>\n\nWe can determine who lives on each floor in a straightforward way by\nenumerating all the possibilities and imposing the given\nrestrictions:<a name="call_footnote_Temp_609" href="#footnote_Temp_609"><sup><small>48</small></sup></a><p>\n\n\n<p><p><tt><a name="%_idx_4938"></a>(define&nbsp;(multiple-dwelling)<br>\n&nbsp;&nbsp;(let&nbsp;((baker&nbsp;(amb&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cooper&nbsp;(amb&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fletcher&nbsp;(amb&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(miller&nbsp;(amb&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(smith&nbsp;(amb&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(require<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(distinct?&nbsp;(list&nbsp;baker&nbsp;cooper&nbsp;fletcher&nbsp;miller&nbsp;smith)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(not&nbsp;(=&nbsp;baker&nbsp;5)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(not&nbsp;(=&nbsp;cooper&nbsp;1)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(not&nbsp;(=&nbsp;fletcher&nbsp;5)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(not&nbsp;(=&nbsp;fletcher&nbsp;1)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(&gt;&nbsp;miller&nbsp;cooper))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(not&nbsp;(=&nbsp;(abs&nbsp;(-&nbsp;smith&nbsp;fletcher))&nbsp;1)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(not&nbsp;(=&nbsp;(abs&nbsp;(-&nbsp;fletcher&nbsp;cooper))&nbsp;1)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(list&nbsp;\'baker&nbsp;baker)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;\'cooper&nbsp;cooper)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;\'fletcher&nbsp;fletcher)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;\'miller&nbsp;miller)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;\'smith&nbsp;smith))))<br>\n</tt><p><p><p>\n\n\nEvaluating the expression <tt>(multiple-dwelling)</tt> produces the\nresult\n\n<p><p><tt>((baker&nbsp;3)&nbsp;(cooper&nbsp;2)&nbsp;(fletcher&nbsp;4)&nbsp;(miller&nbsp;5)&nbsp;(smith&nbsp;1))<br>\n</tt><p><p>\nAlthough this simple procedure works, it is very slow.\nExercises&nbsp;<a href="#%_thm_4.39">4.39</a>\nand&nbsp;<a href="#%_thm_4.40">4.40</a> discuss some possible\nimprovements.<p>\n\n<p><a name="%_thm_4.38"></a>\n<b>Exercise 4.38.</b>&nbsp;&nbsp;Modify the multiple-dwelling procedure to omit the requirement that\nSmith and Fletcher do not live on adjacent floors.  How many solutions\nare there to this modified puzzle?\n<p><p>\n\n<p><a name="%_thm_4.39"></a>\n<b>Exercise 4.39.</b>&nbsp;&nbsp;Does the order of the restrictions in the multiple-dwelling procedure\naffect the answer? Does it affect the time to find an answer?  If you\nthink it matters, demonstrate a faster program obtained from the given\none by reordering the restrictions.  If you think it does not matter,\nargue your case.\n\n<p><p>\n\n<p><a name="%_thm_4.40"></a>\n<b>Exercise 4.40.</b>&nbsp;&nbsp;In the multiple dwelling problem, how many sets of assignments are\nthere of people to floors, both before and after the requirement that\nfloor assignments be distinct?  It is very inefficient to generate all\npossible assignments of people to floors and then leave it to\nbacktracking to eliminate them.  For example, most of the restrictions\ndepend on only one or two of the person-floor variables, and can thus\nbe imposed before floors have been selected for all the people.\nWrite and demonstrate a much more efficient\nnondeterministic procedure that solves this problem based upon\ngenerating only those possibilities that are not already ruled out by\nprevious restrictions.  (Hint: This will require a nest of <tt>let</tt>\nexpressions.)\n\n<p><p>\n\n<p><a name="%_thm_4.41"></a>\n<b>Exercise 4.41.</b>&nbsp;&nbsp;<a name="%_idx_4940"></a>Write an ordinary Scheme program to solve the multiple dwelling puzzle.\n<p><p>\n\n<p><a name="%_thm_4.42"></a>\n<b>Exercise 4.42.</b>&nbsp;&nbsp;<a name="%_idx_4942"></a>Solve the following ``Liars\'\' puzzle (from Phillips 1934):\n<blockquote>\nFive schoolgirls sat for an examination.  Their parents -- so they\nthought -- showed an undue degree of interest in the result.  They\ntherefore agreed that, in writing home about the examination, each \ngirl should make one true statement and one untrue one.  The following\nare the relevant passages from their letters:\n<p><ul>\n<li>Betty: ``Kitty was second in the examination.  I was only third.\'\'\n<li>Ethel: ``You\'ll be glad to hear that I was on top.  Joan was second.\'\'\n<li>Joan: ``I was third, and poor old Ethel was bottom.\'\'\n<li>Kitty: ``I came out second.  Mary was only fourth.\'\'\n<li>Mary: ``I was fourth.  Top place was taken by Betty.\'\'\n</ul><p>\nWhat in fact was the order in which the five girls were placed?\n</blockquote>\n<p><p>\n\n<p><a name="%_thm_4.43"></a>\n<b>Exercise 4.43.</b>&nbsp;&nbsp;Use the <tt>amb</tt> evaluator to solve the following puzzle:<a name="call_footnote_Temp_616" href="#footnote_Temp_616"><sup><small>49</small></sup></a>\n<blockquote>\nMary Ann Moore\'s father has a yacht and so has each of his four\nfriends:  Colonel Downing, Mr. Hall, Sir Barnacle Hood, and Dr.\nParker.  Each of the five also has one daughter and each has named his\nyacht after a daughter of one of the others.  Sir Barnacle\'s yacht is\nthe Gabrielle, Mr. Moore owns the Lorna; Mr. Hall the Rosalind.  The\nMelissa, owned by Colonel Downing, is named after Sir Barnacle\'s\ndaughter.  Gabrielle\'s father owns the yacht that is named after Dr.\nParker\'s daughter.  Who is Lorna\'s father?\n</blockquote>\nTry to write the program so that it runs efficiently (see\nexercise&nbsp;<a href="#%_thm_4.40">4.40</a>).  Also determine how many\nsolutions there are if we are not told that Mary Ann\'s last name is\nMoore.\n<p><p>\n\n<p><a name="%_thm_4.44"></a>\n<b>Exercise 4.44.</b>&nbsp;&nbsp;<a name="%_idx_4944"></a><a name="%_idx_4946"></a><a name="%_idx_4948"></a><a name="%_idx_4950"></a>Exercise&nbsp;<a href="book-Z-H-15.html#%_thm_2.42">2.42</a> described the ``eight-queens puzzle\'\' of\nplacing queens on a chessboard so that no two attack each other.\nWrite a nondeterministic program to solve this puzzle.\n<p><p>\n\n<a name="%_sec_Temp_618"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_618">Parsing natural language</a></h4><p>\n\n<a name="%_idx_4952"></a><a name="%_idx_4954"></a>\nPrograms designed to accept natural language as input usually start by\nattempting to <em>parse</em> the input, that is, to match the input\nagainst some grammatical structure.  For example, we might try to\nrecognize simple sentences consisting of an article followed by a noun\nfollowed by a verb, such as ``The cat eats.\'\'  To accomplish such an\nanalysis, we must be able to identify the parts of speech of\nindividual words.  We could start with some lists that classify\nvarious words:<a name="call_footnote_Temp_619" href="#footnote_Temp_619"><sup><small>50</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_4956"></a>(define&nbsp;nouns&nbsp;\'(noun&nbsp;student&nbsp;professor&nbsp;cat&nbsp;class))<br>\n<a name="%_idx_4958"></a>(define&nbsp;verbs&nbsp;\'(verb&nbsp;studies&nbsp;lectures&nbsp;eats&nbsp;sleeps))<br>\n<a name="%_idx_4960"></a>(define&nbsp;articles&nbsp;\'(article&nbsp;the&nbsp;a))<br>\n</tt><p><p>\n<a name="%_idx_4962"></a>We also need a <em>grammar</em>, that is, a set of rules describing how\ngrammatical elements are composed from simpler elements.  A very\nsimple grammar might stipulate that a sentence always consists of two\npieces -- a noun phrase followed by a verb -- and that a noun phrase\nconsists of an article followed by a noun.  With this grammar, the\nsentence ``The cat eats\'\' is parsed as follows:<p>\n\n<p><p><tt>(sentence&nbsp;(noun-phrase&nbsp;(article&nbsp;the)&nbsp;(noun&nbsp;cat))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(verb&nbsp;eats))<br>\n</tt><p><p><p>\n\nWe can generate such a parse with a simple program that has separate\nprocedures for each of the grammatical rules.  To parse a sentence, we\nidentify its two constituent pieces and return a list of\nthese two elements, tagged with the symbol <tt>sentence</tt>:<p>\n\n<a name="%_idx_4964"></a><p><p><tt>(define&nbsp;(parse-sentence)<br>\n&nbsp;&nbsp;(list&nbsp;\'sentence<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-noun-phrase)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-word&nbsp;verbs)))<br>\n</tt><p><p>\nA noun phrase, similarly, is parsed by finding an article followed by a\nnoun:\n<p><p><tt>(define&nbsp;(parse-noun-phrase)<br>\n&nbsp;&nbsp;(list&nbsp;\'noun-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-word&nbsp;articles)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-word&nbsp;nouns)))<br>\n</tt><p><p><p>\n\nAt the lowest level, parsing boils down to repeatedly checking that\nthe next unparsed word is a member of the list of words for the\nrequired part of speech.  To implement this, we maintain a global\nvariable <tt>*unparsed*</tt>, which is the input that has not yet been\nparsed.  Each time we check a word, we require that <tt>*unparsed*</tt>\nmust be non-empty and that it should begin with a word from the\ndesignated list.  If so, we remove that word from <tt>*unparsed*</tt> and\nreturn the word together with its part of speech (which is found at\nthe head of the list):<a name="call_footnote_Temp_620" href="#footnote_Temp_620"><sup><small>51</small></sup></a><p>\n\n<p><p><tt>(define&nbsp;(parse-word&nbsp;word-list)<br>\n&nbsp;&nbsp;(require&nbsp;(not&nbsp;(null?&nbsp;*unparsed*)))<br>\n&nbsp;&nbsp;(require&nbsp;(memq&nbsp;(car&nbsp;*unparsed*)&nbsp;(cdr&nbsp;word-list)))<br>\n&nbsp;&nbsp;(let&nbsp;((found-word&nbsp;(car&nbsp;*unparsed*)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;*unparsed*&nbsp;(cdr&nbsp;*unparsed*))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(car&nbsp;word-list)&nbsp;found-word)))<br>\n</tt><p><p><p>\n\nTo start the parsing, all we need to do is set <tt>*unparsed*</tt> to be\nthe entire input, try to parse a sentence, and check that nothing is\nleft over:<p>\n\n<p><p><tt>(define&nbsp;*unparsed*&nbsp;\'())<br>\n<a name="%_idx_4966"></a>(define&nbsp;(parse&nbsp;input)<br>\n&nbsp;&nbsp;(set!&nbsp;*unparsed*&nbsp;input)<br>\n&nbsp;&nbsp;(let&nbsp;((sent&nbsp;(parse-sentence)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(null?&nbsp;*unparsed*))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;sent))<br>\n</tt><p><p><p>\n\nWe can now try the parser and verify that it works for our simple test\nsentence:<p>\n\n<p><p><tt><i>;;;&nbsp;Amb-Eval&nbsp;input:</i><br>\n(parse&nbsp;\'(the&nbsp;cat&nbsp;eats))<br>\n<i>;;;&nbsp;Starting&nbsp;a&nbsp;new&nbsp;problem</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;value:</i><br>\n<i>(sentence&nbsp;(noun-phrase&nbsp;(article&nbsp;the)&nbsp;(noun&nbsp;cat))&nbsp;(verb&nbsp;eats))</i><br>\n</tt><p><p><p>\n\nThe <tt>amb</tt> evaluator is useful here because it is convenient to\nexpress the parsing constraints with the aid of <tt>require</tt>.\nAutomatic search and backtracking really pay off, however, when we\nconsider more complex grammars where there are choices for how the\nunits can be decomposed.<p>\n\n\nLet\'s add to our grammar a list of prepositions:<p>\n\n<p><p><tt><a name="%_idx_4968"></a>(define&nbsp;prepositions&nbsp;\'(prep&nbsp;for&nbsp;to&nbsp;in&nbsp;by&nbsp;with))<br>\n</tt><p><p>\n\nand define a prepositional phrase (e.g., ``for the cat\'\') to be\na preposition followed by a noun phrase:<p>\n\n<p><p><tt>(define&nbsp;(parse-prepositional-phrase)<br>\n&nbsp;&nbsp;(list&nbsp;\'prep-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-word&nbsp;prepositions)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-noun-phrase)))<br>\n</tt><p><p>\nNow we can define a sentence to be a noun phrase followed by a verb\nphrase, where a verb phrase can be either a verb or a verb phrase\nextended by a prepositional phrase:<a name="call_footnote_Temp_621" href="#footnote_Temp_621"><sup><small>52</small></sup></a><p>\n\n<p><p><tt>(define&nbsp;(parse-sentence)<br>\n&nbsp;&nbsp;(list&nbsp;\'sentence<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-noun-phrase)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-verb-phrase)))<br>\n(define&nbsp;(parse-verb-phrase)<br>\n&nbsp;&nbsp;(define&nbsp;(maybe-extend&nbsp;verb-phrase)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(amb&nbsp;verb-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(maybe-extend&nbsp;(list&nbsp;\'verb-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verb-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-prepositional-phrase)))))<br>\n&nbsp;&nbsp;(maybe-extend&nbsp;(parse-word&nbsp;verbs)))<br>\n</tt><p><p><p>\n\nWhile we\'re at it, we can also elaborate the definition of noun\nphrases to permit such things as ``a cat in the class.\'\'  What we used\nto call a noun phrase, we\'ll now call a simple noun phrase, and a noun\nphrase will now be either a simple noun phrase or a noun phrase\nextended by a prepositional phrase:<p>\n\n<p><p><tt>(define&nbsp;(parse-simple-noun-phrase)<br>\n&nbsp;&nbsp;(list&nbsp;\'simple-noun-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-word&nbsp;articles)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-word&nbsp;nouns)))<br>\n(define&nbsp;(parse-noun-phrase)<br>\n&nbsp;&nbsp;(define&nbsp;(maybe-extend&nbsp;noun-phrase)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(amb&nbsp;noun-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(maybe-extend&nbsp;(list&nbsp;\'noun-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;noun-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-prepositional-phrase)))))<br>\n&nbsp;&nbsp;(maybe-extend&nbsp;(parse-simple-noun-phrase)))<br>\n</tt><p><p><p>\n\nOur new grammar lets us parse more complex sentences.  For example\n<p><p><tt>(parse&nbsp;\'(the&nbsp;student&nbsp;with&nbsp;the&nbsp;cat&nbsp;sleeps&nbsp;in&nbsp;the&nbsp;class))<br>\n</tt><p><p>\nproduces<p>\n\n<p><p><tt>(sentence<br>\n&nbsp;(noun-phrase<br>\n&nbsp;&nbsp;(simple-noun-phrase&nbsp;(article&nbsp;the)&nbsp;(noun&nbsp;student))<br>\n&nbsp;&nbsp;(prep-phrase&nbsp;(prep&nbsp;with)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(simple-noun-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(article&nbsp;the)&nbsp;(noun&nbsp;cat))))<br>\n&nbsp;(verb-phrase<br>\n&nbsp;&nbsp;(verb&nbsp;sleeps)<br>\n&nbsp;&nbsp;(prep-phrase&nbsp;(prep&nbsp;in)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(simple-noun-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(article&nbsp;the)&nbsp;(noun&nbsp;class)))))<br>\n</tt><p><p><p>\n\nObserve that a given input may have more than one legal parse.  In\nthe sentence ``The professor lectures to the student with the cat,\'\'\nit may be that the professor is lecturing with the cat, or that the\nstudent has the cat.  Our nondeterministic program finds both\npossibilities:<p>\n\n<p><p><tt>(parse&nbsp;\'(the&nbsp;professor&nbsp;lectures&nbsp;to&nbsp;the&nbsp;student&nbsp;with&nbsp;the&nbsp;cat))<br>\n</tt><p><p>\nproduces<p>\n\n<p><p><tt>(sentence<br>\n&nbsp;(simple-noun-phrase&nbsp;(article&nbsp;the)&nbsp;(noun&nbsp;professor))<br>\n&nbsp;(verb-phrase<br>\n&nbsp;&nbsp;(verb-phrase<br>\n&nbsp;&nbsp;&nbsp;(verb&nbsp;lectures)<br>\n&nbsp;&nbsp;&nbsp;(prep-phrase&nbsp;(prep&nbsp;to)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(simple-noun-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(article&nbsp;the)&nbsp;(noun&nbsp;student))))<br>\n&nbsp;&nbsp;(prep-phrase&nbsp;(prep&nbsp;with)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(simple-noun-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(article&nbsp;the)&nbsp;(noun&nbsp;cat)))))<br>\n</tt><p><p>\nAsking the evaluator to try again yields\n<p><p><tt>(sentence<br>\n&nbsp;(simple-noun-phrase&nbsp;(article&nbsp;the)&nbsp;(noun&nbsp;professor))<br>\n&nbsp;(verb-phrase<br>\n&nbsp;&nbsp;(verb&nbsp;lectures)<br>\n&nbsp;&nbsp;(prep-phrase&nbsp;(prep&nbsp;to)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(noun-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(simple-noun-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(article&nbsp;the)&nbsp;(noun&nbsp;student))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(prep-phrase&nbsp;(prep&nbsp;with)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(simple-noun-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(article&nbsp;the)&nbsp;(noun&nbsp;cat)))))))<br>\n</tt><p><p>\n<p>\n\n<p><a name="%_thm_4.45"></a>\n<b>Exercise 4.45.</b>&nbsp;&nbsp;With the grammar given above, the following sentence can be parsed in\nfive different ways:\n``The professor lectures to the student in the class with the cat.\'\'\nGive the five parses and explain the differences in shades of\nmeaning among them.\n<p><p>\n\n<p><a name="%_thm_4.46"></a>\n<b>Exercise 4.46.</b>&nbsp;&nbsp;<a name="%_idx_4970"></a>The evaluators in sections&nbsp;<a href="book-Z-H-26.html#%_sec_4.1">4.1</a> and <a href="book-Z-H-27.html#%_sec_4.2">4.2</a>\ndo not determine what order operands are evaluated in.\nWe will see that the <tt>amb</tt> evaluator evaluates them from left to right.\nExplain why our parsing program wouldn\'t work if the operands were evaluated\nin some other order.\n<p><p>\n\n<p><a name="%_thm_4.47"></a>\n<b>Exercise 4.47.</b>&nbsp;&nbsp;Louis Reasoner suggests that, since a verb phrase is either a verb or\na verb phrase followed by a prepositional phrase, it would be much more\nstraightforward to define the procedure <tt>parse-verb-phrase</tt> as\nfollows (and similarly for noun phrases):\n<p><p><tt>(define&nbsp;(parse-verb-phrase)<br>\n&nbsp;&nbsp;(amb&nbsp;(parse-word&nbsp;verbs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;\'verb-phrase<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-verb-phrase)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parse-prepositional-phrase))))<br>\n</tt><p><p>\nDoes this work?  Does the program\'s behavior change if we interchange\nthe order of expressions in the <tt>amb</tt>?\n<p><p>\n\n<p><a name="%_thm_4.48"></a>\n<b>Exercise 4.48.</b>&nbsp;&nbsp;Extend the grammar given above to handle more complex sentences.  For\nexample, you could extend noun phrases and verb phrases to include\nadjectives and adverbs, or you could handle compound sentences.<a name="call_footnote_Temp_626" href="#footnote_Temp_626"><sup><small>53</small></sup></a>\n<p><p>\n\n<p><a name="%_thm_4.49"></a>\n<b>Exercise 4.49.</b>&nbsp;&nbsp;<a name="%_idx_4976"></a>Alyssa P. Hacker is more interested in generating interesting\nsentences than in parsing them.  She reasons that by simply changing\nthe procedure <tt>parse-word</tt> so that it ignores the ``input\nsentence\'\' and instead always succeeds and generates an appropriate\nword, we can use the programs we had built for parsing to do\ngeneration instead.  Implement Alyssa\'s idea, and show the first\nhalf-dozen or so sentences generated.<a name="call_footnote_Temp_628" href="#footnote_Temp_628"><sup><small>54</small></sup></a>\n\n<p><p>\n\n<a name="%_sec_4.3.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.3.3">4.3.3&nbsp;&nbsp;Implementing the <tt>Amb</tt> Evaluator</a></h3><p>\n\n\n<a name="%_idx_4978"></a>\nThe evaluation of an ordinary Scheme expression may return a value,\nmay never terminate, or may signal an error.  In nondeterministic\nScheme the evaluation of an expression may in addition result in the\ndiscovery of a dead end, in which case evaluation must backtrack to a previous\nchoice point.  The interpretation of nondeterministic Scheme is\ncomplicated by this extra case.<p>\n\n<a name="%_idx_4980"></a>We will construct the <tt>amb</tt> evaluator for nondeterministic Scheme\nby modifying the analyzing evaluator of section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>.<a name="call_footnote_Temp_629" href="#footnote_Temp_629"><sup><small>55</small></sup></a>\nAs in the analyzing evaluator, evaluation of an expression is\naccomplished by calling an <a name="%_idx_4982"></a>execution procedure produced by analysis of\nthat expression.  The difference between the interpretation of ordinary\nScheme and the interpretation of nondeterministic Scheme will be entirely\nin the execution procedures.<p>\n\n<a name="%_sec_Temp_630"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_630">Execution procedures and continuations</a></h4><p>\n\n<a name="%_idx_4984"></a>\n<a name="%_idx_4986"></a>Recall that the execution procedures for the ordinary evaluator take\none argument: the environment of execution.  In contrast, the\nexecution procedures in the <tt>amb</tt> evaluator take three arguments:\nthe environment, and two procedures called <em>continuation\nprocedures</em>.  The evaluation of an expression will finish by calling\none of these two continuations: If the evaluation results in a value,\nthe <a name="%_idx_4988"></a><em>success continuation</em> is called with that value; if the\nevaluation results in the discovery of a dead end, the <a name="%_idx_4990"></a><em>failure\ncontinuation</em> is called.  Constructing and calling appropriate\ncontinuations is the mechanism by which the nondeterministic evaluator\nimplements backtracking.<p>\n\nIt is the job of the success continuation to receive a value and\nproceed with the computation.  Along with that value, the success\ncontinuation is passed another failure continuation, which is to be\ncalled subsequently if the use of that value leads to a dead end.<p>\n\nIt is the job of the failure continuation to try another branch of the\nnondeterministic process.  The essence of the nondeterministic\nlanguage is in the fact that expressions may represent choices among\nalternatives.  The evaluation of such an expression must proceed with\none of the indicated alternative choices, even though it is not known\nin advance which choices will lead to acceptable results.  To deal\nwith this, the evaluator picks one of the alternatives and passes this\nvalue to the success continuation.  Together with this value, the\nevaluator constructs and passes along a failure continuation that can\nbe called later to choose a different alternative.<p>\n\nA failure is triggered during evaluation (that is, a failure\ncontinuation is called) when a user program explicitly rejects the\ncurrent line of attack (for example, a call to <tt>require</tt> may\nresult in execution of <tt>(amb)</tt>, an expression that always\nfails -- see section&nbsp;<a href="#%_sec_4.3.1">4.3.1</a>).  The failure continuation in hand\nat that point will cause the most recent choice point to choose\nanother alternative.  If there are no more alternatives to be\nconsidered at that choice point, a failure at an earlier choice point\nis triggered, and so on.  Failure continuations are also invoked by\nthe driver loop in response to a <tt>try-again</tt> request, to find\nanother value of the expression.<p>\n\nIn addition, if a side-effect operation (such as assignment to a\nvariable) occurs on a branch of the process resulting from a choice,\nit may be necessary, when the process finds a dead end, to undo the\nside effect before making a new choice.  This is accomplished by\nhaving the side-effect operation produce a failure continuation that\nundoes the side effect and propagates the failure.<p>\n\n\nIn summary, failure continuations are constructed by\n<p><ul>\n<li><tt>amb</tt> expressions -- to provide a mechanism to make\nalternative choices if the current choice made by the <tt>amb</tt>\nexpression leads to a dead end;<p>\n\n<li>the top-level driver -- to provide a mechanism to report failure\nwhen the choices are exhausted;<p>\n\n<li>assignments -- to intercept failures and undo assignments\nduring backtracking.\n</ul><p><p>\n\nFailures are initiated only when a dead end is encountered.\nThis occurs\n<p><ul>\n<li>if the user program executes <tt>(amb)</tt>;<p>\n\n<li>if the user types <tt>try-again</tt> at the top-level driver.\n</ul><p><p>\n\nFailure continuations are also called during processing of a failure:\n<p><ul>\n<li>When the failure continuation created by an assignment finishes\nundoing a side effect, it calls the failure continuation it intercepted,\nin order to propagate the failure back to the choice point that\nled to this assignment or to the top level.<p>\n\n<li>When the failure continuation for an <tt>amb</tt> runs out of choices,\nit calls the failure continuation that was originally given to the <tt>amb</tt>,\nin order to propagate the failure back to the previous choice point\nor to the top level.\n</ul><p>\n<p>\n\n\n<a name="%_sec_Temp_631"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_631">Structure of the evaluator</a></h4><p>\n\n<a name="%_idx_4992"></a>The syntax- and data-representation procedures for the <tt>amb</tt>\nevaluator, and also the basic <tt>analyze</tt> procedure, are identical\nto those in the evaluator of section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>,\nexcept for the fact that we need additional syntax procedures to\nrecognize the <tt>amb</tt> special form:<a name="call_footnote_Temp_632" href="#footnote_Temp_632"><sup><small>56</small></sup></a>\n<p><p><tt>(define&nbsp;(amb?&nbsp;exp)&nbsp;(tagged-list?&nbsp;exp&nbsp;\'amb))<br>\n(define&nbsp;(amb-choices&nbsp;exp)&nbsp;(cdr&nbsp;exp))<br>\n</tt><p><p>\nWe must also add to the dispatch in <tt>analyze</tt> a clause that will\nrecognize this special form and generate an appropriate execution procedure:<p>\n\n<p><p><tt>((amb?&nbsp;exp)&nbsp;(analyze-amb&nbsp;exp))<br>\n</tt><p><p><p>\n\nThe top-level procedure <tt>ambeval</tt> (similar to the version of <tt>eval</tt> given in section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>) analyzes the\ngiven expression and applies the resulting execution procedure to the\ngiven environment, together with two given continuations:<p>\n\n<p><p><tt><a name="%_idx_4994"></a>(define&nbsp;(ambeval&nbsp;exp&nbsp;env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;((analyze&nbsp;exp)&nbsp;env&nbsp;succeed&nbsp;fail))<br>\n</tt><p><p><p>\n\n<a name="%_idx_4996"></a><a name="%_idx_4998"></a><a name="%_idx_5000"></a>A success continuation is a procedure of two arguments: the value just\nobtained and another failure continuation to be used if that value leads\nto a subsequent failure. A failure continuation is a procedure of no\narguments.  So <a name="%_idx_5002"></a>the general form of an execution procedure is<p>\n\n<p><p><tt>(lambda&nbsp;(env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;<em>;;&nbsp;<tt>succeed</tt>&nbsp;is&nbsp;<tt>(lambda&nbsp;(value&nbsp;fail)&nbsp;<tt>...</tt>)</tt></em><br>\n&nbsp;&nbsp;<em>;;&nbsp;<tt>fail</tt>&nbsp;is&nbsp;<tt>(lambda&nbsp;()&nbsp;<tt>...</tt>)</tt></em><br>\n&nbsp;&nbsp;<tt>...</tt>)<br>\n</tt><p><p><p>\n\nFor example, executing<p>\n\n<p><p><tt>(ambeval&nbsp;&lt;<em>exp</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-global-environment<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(value&nbsp;fail)&nbsp;value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;\'failed))<br>\n</tt><p><p>\nwill attempt to evaluate the given expression and will return\neither the expression\'s value (if the evaluation succeeds) or\nthe symbol <tt>failed</tt> (if the evaluation fails).\nThe call to <tt>ambeval</tt> in the driver loop shown below uses\nmuch more complicated continuation procedures, which continue the\nloop and support the <tt>try-again</tt> request.<p>\n\nMost of the complexity of the <tt>amb</tt> evaluator results\nfrom the mechanics of passing the continuations around as the\nexecution procedures call each other.  In going through the following code,\nyou should compare each of the execution procedures with the\ncorresponding procedure for the ordinary evaluator given in\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>.<p>\n\n<a name="%_sec_Temp_633"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_633">Simple expressions</a></h4><p>\n\nThe execution procedures for the simplest kinds of expressions are\nessentially the same as those for the ordinary evaluator, except for the\nneed to manage the continuations.  The execution procedures simply\nsucceed with the value of the expression, passing along the failure\ncontinuation that was passed to them.<p>\n\n<a name="%_idx_5004"></a>\n<p><p><tt>(define&nbsp;(analyze-self-evaluating&nbsp;exp)<br>\n&nbsp;&nbsp;(lambda&nbsp;(env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(succeed&nbsp;exp&nbsp;fail)))<br>\n(define&nbsp;(analyze-quoted&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((qval&nbsp;(text-of-quotation&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(succeed&nbsp;qval&nbsp;fail))))<br>\n(define&nbsp;(analyze-variable&nbsp;exp)<br>\n&nbsp;&nbsp;(lambda&nbsp;(env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(succeed&nbsp;(lookup-variable-value&nbsp;exp&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail)))<br>\n(define&nbsp;(analyze-lambda&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((vars&nbsp;(lambda-parameters&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bproc&nbsp;(analyze-sequence&nbsp;(lambda-body&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(succeed&nbsp;(make-procedure&nbsp;vars&nbsp;bproc&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail))))<br>\n</tt><p><p><p>\n\n\n<a name="%_idx_5006"></a>Notice that looking up a variable always ``succeeds.\'\'  If <tt>lookup-variable-value</tt> fails to find the variable, it signals an\nerror, as usual.  Such a ``failure\'\' indicates a program bug -- a\nreference to an unbound variable; it is not an indication that we\nshould try another nondeterministic choice instead of the one that is\ncurrently being tried.<p>\n\n<a name="%_sec_Temp_634"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_634">Conditionals and sequences</a></h4><p>\n\nConditionals are also handled in a similar way as in the ordinary\nevaluator.  The execution procedure generated by <tt>analyze-if</tt>\ninvokes the predicate execution procedure <tt>pproc</tt> with a success\ncontinuation that checks whether the predicate value is true and goes\non to execute either the consequent or the alternative.  If the\nexecution of <tt>pproc</tt> fails, the original failure continuation for\nthe <tt>if</tt> expression is called.<p>\n\n\n<p><p><tt>(define&nbsp;(analyze-if&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((pproc&nbsp;(analyze&nbsp;(if-predicate&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cproc&nbsp;(analyze&nbsp;(if-consequent&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(aproc&nbsp;(analyze&nbsp;(if-alternative&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pproc&nbsp;env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;;&nbsp;success&nbsp;continuation&nbsp;for&nbsp;evaluating&nbsp;the&nbsp;predicate</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;;&nbsp;to&nbsp;obtain&nbsp;<tt>pred-value</tt></em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pred-value&nbsp;fail2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(true?&nbsp;pred-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cproc&nbsp;env&nbsp;succeed&nbsp;fail2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(aproc&nbsp;env&nbsp;succeed&nbsp;fail2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;;&nbsp;failure&nbsp;continuation&nbsp;for&nbsp;evaluating&nbsp;the&nbsp;predicate</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail))))<br>\n</tt><p><p><p>\n\nSequences are also handled in the same way as in the previous\nevaluator, except for the machinations in the subprocedure <tt>sequentially</tt> that are required for passing the continuations.\nNamely, to sequentially execute <tt>a</tt> and then <tt>b</tt>, we call <tt>a</tt> with a success continuation that calls <tt>b</tt>.<p>\n\n<p><p><tt>(define&nbsp;(analyze-sequence&nbsp;exps)<br>\n&nbsp;&nbsp;(define&nbsp;(sequentially&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a&nbsp;env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;;&nbsp;success&nbsp;continuation&nbsp;for&nbsp;calling&nbsp;<tt>a</tt></em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(a-value&nbsp;fail2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b&nbsp;env&nbsp;succeed&nbsp;fail2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;;&nbsp;failure&nbsp;continuation&nbsp;for&nbsp;calling&nbsp;<tt>a</tt></em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail)))<br>\n&nbsp;&nbsp;(define&nbsp;(loop&nbsp;first-proc&nbsp;rest-procs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;rest-procs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first-proc<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(sequentially&nbsp;first-proc&nbsp;(car&nbsp;rest-procs))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;rest-procs))))<br>\n&nbsp;&nbsp;(let&nbsp;((procs&nbsp;(map&nbsp;analyze&nbsp;exps)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;procs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Empty&nbsp;sequence&nbsp;--&nbsp;ANALYZE&quot;))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(car&nbsp;procs)&nbsp;(cdr&nbsp;procs))))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_635"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_635">Definitions and assignments</a></h4><p>\n\nDefinitions are another case where we must go to some trouble to\nmanage the continuations, because it is necessary to evaluate the\ndefinition-value expression before actually defining the new variable.\nTo accomplish this, the definition-value execution procedure <tt>vproc</tt> is called with the environment, a success continuation, and the\nfailure continuation.  If the execution of <tt>vproc</tt> succeeds,\nobtaining a value <tt>val</tt> for the defined variable, the variable is\ndefined and the success is propagated:<p>\n\n<p><p><tt>(define&nbsp;(analyze-definition&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((var&nbsp;(definition-variable&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vproc&nbsp;(analyze&nbsp;(definition-value&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vproc&nbsp;env&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(val&nbsp;fail2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-variable!&nbsp;var&nbsp;val&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(succeed&nbsp;\'ok&nbsp;fail2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail))))<br>\n</tt><p><p><p>\n\n\n<a name="%_idx_5008"></a>Assignments are more interesting.  This is the first place where we\nreally use the continuations, rather than just passing them around.\nThe execution procedure for assignments starts out like the one for\ndefinitions.  It first attempts to obtain the new value to be assigned\nto the variable. If this evaluation of <tt>vproc</tt> fails, the\nassignment fails.<p>\n\nIf <tt>vproc</tt> succeeds, however, and we go on to make the assignment,\nwe must consider the possibility that this branch of the computation\nmight later fail, which will require us to backtrack out of the\nassignment.  Thus, we must arrange to undo the assignment as\npart of the backtracking process.<a name="call_footnote_Temp_636" href="#footnote_Temp_636"><sup><small>57</small></sup></a><p>\n\nThis is accomplished by giving <tt>vproc</tt> a success continuation\n(marked with the comment ``*1*\'\' below) that saves the old value of\nthe variable before assigning the new value to the\nvariable and proceeding from the assignment.  The failure continuation\nthat is passed along with the value of the assignment (marked with the\ncomment ``*2*\'\' below) restores the old value of the variable\nbefore continuing the failure.\nThat is, a successful assignment provides a failure continuation that\nwill intercept a subsequent failure; whatever failure would otherwise\nhave called <tt>fail2</tt> calls this procedure instead, to undo the\nassignment before actually calling <tt>fail2</tt>.<p>\n\n<p><p><tt>(define&nbsp;(analyze-assignment&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((var&nbsp;(assignment-variable&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vproc&nbsp;(analyze&nbsp;(assignment-value&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vproc&nbsp;env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(val&nbsp;fail2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;*1*</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((old-value<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lookup-variable-value&nbsp;var&nbsp;env)))&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-variable-value!&nbsp;var&nbsp;val&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(succeed&nbsp;\'ok<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;*2*</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-variable-value!&nbsp;var<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old-value<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fail2)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail))))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_637"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_637">Procedure applications</a></h4><p>\n\nThe execution procedure for applications contains no new ideas except\nfor the technical complexity of managing the continuations.  This\ncomplexity arises in <tt>analyze-application</tt>, due to the need to\nkeep track of the success and failure continuations as we evaluate the\noperands.  We use a procedure <tt>get-args</tt> to evaluate the list of\noperands, rather than a simple <tt>map</tt> as in the ordinary evaluator.<p>\n\n<p><p><tt>(define&nbsp;(analyze-application&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((fproc&nbsp;(analyze&nbsp;(operator&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(aprocs&nbsp;(map&nbsp;analyze&nbsp;(operands&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fproc&nbsp;env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(proc&nbsp;fail2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-args&nbsp;aprocs<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(args&nbsp;fail3)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(execute-application<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proc&nbsp;args&nbsp;succeed&nbsp;fail3))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail))))<br>\n</tt><p><p><p>\n\nIn <tt>get-args</tt>, notice how <tt>cdr</tt>ing down the list of <tt>aproc</tt> execution procedures and <tt>cons</tt>ing up the resulting list of\n<tt>args</tt> is accomplished by calling each <tt>aproc</tt> in the list\nwith a success continuation that recursively calls <tt>get-args</tt>.\nEach of these recursive calls to <tt>get-args</tt> has a success\ncontinuation whose value is the <tt>cons</tt> of the newly obtained\nargument onto the list of accumulated arguments:<p>\n\n<p><p><tt>(define&nbsp;(get-args&nbsp;aprocs&nbsp;env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;aprocs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(succeed&nbsp;\'()&nbsp;fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((car&nbsp;aprocs)&nbsp;env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;;&nbsp;success&nbsp;continuation&nbsp;for&nbsp;this&nbsp;<tt>aproc</tt></em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(arg&nbsp;fail2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-args&nbsp;(cdr&nbsp;aprocs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;;&nbsp;success&nbsp;continuation&nbsp;for&nbsp;recursive</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;;&nbsp;call&nbsp;to&nbsp;<tt>get-args</tt></em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(args&nbsp;fail3)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(succeed&nbsp;(cons&nbsp;arg&nbsp;args)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail3))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail)))<br>\n</tt><p><p><p>\n\nThe actual procedure application, which is\nperformed by <tt>execute-application</tt>, is\naccomplished in the same way as for the ordinary evaluator, except for\nthe need to manage the continuations.<p>\n\n<p><p><tt><a name="%_idx_5012"></a>(define&nbsp;(execute-application&nbsp;proc&nbsp;args&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;(cond&nbsp;((primitive-procedure?&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(succeed&nbsp;(apply-primitive-procedure&nbsp;proc&nbsp;args)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((compound-procedure?&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((procedure-body&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(extend-environment&nbsp;(procedure-parameters&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure-environment&nbsp;proc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;succeed<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Unknown&nbsp;procedure&nbsp;type&nbsp;--&nbsp;EXECUTE-APPLICATION&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proc))))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_638"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_638">Evaluating <tt>amb</tt> expressions</a></h4><p>\n\n\n<a name="%_idx_5014"></a>The <tt>amb</tt> special form is the key element in the nondeterministic\nlanguage.  Here we see the essence of the interpretation process and\nthe reason for keeping track of the continuations.  The execution\nprocedure for <tt>amb</tt> defines a loop <tt>try-next</tt> that cycles\nthrough the execution procedures for all the possible values of the\n<tt>amb</tt> expression.  Each execution procedure is called with a\nfailure continuation that will try the next one.  When there are no\nmore alternatives to try, the entire <tt>amb</tt> expression fails.<p>\n\n<p><p><tt><a name="%_idx_5016"></a>(define&nbsp;(analyze-amb&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((cprocs&nbsp;(map&nbsp;analyze&nbsp;(amb-choices&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(try-next&nbsp;choices)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;choices)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((car&nbsp;choices)&nbsp;env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;succeed<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(try-next&nbsp;(cdr&nbsp;choices))))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(try-next&nbsp;cprocs))))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_639"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_639">Driver loop</a></h4><p>\n\n<a name="%_idx_5018"></a>\n<a name="%_idx_5020"></a>The driver loop for the <tt>amb</tt> evaluator is complex, due to\nthe mechanism that permits the user to try again in evaluating an\nexpression.  The driver uses a procedure called <tt>internal-loop</tt>,\nwhich takes as argument a procedure <tt>try-again</tt>.  The intent is\nthat calling <tt>try-again</tt> should go on to the next untried\nalternative in the nondeterministic evaluation.  <tt>Internal-loop</tt>\neither calls <tt>try-again</tt> in response to the user typing <tt>try-again</tt> at the driver loop, or else starts a new evaluation by\ncalling <tt>ambeval</tt>.  <p>\n\nThe failure continuation for this call to <tt>ambeval</tt>\ninforms the user that there are no more values and re-invokes the driver loop.<p>\n\n\nThe success continuation for the call to <tt>ambeval</tt>\nis more subtle.  We print the obtained value and then invoke\nthe internal loop again with a <tt>try-again</tt> procedure that will be\nable to try the next alternative.  This <tt>next-alternative</tt>\nprocedure is the second argument that was passed to the\nsuccess continuation.  Ordinarily, we think of this second argument\nas a failure continuation to be used if the current evaluation branch\nlater fails.  In this case, however, we have completed a successful\nevaluation, so we can invoke the ``failure\'\' alternative branch in\norder to search for additional successful evaluations.<p>\n\n<p><p><tt><a name="%_idx_5022"></a>(define&nbsp;input-prompt&nbsp;&quot;;;;&nbsp;Amb-Eval&nbsp;input:&quot;)<br>\n(define&nbsp;output-prompt&nbsp;&quot;;;;&nbsp;Amb-Eval&nbsp;value:&quot;)<br>\n<a name="%_idx_5024"></a>(define&nbsp;(driver-loop)<br>\n&nbsp;&nbsp;(define&nbsp;(internal-loop&nbsp;try-again)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(prompt-for-input&nbsp;input-prompt)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((input&nbsp;(read)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;input&nbsp;\'try-again)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(try-again)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;&quot;;;;&nbsp;Starting&nbsp;a&nbsp;new&nbsp;problem&nbsp;&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ambeval&nbsp;input<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-global-environment<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;;&nbsp;<tt>ambeval</tt>&nbsp;success</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(val&nbsp;next-alternative)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(announce-output&nbsp;output-prompt)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(user-print&nbsp;val)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(internal-loop&nbsp;next-alternative))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;;&nbsp;<tt>ambeval</tt>&nbsp;failure</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(announce-output<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;;;;&nbsp;There&nbsp;are&nbsp;no&nbsp;more&nbsp;values&nbsp;of&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(user-print&nbsp;input)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(driver-loop)))))))<br>\n&nbsp;&nbsp;(internal-loop<br>\n&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;&quot;;;;&nbsp;There&nbsp;is&nbsp;no&nbsp;current&nbsp;problem&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(driver-loop))))<br>\n</tt><p><p>\nThe initial call to <tt>internal-loop</tt> uses a <tt>try-again</tt> procedure that complains that there is no current\nproblem and restarts the driver loop.  This is the behavior that will\nhappen if the user types <tt>try-again</tt> when there is no evaluation\nin progress.<p>\n\n<p><a name="%_thm_4.50"></a>\n<b>Exercise 4.50.</b>&nbsp;&nbsp;Implement a new special form <tt>ramb</tt> that is like <tt>amb</tt> except that it searches alternatives in a random order, rather \nthan from left to right.  Show how this can help with Alyssa\'s problem\nin exercise&nbsp;<a href="#%_thm_4.49">4.49</a>.\n\n<p><p>\n\n<p><a name="%_thm_4.51"></a>\n<b>Exercise 4.51.</b>&nbsp;&nbsp;Implement a new kind of assignment called <tt>permanent-set!</tt> that\nis not undone upon failure.  For example, we can choose two distinct\nelements from a list and count the number of trials required to make a\nsuccessful choice as follows:<p>\n\n<p><p><tt>(define&nbsp;count&nbsp;0)<br>\n(let&nbsp;((x&nbsp;(an-element-of&nbsp;\'(a&nbsp;b&nbsp;c)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(y&nbsp;(an-element-of&nbsp;\'(a&nbsp;b&nbsp;c))))<br>\n&nbsp;&nbsp;(permanent-set!&nbsp;count&nbsp;(+&nbsp;count&nbsp;1))<br>\n&nbsp;&nbsp;(require&nbsp;(not&nbsp;(eq?&nbsp;x&nbsp;y)))<br>\n&nbsp;&nbsp;(list&nbsp;x&nbsp;y&nbsp;count))<br>\n<i>;;;&nbsp;Starting&nbsp;a&nbsp;new&nbsp;problem</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;value:</i><br>\n<i>(a&nbsp;b&nbsp;2)</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;input:</i><br>\ntry-again<br>\n<i>;;;&nbsp;Amb-Eval&nbsp;value:</i><br>\n<i>(a&nbsp;c&nbsp;3)</i><br>\n</tt><p><p>\nWhat values would have been displayed if we had used <tt>set!</tt> here\nrather than <tt>permanent-set!</tt> ?\n\n<p><p>\n\n<p><a name="%_thm_4.52"></a>\n<b>Exercise 4.52.</b>&nbsp;&nbsp;Implement a new construct called <tt>if-fail</tt> that permits the user to\ncatch the failure of an expression.  <tt>If-fail</tt> takes two\nexpressions.  It evaluates the first expression as usual and returns\nas usual if the evaluation succeeds.  If the evaluation fails,\nhowever, the value of the second expression is returned, as in the\nfollowing example:\n<p><p><tt><i>;;;&nbsp;Amb-Eval&nbsp;input:</i><br>\n(if-fail&nbsp;(let&nbsp;((x&nbsp;(an-element-of&nbsp;\'(1&nbsp;3&nbsp;5))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(even?&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'all-odd)<br>\n<i>;;;&nbsp;Starting&nbsp;a&nbsp;new&nbsp;problem</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;value:</i><br>\n<i>all-odd</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;input:</i><br>\n(if-fail&nbsp;(let&nbsp;((x&nbsp;(an-element-of&nbsp;\'(1&nbsp;3&nbsp;5&nbsp;8))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(require&nbsp;(even?&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'all-odd)<br>\n<i>;;;&nbsp;Starting&nbsp;a&nbsp;new&nbsp;problem</i><br>\n<i>;;;&nbsp;Amb-Eval&nbsp;value:</i><br>\n<i>8</i><br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_4.53"></a>\n<b>Exercise 4.53.</b>&nbsp;&nbsp;With <tt>permanent-set!</tt> as described in\nexercise&nbsp;<a href="#%_thm_4.51">4.51</a> and <tt>if-fail</tt> as in\nexercise&nbsp;<a href="#%_thm_4.52">4.52</a>, what will be the result of evaluating\n<p><p><tt>(let&nbsp;((pairs&nbsp;\'()))<br>\n&nbsp;&nbsp;(if-fail&nbsp;(let&nbsp;((p&nbsp;(prime-sum-pair&nbsp;\'(1&nbsp;3&nbsp;5&nbsp;8)&nbsp;\'(20&nbsp;35&nbsp;110))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(permanent-set!&nbsp;pairs&nbsp;(cons&nbsp;p&nbsp;pairs))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(amb))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pairs))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_4.54"></a>\n<b>Exercise 4.54.</b>&nbsp;&nbsp;<a name="%_idx_5026"></a>If we had not realized that <tt>require</tt> could be implemented as an\nordinary procedure that uses <tt>amb</tt>, to be defined by the user as\npart of a nondeterministic program, we would have had to implement it\nas a special form.  This would require syntax procedures<p>\n\n<p><p><tt>(define&nbsp;(require?&nbsp;exp)&nbsp;(tagged-list?&nbsp;exp&nbsp;\'require))<br>\n<br>\n(define&nbsp;(require-predicate&nbsp;exp)&nbsp;(cadr&nbsp;exp))<br>\n</tt><p><p>\nand a new clause in the dispatch in <tt>analyze</tt><p>\n\n<p><p><tt>((require?&nbsp;exp)&nbsp;(analyze-require&nbsp;exp))<br>\n</tt><p><p>\nas well the procedure <tt>analyze-require</tt> that handles <tt>require</tt>\nexpressions.  Complete the following definition of <tt>analyze-require</tt>.<p>\n\n<p><p><tt>(define&nbsp;(analyze-require&nbsp;exp)<br>\n&nbsp;&nbsp;(let&nbsp;((pproc&nbsp;(analyze&nbsp;(require-predicate&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(env&nbsp;succeed&nbsp;fail)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pproc&nbsp;env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pred-value&nbsp;fail2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;&lt;<em>??</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>??</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(succeed&nbsp;\'ok&nbsp;fail2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail))))<br>\n</tt><p><p>\n<p>\n<p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_598" href="#call_footnote_Temp_598"><sup><small>42</small></sup></a> We assume that we have previously defined a\nprocedure <tt>prime?</tt> that tests whether numbers are prime.  Even with\n<tt>prime?</tt> defined, the <tt>prime-sum-pair</tt> procedure may look\nsuspiciously like the unhelpful ``pseudo-Lisp\'\' attempt to define the\nsquare-root function, which we described at the beginning of\nsection&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>.  In fact, a square-root procedure along those\nlines can actually be formulated as a nondeterministic program.\nBy incorporating a search mechanism into the evaluator, we\nare eroding the <a name="%_idx_4816"></a><a name="%_idx_4818"></a>distinction between purely declarative descriptions\nand imperative specifications of how to compute answers.  We\'ll go\neven farther in this direction in\nsection&nbsp;<a href="book-Z-H-29.html#%_sec_4.4">4.4</a>.\n\n<p><a name="footnote_Temp_599" href="#call_footnote_Temp_599"><sup><small>43</small></sup></a> The idea of <tt>amb</tt> for nondeterministic programming was\n<a name="%_idx_4824"></a>first described in 1961 by John McCarthy (see McCarthy 1967).\n\n<p><a name="footnote_Temp_600" href="#call_footnote_Temp_600"><sup><small>44</small></sup></a> In actuality, the distinction between nondeterministically\nreturning a single choice and returning all choices depends somewhat\non our point of view.  From the perspective of the code that uses the\nvalue, the nondeterministic choice returns a single value.  From the\nperspective of the programmer designing the code, the nondeterministic\nchoice potentially returns all possible values, and the computation\nbranches so that each value is investigated separately.\n\n<p><a name="footnote_Temp_601" href="#call_footnote_Temp_601"><sup><small>45</small></sup></a> One might object that this is a hopelessly\ninefficient mechanism.  It might require millions of processors to\nsolve some easily stated problem this way, and most of the time most\nof those processors would be idle.  This objection should be taken in\nthe context of history.  Memory used to be considered just such an\nexpensive commodity.  <a name="%_idx_4838"></a>In 1964 a megabyte of RAM cost about $400,000.\nNow every personal computer has many megabytes of RAM, and most of the\ntime most of that RAM is unused.  It is hard to underestimate the cost\nof mass-produced electronics.\n\n<p><a name="footnote_Temp_602" href="#call_footnote_Temp_602"><sup><small>46</small></sup></a> Automagically: ``Automatically, but in a way\nwhich, for some reason (typically because it is too complicated, or\ntoo ugly, or perhaps even too trivial), the speaker doesn\'t feel like\nexplaining.\'\'  (Steele 1983, Raymond 1993)\n\n<p><a name="footnote_Temp_603" href="#call_footnote_Temp_603"><sup><small>47</small></sup></a> The integration of automatic search strategies\n<a name="%_idx_4860"></a>into programming languages has had a long and checkered history.  The\nfirst suggestions that nondeterministic algorithms might be elegantly\nencoded in a programming language with search and automatic\nbacktracking came from <a name="%_idx_4862"></a>Robert Floyd (1967).  <a name="%_idx_4864"></a>Carl Hewitt\n(1969) invented a programming language called <a name="%_idx_4866"></a>Planner that explicitly\nsupported automatic chronological backtracking, providing for a\nbuilt-in depth-first search strategy.  <a name="%_idx_4868"></a><a name="%_idx_4870"></a><a name="%_idx_4872"></a>Sussman, Winograd, and Charniak \n(1971) implemented a subset of this language, called <a name="%_idx_4874"></a>MicroPlanner,\nwhich was used to support work in problem solving and robot planning.\nSimilar ideas, arising from logic and theorem proving, led to the\ngenesis in Edinburgh and Marseille of the elegant language <a name="%_idx_4876"></a>Prolog\n(which we will discuss in section&nbsp;<a href="book-Z-H-29.html#%_sec_4.4">4.4</a>).  After\nsufficient frustration with automatic search, <a name="%_idx_4878"></a><a name="%_idx_4880"></a>McDermott and Sussman\n(1972) developed a language called <a name="%_idx_4882"></a>Conniver, which included mechanisms\nfor placing the search strategy under programmer control.  This proved\nunwieldy, however, and <a name="%_idx_4884"></a><a name="%_idx_4886"></a>Sussman and Stallman (1975) found a more\ntractable approach while investigating methods of symbolic analysis\nfor electrical circuits.  They developed a non-chronological\nbacktracking scheme that was based on tracing out the logical\ndependencies connecting facts, a technique that has come to be known\nas <a name="%_idx_4888"></a><em>dependency-directed backtracking</em>.  Although their method was\ncomplex, it produced reasonably efficient programs because it did\nlittle redundant search.  <a name="%_idx_4890"></a><a name="%_idx_4892"></a>Doyle (1979) and McAllester (1978, 1980)\ngeneralized and clarified the methods of Stallman and Sussman,\ndeveloping a new paradigm for formulating search that is now called\n<a name="%_idx_4894"></a><em>truth maintenance</em>.  Modern problem-solving systems all\nuse some form of truth-maintenance system as a substrate.  See <a name="%_idx_4896"></a><a name="%_idx_4898"></a>Forbus\nand deKleer 1993 for a discussion of elegant ways to build\ntruth-maintenance systems and applications using truth maintenance.\n<a name="%_idx_4900"></a><a name="%_idx_4902"></a><a name="%_idx_4904"></a>Zabih, McAllester, and\nChapman 1987 describes a nondeterministic extension to Scheme that\nis based on <tt>amb</tt>; it is similar to the interpreter described in\nthis section, but more sophisticated, because it uses\ndependency-directed backtracking rather than chronological\n<a name="%_idx_4906"></a>backtracking.  Winston 1992 gives an introduction to both kinds of\nbacktracking.\n\n<p><a name="footnote_Temp_609" href="#call_footnote_Temp_609"><sup><small>48</small></sup></a> Our program uses the following procedure to determine \nif the elements of a list are distinct:\n<p><p><tt><a name="%_idx_4934"></a>(define&nbsp;(distinct?&nbsp;items)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;items)&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((null?&nbsp;(cdr&nbsp;items))&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((member&nbsp;(car&nbsp;items)&nbsp;(cdr&nbsp;items))&nbsp;false)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(distinct?&nbsp;(cdr&nbsp;items)))))<br>\n</tt><p><p>\n<a name="%_idx_4936"></a><tt>Member</tt> is like <tt>memq</tt> except that it uses <tt>equal?</tt> instead\nof <tt>eq?</tt> to test for equality.\n\n\n<p><a name="footnote_Temp_616" href="#call_footnote_Temp_616"><sup><small>49</small></sup></a> This is taken from a booklet called ``Problematical\nRecreations,\'\' published in the 1960s by Litton Industries, where it\nis attributed to the <em>Kansas State Engineer</em>.\n\n<p><a name="footnote_Temp_619" href="#call_footnote_Temp_619"><sup><small>50</small></sup></a> Here we use the convention that the first element of each list\ndesignates the part of speech for the rest of the words in the list.\n\n<p><a name="footnote_Temp_620" href="#call_footnote_Temp_620"><sup><small>51</small></sup></a> Notice that <tt>parse-word</tt> uses <tt>set!</tt> to modify the\nunparsed input list.  For this to work, our <tt>amb</tt> evaluator must\nundo the effects of <tt>set!</tt> operations when it backtracks.\n\n<p><a name="footnote_Temp_621" href="#call_footnote_Temp_621"><sup><small>52</small></sup></a> Observe that this\ndefinition is recursive -- a verb may be followed by any number\nof prepositional phrases.\n\n<p><a name="footnote_Temp_626" href="#call_footnote_Temp_626"><sup><small>53</small></sup></a> This kind of grammar can become arbitrarily complex, but it\n<a name="%_idx_4972"></a>is only a toy as far as real language understanding is concerned.\nReal natural-language understanding by computer requires an elaborate\nmixture of syntactic analysis and interpretation of meaning.  On the\nother hand, even toy parsers can be useful in supporting flexible\ncommand languages for programs such as information-retrieval systems.\n<a name="%_idx_4974"></a>Winston 1992 discusses computational approaches to real\nlanguage understanding and also the applications of simple grammars to\ncommand languages.\n\n<p><a name="footnote_Temp_628" href="#call_footnote_Temp_628"><sup><small>54</small></sup></a> Although Alyssa\'s idea works just fine (and is\nsurprisingly simple), the sentences that it generates are a bit\nboring -- they don\'t sample the possible sentences of this language in\na very interesting way.  In fact, the grammar is highly recursive in\nmany places, and Alyssa\'s technique ``falls into\'\' one of these recursions and\ngets stuck.  See exercise&nbsp;<a href="#%_thm_4.50">4.50</a> for a way to deal with this.\n\n<p><a name="footnote_Temp_629" href="#call_footnote_Temp_629"><sup><small>55</small></sup></a> We chose to implement the lazy evaluator in\nsection&nbsp;<a href="book-Z-H-27.html#%_sec_4.2">4.2</a> as a modification of the ordinary\nmetacircular evaluator of section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>.  In\ncontrast, we will base the <tt>amb</tt> evaluator on the analyzing evaluator\nof section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>, because the execution procedures\nin that evaluator provide a convenient framework for implementing\nbacktracking.\n\n<p><a name="footnote_Temp_632" href="#call_footnote_Temp_632"><sup><small>56</small></sup></a> We assume that the evaluator supports <tt>let</tt>\n(see exercise&nbsp;<a href="book-Z-H-26.html#%_thm_4.22">4.22</a>),\nwhich we have used in our nondeterministic programs.\n\n<p><a name="footnote_Temp_636" href="#call_footnote_Temp_636"><sup><small>57</small></sup></a> We didn\'t worry about undoing definitions, since we can\n<a name="%_idx_5010"></a>assume that internal definitions are scanned out\n(section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.6">4.1.6</a>).\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_4.4"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_4.4">4.4&nbsp;&nbsp;Logic Programming</a></h2><p>\n\n\n<a name="%_idx_5028"></a>\n<a name="%_idx_5030"></a><a name="%_idx_5032"></a><a name="%_idx_5034"></a><a name="%_idx_5036"></a>In chapter&nbsp;1 we stressed that computer science deals with imperative\n(how to) knowledge, whereas mathematics deals with declarative (what\nis) knowledge.  Indeed, programming languages require that the\nprogrammer express knowledge in a form that indicates the step-by-step\nmethods for solving particular problems.  On the other hand,\nhigh-level languages provide, as part of the language implementation,\na substantial amount of methodological knowledge that frees\nthe user from concern with numerous details of how a specified\ncomputation will progress.<p>\n\nMost programming languages, including Lisp, are organized around\ncomputing the values of mathematical functions.  Expression-oriented\nlanguages (such as Lisp, Fortran, and Algol) capitalize on the ``pun\'\'\nthat an expression that describes the value of a function may also be\ninterpreted as a means of computing that value.  Because of this, most\nprogramming languages are strongly biased toward unidirectional\ncomputations (computations with well-defined inputs and outputs).\nThere are, however, radically different programming languages that\nrelax this bias.  We saw one such example in\nsection&nbsp;<a href="book-Z-H-22.html#%_sec_3.3.5">3.3.5</a>, where the objects of computation were\narithmetic constraints.  In a constraint system the direction and the\norder of computation are not so well specified; in carrying out a\ncomputation the system must therefore provide more detailed ``how to\'\'\nknowledge than would be the case with an ordinary arithmetic\ncomputation.  This does not mean, however, that the user is released\naltogether from the responsibility of providing imperative knowledge.\nThere are many constraint networks that implement the same set of\nconstraints, and the user must choose from the set of mathematically\nequivalent networks a suitable network to specify a particular\ncomputation.<p>\n\n\nThe nondeterministic program evaluator of\nsection&nbsp;<a href="book-Z-H-28.html#%_sec_4.3">4.3</a> also moves away from the\nview that programming is about constructing algorithms for computing\nunidirectional functions.  In a nondeterministic language, expressions\ncan have more than one value, and, as a result, the computation is\n<a name="%_idx_5038"></a>dealing with relations rather than with\nsingle-valued functions.  Logic programming extends this idea by\ncombining a relational vision of programming with a powerful kind of\nsymbolic pattern matching called <em>unification</em>.<a name="call_footnote_Temp_645" href="#footnote_Temp_645"><sup><small>58</small></sup></a><p>\n\n<a name="%_idx_5070"></a><a name="%_idx_5072"></a>This approach, when it works, can be a very powerful way to write\nprograms.  Part of the power comes from the fact that a single ``what\nis\'\' fact can be used to solve a number of different problems that\nwould have different ``how to\'\' components.  As an example, consider\nthe <a name="%_idx_5074"></a><tt>append</tt> operation, which takes two lists as arguments and\ncombines their elements to form a single list.  In a procedural\nlanguage such as Lisp, we could define <tt>append</tt> in terms of the\nbasic list constructor <tt>cons</tt>, as we did in\nsection&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.1">2.2.1</a>:<p>\n\n<p><p><tt>(define&nbsp;(append&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;x)&nbsp;(append&nbsp;(cdr&nbsp;x)&nbsp;y))))<br>\n</tt><p><p>\nThis procedure can be regarded as a translation into Lisp of the\nfollowing two rules, the first of which covers the case where the\nfirst list is empty and the second of which handles the case of a\nnonempty list, which is a <tt>cons</tt> of two parts:<p>\n\n<p><ul>\n<li>For any list <tt>y</tt>, the empty list and <tt>y</tt> <tt>append</tt> to form <tt>y</tt>.<p>\n\n<li>For any <tt>u</tt>,  <tt>v</tt>,  <tt>y</tt>, and <tt>z</tt>,\n <tt>(cons u v)</tt> and <tt>y</tt> <tt>append</tt> to form <tt>(cons&nbsp;u&nbsp;z)</tt>\nif <tt>v</tt> and <tt>y</tt> <tt>append</tt> to form <tt>z</tt>.<a name="call_footnote_Temp_646" href="#footnote_Temp_646"><sup><small>59</small></sup></a>\n</ul><p><p>\n\nUsing the <tt>append</tt> procedure, we can answer questions such as\n\n<blockquote>\nFind the <tt>append</tt> of <tt>(a b)</tt> and <tt>(c d)</tt>.\n</blockquote><p>\n\nBut the same two rules are also sufficient for answering the following\nsorts of questions, which the procedure can\'t answer:<p>\n\n<blockquote>\nFind a list <tt>y</tt> that <tt>append</tt>s with <tt>(a b)</tt> \nto produce <tt>(a b c d)</tt>.<p>\n\nFind all <tt>x</tt> and <tt>y</tt> that <tt>append</tt> to form <tt>(a b c\nd)</tt>.\n</blockquote><p>\n\n<a name="%_idx_5076"></a><a name="%_idx_5078"></a>In a logic programming language, the programmer writes an <tt>append</tt>\n``procedure\'\' by stating the two rules about <tt>append</tt> given above.\n``How to\'\' knowledge is provided automatically by the interpreter to\nallow this single pair of rules to be used to answer all three types\nof questions about <tt>append</tt>.<a name="call_footnote_Temp_647" href="#footnote_Temp_647"><sup><small>60</small></sup></a><p>\n\nContemporary logic programming languages (including the one we\nimplement here) have substantial deficiencies, in that their general\n``how to\'\' methods can lead them into spurious infinite loops or other\nundesirable behavior.\nLogic programming is an active field of research in computer science.<a name="call_footnote_Temp_648" href="#footnote_Temp_648"><sup><small>61</small></sup></a><p>\n\nEarlier in this chapter we explored the technology of implementing\ninterpreters and described the elements that are essential to an\ninterpreter for a Lisp-like language (indeed, to an interpreter for\nany conventional language).  Now we will apply these ideas to discuss\nan interpreter for a logic programming language.  We call this\n<a name="%_idx_5090"></a>language the <em>query language</em>, because it is very useful for\nretrieving information from data bases by formulating <a name="%_idx_5092"></a><em>queries</em>,\nor questions, expressed in the language.  Even though the query\nlanguage is very different from Lisp, we will find it convenient to\ndescribe the language in terms of the same general framework we have\nbeen using all along: as a collection of primitive elements, together\nwith means of combination that enable us to combine simple elements to\ncreate more complex elements and means of abstraction that enable us\nto regard complex elements as single conceptual units.  An interpreter\nfor a logic programming language is considerably more complex than an\ninterpreter for a language like Lisp.  Nevertheless, we will see\n<a name="%_idx_5094"></a>that our query-language interpreter contains many of the same elements\nfound in the interpreter of section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1">4.1</a>.  In particular,\nthere will be an ``eval\'\' part that classifies expressions according\nto type and an ``apply\'\' part that implements the language\'s\nabstraction mechanism (procedures in the case of Lisp, and <em>rules</em>\nin the case of logic programming).  Also, a central role is played in\nthe implementation by a frame data structure, which determines the\ncorrespondence between symbols and their associated values.  One\nadditional interesting aspect of our query-language implementation is\nthat we make substantial use of streams, which were introduced in\nchapter&nbsp;3.\n\n<a name="%_sec_4.4.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.4.1">4.4.1&nbsp;&nbsp;Deductive Information Retrieval</a></h3><p>\n\n\n<a name="%_idx_5096"></a>\n<a name="%_idx_5098"></a>Logic programming excels in providing interfaces to data bases for\ninformation retrieval.  The query language we shall implement in this\nchapter is designed to be used in this way.<p>\n\nIn order to illustrate what the query system does, we will show how it\ncan be used to manage the data base of personnel records for\n<a name="%_idx_5100"></a>Microshaft, a thriving high-technology company in the\nBoston area.  The language provides pattern-directed access to\npersonnel information and can also take advantage of general rules in\norder to make logical deductions.<p>\n\n<a name="%_sec_Temp_649"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_649">A sample data base</a></h4><p>\n\n<a name="%_idx_5102"></a>\n<a name="%_idx_5104"></a><a name="%_idx_5106"></a>The personnel data base for Microshaft\ncontains <em>assertions</em> about company personnel.  Here is the\ninformation about Ben Bitdiddle, the resident computer wizard:<p>\n\n<p><p><tt>(address&nbsp;(Bitdiddle&nbsp;Ben)&nbsp;(Slumerville&nbsp;(Ridge&nbsp;Road)&nbsp;10))<br>\n(job&nbsp;(Bitdiddle&nbsp;Ben)&nbsp;(computer&nbsp;wizard))<br>\n(salary&nbsp;(Bitdiddle&nbsp;Ben)&nbsp;60000)<br>\n</tt><p><p>\nEach assertion is a list (in this case a triple) whose elements can\nthemselves be lists.<p>\n\nAs resident wizard, Ben is in charge of the company\'s computer\ndivision, and he supervises two programmers and one technician.  Here\nis the information about them:<p>\n\n<p><p><tt>(address&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)&nbsp;(Cambridge&nbsp;(Mass&nbsp;Ave)&nbsp;78))<br>\n(job&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)&nbsp;(computer&nbsp;programmer))<br>\n(salary&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)&nbsp;40000)<br>\n(supervisor&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)&nbsp;(Bitdiddle&nbsp;Ben))<br>\n(address&nbsp;(Fect&nbsp;Cy&nbsp;D)&nbsp;(Cambridge&nbsp;(Ames&nbsp;Street)&nbsp;3))<br>\n(job&nbsp;(Fect&nbsp;Cy&nbsp;D)&nbsp;(computer&nbsp;programmer))<br>\n(salary&nbsp;(Fect&nbsp;Cy&nbsp;D)&nbsp;35000)<br>\n(supervisor&nbsp;(Fect&nbsp;Cy&nbsp;D)&nbsp;(Bitdiddle&nbsp;Ben))<br>\n(address&nbsp;(Tweakit&nbsp;Lem&nbsp;E)&nbsp;(Boston&nbsp;(Bay&nbsp;State&nbsp;Road)&nbsp;22))<br>\n(job&nbsp;(Tweakit&nbsp;Lem&nbsp;E)&nbsp;(computer&nbsp;technician))<br>\n(salary&nbsp;(Tweakit&nbsp;Lem&nbsp;E)&nbsp;25000)<br>\n(supervisor&nbsp;(Tweakit&nbsp;Lem&nbsp;E)&nbsp;(Bitdiddle&nbsp;Ben))<br>\n</tt><p><p>\nThere is also a programmer trainee, who is supervised by Alyssa:\n<p><p><tt>(address&nbsp;(Reasoner&nbsp;Louis)&nbsp;(Slumerville&nbsp;(Pine&nbsp;Tree&nbsp;Road)&nbsp;80))<br>\n(job&nbsp;(Reasoner&nbsp;Louis)&nbsp;(computer&nbsp;programmer&nbsp;trainee))<br>\n(salary&nbsp;(Reasoner&nbsp;Louis)&nbsp;30000)<br>\n(supervisor&nbsp;(Reasoner&nbsp;Louis)&nbsp;(Hacker&nbsp;Alyssa&nbsp;P))<br>\n</tt><p><p>\nAll of these people are in the computer division, as indicated by the\nword <tt>computer</tt> as the first item in their job descriptions.<p>\n\nBen is a high-level employee.  His supervisor is the company\'s big\nwheel himself:<p>\n\n<p><p><tt>(supervisor&nbsp;(Bitdiddle&nbsp;Ben)&nbsp;(Warbucks&nbsp;Oliver))<br>\n(address&nbsp;(Warbucks&nbsp;Oliver)&nbsp;(Swellesley&nbsp;(Top&nbsp;Heap&nbsp;Road)))<br>\n(job&nbsp;(Warbucks&nbsp;Oliver)&nbsp;(administration&nbsp;big&nbsp;wheel))<br>\n(salary&nbsp;(Warbucks&nbsp;Oliver)&nbsp;150000)<br>\n</tt><p><p><p>\n\nBesides the computer division supervised by Ben, the company has an\naccounting division, consisting of a chief accountant and his\nassistant:<p>\n\n<p><p><tt>(address&nbsp;(Scrooge&nbsp;Eben)&nbsp;(Weston&nbsp;(Shady&nbsp;Lane)&nbsp;10))<br>\n(job&nbsp;(Scrooge&nbsp;Eben)&nbsp;(accounting&nbsp;chief&nbsp;accountant))<br>\n(salary&nbsp;(Scrooge&nbsp;Eben)&nbsp;75000)<br>\n(supervisor&nbsp;(Scrooge&nbsp;Eben)&nbsp;(Warbucks&nbsp;Oliver))<br>\n(address&nbsp;(Cratchet&nbsp;Robert)&nbsp;(Allston&nbsp;(N&nbsp;Harvard&nbsp;Street)&nbsp;16))<br>\n(job&nbsp;(Cratchet&nbsp;Robert)&nbsp;(accounting&nbsp;scrivener))<br>\n(salary&nbsp;(Cratchet&nbsp;Robert)&nbsp;18000)<br>\n(supervisor&nbsp;(Cratchet&nbsp;Robert)&nbsp;(Scrooge&nbsp;Eben))<br>\n</tt><p><p>\nThere is also a secretary for the big wheel:<p>\n\n<p><p><tt>(address&nbsp;(Aull&nbsp;DeWitt)&nbsp;(Slumerville&nbsp;(Onion&nbsp;Square)&nbsp;5))<br>\n(job&nbsp;(Aull&nbsp;DeWitt)&nbsp;(administration&nbsp;secretary))<br>\n(salary&nbsp;(Aull&nbsp;DeWitt)&nbsp;25000)<br>\n(supervisor&nbsp;(Aull&nbsp;DeWitt)&nbsp;(Warbucks&nbsp;Oliver))<br>\n</tt><p><p><p>\n\nThe data base also contains assertions about which kinds of jobs can\nbe done by people holding other kinds of jobs.  For instance, a\ncomputer wizard can do the jobs of both a computer programmer and a\ncomputer technician:<p>\n\n<p><p><tt>(can-do-job&nbsp;(computer&nbsp;wizard)&nbsp;(computer&nbsp;programmer))<br>\n(can-do-job&nbsp;(computer&nbsp;wizard)&nbsp;(computer&nbsp;technician))<br>\n</tt><p><p>\nA computer programmer could fill in for a trainee:\n<p><p><tt>(can-do-job&nbsp;(computer&nbsp;programmer)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(computer&nbsp;programmer&nbsp;trainee))<br>\n</tt><p><p>\n<a name="%_idx_5108"></a>Also, as is well known,\n<p><p><tt>(can-do-job&nbsp;(administration&nbsp;secretary)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(administration&nbsp;big&nbsp;wheel))<br>\n</tt><p><p>\n\n<a name="%_sec_Temp_650"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_650">Simple queries</a></h4><p>\n\n<a name="%_idx_5110"></a>\nThe query language allows users to retrieve information from the data\nbase by posing queries in response to the system\'s prompt.  For\nexample, to find all computer programmers one can say<p>\n\n<p><p><tt><i>;;;&nbsp;Query&nbsp;input:</i><br>\n(job&nbsp;?x&nbsp;(computer&nbsp;programmer))<br>\n</tt><p><p>\nThe system will respond with the following items:<p>\n\n<p><p><tt><i>;;;&nbsp;Query&nbsp;results:</i><br>\n(job&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)&nbsp;(computer&nbsp;programmer))<br>\n(job&nbsp;(Fect&nbsp;Cy&nbsp;D)&nbsp;(computer&nbsp;programmer))<br>\n</tt><p><p><p>\n\n\n<a name="%_idx_5112"></a>The input query specifies that we are looking for entries in the data\nbase that match a certain <em>pattern</em>.  In this example, the pattern\nspecifies entries consisting of three items, of which the first is the\nliteral symbol <tt>job</tt>, the second can be anything, and the third is\nthe literal list <tt>(computer programmer)</tt>.  The ``anything\'\' that\ncan be the second item in the matching list is specified by a <a name="%_idx_5114"></a><em>pattern variable</em>, <tt>?x</tt>.  The general form of a pattern variable\nis a symbol, taken to be the name of the variable, preceded by a\nquestion mark.  We will see below why it is useful to specify names\nfor pattern variables rather than just putting <tt>?</tt> into patterns\nto represent ``anything.\'\'  The system responds to a simple query by\nshowing all entries in the data base that match the specified pattern.<p>\n\nA pattern can have more than one variable.  For example, the query\n<p><p><tt>(address&nbsp;?x&nbsp;?y)<br>\n</tt><p><p>\nwill list all the employees\' addresses.<p>\n\nA pattern can have no variables, in which case the query simply\ndetermines whether that pattern is an entry in the data base.  If so,\nthere will be one match; if not, there will be no matches.<p>\n\nThe same pattern variable can appear more than once in a query,\nspecifying that the same ``anything\'\' must appear in each position.\nThis is why variables have names.  For example,<p>\n\n<p><p><tt>(supervisor&nbsp;?x&nbsp;?x)<br>\n</tt><p><p>\nfinds all people who supervise themselves (though there are no such\nassertions in our sample data base).<p>\n\nThe query\n<p><p><tt>(job&nbsp;?x&nbsp;(computer&nbsp;?type))<br>\n</tt><p><p>\nmatches all job entries whose third item is a two-element list whose\nfirst item is <tt>computer</tt>:<p>\n\n<p><p><tt>(job&nbsp;(Bitdiddle&nbsp;Ben)&nbsp;(computer&nbsp;wizard))<br>\n(job&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)&nbsp;(computer&nbsp;programmer))<br>\n(job&nbsp;(Fect&nbsp;Cy&nbsp;D)&nbsp;(computer&nbsp;programmer))<br>\n(job&nbsp;(Tweakit&nbsp;Lem&nbsp;E)&nbsp;(computer&nbsp;technician))<br>\n</tt><p><p>\nThis same pattern does <em>not</em> match\n<p><p><tt>(job&nbsp;(Reasoner&nbsp;Louis)&nbsp;(computer&nbsp;programmer&nbsp;trainee))<br>\n</tt><p><p>\nbecause the third item in the entry is a list of three elements, and\nthe pattern\'s third item specifies that there should be two elements.\nIf we wanted to change the pattern so that the third item could be any\nlist beginning with <tt>computer</tt>, we could specify<a name="%_idx_5116"></a><a name="call_footnote_Temp_651" href="#footnote_Temp_651"><sup><small>62</small></sup></a><p>\n\n<p><p><tt>(job&nbsp;?x&nbsp;(computer&nbsp;.&nbsp;?type))<br>\n</tt><p><p>\nFor example,\n<p><p><tt>(computer&nbsp;.&nbsp;?type)<br>\n</tt><p><p>\nmatches the data<p>\n\n<p><p><tt>(computer&nbsp;programmer&nbsp;trainee)<br>\n</tt><p><p>\nwith <tt>?type</tt> as the list <tt>(programmer trainee)</tt>.  It also\nmatches the data<p>\n\n<p><p><tt>(computer&nbsp;programmer)<br>\n</tt><p><p>\nwith <tt>?type</tt> as the list <tt>(programmer)</tt>, and matches the data<p>\n\n<p><p><tt>(computer)<br>\n</tt><p><p>\nwith <tt>?type</tt> as the empty list <tt>()</tt>.<p>\n\nWe can describe the query language\'s processing of simple queries as\nfollows:<p>\n\n<p><ul>\n<li>The system finds all assignments to variables in the query\n<a name="%_idx_5118"></a>pattern that <em>satisfy</em> the pattern -- that is, all sets of values\nfor the variables such that if the pattern variables are <a name="%_idx_5120"></a><em>instantiated with</em> (replaced by) the values, the result is in the data\nbase.<p>\n\n<li>The system responds to the query by listing all instantiations of the\nquery pattern with the variable assignments that satisfy it.\n</ul><p><p>\n\nNote that if the pattern has no variables, the query reduces to a\ndetermination of whether that pattern is in the data base.  If so, the\nempty assignment, which assigns no values to variables, satisfies that\npattern for that data base.<p>\n\n\n<p><a name="%_thm_4.55"></a>\n<b>Exercise 4.55.</b>&nbsp;&nbsp;Give simple queries that retrieve the following information from the\ndata base:<p>\n\n<p><p>a. all people supervised by Ben Bitdiddle;<p>\n\n<p><p>b. the names and jobs of all people in the accounting division;<p>\n\n<p><p>c. the names and addresses of all people who live \nin Slumerville.\n<p>\n\n<a name="%_sec_Temp_653"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_653">Compound queries</a></h4><p>\n\n<a name="%_idx_5122"></a>\nSimple queries form the primitive operations of the query language.\nIn order to form compound operations, the query language provides\nmeans of combination.  One thing that makes the query language a logic\nprogramming language is that the means of combination mirror the means\nof combination used in forming logical expressions: <tt>and</tt>, <tt>or</tt>, and <tt>not</tt>.  (Here <tt>and</tt>, <tt>or</tt>, and <tt>not</tt> are not\nthe Lisp primitives, but rather operations built into the query\nlanguage.)<p>\n\n<a name="%_idx_5124"></a>We can use <tt>and</tt> as follows to find the addresses of all the\ncomputer programmers:<p>\n\n<p><p><tt>(and&nbsp;(job&nbsp;?person&nbsp;(computer&nbsp;programmer))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(address&nbsp;?person&nbsp;?where))<br>\n</tt><p><p>\nThe resulting output is\n<p><p><tt>(and&nbsp;(job&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)&nbsp;(computer&nbsp;programmer))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(address&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)&nbsp;(Cambridge&nbsp;(Mass&nbsp;Ave)&nbsp;78)))<br>\n(and&nbsp;(job&nbsp;(Fect&nbsp;Cy&nbsp;D)&nbsp;(computer&nbsp;programmer))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(address&nbsp;(Fect&nbsp;Cy&nbsp;D)&nbsp;(Cambridge&nbsp;(Ames&nbsp;Street)&nbsp;3)))<br>\n</tt><p><p>\n<a name="%_idx_5126"></a>In general,\n<p><p><tt>(and&nbsp;&lt;<em>query<sub>1</sub></em>&gt;&nbsp;&lt;<em>query<sub>2</sub></em>&gt;&nbsp;<tt>...</tt> &lt;<em>query<sub><em>n</em></sub></em>&gt;)<br>\n</tt><p><p>\nis satisfied by all sets of values for the pattern variables that\nsimultaneously satisfy &lt;<em>query<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>query<sub><em>n</em></sub></em>&gt;.<p>\n\nAs for simple queries, the system processes a compound query by\nfinding all assignments to the pattern variables that satisfy the\nquery, then displaying instantiations of the query with those values.<p>\n\n<a name="%_idx_5128"></a>Another means of constructing compound queries is through <tt>or</tt>.\nFor example,<p>\n\n<p><p><tt>(or&nbsp;(supervisor&nbsp;?x&nbsp;(Bitdiddle&nbsp;Ben))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(supervisor&nbsp;?x&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)))<br>\n</tt><p><p>\n\nwill find all employees supervised by Ben Bitdiddle or Alyssa P.\nHacker:<p>\n\n<p><p><tt>(or&nbsp;(supervisor&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)&nbsp;(Bitdiddle&nbsp;Ben))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(supervisor&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)))<br>\n(or&nbsp;(supervisor&nbsp;(Fect&nbsp;Cy&nbsp;D)&nbsp;(Bitdiddle&nbsp;Ben))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(supervisor&nbsp;(Fect&nbsp;Cy&nbsp;D)&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)))<br>\n(or&nbsp;(supervisor&nbsp;(Tweakit&nbsp;Lem&nbsp;E)&nbsp;(Bitdiddle&nbsp;Ben))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(supervisor&nbsp;(Tweakit&nbsp;Lem&nbsp;E)&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)))<br>\n(or&nbsp;(supervisor&nbsp;(Reasoner&nbsp;Louis)&nbsp;(Bitdiddle&nbsp;Ben))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(supervisor&nbsp;(Reasoner&nbsp;Louis)&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)))<br>\n</tt><p><p>\nIn general,\n<p><p><tt>(or&nbsp;&lt;<em>query<sub>1</sub></em>&gt;&nbsp;&lt;<em>query<sub>2</sub></em>&gt;&nbsp;<tt>...</tt> &lt;<em>query<sub><em>n</em></sub></em>&gt;)<br>\n</tt><p><p>\nis satisfied by all sets of values for the pattern variables that\nsatisfy at least one of &lt;<em>query<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>query<sub><em>n</em></sub></em>&gt;.<p>\n\n<a name="%_idx_5130"></a>Compound queries can also be formed with <tt>not</tt>. For example,\n<p><p><tt>(and&nbsp;(supervisor&nbsp;?x&nbsp;(Bitdiddle&nbsp;Ben))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(not&nbsp;(job&nbsp;?x&nbsp;(computer&nbsp;programmer))))<br>\n</tt><p><p>\nfinds all people supervised by Ben Bitdiddle who are not computer\nprogrammers.  In general,<p>\n\n<p><p><tt>(not&nbsp;&lt;<em>query<sub>1</sub></em>&gt;)<br>\n</tt><p><p>\nis satisfied by all assignments to the pattern variables that do not\nsatisfy &lt;<em>query<sub>1</sub></em>&gt;.<a name="call_footnote_Temp_654" href="#footnote_Temp_654"><sup><small>63</small></sup></a><p>\n\n<a name="%_idx_5132"></a>The final combining form is called <tt>lisp-value</tt>.  When <tt>lisp-value</tt> is the first element of a pattern, it specifies that the\nnext element is a Lisp predicate to be applied to the rest of the\n(instantiated) elements as arguments.  In general,<p>\n\n<p><p><tt>(lisp-value&nbsp;&lt;<em>predicate</em>&gt;&nbsp;&lt;<em>arg<sub>1</sub></em>&gt;&nbsp;<tt>...</tt> &lt;<em>arg<sub><em>n</em></sub></em>&gt;)<br>\n</tt><p><p>\nwill be satisfied by assignments to the pattern variables for which the\n&lt;<em>predicate</em>&gt; applied to the instantiated\n&lt;<em>arg<sub>1</sub></em>&gt; <tt>...</tt> &lt;<em>arg<sub><em>n</em></sub></em>&gt;\nis true.  For example, to find all people whose salary is greater than\n$30,000 we could write<a name="call_footnote_Temp_655" href="#footnote_Temp_655"><sup><small>64</small></sup></a><p>\n\n<p><p><tt>(and&nbsp;(salary&nbsp;?person&nbsp;?amount)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lisp-value&nbsp;&gt;&nbsp;?amount&nbsp;30000))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_4.56"></a>\n<b>Exercise 4.56.</b>&nbsp;&nbsp;Formulate compound queries that retrieve the following information:<p>\n\n<p><p>a. the names of all people who are supervised by Ben Bitdiddle, together\nwith their addresses;<p>\n\n<p><p>b. all people whose salary is less than Ben Bitdiddle\'s, together with\ntheir salary and Ben Bitdiddle\'s salary;<p>\n\n<p><p>c. all people who are supervised by someone who is not in the computer\ndivision, together with the supervisor\'s name and job.\n<p>\n<p>\n\n<a name="%_sec_Temp_657"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_657">Rules</a></h4><p>\n\n<a name="%_idx_5136"></a>\n<a name="%_idx_5138"></a>In addition to primitive queries and compound queries, the query\nlanguage provides means for abstracting queries.  These are given by\n<em>rules</em>.  The rule<p>\n\n<p><p><tt><a name="%_idx_5140"></a>(rule&nbsp;(lives-near&nbsp;?person-1&nbsp;?person-2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(address&nbsp;?person-1&nbsp;(?town&nbsp;.&nbsp;?rest-1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(address&nbsp;?person-2&nbsp;(?town&nbsp;.&nbsp;?rest-2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(not&nbsp;(same&nbsp;?person-1&nbsp;?person-2))))<br>\n</tt><p><p>\nspecifies that two people live near each other if they live in the\nsame town.  The final <tt>not</tt> clause prevents the rule from saying\nthat all people live near themselves.  The <tt>same</tt> relation is\ndefined by a very simple rule:<a name="call_footnote_Temp_658" href="#footnote_Temp_658"><sup><small>65</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_5142"></a>(rule&nbsp;(same&nbsp;?x&nbsp;?x))<br>\n</tt><p><p><p>\n\nThe following rule declares that a person is a ``wheel\'\' in an\norganization if he supervises someone who is in turn a supervisor:<p>\n\n<p><p><tt><a name="%_idx_5144"></a>(rule&nbsp;(wheel&nbsp;?person)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(supervisor&nbsp;?middle-manager&nbsp;?person)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(supervisor&nbsp;?x&nbsp;?middle-manager)))<br>\n</tt><p><p><p>\n\nThe general form of a rule is\n\n<p><p><tt>(rule&nbsp;&lt;<em>conclusion</em>&gt;&nbsp;&lt;<em>body</em>&gt;)<br>\n</tt><p><p>\nwhere &lt;<em>conclusion</em>&gt; is a pattern and &lt;<em>body</em>&gt; is any\nquery.<a name="call_footnote_Temp_659" href="#footnote_Temp_659"><sup><small>66</small></sup></a> We can think\nof a rule as representing a large (even infinite) set of assertions,\nnamely all instantiations of the rule conclusion with variable\nassignments that satisfy the rule body.  When we described simple\nqueries (patterns), we said that an assignment to variables satisfies\na pattern if the instantiated pattern is in the data base.  But the\npattern needn\'t be explicitly in the data base as an assertion.  It\n<a name="%_idx_5148"></a>can be an implicit assertion implied by a rule.  For example, the\nquery\n\n<p><p><tt>(lives-near&nbsp;?x&nbsp;(Bitdiddle&nbsp;Ben))<br>\n</tt><p><p>\nresults in\n\n<p><p><tt>(lives-near&nbsp;(Reasoner&nbsp;Louis)&nbsp;(Bitdiddle&nbsp;Ben))<br>\n(lives-near&nbsp;(Aull&nbsp;DeWitt)&nbsp;(Bitdiddle&nbsp;Ben))<br>\n</tt><p><p>\nTo find all computer programmers who live near Ben Bitdiddle, we can\nask\n\n<p><p><tt>(and&nbsp;(job&nbsp;?x&nbsp;(computer&nbsp;programmer))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lives-near&nbsp;?x&nbsp;(Bitdiddle&nbsp;Ben)))<br>\n</tt><p><p><p>\n\n\n<a name="%_idx_5150"></a>As in the case of compound procedures, rules can be used as parts of\nother rules (as we saw with the <tt>lives-near</tt> rule above)\nor even be defined recursively.  For instance, the rule\n\n<p><p><tt><a name="%_idx_5152"></a>(rule&nbsp;(outranked-by&nbsp;?staff-person&nbsp;?boss)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(supervisor&nbsp;?staff-person&nbsp;?boss)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(supervisor&nbsp;?staff-person&nbsp;?middle-manager)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(outranked-by&nbsp;?middle-manager&nbsp;?boss))))<br>\n</tt><p><p>\nsays that a staff person is outranked by a boss in the organization if\nthe boss is the person\'s supervisor or (recursively) if the person\'s\nsupervisor is outranked by the boss.<p>\n\n<p><a name="%_thm_4.57"></a>\n<b>Exercise 4.57.</b>&nbsp;&nbsp;Define a rule that says that person 1 can replace person 2 if either\nperson 1 does the same job as person 2 or someone who does person 1\'s\njob can also do person&nbsp;2\'s job, and if person 1 and person 2 are not\nthe same person. Using your rule, give queries that find the\nfollowing:<p>\n\na.&nbsp;&nbsp;all people who can replace Cy D. Fect;<p>\n\nb.&nbsp;&nbsp;all people who can replace someone who is being paid more than they\nare, together with the two salaries.\n<p><p>\n\n<p><a name="%_thm_4.58"></a>\n<b>Exercise 4.58.</b>&nbsp;&nbsp;Define a rule that says that a person is a ``big shot\'\' in a division\nif the person works in the division but does not have a supervisor who\nworks in the division.\n<p><p>\n\n<p><a name="%_thm_4.59"></a>\n<b>Exercise 4.59.</b>&nbsp;&nbsp;Ben Bitdiddle has missed one meeting too many.\nFearing that his habit of forgetting meetings could cost him his\njob, Ben decides to do something about it.  He adds all the weekly\nmeetings of the firm to the Microshaft data base by\nasserting the following:\n<p><p><tt>(meeting&nbsp;accounting&nbsp;(Monday&nbsp;9am))<br>\n(meeting&nbsp;administration&nbsp;(Monday&nbsp;10am))<br>\n(meeting&nbsp;computer&nbsp;(Wednesday&nbsp;3pm))<br>\n(meeting&nbsp;administration&nbsp;(Friday&nbsp;1pm))<br>\n</tt><p><p>\nEach of the above assertions is for a meeting of an entire division.\nBen also adds an entry for the company-wide meeting that spans all the\ndivisions.  All of the company\'s employees attend this meeting.\n<p><p><tt>(meeting&nbsp;whole-company&nbsp;(Wednesday&nbsp;4pm))<br>\n</tt><p><p>\n<p>\n\n<p><p>a. On Friday morning, Ben wants to query the data base for all the meetings\nthat occur that day.  What query should he use?<p>\n\n<p><p>b. Alyssa P. Hacker is unimpressed.  She thinks it would be much more\nuseful to be able to ask for her meetings by specifying her name.  So\nshe designs a rule that says that a person\'s meetings include all <tt>whole-company</tt> meetings plus all meetings of that person\'s division.\nFill in the body of Alyssa\'s rule.\n<p><p><tt>(rule&nbsp;(meeting-time&nbsp;?person&nbsp;?day-and-time)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>rule-body</em>&gt;)<br>\n</tt><p><p><p>\n\nc. Alyssa arrives at work on Wednesday morning and wonders what meetings she \nhas to attend that day.  Having defined the above rule,\nwhat query should she make to find this out?\n<p><p>\n\n<p><a name="%_thm_4.60"></a>\n<b>Exercise 4.60.</b>&nbsp;&nbsp;<a name="%_idx_5154"></a>By giving the query\n<p><p><tt>(lives-near&nbsp;?person&nbsp;(Hacker&nbsp;Alyssa&nbsp;P))<br>\n</tt><p><p>\nAlyssa P. Hacker is able to find people who live near her, with whom\nshe can ride to work.  On the other hand, when she tries to find all\npairs of people who live near each other by querying<p>\n\n<p><p><tt>(lives-near&nbsp;?person-1&nbsp;?person-2)<br>\n</tt><p><p>\nshe notices that each pair of people who live near each other is\nlisted twice; for example,<p>\n\n<p><p><tt>(lives-near&nbsp;(Hacker&nbsp;Alyssa&nbsp;P)&nbsp;(Fect&nbsp;Cy&nbsp;D))<br>\n(lives-near&nbsp;(Fect&nbsp;Cy&nbsp;D)&nbsp;(Hacker&nbsp;Alyssa&nbsp;P))<br>\n</tt><p><p>\nWhy does this happen?\nIs there a way to find a list of people who live near each other, in\nwhich each pair appears only once?  Explain.\n<p><p>\n\n<a name="%_sec_Temp_664"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_664">Logic as programs</a></h4><p>\n\n<a name="%_idx_5156"></a>\nWe can regard a rule as a kind of logical implication: <em>If</em> an\nassignment of values to pattern variables satisfies the body, <em>then</em> it satisfies the conclusion.  Consequently, we can regard the\nquery language as having the ability to perform <em>logical\ndeductions</em> based upon the rules.  As an example, consider the <tt>append</tt> operation described at the beginning of\nsection&nbsp;<a href="#%_sec_4.4">4.4</a>.  As we said, <tt>append</tt> can be\ncharacterized by the following two rules:<p>\n\n<p><ul>\n<li>For any list <tt>y</tt>, the empty list and <tt>y</tt> <tt>append</tt> to form <tt>y</tt>.<p>\n\n<li>For any <tt>u</tt>,  <tt>v</tt>,  <tt>y</tt>, and <tt>z</tt>,\n <tt>(cons u v)</tt> and <tt>y</tt> <tt>append</tt> to form <tt>(cons&nbsp;u&nbsp;z)</tt>\nif <tt>v</tt> and <tt>y</tt> <tt>append</tt> to form <tt>z</tt>.\n</ul><p><p>\n\n\nTo express this in our query language, we define two rules for a\nrelation\n<p><p><tt>(append-to-form&nbsp;x&nbsp;y&nbsp;z)<br>\n</tt><p><p>\nwhich we can interpret to mean ``<tt>x</tt> and <tt>y</tt> <tt>append</tt> to\nform <tt>z</tt>\'\':<p>\n\n<p><p><tt><a name="%_idx_5158"></a>(rule&nbsp;(append-to-form&nbsp;()&nbsp;?y&nbsp;?y))<br>\n(rule&nbsp;(append-to-form&nbsp;(?u&nbsp;.&nbsp;?v)&nbsp;?y&nbsp;(?u&nbsp;.&nbsp;?z))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append-to-form&nbsp;?v&nbsp;?y&nbsp;?z))<br>\n</tt><p><p>\n<a name="%_idx_5160"></a>The first rule has no body, which means that the conclusion holds for\nany value of <tt>?y</tt>.  Note how the second rule makes use of\n<a name="%_idx_5162"></a>dotted-tail notation to name the <tt>car</tt> and <tt>cdr</tt> of a list.<p>\n\nGiven these two rules, we can formulate queries that compute the <tt>append</tt> of two lists:\n\n<p><p><tt><i>;;;&nbsp;Query&nbsp;input:</i><br>\n(append-to-form&nbsp;(a&nbsp;b)&nbsp;(c&nbsp;d)&nbsp;?z)<br>\n<i>;;;&nbsp;Query&nbsp;results:</i><br>\n(append-to-form&nbsp;(a&nbsp;b)&nbsp;(c&nbsp;d)&nbsp;(a&nbsp;b&nbsp;c&nbsp;d))<br>\n</tt><p><p>\nWhat is more striking, we can use the same rules to ask the question\n``Which list, when <tt>append</tt>ed to <tt>(a b)</tt>, yields <tt>(a b c d)</tt>?\'\'\nThis is done as follows:\n\n<p><p><tt><i>;;;&nbsp;Query&nbsp;input:</i><br>\n(append-to-form&nbsp;(a&nbsp;b)&nbsp;?y&nbsp;(a&nbsp;b&nbsp;c&nbsp;d))<br>\n<i>;;;&nbsp;Query&nbsp;results:</i><br>\n(append-to-form&nbsp;(a&nbsp;b)&nbsp;(c&nbsp;d)&nbsp;(a&nbsp;b&nbsp;c&nbsp;d))<br>\n</tt><p><p>\nWe can also ask for all pairs of lists that <tt>append</tt> to form <tt>(a b c d)</tt>:\n\n<p><p><tt><i>;;;&nbsp;Query&nbsp;input:</i><br>\n(append-to-form&nbsp;?x&nbsp;?y&nbsp;(a&nbsp;b&nbsp;c&nbsp;d))<br>\n<i>;;;&nbsp;Query&nbsp;results:</i><br>\n(append-to-form&nbsp;()&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)&nbsp;(a&nbsp;b&nbsp;c&nbsp;d))<br>\n(append-to-form&nbsp;(a)&nbsp;(b&nbsp;c&nbsp;d)&nbsp;(a&nbsp;b&nbsp;c&nbsp;d))<br>\n(append-to-form&nbsp;(a&nbsp;b)&nbsp;(c&nbsp;d)&nbsp;(a&nbsp;b&nbsp;c&nbsp;d))<br>\n(append-to-form&nbsp;(a&nbsp;b&nbsp;c)&nbsp;(d)&nbsp;(a&nbsp;b&nbsp;c&nbsp;d))<br>\n(append-to-form&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)&nbsp;()&nbsp;(a&nbsp;b&nbsp;c&nbsp;d))<br>\n</tt><p><p><p>\n\n\nThe query system may seem to exhibit quite a bit of intelligence in\nusing the rules to deduce the answers to the queries above.  Actually,\nas we will see in the next section, the system is following a\nwell-determined algorithm in unraveling the rules.  Unfortunately,\nalthough the system works impressively in the <tt>append</tt> case, the\ngeneral methods may break down in more complex cases, as we will see\nin section&nbsp;<a href="#%_sec_4.4.3">4.4.3</a>.<p>\n\n<p><a name="%_thm_4.61"></a>\n<b>Exercise 4.61.</b>&nbsp;&nbsp;The following rules implement a <tt>next-to</tt> relation that finds\nadjacent elements of a list:\n\n<p><p><tt><a name="%_idx_5164"></a>(rule&nbsp;(?x&nbsp;next-to&nbsp;?y&nbsp;in&nbsp;(?x&nbsp;?y&nbsp;.&nbsp;?u)))<br>\n<br>\n(rule&nbsp;(?x&nbsp;next-to&nbsp;?y&nbsp;in&nbsp;(?v&nbsp;.&nbsp;?z))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(?x&nbsp;next-to&nbsp;?y&nbsp;in&nbsp;?z))<br>\n</tt><p><p>\nWhat will the response be to the following queries?\n\n<p><p><tt>(?x&nbsp;next-to&nbsp;?y&nbsp;in&nbsp;(1&nbsp;(2&nbsp;3)&nbsp;4))<br>\n<br>\n(?x&nbsp;next-to&nbsp;1&nbsp;in&nbsp;(2&nbsp;1&nbsp;3&nbsp;1))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_4.62"></a>\n<b>Exercise 4.62.</b>&nbsp;&nbsp;<a name="%_idx_5166"></a>Define rules to implement the <tt>last-pair</tt> operation of\nexercise&nbsp;<a href="book-Z-H-15.html#%_thm_2.17">2.17</a>, which returns a list containing the last\nelement of a nonempty list.  Check your rules on queries such as\n<tt>(last-pair (3) ?x)</tt>, <tt>(last-pair (1 2 3) ?x)</tt>, and <tt>(last-pair (2 ?x) (3))</tt>.\nDo your rules work correctly on queries such as <tt>(last-pair ?x (3))</tt> ?\n<p><p>\n\n<p><a name="%_thm_4.63"></a>\n<b>Exercise 4.63.</b>&nbsp;&nbsp;<a name="%_idx_5168"></a><a name="%_idx_5170"></a>The following data base (see Genesis 4) traces the genealogy of the\ndescendants of Ada back to Adam, by way of Cain:<p>\n\n<p><p><tt>(son&nbsp;Adam&nbsp;Cain)<br>\n(son&nbsp;Cain&nbsp;Enoch)<br>\n(son&nbsp;Enoch&nbsp;Irad)<br>\n(son&nbsp;Irad&nbsp;Mehujael)<br>\n(son&nbsp;Mehujael&nbsp;Methushael)<br>\n(son&nbsp;Methushael&nbsp;Lamech)<br>\n(wife&nbsp;Lamech&nbsp;Ada)<br>\n(son&nbsp;Ada&nbsp;Jabal)<br>\n(son&nbsp;Ada&nbsp;Jubal)<br>\n</tt><p><p>\nFormulate rules such as ``If <em>S</em> is the son of <em>F</em>, and <em>F</em> is the son of <em>G</em>, then <em>S</em> is the grandson of <em>G</em>\'\'\nand ``If <em>W</em> is the wife of <em>M</em>, and <em>S</em> is the son of\n<em>W</em>, then <em>S</em> is the son of <em>M</em>\'\' (which was supposedly\nmore true in biblical times than today) that will enable the query\nsystem to find the grandson of Cain; the sons of Lamech; the grandsons\nof Methushael.\n(See exercise&nbsp;<a href="#%_thm_4.69">4.69</a> for some rules to\ndeduce more complicated relationships.)\n\n<p>\n\n<a name="%_sec_4.4.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.4.2">4.4.2&nbsp;&nbsp;How the Query System Works</a></h3><p>\n\n\n<a name="%_idx_5172"></a>\nIn section&nbsp;<a href="#%_sec_4.4.4">4.4.4</a> we will present an\nimplementation of the query interpreter as a collection of procedures.\nIn this section we give an overview that explains the general\nstructure of the system independent of low-level implementation\ndetails.  After describing the implementation of the interpreter, we\nwill be in a position to understand some of its limitations and some\nof the subtle ways in which the query language\'s logical operations\ndiffer from the operations of mathematical logic.<p>\n\nIt should be apparent that the query evaluator must perform some kind\nof search in order to match queries against facts and rules in the\ndata base.  One way to do this would be to implement the query system\nas a nondeterministic program, using the <tt>amb</tt> evaluator of\nsection&nbsp;<a href="book-Z-H-28.html#%_sec_4.3">4.3</a> (see\nexercise&nbsp;<a href="#%_thm_4.78">4.78</a>).  Another possibility is to manage\nthe search with the aid of streams.  Our implementation follows this\nsecond approach.<p>\n\nThe query system is organized around two central operations called\n<em>pattern matching</em> and <em>unification</em>.  We first describe\npattern matching and explain how this operation, together with the\norganization of information in terms of streams of frames, enables us\nto implement both simple and compound queries.  We next discuss\nunification, a generalization of pattern matching needed to implement\nrules.  Finally, we show how the entire query interpreter fits\ntogether through a procedure that classifies expressions in a manner\nanalogous to the way <tt>eval</tt> classifies expressions for the\ninterpreter described in section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1">4.1</a>.<p>\n\n<a name="%_sec_Temp_668"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_668">Pattern matching</a></h4><p>\n\n<a name="%_idx_5174"></a><a name="%_idx_5176"></a>\nA <em>pattern matcher</em> is a program that tests whether some datum\nfits a specified pattern.  For example, the data list <tt>((a b) c (a\nb))</tt> matches the pattern <tt>(?x c ?x)</tt> with the pattern variable\n<tt>?x</tt> bound to <tt>(a b)</tt>.  The same data list matches the pattern\n<tt>(?x ?y ?z)</tt> with <tt>?x</tt> and <tt>?z</tt> both bound to <tt>(a b)</tt>\nand <tt>?y</tt> bound to <tt>c</tt>.  It also matches the pattern <tt>((?x&nbsp;?y)&nbsp;c&nbsp;(?x&nbsp;?y))</tt> with <tt>?x</tt> bound to <tt>a</tt> and <tt>?y</tt> bound\nto <tt>b</tt>.  However, it does not match the pattern <tt>(?x a ?y)</tt>,\nsince that pattern specifies a list whose second element is the symbol\n<tt>a</tt>.<p>\n\n<a name="%_idx_5178"></a><a name="%_idx_5180"></a>The pattern matcher used by the query system takes as inputs a\npattern, a datum, and a <em>frame</em> that specifies bindings for\nvarious pattern variables.  It checks whether the datum matches the\npattern in a way that is consistent with the bindings already in the\nframe.  If so, it returns the given frame augmented by any bindings\nthat may have been determined by the match.  Otherwise, it indicates\nthat the match has failed.<p>\n\nFor example, using the pattern <tt>(?x ?y ?x)</tt> to match <tt>(a b a)</tt>\ngiven an empty frame will return a frame specifying that <tt>?x</tt> is\nbound to <tt>a</tt> and <tt>?y</tt> is bound to <tt>b</tt>.  Trying the match\nwith the same pattern, the same datum, and a frame specifying that\n<tt>?y</tt> is bound to <tt>a</tt> will fail.  Trying the match with the\nsame pattern, the same datum, and a frame in which <tt>?y</tt> is bound\nto <tt>b</tt> and <tt>?x</tt> is unbound will return the given frame\naugmented by a binding of <tt>?x</tt> to <tt>a</tt>.<p>\n\n<a name="%_idx_5182"></a>The pattern matcher is all the mechanism that is needed to process\nsimple queries that don\'t involve rules.  For instance, to process the\nquery<p>\n\n<p><p><tt>(job&nbsp;?x&nbsp;(computer&nbsp;programmer))<br>\n</tt><p><p>\nwe scan through all assertions in the data base and select those that\nmatch the pattern with respect to an initially empty frame.  For each\nmatch we find, we use the frame returned by the match to instantiate\nthe pattern with a value for <tt>?x</tt>.\n\n<a name="%_sec_Temp_669"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_669">Streams of frames</a></h4><p>\n\n<a name="%_idx_5184"></a><a name="%_idx_5186"></a>\nThe testing of patterns against frames is organized through the use of\nstreams.  Given a single frame, the matching process runs through the\ndata-base entries one by one.  For each data-base entry, the matcher\ngenerates either a special symbol indicating that the match has failed\nor an extension to the frame.  The results for all the data-base\nentries are collected into a stream, which is passed through a filter\nto weed out the failures.  The result is a stream of all the frames\nthat extend the given frame via a match to some assertion in the data\nbase.<a name="call_footnote_Temp_670" href="#footnote_Temp_670"><sup><small>67</small></sup></a><p>\n\nIn our system, a query takes an input stream of frames and performs\nthe above matching operation for every frame in the stream, as\nindicated in figure&nbsp;<a href="#%_fig_4.4">4.4</a>.  That is, for each frame in\nthe input stream, the query generates a new stream consisting of all\nextensions to that frame by matches to assertions in the data base.\nAll these streams are then combined to form one huge stream, which\ncontains all possible extensions of every frame in the input stream.\nThis stream is the output of the query.<p>\n\n<a name="%_fig_4.4"></a><p><div align=left><table width=100%><tr><td><img src="ch4-Z-G-4.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 4.4:</b>&nbsp;&nbsp;A query processes a stream of frames.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_idx_5194"></a>To answer a simple query, we use the query with an input stream\nconsisting of a single empty frame.  The resulting output stream\ncontains all extensions to the empty frame (that is, all answers to\nour query).  This stream of frames is then used to generate a stream\nof copies of the original query pattern with the variables\ninstantiated by the values in each frame, and this is the stream that\nis finally printed.<p>\n\n<a name="%_sec_Temp_671"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_671">Compound queries</a></h4><p>\n\n<a name="%_idx_5196"></a>\nThe real elegance of the stream-of-frames implementation is evident\nwhen we deal with compound queries.  The processing of compound\nqueries makes use of the ability of our matcher to demand that a match\n<a name="%_idx_5198"></a>be consistent with a specified frame.  For example, to handle the <tt>and</tt> of two queries, such as<p>\n\n<p><p><tt>(and&nbsp;(can-do-job&nbsp;?x&nbsp;(computer&nbsp;programmer&nbsp;trainee))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(job&nbsp;?person&nbsp;?x))<br>\n</tt><p><p>\n(informally, ``Find all people who can do the job of a computer\nprogrammer trainee\'\'), we first find all entries that match the\npattern<p>\n\n<p><p><tt>(can-do-job&nbsp;?x&nbsp;(computer&nbsp;programmer&nbsp;trainee))<br>\n</tt><p><p>\nThis produces a stream of frames, each of which contains a binding for\n<tt>?x</tt>.  Then for each frame in the stream we find all entries that\nmatch<p>\n\n<p><p><tt>(job&nbsp;?person&nbsp;?x)<br>\n</tt><p><p>\nin a way that is consistent with the given binding for <tt>?x</tt>.  Each\nsuch match will produce a frame containing bindings for <tt>?x</tt> and\n<tt>?person</tt>.  The <tt>and</tt> of two queries can be viewed as a series\ncombination of the two component queries, as shown in\nfigure&nbsp;<a href="#%_fig_4.5">4.5</a>.  The frames that pass through the first\nquery filter are filtered and further extended by the second query.<p>\n\n<a name="%_fig_4.5"></a><p><div align=left><table width=100%><tr><td><img src="ch4-Z-G-5.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 4.5:</b>&nbsp;&nbsp;The <tt>and</tt> combination of two queries is\nproduced by operating on the stream of frames in series.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_idx_5200"></a>Figure&nbsp;<a href="#%_fig_4.6">4.6</a> shows the analogous method for computing the\n<tt>or</tt> of two queries as a parallel combination of the two component\nqueries.  The input stream of frames is extended separately by each\nquery.  The two resulting streams are then merged to produce the final\noutput stream.<p>\n\n<a name="%_fig_4.6"></a><p><div align=left><table width=100%><tr><td><img src="ch4-Z-G-6.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 4.6:</b>&nbsp;&nbsp;The <tt>or</tt> combination of two queries is produced by \noperating on the stream of frames in parallel and merging the\nresults.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_idx_5202"></a>Even from this high-level description, it is apparent that the\nprocessing of compound queries can be slow.\nFor example, since a query may produce more than one output frame for\neach input frame, and each query in an <tt>and</tt> gets its input frames\nfrom the previous query, an <tt>and</tt> query could, in the worst case,\nhave to perform a number of matches that is exponential in the number\nof queries (see exercise&nbsp;<a href="#%_thm_4.76">4.76</a>).<a name="call_footnote_Temp_672" href="#footnote_Temp_672"><sup><small>68</small></sup></a>\nThough systems for handling only simple queries are quite practical,\ndealing with complex queries is extremely difficult.<a name="call_footnote_Temp_673" href="#footnote_Temp_673"><sup><small>69</small></sup></a><p>\n\n<a name="%_idx_5204"></a>From the stream-of-frames viewpoint, the <tt>not</tt> of some query acts\nas a filter that removes all frames for which the query can be\nsatisfied.  For instance, given the pattern<p>\n\n<p><p><tt>(not&nbsp;(job&nbsp;?x&nbsp;(computer&nbsp;programmer)))<br>\n</tt><p><p>\nwe attempt, for each frame in the input stream, to produce extension\nframes that satisfy <tt>(job ?x (computer programmer))</tt>.  We remove\nfrom the input stream all frames for which such extensions exist.  The\nresult is a stream consisting of only those frames in which the\nbinding for <tt>?x</tt> does not satisfy <tt>(job ?x (computer\nprogrammer))</tt>.  For example, in processing the query<p>\n\n<p><p><tt>(and&nbsp;(supervisor&nbsp;?x&nbsp;?y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(not&nbsp;(job&nbsp;?x&nbsp;(computer&nbsp;programmer))))<br>\n</tt><p><p>\nthe first clause will generate frames with bindings for <tt>?x</tt> and\n<tt>?y</tt>.  The <tt>not</tt> clause will then filter\nthese by removing all frames in which the binding for <tt>?x</tt>\nsatisfies the restriction that <tt>?x</tt> is a computer\nprogrammer.<a name="call_footnote_Temp_674" href="#footnote_Temp_674"><sup><small>70</small></sup></a><p>\n\n<a name="%_idx_5206"></a>The <tt>lisp-value</tt> special form is implemented as a similar filter\non frame streams.  We use each frame in the stream to instantiate any\nvariables in the pattern, then apply the Lisp predicate.  We remove\nfrom the input stream all frames for which the predicate fails.\n\n<a name="%_sec_Temp_675"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_675">Unification</a></h4><p>\n\n<a name="%_idx_5208"></a><a name="%_idx_5210"></a>\nIn order to handle rules in the query language, we must be able to\nfind the rules whose conclusions match a given query pattern.  Rule\nconclusions are like assertions except that they can contain\nvariables, so we will need a generalization of pattern\nmatching -- called <em>unification</em> -- in which both the ``pattern\'\'\nand the ``datum\'\' may contain variables.<p>\n\nA unifier takes two patterns, each containing constants and variables,\nand determines whether it is possible to assign values to the\nvariables that will make the two patterns equal.  If so, it returns a\nframe containing these bindings.  For example, unifying <tt>(?x a\n?y)</tt> and <tt>(?y ?z a)</tt> will specify a frame in which <tt>?x</tt>, \n<tt>?y</tt>, and <tt>?z</tt> must all be bound to <tt>a</tt>.  On the other\nhand, unifying <tt>(?x ?y a)</tt> and <tt>(?x b ?y)</tt> will fail, because\nthere is no value for <tt>?y</tt> that can make the two patterns equal.\n(For the second elements of the patterns to be equal, <tt>?y</tt> would\nhave to be <tt>b</tt>; however, for the third elements to be equal, <tt>?y</tt> would have to be <tt>a</tt>.)  The unifier used in the query system,\nlike the pattern matcher, takes a frame as input and performs\nunifications that are consistent with this frame.<p>\n\nThe unification algorithm is the most technically difficult part of\nthe query system.  With complex patterns, performing unification may\nseem to require deduction.  To unify <tt>(?x ?x)</tt> and <tt>((a ?y c)\n(a b ?z))</tt>, for example, the algorithm must infer that <tt>?x</tt> should\nbe <tt>(a b c)</tt>,   <tt>?y</tt> should be <tt>b</tt>, and <tt>?z</tt> should\nbe <tt>c</tt>.  We may think of this process as solving a set of\nequations among the pattern components.  In general, these are\nsimultaneous equations, which may require substantial manipulation to\nsolve.<a name="call_footnote_Temp_676" href="#footnote_Temp_676"><sup><small>71</small></sup></a>  For example, unifying <tt>(?x\n?x)</tt> and <tt>((a ?y c) (a b ?z))</tt> may be thought of as specifying the\nsimultaneous equations<p>\n\n<p><p><tt>?x&nbsp; = &nbsp;(a&nbsp;?y&nbsp;c)<br>\n?x&nbsp; = &nbsp;(a&nbsp;b&nbsp;?z)<br>\n</tt><p><p>\nThese equations imply that<p>\n\n<p><p><tt>(a&nbsp;?y&nbsp;c)&nbsp; = &nbsp;(a&nbsp;b&nbsp;?z)<br>\n</tt><p><p>\nwhich in turn implies that<p>\n\n<p><p><tt>a&nbsp; = &nbsp;a,&nbsp;?y&nbsp; = &nbsp;b,&nbsp;c&nbsp; = &nbsp;?z,<br>\n</tt><p><p>\nand hence that<p>\n\n<p><p><tt>?x&nbsp; = &nbsp;(a&nbsp;b&nbsp;c)<br>\n</tt><p><p><p>\n\n<a name="%_idx_5212"></a><a name="%_idx_5214"></a>In a successful pattern match, all pattern variables become bound, and\nthe values to which they are bound contain only constants.  This is\nalso true of all the examples of unification we have seen so far.  In\ngeneral, however, a successful unification may not completely\ndetermine the variable values; some variables may remain unbound and\nothers may be bound to values that contain variables.<p>\n\nConsider the unification of <tt>(?x a)</tt> and <tt>((b ?y) ?z)</tt>.  We\ncan deduce that <tt>?x  =  (b ?y)</tt> and <tt>a  =  ?z</tt>, but we cannot\nfurther solve for <tt>?x</tt> or&nbsp;<tt>?y</tt>.  The unification doesn\'t fail,\nsince it is certainly possible to make the two patterns equal by\nassigning values to <tt>?x</tt> and <tt>?y</tt>.  Since this match in no way\nrestricts the values <tt>?y</tt> can take on, no binding for <tt>?y</tt> is\nput into the result frame.  The match does, however, restrict the\nvalue of&nbsp;<tt>?x</tt>.  Whatever value <tt>?y</tt> has, <tt>?x</tt> must be <tt>(b ?y)</tt>.  A binding of <tt>?x</tt> to the pattern <tt>(b ?y)</tt> is thus\nput into the frame.  If a value for <tt>?y</tt> is later determined and\nadded to the frame (by a pattern match or unification that is required\nto be consistent with this frame), the previously bound <tt>?x</tt> will\nrefer to this value.<a name="call_footnote_Temp_677" href="#footnote_Temp_677"><sup><small>72</small></sup></a>\n\n<a name="%_sec_Temp_678"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_678">Applying rules</a></h4><p>\n\n<a name="%_idx_5216"></a>\nUnification is the key to the component of the query system that makes\ninferences from rules. To see how this is accomplished, consider\nprocessing a query that involves applying a rule, such as<p>\n\n<p><p><tt>(lives-near&nbsp;?x&nbsp;(Hacker&nbsp;Alyssa&nbsp;P))<br>\n</tt><p><p>\nTo process this query, we first use the ordinary pattern-match\nprocedure described above to see if there are any assertions in the\ndata base that match this pattern.  (There will not be any in this\ncase, since our data base includes no direct assertions about who\nlives near whom.)  The next step is to attempt to unify the query\npattern with the conclusion of each rule.  We find that the pattern\nunifies with the conclusion of the rule<p>\n\n<p><p><tt>(rule&nbsp;(lives-near&nbsp;?person-1&nbsp;?person-2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(address&nbsp;?person-1&nbsp;(?town&nbsp;.&nbsp;?rest-1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(address&nbsp;?person-2&nbsp;(?town&nbsp;.&nbsp;?rest-2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(not&nbsp;(same&nbsp;?person-1&nbsp;?person-2))))<br>\n</tt><p><p>\nresulting in a frame specifying that <tt>?person-2</tt> is bound\nto <tt>(Hacker Alyssa P)</tt> and that <tt>?x</tt> should be bound to (have\nthe same value as) <tt>?person-1</tt>.  Now, relative to this frame, we\nevaluate the compound query given by the body of the rule.  Successful\nmatches will extend this frame by providing a binding for <tt>?person-1</tt>, and consequently a value for <tt>?x</tt>, which we can use to\ninstantiate the original query pattern.<p>\n\nIn general, the query evaluator uses the following method to apply a\nrule when trying to establish a query pattern in a frame that\nspecifies bindings for some of the pattern variables:<p>\n\n<p><ul>\n<li>Unify the query with the conclusion of the rule to form, if\nsuccessful, an extension of the original frame.<p>\n\n<li>Relative to the extended frame, evaluate the query formed by\nthe body of the rule.\n</ul><p><p>\n\n<a name="%_idx_5218"></a>Notice how similar this is to the method for applying a procedure in\nthe <tt>eval</tt>/<tt>apply</tt> evaluator for Lisp:\n<p><ul><p>\n\n<li>Bind the procedure\'s parameters to its arguments to form a\nframe that extends the original procedure environment.<p>\n\n<li>Relative to the extended environment, evaluate the expression\nformed by the body of the procedure.\n</ul><p><p>\n\nThe similarity between the two evaluators should come as no surprise.\nJust as procedure definitions are the means of abstraction in Lisp,\nrule definitions are the means of abstraction in the query language.\nIn each case, we unwind the abstraction by creating appropriate\nbindings and evaluating the rule or procedure body relative to these.\n<p>\n\n<a name="%_sec_Temp_679"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_679">Simple queries</a></h4><p>\n\n<a name="%_idx_5220"></a>\nWe saw earlier in this section how to evaluate simple queries in the\nabsence of rules.  Now that we have seen how to apply rules, we can\ndescribe how to evaluate simple queries by using both rules and\nassertions.<p>\n\nGiven the query pattern and a stream of frames, we produce, for each\nframe in the input stream, two streams:<p>\n\n<p><ul>\n<li>a stream of extended frames obtained by matching the pattern\nagainst all assertions in the data base (using the pattern matcher),\nand<p>\n\n<li>a stream of extended frames obtained by applying all\npossible rules (using the unifier).<a name="call_footnote_Temp_680" href="#footnote_Temp_680"><sup><small>73</small></sup></a>\n</ul><p><p>\n\nAppending these two streams produces a stream that consists of all the\nways that the given pattern can be satisfied consistent with the\noriginal frame.  These streams (one for each frame in the input\nstream) are now all combined to form one large stream, which therefore\nconsists of all the ways that any of the frames in the original input\nstream can be extended to produce a match with the given pattern.\n\n<a name="%_sec_Temp_681"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_681">The query evaluator and the driver loop</a></h4><p>\n\n<a name="%_idx_5226"></a>\nDespite the complexity of the underlying matching operations, the\nsystem is organized much like an evaluator for any language.  The\nprocedure that coordinates the matching operations is called <a name="%_idx_5228"></a><a name="%_idx_5230"></a><tt>qeval</tt>, and it plays a role analogous to that of the <tt>eval</tt>\nprocedure for Lisp.  <tt>Qeval</tt> takes as inputs a query and a stream\nof frames.  Its output is a stream of frames, corresponding to\nsuccessful matches to the query pattern, that extend some frame in the\ninput stream, as indicated in figure&nbsp;<a href="#%_fig_4.4">4.4</a>.  Like\n<tt>eval</tt>, <tt>qeval</tt> classifies the different types of expressions\n(queries) and dispatches to an appropriate procedure for each.  There\nis a procedure for each special form (<tt>and</tt>, <tt>or</tt>, <tt>not</tt>,\nand <tt>lisp-value</tt>) and one for simple queries.<p>\n\n<a name="%_idx_5232"></a><a name="%_idx_5234"></a>The driver loop, which is analogous to the <tt>driver-loop</tt> procedure\nfor the other evaluators in this chapter, reads queries from the\nterminal.  For each query, it calls <tt>qeval</tt> with the query and a\nstream that consists of a single empty frame.  This will produce the\nstream of all possible matches (all possible extensions to the empty\nframe).  For each frame in the resulting stream, it instantiates the\noriginal query using the values of the variables found in the frame.\nThis stream of instantiated queries is then printed.<a name="call_footnote_Temp_682" href="#footnote_Temp_682"><sup><small>74</small></sup></a><p>\n\n<a name="%_idx_5240"></a><a name="%_idx_5242"></a>The driver also checks for the special command <tt>assert!</tt>, which\nsignals that the input is not a query but rather an assertion or rule\nto be added to the data base.  For instance,<p>\n\n<p><p><tt>(assert!&nbsp;(job&nbsp;(Bitdiddle&nbsp;Ben)&nbsp;(computer&nbsp;wizard)))<br>\n(assert!&nbsp;(rule&nbsp;(wheel&nbsp;?person)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(supervisor&nbsp;?middle-manager&nbsp;?person)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(supervisor&nbsp;?x&nbsp;?middle-manager))))<br>\n</tt><p><p>\n\n<a name="%_sec_4.4.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.4.3">4.4.3&nbsp;&nbsp;Is Logic Programming Mathematical Logic?</a></h3><p>\n\n\n<a name="%_idx_5244"></a><a name="%_idx_5246"></a>\nThe means of combination used in the query language may at first seem\nidentical to the operations <tt>and</tt>, <tt>or</tt>, and <tt>not</tt> of\nmathematical logic, and the application of query-language rules is in\nfact accomplished through a legitimate method of\n<a name="%_idx_5248"></a>inference.<a name="call_footnote_Temp_683" href="#footnote_Temp_683"><sup><small>75</small></sup></a> This identification of the query language with mathematical\nlogic is not really valid, though, because the query language provides\na <a name="%_idx_5252"></a><em>control structure</em> that interprets the logical statements\nprocedurally.  We can often take advantage of this control structure.\nFor example, to find all of the supervisors of programmers we could\nformulate a query in either of two logically equivalent forms:<p>\n\n\n<p><p><tt>(and&nbsp;(job&nbsp;?x&nbsp;(computer&nbsp;programmer))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(supervisor&nbsp;?x&nbsp;?y))<br>\n</tt><p><p>\nor\n<p><p><tt>(and&nbsp;(supervisor&nbsp;?x&nbsp;?y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(job&nbsp;?x&nbsp;(computer&nbsp;programmer)))<br>\n</tt><p><p>\n<a name="%_idx_5254"></a>If a company has many more supervisors than programmers (the usual\ncase), it is better to use the first form rather than the second\nbecause the data base must be scanned for each intermediate result\n(frame) produced by the first clause of the <tt>and</tt>.<p>\n\n<a name="%_idx_5256"></a><a name="%_idx_5258"></a>The aim of logic programming is to provide the programmer with\ntechniques for decomposing a computational problem into two separate\nproblems: ``what\'\' is to be computed, and ``how\'\' this should be\ncomputed.  This is accomplished by selecting a subset of the\nstatements of mathematical logic that is powerful enough to be able to\ndescribe anything one might want to compute, yet weak enough to have a\ncontrollable procedural interpretation.  The intention here is that,\non the one hand, a program specified in a logic programming language\nshould be an effective program that can be carried out by a computer.\nControl (``how\'\' to compute) is effected by using the order of\nevaluation of the language.  We should be able to arrange the order of\nclauses and the order of subgoals within each clause so that the\ncomputation is done in an order deemed to be effective and efficient.\nAt the same time, we should be able to view the result of the\ncomputation (``what\'\' to compute) as a simple consequence of the laws\nof logic.<p>\n\nOur query language can be regarded as just such a procedurally\ninterpretable subset of mathematical logic.  An assertion represents a\nsimple fact (an atomic proposition).  A rule represents the\nimplication that the rule conclusion holds for those cases where the\nrule body holds.  A rule has a natural procedural interpretation: To\nestablish the conclusion of the rule, establish the body of the rule.\nRules, therefore, specify computations.  However, because rules can\nalso be regarded as statements of mathematical logic, we can justify\nany ``inference\'\' accomplished by a logic program by asserting that\nthe same result could be obtained by working entirely within\nmathematical logic.<a name="call_footnote_Temp_684" href="#footnote_Temp_684"><sup><small>76</small></sup></a><p>\n\n<a name="%_sec_Temp_685"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_685">Infinite loops</a></h4><p>\n\n<a name="%_idx_5260"></a>\nA consequence of the procedural interpretation of logic programs is\nthat it is possible to construct hopelessly inefficient programs for\nsolving certain problems.  An extreme case of inefficiency occurs when\nthe system falls into infinite loops in making deductions.  As a\nsimple example, suppose we are setting up a data base of famous\nmarriages, including<p>\n\n<a name="%_idx_5262"></a><p><p><tt>(assert!&nbsp;(married&nbsp;Minnie&nbsp;Mickey))<br>\n</tt><p><p>\nIf we now ask<p>\n\n<p><p><tt>(married&nbsp;Mickey&nbsp;?who)<br>\n</tt><p><p>\nwe will get no response, because the system doesn\'t know that if <em>A</em>\nis married to <em>B</em>, then <em>B</em> is married to <em>A</em>.  So we assert the rule<p>\n\n<p><p><tt>(assert!&nbsp;(rule&nbsp;(married&nbsp;?x&nbsp;?y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(married&nbsp;?y&nbsp;?x)))<br>\n</tt><p><p>\nand again query<p>\n\n<p><p><tt>(married&nbsp;Mickey&nbsp;?who)<br>\n</tt><p><p>\n\nUnfortunately, this will drive the system into an infinite loop, as\nfollows:<p>\n\n<p><ul>\n<li>The system finds that the <tt>married</tt> rule is applicable;\nthat is, the rule conclusion <tt>(married ?x ?y)</tt> successfully\nunifies with the query pattern <tt>(married Mickey ?who)</tt> to produce\na frame in which <tt>?x</tt> is bound to <tt>Mickey</tt> and <tt>?y</tt> is\nbound to <tt>?who</tt>.  So the interpreter proceeds to evaluate the rule\nbody <tt>(married ?y ?x)</tt> in this frame -- in effect, to process the\nquery <tt>(married ?who Mickey)</tt>.<p>\n\n<li>One answer appears directly as an assertion in the data\nbase: <tt>(married Minnie Mickey)</tt>.<p>\n\n<li>The <tt>married</tt> rule is also applicable, so the\ninterpreter again evaluates the rule body, which this time is\nequivalent to <tt>(married Mickey ?who)</tt>.\n</ul><p><p>\n\nThe system is now in an infinite loop.  Indeed, whether the system\nwill find the simple answer <tt>(married Minnie Mickey)</tt> before it\ngoes into the loop depends on implementation details concerning the\norder in which the system checks the items in the data base.  This is\na very simple example of the kinds of loops that can occur.\nCollections of interrelated rules can lead to loops that are much\nharder to anticipate, and the appearance of a loop can depend on the order\nof clauses in an <tt>and</tt> (see exercise&nbsp;<a href="#%_thm_4.64">4.64</a>)\nor on low-level details concerning the order in which the system\nprocesses queries.<a name="call_footnote_Temp_686" href="#footnote_Temp_686"><sup><small>77</small></sup></a>\n\n<a name="%_sec_Temp_687"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_687">Problems with <tt>not</tt></a></h4><p>\n\n<a name="%_idx_5266"></a>\n<a name="%_idx_5268"></a>Another quirk in the query system concerns <tt>not</tt>.  Given the data\nbase of section&nbsp;<a href="#%_sec_4.4.1">4.4.1</a>, consider the\nfollowing two queries:<p>\n\n<p><p><tt>(and&nbsp;(supervisor&nbsp;?x&nbsp;?y)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(not&nbsp;(job&nbsp;?x&nbsp;(computer&nbsp;programmer))))<br>\n(and&nbsp;(not&nbsp;(job&nbsp;?x&nbsp;(computer&nbsp;programmer)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(supervisor&nbsp;?x&nbsp;?y))<br>\n</tt><p><p>\nThese two queries do not produce the same result.  The first query\nbegins by finding all entries in the data base that match <tt>(supervisor ?x ?y)</tt>, and then filters the resulting frames by removing\nthe ones in which the value of <tt>?x</tt> satisfies <tt>(job ?x\n(computer programmer))</tt>.  The second query begins by filtering the\nincoming frames to remove those that can satisfy <tt>(job ?x\n(computer programmer))</tt>.  Since the only incoming frame is empty, it\nchecks the data base to see if there are any patterns that satisfy\n<tt>(job ?x (computer programmer))</tt>.  Since there generally are\nentries of this form, the <tt>not</tt> clause filters out the empty frame\nand returns an empty stream of frames.  Consequently, the entire\ncompound query returns an empty stream.<p>\n\nThe trouble is that our implementation of <tt>not</tt> really is meant to\nserve as a filter on values for the variables.  If a <tt>not</tt> clause\nis processed with a frame in which some of the variables remain\nunbound (as does <tt>?x</tt> in the example above), the system will\nproduce unexpected results. Similar problems occur with the use of\n<a name="%_idx_5270"></a><tt>lisp-value</tt> -- the Lisp predicate can\'t work if some of its\narguments are unbound.  See exercise&nbsp;<a href="#%_thm_4.77">4.77</a>.<p>\n\nThere is also a much more serious way in which the <tt>not</tt> of the\nquery language differs from the <tt>not</tt> of mathematical logic.  In\nlogic, we interpret the statement ``not <em>P</em>\'\' to mean that <em>P</em> is not\ntrue.  In the query system, however, ``not <em>P</em>\'\' means that <em>P</em> is not\ndeducible from the knowledge in the data base.  For example, given the\npersonnel data base of section&nbsp;<a href="#%_sec_4.4.1">4.4.1</a>, the\nsystem would happily deduce all sorts of <tt>not</tt> statements, such as\nthat Ben Bitdiddle is not a baseball fan, that it is not raining\noutside, and that 2 + 2 is not 4.<a name="call_footnote_Temp_688" href="#footnote_Temp_688"><sup><small>78</small></sup></a> In other words, the <tt>not</tt>\nof logic programming languages reflects the so-called <a name="%_idx_5272"></a><em>closed\nworld assumption</em> that all relevant information has been included in\nthe data base.<a name="call_footnote_Temp_689" href="#footnote_Temp_689"><sup><small>79</small></sup></a>\n\n<p><a name="%_thm_4.64"></a>\n<b>Exercise 4.64.</b>&nbsp;&nbsp;<a name="%_idx_5276"></a>Louis Reasoner mistakenly deletes the <tt>outranked-by</tt> rule\n(section&nbsp;<a href="#%_sec_4.4.1">4.4.1</a>) from the data base.  When\nhe realizes this, he quickly reinstalls it.  Unfortunately, he makes a\nslight change in the rule, and types it in as<p>\n\n<p><p><tt>(rule&nbsp;(outranked-by&nbsp;?staff-person&nbsp;?boss)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(supervisor&nbsp;?staff-person&nbsp;?boss)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(outranked-by&nbsp;?middle-manager&nbsp;?boss)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(supervisor&nbsp;?staff-person&nbsp;?middle-manager))))<br>\n</tt><p><p>\nJust after Louis types this information into the system, DeWitt\nAull comes by to find out who outranks Ben Bitdiddle. He issues\nthe query<p>\n\n<p><p><tt>(outranked-by&nbsp;(Bitdiddle&nbsp;Ben)&nbsp;?who)<br>\n</tt><p><p>\nAfter answering, the system goes into an infinite loop.  Explain why.\n\n<p><p>\n\n<p><a name="%_thm_4.65"></a>\n<b>Exercise 4.65.</b>&nbsp;&nbsp;<a name="%_idx_5278"></a>Cy D. Fect, looking forward to the day when he will rise in the\norganization, gives a query to find all the wheels\n(using the <tt>wheel</tt> rule of section&nbsp;<a href="#%_sec_4.4.1">4.4.1</a>):<p>\n\n<p><p><tt>(wheel&nbsp;?who)<br>\n</tt><p><p>\nTo his surprise, the system responds<p>\n\n<p><p><tt><i>;;;&nbsp;Query&nbsp;results:</i><br>\n(wheel&nbsp;(Warbucks&nbsp;Oliver))<br>\n(wheel&nbsp;(Bitdiddle&nbsp;Ben))<br>\n(wheel&nbsp;(Warbucks&nbsp;Oliver))<br>\n(wheel&nbsp;(Warbucks&nbsp;Oliver))<br>\n(wheel&nbsp;(Warbucks&nbsp;Oliver))<br>\n</tt><p><p>\nWhy is Oliver Warbucks listed four times?\n\n<p><p>\n\n<p><a name="%_thm_4.66"></a>\n<b>Exercise 4.66.</b>&nbsp;&nbsp;<a name="%_idx_5280"></a>Ben has been generalizing the query system to provide statistics\nabout the company.  For example, to find the total salaries of all the\ncomputer programmers one will be able to say<p>\n\n<p><p><tt>(sum&nbsp;?amount<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(job&nbsp;?x&nbsp;(computer&nbsp;programmer))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(salary&nbsp;?x&nbsp;?amount)))<br>\n</tt><p><p>\nIn general, Ben\'s new system allows expressions of the form<p>\n\n<p><p><tt>(accumulation-function&nbsp;&lt;<em>variable</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>query&nbsp;pattern</em>&gt;)<br>\n</tt><p><p>\nwhere <tt>accumulation-function</tt> can be things like <tt>sum</tt>,  \n<tt>average</tt>, or <tt>maximum</tt>.  Ben reasons that it should be a\ncinch to implement this.  He will simply feed the query pattern to\n<tt>qeval</tt>.  This will produce a stream of frames.  He will then pass\nthis stream through a mapping function that extracts the value of the\ndesignated variable from each frame in the stream and feed the\nresulting stream of values to the accumulation function.  Just as Ben\ncompletes the implementation and is about to try it out, Cy walks by,\nstill puzzling over the <tt>wheel</tt> query result in\nexercise&nbsp;<a href="#%_thm_4.65">4.65</a>.  When Cy shows Ben the system\'s\nresponse, Ben groans, ``Oh, no, my simple accumulation scheme won\'t\nwork!\'\'<p>\n\nWhat has Ben just realized?  Outline a method he can use to\nsalvage the situation.\n<p><p>\n\n<p><a name="%_thm_4.67"></a>\n<b>Exercise 4.67.</b>&nbsp;&nbsp;<a name="%_idx_5282"></a><a name="%_idx_5284"></a>Devise a way to install a loop detector in the query system so as to\navoid the kinds of simple loops illustrated in the text and in\nexercise&nbsp;<a href="#%_thm_4.64">4.64</a>.  The general idea is that the\nsystem should maintain some sort of history of its current chain of\ndeductions and should not begin processing a query that it is already\nworking on.  Describe what kind of information (patterns and frames)\nis included in this history, and how the check should be made.  (After\nyou study the details of the query-system implementation in\nsection&nbsp;<a href="#%_sec_4.4.4">4.4.4</a>, you may want to\nmodify the system to include your loop detector.)\n\n<p><p>\n\n<p><a name="%_thm_4.68"></a>\n<b>Exercise 4.68.</b>&nbsp;&nbsp;<a name="%_idx_5286"></a>Define rules to implement the <tt>reverse</tt> operation of\nexercise&nbsp;<a href="book-Z-H-15.html#%_thm_2.18">2.18</a>, which returns a list containing the same\nelements as a given list in reverse order.  (Hint: Use <tt>append-to-form</tt>.)\nCan your rules answer both\n<tt>(reverse (1 2 3) ?x)</tt> and <tt>(reverse ?x (1 2 3))</tt> ?\n<p><p>\n\n<p><a name="%_thm_4.69"></a>\n<b>Exercise 4.69.</b>&nbsp;&nbsp;Beginning with the data base and the rules you formulated in\nexercise&nbsp;<a href="#%_thm_4.63">4.63</a>, devise a rule for adding ``greats\'\' to\na grandson relationship. This should enable the system to deduce that\nIrad is the great-grandson of Adam, or that Jabal and Jubal are\nthe great-great-great-great-great-grandsons of Adam.  (Hint: Represent\nthe fact about Irad, for example, as <tt>((great grandson) Adam\nIrad)</tt>.  Write rules that determine if a list ends in the word\n<tt>grandson</tt>.  Use this to express a rule that allows one to derive\nthe relationship <tt>((great .  ?rel) ?x ?y)</tt>, where <tt>?rel</tt> is a\nlist ending in <tt>grandson</tt>.)\nCheck your rules on queries such as\n<tt>((great grandson) ?g ?ggs)</tt> and <tt>(?relationship Adam Irad)</tt>.\n\n<p>\n\n<a name="%_sec_4.4.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4">4.4.4&nbsp;&nbsp;Implementing the Query System</a></h3><p>\n\n<p>\n\nSection&nbsp;<a href="#%_sec_4.4.2">4.4.2</a> described how the query system\nworks. Now we fill in the details by presenting a complete\nimplementation of the system.<p>\n\n<a name="%_sec_4.4.4.1"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.1">4.4.4.1&nbsp;&nbsp;The Driver Loop and Instantiation</a></h4><p>\n\n<p>\n\n<a name="%_idx_5288"></a><a name="%_idx_5290"></a>The driver loop for the query system repeatedly reads input\nexpressions.  If the expression is a rule or assertion to be added to\nthe data base, then the information is added.  Otherwise the\nexpression is assumed to be a query.  The driver passes this query to\nthe evaluator <tt>qeval</tt> together with an initial frame stream\nconsisting of a single empty frame.  The result of the evaluation is a\nstream of frames generated by satisfying the query with variable\nvalues found in the data base.  These frames are used to form a new\nstream consisting of copies of the original query in which the\nvariables are instantiated with values supplied by the stream of\nframes, and this final stream is printed at the terminal:<p>\n\n<p><p><tt><a name="%_idx_5292"></a>(define&nbsp;input-prompt&nbsp;&quot;;;;&nbsp;Query&nbsp;input:&quot;)<br>\n(define&nbsp;output-prompt&nbsp;&quot;;;;&nbsp;Query&nbsp;results:&quot;)<br>\n<a name="%_idx_5294"></a>(define&nbsp;(query-driver-loop)<br>\n&nbsp;&nbsp;(prompt-for-input&nbsp;input-prompt)<br>\n&nbsp;&nbsp;(let&nbsp;((q&nbsp;(query-syntax-process&nbsp;(read))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((assertion-to-be-added?&nbsp;q)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-rule-or-assertion!&nbsp;(add-assertion-body&nbsp;q))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;&quot;Assertion&nbsp;added&nbsp;to&nbsp;data&nbsp;base.&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(query-driver-loop))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;output-prompt)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-map<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(instantiate&nbsp;q<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(v&nbsp;f)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(contract-question-mark&nbsp;v))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(qeval&nbsp;q&nbsp;(singleton-stream&nbsp;\'()))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(query-driver-loop)))))<br>\n</tt><p><p>\n<a name="%_idx_5296"></a>Here, as in the other evaluators in this chapter, we use an abstract\nsyntax for the expressions of the query language.\nThe implementation of the expression syntax, including the predicate\n<tt>assertion-to-be-added?</tt> and the selector <tt>add-assertion-body</tt>,\nis given in section&nbsp;<a href="#%_sec_4.4.4.7">4.4.4.7</a>.\n<tt>Add-rule-or-assertion!</tt> is defined in section&nbsp;<a href="#%_sec_4.4.4.5">4.4.4.5</a>.<p>\n\nBefore doing any processing on an input expression, the driver loop\ntransforms it syntactically into a form that makes the processing more\nefficient.  This involves changing the <a name="%_idx_5298"></a><a name="%_idx_5300"></a>representation of pattern\nvariables.  When the query is instantiated, any variables that remain\nunbound are transformed back to the input representation before being\nprinted.  These transformations are performed by the two procedures\n<tt>query-syntax-process</tt> and <tt>contract-question-mark</tt>\n(section &nbsp;<a href="#%_sec_4.4.4.7">4.4.4.7</a>).<p>\n\n<a name="%_idx_5302"></a>To instantiate an expression, we copy it, replacing any variables in\nthe expression by their values in a given frame.  The values are\nthemselves instantiated, since they could contain variables (for\nexample, if <tt>?x</tt> in <tt>exp</tt> is bound to <tt>?y</tt> as the result\nof unification and <tt>?y</tt> is in turn bound to&nbsp;5).  The action to\ntake if a variable cannot be instantiated is given by a procedural\nargument to <tt>instantiate</tt>.<p>\n\n<p><p><tt><a name="%_idx_5304"></a>(define&nbsp;(instantiate&nbsp;exp&nbsp;frame&nbsp;unbound-var-handler)<br>\n&nbsp;&nbsp;(define&nbsp;(copy&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((var?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((binding&nbsp;(binding-in-frame&nbsp;exp&nbsp;frame)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;binding<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(copy&nbsp;(binding-value&nbsp;binding))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unbound-var-handler&nbsp;exp&nbsp;frame))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((pair?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(copy&nbsp;(car&nbsp;exp))&nbsp;(copy&nbsp;(cdr&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;exp)))<br>\n&nbsp;&nbsp;(copy&nbsp;exp))<br>\n</tt><p><p>\nThe procedures that manipulate bindings are defined in\nsection&nbsp;<a href="#%_sec_4.4.4.8">4.4.4.8</a>.\n<p>\n\n<a name="%_sec_4.4.4.2"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.2">4.4.4.2&nbsp;&nbsp;The Evaluator</a></h4><p>\n\n<p>\n\n<a name="%_idx_5306"></a>The <tt>qeval</tt> procedure, called by the <tt>query-driver-loop</tt>, is\nthe basic evaluator of the query system.  It takes as inputs a query\nand a stream of frames, and it returns a stream of extended frames.\nIt identifies special forms by a <a name="%_idx_5308"></a>data-directed dispatch using <tt>get</tt> and <tt>put</tt>, just as we did in implementing generic operations\nin chapter&nbsp;2.  Any query that is not identified as a special form is\nassumed to be a simple query, to be processed by <tt>simple-query</tt>.<p>\n\n<p><p><tt><a name="%_idx_5310"></a>(define&nbsp;(qeval&nbsp;query&nbsp;frame-stream)<br>\n&nbsp;&nbsp;(let&nbsp;((qproc&nbsp;(get&nbsp;(type&nbsp;query)&nbsp;\'qeval)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;qproc<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(qproc&nbsp;(contents&nbsp;query)&nbsp;frame-stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(simple-query&nbsp;query&nbsp;frame-stream))))<br>\n</tt><p><p>\n<tt>Type</tt> and <tt>contents</tt>, defined in section&nbsp;<a href="#%_sec_4.4.4.7">4.4.4.7</a>,\nimplement the abstract syntax of the special forms.<p>\n\n<a name="%_sec_Temp_696"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_696">Simple queries</a></h4><p>\n\n<a name="%_idx_5312"></a>\nThe <tt>simple-query</tt> procedure handles simple queries.  It takes as\narguments a simple query (a pattern) together with a stream of frames,\nand it returns the stream formed by extending each frame by all\ndata-base matches of the query.<p>\n\n<p><p><tt><a name="%_idx_5314"></a>(define&nbsp;(simple-query&nbsp;query-pattern&nbsp;frame-stream)<br>\n&nbsp;&nbsp;(stream-flatmap<br>\n&nbsp;&nbsp;&nbsp;(lambda&nbsp;(frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-append-delayed<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(find-assertions&nbsp;query-pattern&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(delay&nbsp;(apply-rules&nbsp;query-pattern&nbsp;frame))))<br>\n&nbsp;&nbsp;&nbsp;frame-stream))<br>\n</tt><p><p><p>\n\nFor each frame in the input stream, we use <tt>find-assertions</tt>\n(section&nbsp;<a href="#%_sec_4.4.4.3">4.4.4.3</a>) to match the pattern against all\nassertions in the data base, producing a stream of extended frames,\nand we use <tt>apply-rules</tt> (section&nbsp;<a href="#%_sec_4.4.4.4">4.4.4.4</a>) to apply\nall possible rules, producing another stream of extended frames.\nThese two streams are combined (using <tt>stream-append-delayed</tt>,\nsection&nbsp;<a href="#%_sec_4.4.4.6">4.4.4.6</a>) to make a stream of all the ways that\nthe given pattern can be satisfied consistent with the original frame\n(see exercise&nbsp;<a href="#%_thm_4.71">4.71</a>).  The streams for the\nindividual input frames are combined using <tt>stream-flatmap</tt>\n(section&nbsp;<a href="#%_sec_4.4.4.6">4.4.4.6</a>) to form one large stream of all the\nways that any of the frames in the original input stream can be\nextended to produce a match with the given pattern.\n\n<a name="%_sec_Temp_697"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_697">Compound queries</a></h4><p>\n\n<a name="%_idx_5316"></a>\n<a name="%_idx_5318"></a><tt>And</tt> queries are handled as illustrated in\nfigure&nbsp;<a href="#%_fig_4.5">4.5</a> by the <tt>conjoin</tt> procedure.  <tt>Conjoin</tt> takes as inputs the conjuncts and the frame stream and\nreturns the stream of extended frames.  First, <tt>conjoin</tt> processes\nthe stream of frames to find the stream of all possible frame extensions\nthat satisfy the first query in the conjunction.  Then, using this as the new\nframe stream, it recursively applies <tt>conjoin</tt> to the rest of the\nqueries.<p>\n\n\n<p><p><tt><a name="%_idx_5320"></a>(define&nbsp;(conjoin&nbsp;conjuncts&nbsp;frame-stream)<br>\n&nbsp;&nbsp;(if&nbsp;(empty-conjunction?&nbsp;conjuncts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(conjoin&nbsp;(rest-conjuncts&nbsp;conjuncts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(qeval&nbsp;(first-conjunct&nbsp;conjuncts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame-stream))))<br>\n</tt><p><p>\nThe expression\n\n<p><p><tt>(put&nbsp;\'and&nbsp;\'qeval&nbsp;conjoin)<br>\n</tt><p><p>\nsets up <tt>qeval</tt> to dispatch to <tt>conjoin</tt> when an <tt>and</tt>\nform is encountered.<p>\n\n\n<a name="%_idx_5322"></a><tt>Or</tt> queries are handled similarly, as shown in\nfigure&nbsp;<a href="#%_fig_4.6">4.6</a>.  The output streams for the various\ndisjuncts of the <tt>or</tt> are computed separately and merged using the\n<tt>interleave-delayed</tt> procedure from section&nbsp;<a href="#%_sec_4.4.4.6">4.4.4.6</a>.\n(See exercises&nbsp;<a href="#%_thm_4.71">4.71</a> and&nbsp;<a href="#%_thm_4.72">4.72</a>.)<p>\n\n\n<p><p><tt><a name="%_idx_5324"></a>(define&nbsp;(disjoin&nbsp;disjuncts&nbsp;frame-stream)<br>\n&nbsp;&nbsp;(if&nbsp;(empty-disjunction?&nbsp;disjuncts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(interleave-delayed<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(qeval&nbsp;(first-disjunct&nbsp;disjuncts)&nbsp;frame-stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(delay&nbsp;(disjoin&nbsp;(rest-disjuncts&nbsp;disjuncts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame-stream)))))<br>\n(put&nbsp;\'or&nbsp;\'qeval&nbsp;disjoin)<br>\n</tt><p><p>\nThe predicates and selectors for the syntax of conjuncts and disjuncts\nare given in section&nbsp;<a href="#%_sec_4.4.4.7">4.4.4.7</a>.<p>\n\n<a name="%_sec_Temp_698"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_698">Filters</a></h4><p>\n\n<a name="%_idx_5326"></a><tt>Not</tt> is handled by the method outlined in\nsection&nbsp;<a href="#%_sec_4.4.2">4.4.2</a>.  We attempt to extend each frame in\nthe input stream to satisfy the query being negated, and we include a\ngiven frame in the output stream only if it cannot be extended.<p>\n\n<p><p><tt><a name="%_idx_5328"></a>(define&nbsp;(negate&nbsp;operands&nbsp;frame-stream)<br>\n&nbsp;&nbsp;(stream-flatmap<br>\n&nbsp;&nbsp;&nbsp;(lambda&nbsp;(frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(stream-null?&nbsp;(qeval&nbsp;(negated-query&nbsp;operands)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(singleton-stream&nbsp;frame)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(singleton-stream&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-stream))<br>\n&nbsp;&nbsp;&nbsp;frame-stream))<br>\n(put&nbsp;\'not&nbsp;\'qeval&nbsp;negate)<br>\n</tt><p><p><p>\n\n<a name="%_idx_5330"></a><tt>Lisp-value</tt> is a filter similar to <tt>not</tt>.  Each frame in the\nstream is used to instantiate the variables in the pattern, the\nindicated predicate is applied, and the frames for which the predicate\nreturns false are filtered out of the input stream.  An error results\nif there are unbound pattern variables.<p>\n\n<p><p><tt><a name="%_idx_5332"></a>(define&nbsp;(lisp-value&nbsp;call&nbsp;frame-stream)<br>\n&nbsp;&nbsp;(stream-flatmap<br>\n&nbsp;&nbsp;&nbsp;(lambda&nbsp;(frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(execute<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(instantiate<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(v&nbsp;f)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;pat&nbsp;var&nbsp;--&nbsp;LISP-VALUE&quot;&nbsp;v))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(singleton-stream&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-stream))<br>\n&nbsp;&nbsp;&nbsp;frame-stream))<br>\n(put&nbsp;\'lisp-value&nbsp;\'qeval&nbsp;lisp-value)<br>\n</tt><p><p><p>\n\n<tt>Execute</tt>, which applies the predicate to the arguments, must <tt>eval</tt> the predicate expression to get the procedure to apply.\nHowever, it must not evaluate the arguments, since they are already\nthe actual arguments, not expressions whose evaluation (in Lisp) will\nproduce the arguments.  Note that <tt>execute</tt> is implemented using\n<a name="%_idx_5334"></a><tt>eval</tt> and <tt>apply</tt> from the underlying Lisp system.<p>\n\n<p><p><tt>(define&nbsp;(execute&nbsp;exp)<br>\n&nbsp;&nbsp;(apply&nbsp;(eval&nbsp;(predicate&nbsp;exp)&nbsp;user-initial-environment)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(args&nbsp;exp)))<br>\n</tt><p><p><p>\n\nThe <tt>always-true</tt> special form provides for a query that is always\nsatisfied.  It ignores its contents (normally empty) and simply passes\nthrough all the frames in the input stream.  <tt>Always-true</tt> is used\nby the <tt>rule-body</tt> selector (section&nbsp;<a href="#%_sec_4.4.4.7">4.4.4.7</a>)\n<a name="%_idx_5336"></a>to provide bodies for rules that were\ndefined without bodies (that is, rules whose conclusions are always\nsatisfied).<p>\n\n<p><p><tt><a name="%_idx_5338"></a>(define&nbsp;(always-true&nbsp;ignore&nbsp;frame-stream)&nbsp;frame-stream)<br>\n(put&nbsp;\'always-true&nbsp;\'qeval&nbsp;always-true)<br>\n</tt><p><p>\nThe selectors that define the syntax of <tt>not</tt> and <tt>lisp-value</tt>\nare given in section&nbsp;<a href="#%_sec_4.4.4.7">4.4.4.7</a>.\n<p>\n\n<a name="%_sec_4.4.4.3"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.3">4.4.4.3&nbsp;&nbsp;Finding Assertions by Pattern Matching</a></h4><p>\n\n<p>\n\n<a name="%_idx_5340"></a><a name="%_idx_5342"></a><tt>Find-assertions</tt>, called by <tt>simple-query</tt>\n(section&nbsp;<a href="#%_sec_4.4.4.2">4.4.4.2</a>), takes as input a pattern and a frame.\nIt returns a stream of frames, each extending the given one by a\ndata-base match of the given pattern.  It uses <tt>fetch-assertions</tt>\n(section&nbsp;<a href="#%_sec_4.4.4.5">4.4.4.5</a>) to get a stream of all the assertions in\nthe data base that should be checked for a match against the pattern\nand the frame.  The reason for <tt>fetch-assertions</tt> here is that we\ncan often apply simple tests that will eliminate many of the entries\nin the data base from the pool of candidates for a successful match.\nThe system would still work if we eliminated <tt>fetch-assertions</tt>\nand simply checked a stream of all assertions in the data base, but\nthe computation would be less efficient because we would need to make\nmany more calls to the matcher.<p>\n\n<p><p><tt><a name="%_idx_5344"></a>(define&nbsp;(find-assertions&nbsp;pattern&nbsp;frame)<br>\n&nbsp;&nbsp;(stream-flatmap&nbsp;(lambda&nbsp;(datum)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(check-an-assertion&nbsp;datum&nbsp;pattern&nbsp;frame))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fetch-assertions&nbsp;pattern&nbsp;frame)))<br>\n</tt><p><p><p>\n\n<tt>Check-an-assertion</tt> takes as arguments a pattern, a data object\n(assertion), and a frame and returns either a one-element stream\ncontaining the extended frame or <tt>the-empty-stream</tt> if the match\nfails.<p>\n\n<p><p><tt>(define&nbsp;(check-an-assertion&nbsp;assertion&nbsp;query-pat&nbsp;query-frame)<br>\n&nbsp;&nbsp;(let&nbsp;((match-result<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pattern-match&nbsp;query-pat&nbsp;assertion&nbsp;query-frame)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;match-result&nbsp;\'failed)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(singleton-stream&nbsp;match-result))))<br>\n</tt><p><p>\nThe basic pattern matcher returns either the symbol <tt>failed</tt> or an\nextension of the given frame.  The basic idea of the matcher is to\ncheck the pattern against the data, element by element, accumulating\nbindings for the pattern variables.  If the pattern and the data\nobject are the same, the match succeeds and we return the frame of\nbindings accumulated so far.  Otherwise, if the pattern is a variable\nwe extend the current frame by binding the variable to the data, so\nlong as this is consistent with the bindings already in the frame.  If\nthe pattern and the data are both pairs, we (recursively) match the\n<tt>car</tt> of the pattern against the <tt>car</tt> of the data to produce\na frame; in this frame we then match the <tt>cdr</tt> of the pattern\nagainst the <tt>cdr</tt> of the data.  If none of these cases are\napplicable, the match fails and we return the symbol <tt>failed</tt>.<p>\n\n<p><p><tt><a name="%_idx_5346"></a>(define&nbsp;(pattern-match&nbsp;pat&nbsp;dat&nbsp;frame)<br>\n&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;frame&nbsp;\'failed)&nbsp;\'failed)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal?&nbsp;pat&nbsp;dat)&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((var?&nbsp;pat)&nbsp;(extend-if-consistent&nbsp;pat&nbsp;dat&nbsp;frame))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(pair?&nbsp;pat)&nbsp;(pair?&nbsp;dat))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pattern-match&nbsp;(cdr&nbsp;pat)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;dat)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pattern-match&nbsp;(car&nbsp;pat)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;dat)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;\'failed)))<br>\n</tt><p><p><p>\n\nHere is the procedure that extends a frame by adding a new binding, if\nthis is consistent with the bindings already in the frame:<p>\n\n<p><p><tt><a name="%_idx_5348"></a>(define&nbsp;(extend-if-consistent&nbsp;var&nbsp;dat&nbsp;frame)<br>\n&nbsp;&nbsp;(let&nbsp;((binding&nbsp;(binding-in-frame&nbsp;var&nbsp;frame)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;binding<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pattern-match&nbsp;(binding-value&nbsp;binding)&nbsp;dat&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(extend&nbsp;var&nbsp;dat&nbsp;frame))))<br>\n</tt><p><p>\nIf there is no binding for the variable in the frame, we simply add\nthe binding of the variable to the data.  Otherwise we match, in the\nframe, the data against the value of the variable in the frame.  If\nthe stored value contains only constants, as it must if it was stored\nduring pattern matching by <tt>extend-if-consistent</tt>, then the match\nsimply tests whether the stored and new values are the same.  If so,\nit returns the unmodified frame; if not, it returns a failure\nindication.  The stored value may, however, contain pattern variables\nif it was stored during unification (see section&nbsp;<a href="#%_sec_4.4.4.4">4.4.4.4</a>).\nThe recursive match of the stored pattern against the new data will add or\ncheck bindings for the variables in this pattern.  For example,\nsuppose we have a frame in which <tt>?x</tt> is bound to <tt>(f ?y)</tt> and\n<tt>?y</tt> is unbound, and we wish to augment this frame by a binding of\n<tt>?x</tt> to <tt>(f b)</tt>.  We look up <tt>?x</tt> and find that it is\nbound to <tt>(f ?y)</tt>.  This leads us to match <tt>(f ?y)</tt> against\nthe proposed new value <tt>(f b)</tt> in the same frame.  Eventually\nthis match extends the frame by adding a binding of <tt>?y</tt> to <tt>b</tt>.  <tt>?X</tt> remains bound to <tt>(f ?y)</tt>.  We never modify a stored\nbinding and we never store more than one binding for a given variable.<p>\n\nThe procedures used by <tt>extend-if-consistent</tt> to manipulate\nbindings are defined in section&nbsp;<a href="#%_sec_4.4.4.8">4.4.4.8</a>.<p>\n\n<a name="%_sec_Temp_699"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_699">Patterns with dotted tails</a></h4><p>\n\n<a name="%_idx_5350"></a>\n\nIf a pattern contains a dot followed by a pattern variable, the\npattern variable matches the rest of the data list (rather than the\nnext element of the data list), just as one would expect with the\ndotted-tail notation described in exercise&nbsp;<a href="book-Z-H-15.html#%_thm_2.20">2.20</a>.\nAlthough the pattern matcher we have just implemented doesn\'t look for\ndots, it does behave as we want.  This is because the Lisp <tt>read</tt>\nprimitive, which is used by <tt>query-driver-loop</tt> to read the query\nand represent it as a list structure, treats dots in a special way.<p>\n\n<a name="%_idx_5352"></a><a name="%_idx_5354"></a>When <tt>read</tt> sees a dot, instead of making the next item be the\nnext element of a list (the <tt>car</tt> of a <tt>cons</tt> whose <tt>cdr</tt>\nwill be the rest of the list) it makes the next item be the <tt>cdr</tt>\nof the list structure.  For example, the list structure produced by\n<tt>read</tt> for the pattern <tt>(computer ?type)</tt> could be constructed\nby evaluating the expression <tt>(cons \'computer (cons&nbsp;\'?type \'()))</tt>,\nand that for <tt>(computer . ?type)</tt> could be constructed by\nevaluating the expression <tt>(cons \'computer \'?type)</tt>.<p>\n\n\nThus, as <tt>pattern-match</tt> recursively compares <tt>car</tt>s and <tt>cdr</tt>s of a data list and a pattern that had a dot, it eventually\nmatches the variable after the dot (which is a <tt>cdr</tt> of the\npattern) against a sublist of the data list, binding the variable to\nthat list.  For example, matching the pattern <tt>(computer . ?type)</tt> against\n<tt>(computer&nbsp;programmer&nbsp;trainee)</tt> will match <tt>?type</tt> against the\nlist <tt>(programmer trainee)</tt>.\n\n<a name="%_sec_4.4.4.4"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.4">4.4.4.4&nbsp;&nbsp;Rules and Unification</a></h4><p>\n\n<p>\n\n<a name="%_idx_5356"></a><tt>Apply-rules</tt> is the rule analog of <tt>find-assertions</tt>\n(section&nbsp;<a href="#%_sec_4.4.4.3">4.4.4.3</a>).  It\ntakes as input a pattern and a frame, and it forms a stream of\nextension frames by applying rules from the data base.  <tt>Stream-flatmap</tt> maps <tt>apply-a-rule</tt> down the stream of possibly\napplicable rules (selected by <tt>fetch-rules</tt>, section&nbsp;<a href="#%_sec_4.4.4.5">4.4.4.5</a>)\nand combines the resulting streams of frames.<p>\n\n<p><p><tt><a name="%_idx_5358"></a>(define&nbsp;(apply-rules&nbsp;pattern&nbsp;frame)<br>\n&nbsp;&nbsp;(stream-flatmap&nbsp;(lambda&nbsp;(rule)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply-a-rule&nbsp;rule&nbsp;pattern&nbsp;frame))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fetch-rules&nbsp;pattern&nbsp;frame)))<br>\n</tt><p><p><p>\n\n<tt>Apply-a-rule</tt> applies rules using the method outlined in\nsection <a href="#%_sec_4.4.2">4.4.2</a>.  It first augments its argument\nframe by unifying the rule conclusion with the pattern in the given\nframe.  If this succeeds, it evaluates the rule body in this new\nframe.<p>\n\nBefore any of this happens, however, the program renames all the\nvariables in the rule with unique new names.  The reason for this is\nto prevent the variables for different rule applications from becoming\nconfused with each other.  For instance, if two rules both use a\nvariable named <tt>?x</tt>, then each one may add a binding for <tt>?x</tt>\nto the frame when it is applied.  These two <tt>?x</tt>\'s have nothing to\ndo with each other, and we should not be fooled into thinking that the\ntwo bindings must be consistent.  Rather than rename variables, we\ncould devise a more clever environment structure; however, the\nrenaming approach we have chosen here is the most straightforward,\neven if not the most efficient.  (See\nexercise&nbsp;<a href="#%_thm_4.79">4.79</a>.)  Here is the <tt>apply-a-rule</tt>\nprocedure:<p>\n\n<p><p><tt>(define&nbsp;(apply-a-rule&nbsp;rule&nbsp;query-pattern&nbsp;query-frame)<br>\n&nbsp;&nbsp;(let&nbsp;((clean-rule&nbsp;(rename-variables-in&nbsp;rule)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((unify-result<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unify-match&nbsp;query-pattern<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(conclusion&nbsp;clean-rule)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;query-frame)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;unify-result&nbsp;\'failed)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(qeval&nbsp;(rule-body&nbsp;clean-rule)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(singleton-stream&nbsp;unify-result))))))<br>\n</tt><p><p>\nThe selectors <tt>rule-body</tt> and <tt>conclusion</tt> that extract parts\nof a rule are defined in section&nbsp;<a href="#%_sec_4.4.4.7">4.4.4.7</a>.<p>\n\nWe generate unique variable names by associating a unique identifier\n(such as a number) with each rule application and combining this\nidentifier with the original variable names.  For example, if the\nrule-application identifier is 7, we might change each <tt>?x</tt> in\nthe rule to <tt>?x-7</tt> and each <tt>?y</tt> in the rule to <tt>?y-7</tt>.\n(<tt>Make-new-variable</tt> and <tt>new-rule-application-id</tt> are\nincluded with the syntax procedures in section&nbsp;<a href="#%_sec_4.4.4.7">4.4.4.7</a>.)<p>\n\n<p><p><tt>(define&nbsp;(rename-variables-in&nbsp;rule)<br>\n&nbsp;&nbsp;(let&nbsp;((rule-application-id&nbsp;(new-rule-application-id)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(tree-walk&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((var?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-new-variable&nbsp;exp&nbsp;rule-application-id))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((pair?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(tree-walk&nbsp;(car&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tree-walk&nbsp;(cdr&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(tree-walk&nbsp;rule)))<br>\n</tt><p><p>\n\n<a name="%_idx_5360"></a><a name="%_idx_5362"></a>The unification algorithm is implemented as a procedure that takes as\ninputs two patterns and a frame and returns either the extended frame\nor the symbol <tt>failed</tt>.\nThe unifier is like the pattern matcher except that it is\nsymmetrical -- variables are allowed on both sides of the match.\n<tt>Unify-match</tt> is basically the same as <tt>pattern-match</tt>,\nexcept that there is extra code (marked ``<tt>***</tt>\'\' below) to handle\nthe case where the object on the right side of the match is a variable.<p>\n\n<p><p><tt><a name="%_idx_5364"></a>(define&nbsp;(unify-match&nbsp;p1&nbsp;p2&nbsp;frame)<br>\n&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;frame&nbsp;\'failed)&nbsp;\'failed)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((equal?&nbsp;p1&nbsp;p2)&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((var?&nbsp;p1)&nbsp;(extend-if-possible&nbsp;p1&nbsp;p2&nbsp;frame))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((var?&nbsp;p2)&nbsp;(extend-if-possible&nbsp;p2&nbsp;p1&nbsp;frame))&nbsp;&nbsp;<em>;&nbsp;***</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(pair?&nbsp;p1)&nbsp;(pair?&nbsp;p2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unify-match&nbsp;(cdr&nbsp;p1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;p2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unify-match&nbsp;(car&nbsp;p1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;p2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;\'failed)))<br>\n</tt><p><p><p>\n\nIn unification, as in one-sided pattern matching, we want to accept a\nproposed extension of the frame only if it is consistent with existing\nbindings.  The procedure <tt>extend-if-possible</tt> used in unification\nis the same as the <tt>extend-if-consistent</tt> used in pattern matching\nexcept for two special checks, marked ``<tt>***</tt>\'\' in the program\nbelow.  In the first case, if the variable we are trying to match is\nnot bound, but the value we are trying to match it with\nis itself a (different) variable, it is\nnecessary to check to see if the value is bound, and if so, to match\nits value.  If both parties to the match are unbound, we may bind\neither to the other.<p>\n\nThe second check deals with attempts to bind a variable to a pattern\nthat includes that variable.  Such a situation can occur whenever a\nvariable is repeated in both patterns.  Consider, for example,\nunifying the two patterns <tt>(?x ?x)</tt> and <tt>(?y\n&lt;<em>expression involving <tt>?y</tt></em>&gt;)</tt> in a frame where both <tt>?x</tt>\nand <tt>?y</tt> are unbound.  First <tt>?x</tt> is matched\nagainst <tt>?y</tt>, making a binding of <tt>?x</tt> to <tt>?y</tt>.  Next, the same <tt>?x</tt> is matched against the given expression\ninvolving <tt>?y</tt>.\nSince <tt>?x</tt> is already bound to <tt>?y</tt>, this\nresults in matching <tt>?y</tt> against the expression.\nIf we think of the\nunifier as finding a set of values for the pattern variables that make\nthe patterns the same, then these patterns imply instructions to find\na <tt>?y</tt> such that <tt>?y</tt> is equal to the expression involving <tt>?y</tt>.\nThere is no general method for solving such\nequations, so we reject such bindings; these cases are recognized by\nthe predicate <tt>depends-on?</tt>.<a name="call_footnote_Temp_700" href="#footnote_Temp_700"><sup><small>80</small></sup></a>\nOn the other hand, we do not want to reject attempts\nto bind a variable to itself.  For example, consider unifying <tt>(?x&nbsp;?x)</tt>\nand <tt>(?y&nbsp;?y)</tt>.  The second attempt to bind <tt>?x</tt> to <tt>?y</tt> matches <tt>?y</tt> (the stored value of <tt>?x</tt>) against <tt>?y</tt>\n(the new value of <tt>?x</tt>).  This is taken care of by the <tt>equal?</tt> clause\nof <tt>unify-match</tt>.<p>\n\n<p><p><tt><a name="%_idx_5370"></a>(define&nbsp;(extend-if-possible&nbsp;var&nbsp;val&nbsp;frame)<br>\n&nbsp;&nbsp;(let&nbsp;((binding&nbsp;(binding-in-frame&nbsp;var&nbsp;frame)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;(binding<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unify-match<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(binding-value&nbsp;binding)&nbsp;val&nbsp;frame))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((var?&nbsp;val)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;***</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((binding&nbsp;(binding-in-frame&nbsp;val&nbsp;frame)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;binding<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unify-match<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;(binding-value&nbsp;binding)&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(extend&nbsp;var&nbsp;val&nbsp;frame))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((depends-on?&nbsp;val&nbsp;var&nbsp;frame)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;***</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'failed)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(extend&nbsp;var&nbsp;val&nbsp;frame)))))<br>\n</tt><p><p><p>\n\n<tt>Depends-on?</tt> is a predicate that tests whether an expression\nproposed to be the value of a pattern variable depends on the variable.\nThis must be done relative to the current frame because the expression\nmay contain occurrences of a variable that already has a value that\ndepends on our test variable.  The structure of <tt>depends-on?</tt> is a\nsimple recursive tree walk in which we substitute for the values of\nvariables whenever necessary.<p>\n\n<p><p><tt>(define&nbsp;(depends-on?&nbsp;exp&nbsp;var&nbsp;frame)<br>\n&nbsp;&nbsp;(define&nbsp;(tree-walk&nbsp;e)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((var?&nbsp;e)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(equal?&nbsp;var&nbsp;e)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((b&nbsp;(binding-in-frame&nbsp;e&nbsp;frame)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;b<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tree-walk&nbsp;(binding-value&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((pair?&nbsp;e)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(tree-walk&nbsp;(car&nbsp;e))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tree-walk&nbsp;(cdr&nbsp;e))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;false)))<br>\n&nbsp;&nbsp;(tree-walk&nbsp;exp))<br>\n</tt><p><p>\n\n<a name="%_sec_4.4.4.5"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.5">4.4.4.5&nbsp;&nbsp;Maintaining the Data Base</a></h4><p>\n\n\n<a name="%_idx_5372"></a>\n<a name="%_idx_5374"></a><a name="%_idx_5376"></a>One important problem in designing logic programming languages is that\nof arranging things so that as few irrelevant data-base entries as\npossible will be examined in checking a given pattern.  In our\nsystem, in addition to storing all assertions in one big stream,\nwe store all assertions whose <tt>car</tt>s are constant symbols\nin separate streams, in a table indexed by the symbol.  To fetch an\nassertion that may match a pattern, we first check to see if the <tt>car</tt> of the pattern is a constant symbol.  If so, we return (to be\ntested using the matcher) all the stored assertions that have the same\n<tt>car</tt>.  If the pattern\'s <tt>car</tt> is not a constant symbol, we\nreturn all the stored assertions.  Cleverer methods could also take\nadvantage of information in the frame, or try also to optimize the\ncase where the <tt>car</tt> of the pattern is not a constant symbol.  We\navoid building our criteria for indexing (using the <tt>car</tt>,\nhandling only the case of constant symbols) into the program; instead\nwe call on predicates and selectors that embody our criteria.<p>\n\n<p><p><tt>(define&nbsp;THE-ASSERTIONS&nbsp;the-empty-stream)<br>\n<a name="%_idx_5378"></a>(define&nbsp;(fetch-assertions&nbsp;pattern&nbsp;frame)<br>\n&nbsp;&nbsp;(if&nbsp;(use-index?&nbsp;pattern)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-indexed-assertions&nbsp;pattern)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-all-assertions)))<br>\n(define&nbsp;(get-all-assertions)&nbsp;THE-ASSERTIONS)<br>\n(define&nbsp;(get-indexed-assertions&nbsp;pattern)<br>\n&nbsp;&nbsp;(get-stream&nbsp;(index-key-of&nbsp;pattern)&nbsp;\'assertion-stream))<br>\n</tt><p><p>\n<tt>Get-stream</tt> looks up a stream in the table and returns an empty\nstream if nothing is stored there.<p>\n\n<p><p><tt>(define&nbsp;(get-stream&nbsp;key1&nbsp;key2)<br>\n&nbsp;&nbsp;(let&nbsp;((s&nbsp;(get&nbsp;key1&nbsp;key2)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;s&nbsp;s&nbsp;the-empty-stream)))<br>\n</tt><p><p><p>\n\nRules are stored similarly, using the <tt>car</tt> of the rule\nconclusion.  Rule conclusions are arbitrary patterns, however, so they\ndiffer from assertions in that they can contain variables.  A pattern\nwhose <tt>car</tt> is a constant symbol can match rules whose conclusions\nstart with a variable as well as rules whose conclusions have the same\n<tt>car</tt>.  Thus, when fetching rules that might match a pattern whose\n<tt>car</tt> is a constant symbol we fetch all rules whose conclusions\nstart with a variable as well as those whose conclusions have the same\n<tt>car</tt> as the pattern.  For this purpose we store all rules whose\nconclusions start with a variable in a separate stream in our table,\nindexed by the symbol <tt>?</tt>.<p>\n\n<p><p><tt>(define&nbsp;THE-RULES&nbsp;the-empty-stream)<br>\n<a name="%_idx_5380"></a>(define&nbsp;(fetch-rules&nbsp;pattern&nbsp;frame)<br>\n&nbsp;&nbsp;(if&nbsp;(use-index?&nbsp;pattern)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-indexed-rules&nbsp;pattern)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-all-rules)))<br>\n(define&nbsp;(get-all-rules)&nbsp;THE-RULES)<br>\n(define&nbsp;(get-indexed-rules&nbsp;pattern)<br>\n&nbsp;&nbsp;(stream-append<br>\n&nbsp;&nbsp;&nbsp;(get-stream&nbsp;(index-key-of&nbsp;pattern)&nbsp;\'rule-stream)<br>\n&nbsp;&nbsp;&nbsp;(get-stream&nbsp;\'?&nbsp;\'rule-stream)))<br>\n</tt><p><p><p>\n\n\n<tt>Add-rule-or-assertion!</tt> is used by <tt>query-driver-loop</tt> to\nadd assertions and rules to the data base.  Each item is stored in the\nindex, if appropriate, and in a stream of all assertions or rules in\nthe data base.<p>\n\n\n<p><p><tt><a name="%_idx_5382"></a>(define&nbsp;(add-rule-or-assertion!&nbsp;assertion)<br>\n&nbsp;&nbsp;(if&nbsp;(rule?&nbsp;assertion)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-rule!&nbsp;assertion)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add-assertion!&nbsp;assertion)))<br>\n(define&nbsp;(add-assertion!&nbsp;assertion)<br>\n&nbsp;&nbsp;(store-assertion-in-index&nbsp;assertion)<br>\n&nbsp;&nbsp;(let&nbsp;((old-assertions&nbsp;THE-ASSERTIONS))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;THE-ASSERTIONS<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;assertion&nbsp;old-assertions))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\'ok))<br>\n(define&nbsp;(add-rule!&nbsp;rule)<br>\n&nbsp;&nbsp;(store-rule-in-index&nbsp;rule)<br>\n&nbsp;&nbsp;(let&nbsp;((old-rules&nbsp;THE-RULES))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;THE-RULES&nbsp;(cons-stream&nbsp;rule&nbsp;old-rules))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\'ok))<br>\n</tt><p><p><p>\n\nTo actually store an assertion or a rule, we check to see if it can be\nindexed.  If so, we store it in the appropriate stream.<p>\n\n\n<p><p><tt>(define&nbsp;(store-assertion-in-index&nbsp;assertion)<br>\n&nbsp;&nbsp;(if&nbsp;(indexable?&nbsp;assertion)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((key&nbsp;(index-key-of&nbsp;assertion)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((current-assertion-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-stream&nbsp;key&nbsp;\'assertion-stream)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put&nbsp;key<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'assertion-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;assertion<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current-assertion-stream))))))<br>\n(define&nbsp;(store-rule-in-index&nbsp;rule)<br>\n&nbsp;&nbsp;(let&nbsp;((pattern&nbsp;(conclusion&nbsp;rule)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(indexable?&nbsp;pattern)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((key&nbsp;(index-key-of&nbsp;pattern)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((current-rule-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-stream&nbsp;key&nbsp;\'rule-stream)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(put&nbsp;key<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'rule-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;rule<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current-rule-stream)))))))<br>\n</tt><p><p><p>\n\nThe following procedures define how the data-base index is used.  A\npattern (an assertion or a rule conclusion) will be stored in the\ntable if it starts with a variable or a constant symbol.<p>\n\n\n<p><p><tt>(define&nbsp;(indexable?&nbsp;pat)<br>\n&nbsp;&nbsp;(or&nbsp;(constant-symbol?&nbsp;(car&nbsp;pat))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(var?&nbsp;(car&nbsp;pat))))<br>\n</tt><p><p>\nThe key under which a pattern is stored in the table is either <tt>?</tt> (if it starts with a variable) or the constant symbol with which\nit starts.<p>\n\n\n<p><p><tt>(define&nbsp;(index-key-of&nbsp;pat)<br>\n&nbsp;&nbsp;(let&nbsp;((key&nbsp;(car&nbsp;pat)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(var?&nbsp;key)&nbsp;\'?&nbsp;key)))<br>\n</tt><p><p>\nThe index will be used to retrieve items that might match a pattern if\nthe pattern starts with a constant symbol.<p>\n\n\n<p><p><tt>(define&nbsp;(use-index?&nbsp;pat)<br>\n&nbsp;&nbsp;(constant-symbol?&nbsp;(car&nbsp;pat)))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_4.70"></a>\n<b>Exercise 4.70.</b>&nbsp;&nbsp;What is the purpose of the <tt>let</tt> bindings in the procedures <tt>add-assertion!</tt> and <tt>add-rule!</tt> ?  What would be wrong with the\nfollowing implementation of <tt>add-assertion!</tt> ?\nHint: Recall the definition of the infinite stream of ones in\nsection&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.2">3.5.2</a>: <tt>(define ones (cons-stream 1 ones))</tt>.<p>\n\n<p><p><tt>(define&nbsp;(add-assertion!&nbsp;assertion)<br>\n&nbsp;&nbsp;(store-assertion-in-index&nbsp;assertion)<br>\n&nbsp;&nbsp;(set!&nbsp;THE-ASSERTIONS<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream&nbsp;assertion&nbsp;THE-ASSERTIONS))<br>\n&nbsp;&nbsp;\'ok)<br>\n</tt><p><p>\n<p>\n\n<a name="%_sec_4.4.4.6"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.6">4.4.4.6&nbsp;&nbsp;Stream Operations</a></h4><p>\n\n\n<a name="%_idx_5384"></a>\nThe query system uses a few stream operations that were not presented\nin chapter&nbsp;3.<p>\n\n\n<tt>Stream-append-delayed</tt> and <tt>interleave-delayed</tt>\nare just like <tt>stream-append</tt> and <tt>interleave</tt>\n(section&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.3">3.5.3</a>),\nexcept that they take a delayed argument (like the <tt>integral</tt>\nprocedure in section&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.4">3.5.4</a>).\nThis postpones looping in some cases (see exercise&nbsp;<a href="#%_thm_4.71">4.71</a>).<p>\n\n<p><p><tt><a name="%_idx_5386"></a>(define&nbsp;(stream-append-delayed&nbsp;s1&nbsp;delayed-s2)<br>\n&nbsp;&nbsp;(if&nbsp;(stream-null?&nbsp;s1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(force&nbsp;delayed-s2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-car&nbsp;s1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-append-delayed&nbsp;(stream-cdr&nbsp;s1)&nbsp;delayed-s2))))<br>\n<a name="%_idx_5388"></a>(define&nbsp;(interleave-delayed&nbsp;s1&nbsp;delayed-s2)<br>\n&nbsp;&nbsp;(if&nbsp;(stream-null?&nbsp;s1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(force&nbsp;delayed-s2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-car&nbsp;s1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(interleave-delayed&nbsp;(force&nbsp;delayed-s2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(delay&nbsp;(stream-cdr&nbsp;s1))))))<br>\n</tt><p><p><p>\n\n<tt>Stream-flatmap</tt>, which is used throughout the query evaluator to\nmap a procedure over a stream of frames and combine the resulting\nstreams of frames, is the stream analog of the <tt>flatmap</tt> procedure\nintroduced for ordinary lists in section&nbsp;<a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>.\nUnlike ordinary <tt>flatmap</tt>, however, we accumulate the streams with\nan interleaving process, rather than simply appending them (see\nexercises&nbsp;<a href="#%_thm_4.72">4.72</a> and &nbsp;<a href="#%_thm_4.73">4.73</a>).<p>\n\n<p><p><tt><a name="%_idx_5390"></a>(define&nbsp;(stream-flatmap&nbsp;proc&nbsp;s)<br>\n&nbsp;&nbsp;(flatten-stream&nbsp;(stream-map&nbsp;proc&nbsp;s)))<br>\n<a name="%_idx_5392"></a>(define&nbsp;(flatten-stream&nbsp;stream)<br>\n&nbsp;&nbsp;(if&nbsp;(stream-null?&nbsp;stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(interleave-delayed<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-car&nbsp;stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(delay&nbsp;(flatten-stream&nbsp;(stream-cdr&nbsp;stream))))))<br>\n</tt><p><p><p>\n\nThe evaluator also uses the following simple procedure\nto generate a stream consisting of a single element:<p>\n\n<p><p><tt><a name="%_idx_5394"></a>(define&nbsp;(singleton-stream&nbsp;x)<br>\n&nbsp;&nbsp;(cons-stream&nbsp;x&nbsp;the-empty-stream))<br>\n</tt><p><p>\n\n<a name="%_sec_4.4.4.7"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.7">4.4.4.7&nbsp;&nbsp;Query Syntax Procedures</a></h4><p>\n\n\n<a name="%_idx_5396"></a>\n<tt>Type</tt> and <tt>contents</tt>, used by <tt>qeval</tt>\n(section&nbsp;<a href="#%_sec_4.4.4.2">4.4.4.2</a>), specify that a\nspecial form is identified by the symbol in its <tt>car</tt>.\nThey are the same as the <tt>type-tag</tt> and <tt>contents</tt> procedures in\nsection&nbsp;<a href="book-Z-H-17.html#%_sec_2.4.2">2.4.2</a>, except for the error message.<p>\n\n<p><p><tt>(define&nbsp;(type&nbsp;exp)<br>\n&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;expression&nbsp;TYPE&quot;&nbsp;exp)))<br>\n(define&nbsp;(contents&nbsp;exp)<br>\n&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;expression&nbsp;CONTENTS&quot;&nbsp;exp)))<br>\n</tt><p><p><p>\n\nThe following procedures, used by <tt>query-driver-loop</tt>\n(in section <a href="#%_sec_4.4.4.1">4.4.4.1</a>), specify\nthat rules and assertions are added to the data base by expressions of\nthe form <tt>(assert! &lt;<em>rule-or-assertion</em>&gt;):</tt><p>\n\n<p><p><tt>(define&nbsp;(assertion-to-be-added?&nbsp;exp)<br>\n&nbsp;&nbsp;(eq?&nbsp;(type&nbsp;exp)&nbsp;\'assert!))<br>\n(define&nbsp;(add-assertion-body&nbsp;exp)<br>\n&nbsp;&nbsp;(car&nbsp;(contents&nbsp;exp)))<br>\n</tt><p><p><p>\n\nHere are the syntax definitions for the <tt>and</tt>,  <tt>or</tt>,  <tt>not</tt>, and <tt>lisp-value</tt> special forms\n(section&nbsp;<a href="#%_sec_4.4.4.2">4.4.4.2</a>):<p>\n\n<p><p><tt>(define&nbsp;(empty-conjunction?&nbsp;exps)&nbsp;(null?&nbsp;exps))<br>\n(define&nbsp;(first-conjunct&nbsp;exps)&nbsp;(car&nbsp;exps))<br>\n(define&nbsp;(rest-conjuncts&nbsp;exps)&nbsp;(cdr&nbsp;exps))<br>\n(define&nbsp;(empty-disjunction?&nbsp;exps)&nbsp;(null?&nbsp;exps))<br>\n(define&nbsp;(first-disjunct&nbsp;exps)&nbsp;(car&nbsp;exps))<br>\n(define&nbsp;(rest-disjuncts&nbsp;exps)&nbsp;(cdr&nbsp;exps))<br>\n(define&nbsp;(negated-query&nbsp;exps)&nbsp;(car&nbsp;exps))<br>\n(define&nbsp;(predicate&nbsp;exps)&nbsp;(car&nbsp;exps))<br>\n(define&nbsp;(args&nbsp;exps)&nbsp;(cdr&nbsp;exps))<br>\n</tt><p><p><p>\n\nThe following three procedures define the syntax of rules:<p>\n\n<p><p><tt>(define&nbsp;(rule?&nbsp;statement)<br>\n&nbsp;&nbsp;(tagged-list?&nbsp;statement&nbsp;\'rule))<br>\n(define&nbsp;(conclusion&nbsp;rule)&nbsp;(cadr&nbsp;rule))<br>\n(define&nbsp;(rule-body&nbsp;rule)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;(cddr&nbsp;rule))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'(always-true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(caddr&nbsp;rule)))<br>\n</tt><p><p><p>\n\n<a name="%_idx_5398"></a><a name="%_idx_5400"></a><tt>Query-driver-loop</tt> (section&nbsp;<a href="#%_sec_4.4.4.1">4.4.4.1</a>)\ncalls <tt>query-syntax-process</tt> to\ntransform pattern variables in the expression, which have the form\n<tt>?symbol</tt>, into the internal format <tt>(? symbol)</tt>.  That is to\nsay, a pattern such as <tt>(job ?x ?y)</tt> is actually represented\ninternally by the system as <tt>(job (? x) (? y))</tt>.  This increases\nthe efficiency of query processing, since it means that the system can\ncheck to see if an expression is a pattern variable by checking\nwhether the <tt>car</tt> of the expression is the symbol <tt>?</tt>, rather\nthan having to extract characters from the symbol.  The syntax\ntransformation is accomplished by the following\nprocedure:<a name="call_footnote_Temp_702" href="#footnote_Temp_702"><sup><small>81</small></sup></a><p>\n\n<p><p><tt>(define&nbsp;(query-syntax-process&nbsp;exp)<br>\n&nbsp;&nbsp;(map-over-symbols&nbsp;expand-question-mark&nbsp;exp))<br>\n<a name="%_idx_5412"></a>(define&nbsp;(map-over-symbols&nbsp;proc&nbsp;exp)<br>\n&nbsp;&nbsp;(cond&nbsp;((pair?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(map-over-symbols&nbsp;proc&nbsp;(car&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map-over-symbols&nbsp;proc&nbsp;(cdr&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((symbol?&nbsp;exp)&nbsp;(proc&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;exp)))<br>\n(define&nbsp;(expand-question-mark&nbsp;symbol)<br>\n&nbsp;&nbsp;(let&nbsp;((chars&nbsp;(symbol-&gt;string&nbsp;symbol)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(string=?&nbsp;(substring&nbsp;chars&nbsp;0&nbsp;1)&nbsp;&quot;?&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;\'?<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(substring&nbsp;chars&nbsp;1&nbsp;(string-length&nbsp;chars))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbol)))<br>\n</tt><p><p><p>\n\nOnce the variables are transformed in this way, the variables in a\npattern are lists starting with <tt>?</tt>,\nand the constant symbols (which need to be recognized for\ndata-base indexing, section&nbsp;<a href="#%_sec_4.4.4.5">4.4.4.5</a>) are just the symbols.<p>\n\n<p><p><tt>(define&nbsp;(var?&nbsp;exp)<br>\n&nbsp;&nbsp;(tagged-list?&nbsp;exp&nbsp;\'?))<br>\n(define&nbsp;(constant-symbol?&nbsp;exp)&nbsp;(symbol?&nbsp;exp))<br>\n</tt><p><p><p>\n\nUnique variables are constructed during rule application\n(in section <a href="#%_sec_4.4.4.4">4.4.4.4</a>) by means of\nthe following procedures.  The unique identifier for a rule\napplication is a number, which is incremented each time a rule is\napplied.<p>\n\n\n<p><p><tt>(define&nbsp;rule-counter&nbsp;0)<br>\n(define&nbsp;(new-rule-application-id)<br>\n&nbsp;&nbsp;(set!&nbsp;rule-counter&nbsp;(+&nbsp;1&nbsp;rule-counter))<br>\n&nbsp;&nbsp;rule-counter)<br>\n(define&nbsp;(make-new-variable&nbsp;var&nbsp;rule-application-id)<br>\n&nbsp;&nbsp;(cons&nbsp;\'?&nbsp;(cons&nbsp;rule-application-id&nbsp;(cdr&nbsp;var))))<br>\n</tt><p><p><p>\n\nWhen <tt>query-driver-loop</tt> instantiates the query to print the\nanswer, it converts any unbound pattern variables back to the right\nform for printing, using<p>\n\n<p><p><tt>(define&nbsp;(contract-question-mark&nbsp;variable)<br>\n&nbsp;&nbsp;(string-&gt;symbol<br>\n&nbsp;&nbsp;&nbsp;(string-append&nbsp;&quot;?&quot;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(number?&nbsp;(cadr&nbsp;variable))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-append&nbsp;(symbol-&gt;string&nbsp;(caddr&nbsp;variable))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;-&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(number-&gt;string&nbsp;(cadr&nbsp;variable)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(symbol-&gt;string&nbsp;(cadr&nbsp;variable))))))<br>\n</tt><p><p>\n\n<a name="%_sec_4.4.4.8"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.8">4.4.4.8&nbsp;&nbsp;Frames and Bindings</a></h4><p>\n\n<p>\n\n<a name="%_idx_5414"></a><a name="%_idx_5416"></a>Frames are represented as lists of bindings, which are\nvariable-value pairs:<p>\n\n<p><p><tt>(define&nbsp;(make-binding&nbsp;variable&nbsp;value)<br>\n&nbsp;&nbsp;(cons&nbsp;variable&nbsp;value))<br>\n(define&nbsp;(binding-variable&nbsp;binding)<br>\n&nbsp;&nbsp;(car&nbsp;binding))<br>\n(define&nbsp;(binding-value&nbsp;binding)<br>\n&nbsp;&nbsp;(cdr&nbsp;binding))<br>\n(define&nbsp;(binding-in-frame&nbsp;variable&nbsp;frame)<br>\n&nbsp;&nbsp;(assoc&nbsp;variable&nbsp;frame))<br>\n(define&nbsp;(extend&nbsp;variable&nbsp;value&nbsp;frame)<br>\n&nbsp;&nbsp;(cons&nbsp;(make-binding&nbsp;variable&nbsp;value)&nbsp;frame))<br>\n</tt><p><p>\n\n<p><a name="%_thm_4.71"></a>\n<b>Exercise 4.71.</b>&nbsp;&nbsp;Louis Reasoner wonders why the <tt>simple-query</tt> and <tt>disjoin</tt>\nprocedures (section&nbsp;<a href="#%_sec_4.4.4.2">4.4.4.2</a>) are implemented using\nexplicit <tt>delay</tt> operations, rather than being defined as follows:<p>\n\n<p><p><tt>(define&nbsp;(simple-query&nbsp;query-pattern&nbsp;frame-stream)<br>\n&nbsp;&nbsp;(stream-flatmap<br>\n&nbsp;&nbsp;&nbsp;(lambda&nbsp;(frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-append&nbsp;(find-assertions&nbsp;query-pattern&nbsp;frame)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply-rules&nbsp;query-pattern&nbsp;frame)))<br>\n&nbsp;&nbsp;&nbsp;frame-stream))<br>\n(define&nbsp;(disjoin&nbsp;disjuncts&nbsp;frame-stream)<br>\n&nbsp;&nbsp;(if&nbsp;(empty-disjunction?&nbsp;disjuncts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(interleave<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(qeval&nbsp;(first-disjunct&nbsp;disjuncts)&nbsp;frame-stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(disjoin&nbsp;(rest-disjuncts&nbsp;disjuncts)&nbsp;frame-stream))))<br>\n</tt><p><p>\nCan you give examples of queries where these simpler definitions would\nlead to undesirable behavior?\n\n<p><p>\n\n<p><a name="%_thm_4.72"></a>\n<b>Exercise 4.72.</b>&nbsp;&nbsp;Why do <tt>disjoin</tt> and <tt>stream-flatmap</tt> interleave the\nstreams rather than simply append them?  Give examples that illustrate\nwhy interleaving works better.  (Hint: Why did we use <tt>interleave</tt> in\nsection&nbsp;<a href="book-Z-H-24.html#%_sec_3.5.3">3.5.3</a>?)\n\n<p><p>\n\n<p><a name="%_thm_4.73"></a>\n<b>Exercise 4.73.</b>&nbsp;&nbsp;Why does <tt>flatten-stream</tt> use <tt>delay</tt> explicitly?\nWhat would be wrong with defining it as follows:\n<p><p><tt>(define&nbsp;(flatten-stream&nbsp;stream)<br>\n&nbsp;&nbsp;(if&nbsp;(stream-null?&nbsp;stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the-empty-stream<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(interleave<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-car&nbsp;stream)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flatten-stream&nbsp;(stream-cdr&nbsp;stream)))))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_4.74"></a>\n<b>Exercise 4.74.</b>&nbsp;&nbsp;<a name="%_idx_5418"></a>Alyssa P. Hacker proposes to use a simpler version of <tt>stream-flatmap</tt>\nin <tt>negate</tt>, <tt>lisp-value</tt>, and <tt>find-assertions</tt>.\nShe observes that the procedure that is mapped over the frame stream\nin these cases always produces either the empty stream or a singleton\nstream, so no interleaving is needed when combining these streams.<p>\n\n<p><p>a. Fill in the missing expressions in Alyssa\'s program.\n<p><p><tt>(define&nbsp;(simple-stream-flatmap&nbsp;proc&nbsp;s)<br>\n&nbsp;&nbsp;(simple-flatten&nbsp;(stream-map&nbsp;proc&nbsp;s)))<br>\n<br>\n(define&nbsp;(simple-flatten&nbsp;stream)<br>\n&nbsp;&nbsp;(stream-map&nbsp;&lt;<em>??</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-filter&nbsp;&lt;<em>??</em>&gt;&nbsp;stream)))<br>\n</tt><p><p>\n<p><p>b. Does the query system\'s behavior change if we change it in this way?\n<p><p>\n\n<p><a name="%_thm_4.75"></a>\n<b>Exercise 4.75.</b>&nbsp;&nbsp;<a name="%_idx_5420"></a><a name="%_idx_5422"></a><a name="%_idx_5424"></a>Implement for the query language a new special form called <tt>unique</tt>.  <tt>Unique</tt> should succeed if there is precisely one item\nin the data base satisfying a specified query.  For example,<p>\n\n<p><p><tt>(unique&nbsp;(job&nbsp;?x&nbsp;(computer&nbsp;wizard)))<br>\n</tt><p><p>\nshould print the one-item stream<p>\n\n<p><p><tt>(unique&nbsp;(job&nbsp;(Bitdiddle&nbsp;Ben)&nbsp;(computer&nbsp;wizard)))<br>\n</tt><p><p>\nsince Ben is the only computer wizard, and<p>\n\n<p><p><tt>(unique&nbsp;(job&nbsp;?x&nbsp;(computer&nbsp;programmer)))<br>\n</tt><p><p>\nshould print the empty stream, since there is more than one computer\nprogrammer.  Moreover,<p>\n\n<p><p><tt>(and&nbsp;(job&nbsp;?x&nbsp;?j)&nbsp;(unique&nbsp;(job&nbsp;?anyone&nbsp;?j)))<br>\n</tt><p><p>\nshould list all the jobs that are filled by only one person, and the\npeople who fill them.<p>\n\nThere are two parts to implementing <tt>unique</tt>.  The first is to\nwrite a procedure that handles this special form, and the second is to make\n<tt>qeval</tt> dispatch to that procedure.  The second part is trivial,\nsince <tt>qeval</tt> does its dispatching in a data-directed way.  If\nyour procedure is called <tt>uniquely-asserted</tt>, all you need to do\nis<p>\n\n<p><p><tt>(put&nbsp;\'unique&nbsp;\'qeval&nbsp;uniquely-asserted)<br>\n</tt><p><p>\nand <tt>qeval</tt> will dispatch to this procedure for every query whose\n<tt>type</tt> (<tt>car</tt>) is the symbol <tt>unique</tt>.<p>\n\nThe real problem is to write the procedure <tt>uniquely-asserted</tt>.\nThis should take as input the <tt>contents</tt> (<tt>cdr</tt>) of the <tt>unique</tt> query, together with a stream of frames.  For each frame in\nthe stream, it should use <tt>qeval</tt> to find the stream of all\nextensions to the frame that satisfy the given query.  Any stream that\ndoes not have exactly one item in it should be eliminated.  The\nremaining streams should be passed back to be accumulated into one big\nstream that is the result of the <tt>unique</tt> query.  This is similar\nto the implementation of the <tt>not</tt> special form.<p>\n\nTest your implementation by forming a query that lists all people who\nsupervise precisely one person.\n<p><p>\n\n<p><a name="%_thm_4.76"></a>\n<b>Exercise 4.76.</b>&nbsp;&nbsp;<a name="%_idx_5426"></a><a name="%_idx_5428"></a><a name="%_idx_5430"></a>Our implementation of <tt>and</tt> as a series combination of queries\n(figure&nbsp;<a href="#%_fig_4.5">4.5</a>) is elegant, but it is inefficient because in\nprocessing the second query of the <tt>and</tt> we must scan the data\nbase for each frame produced by the first query.  If the data base has\n<em>N</em> elements, and a typical query produces a number of output frames\nproportional to <em>N</em> (say <em>N</em>/<em>k</em>), then scanning the data base for each\nframe produced by the first query will require <em>N</em><sup>2</sup>/<em>k</em> calls to the\npattern matcher.  Another approach would be to process the two clauses\nof the <tt>and</tt> separately, then look for all pairs of output frames\nthat are compatible.  If each query produces <em>N</em>/<em>k</em> output frames, then\nthis means that we must perform <em>N</em><sup>2</sup>/<em>k</em><sup>2</sup> compatibility checks -- a\nfactor of <em>k</em> fewer than the number of matches required in our current\nmethod.<p>\n\nDevise an implementation of <tt>and</tt> that uses this strategy.  You\nmust implement a procedure that takes two frames as inputs, checks\nwhether the bindings in the frames are compatible, and, if so,\nproduces a frame that merges the two sets of bindings.  This operation\nis similar to unification.\n\n<p><p>\n\n<p><a name="%_thm_4.77"></a>\n<b>Exercise 4.77.</b>&nbsp;&nbsp;<a name="%_idx_5432"></a><a name="%_idx_5434"></a><a name="%_idx_5436"></a><a name="%_idx_5438"></a><a name="%_idx_5440"></a>In section&nbsp;<a href="#%_sec_4.4.3">4.4.3</a> we saw that <tt>not</tt> and <tt>lisp-value</tt> can cause the query language to give ``wrong\'\' answers if\nthese filtering operations are applied to frames in which variables\nare unbound.  Devise a way to fix this shortcoming.  One idea is to\nperform the filtering in a ``delayed\'\' manner by appending to the\nframe a ``promise\'\' to filter that is fulfilled only when enough\nvariables have been bound to make the operation possible.  We could\nwait to perform filtering until all other operations have been\nperformed.  However, for efficiency\'s sake, we would like to perform\nfiltering as soon as possible so as to cut down on the number of\nintermediate frames generated.\n\n<p><p>\n\n<p><a name="%_thm_4.78"></a>\n<b>Exercise 4.78.</b>&nbsp;&nbsp;<a name="%_idx_5442"></a>Redesign the query language as a nondeterministic program to be\nimplemented using the evaluator of\nsection&nbsp;<a href="book-Z-H-28.html#%_sec_4.3">4.3</a>, rather than as a stream\nprocess.  In this approach, each query will produce a single answer\n(rather than the stream of all answers) and the user can type <tt>try-again</tt> to see more answers.  You should find that much of the\nmechanism we built in this section is subsumed by nondeterministic\nsearch and backtracking.  You will probably also find, however, that\nyour new query language has subtle differences in behavior from the\none implemented here.  Can you find examples that illustrate this\ndifference?\n\n<p><p>\n\n<p><a name="%_thm_4.79"></a>\n<b>Exercise 4.79.</b>&nbsp;&nbsp;<a name="%_idx_5444"></a><a name="%_idx_5446"></a>When we implemented the Lisp evaluator in section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1">4.1</a>,\nwe saw how to use local environments to avoid name conflicts between\nthe parameters of procedures.  For example, in evaluating<p>\n\n<p><p><tt>(define&nbsp;(square&nbsp;x)<br>\n&nbsp;&nbsp;(*&nbsp;x&nbsp;x))<br>\n(define&nbsp;(sum-of-squares&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(+&nbsp;(square&nbsp;x)&nbsp;(square&nbsp;y)))<br>\n(sum-of-squares&nbsp;3&nbsp;4)<br>\n</tt><p><p>\nthere is no confusion between the <tt>x</tt> in <tt>square</tt> and the <tt>x</tt>\nin <tt>sum-of-squares</tt>, because we evaluate the body of each\nprocedure in an environment that is specially constructed to contain\nbindings for the local variables.  In the query system, we used a\ndifferent strategy to avoid name conflicts in applying rules.  Each\ntime we apply a rule we rename the variables with new names that are\nguaranteed to be unique.  The analogous strategy for the Lisp\nevaluator would be to do away with local environments and simply\nrename the variables in the body of a procedure each time we apply the\nprocedure.<p>\n\n<a name="%_idx_5448"></a><a name="%_idx_5450"></a><a name="%_idx_5452"></a><a name="%_idx_5454"></a>Implement for the query language a rule-application method that uses\nenvironments rather than renaming.  See if you can build on your\nenvironment structure to create constructs in the query language for\ndealing with large systems, such as the rule analog of\nblock-structured procedures.  Can you relate any of this to the\nproblem of making deductions in a context (e.g., ``If I supposed that\n<em>P</em> were true, then I would be able to deduce <em>A</em> and <em>B</em>.\'\') as a\nmethod of problem solving?  (This problem is open-ended.  A good\nanswer is probably worth a Ph.D.)\n\n<p>\n<p>\n\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_645" href="#call_footnote_Temp_645"><sup><small>58</small></sup></a> Logic programming has grown out of a long\n<a name="%_idx_5040"></a><a name="%_idx_5042"></a>history of research in automatic theorem proving.  Early\ntheorem-proving programs could accomplish very little, because they\nexhaustively searched the space of possible proofs.  The major\nbreakthrough that made such a search plausible was the discovery in\nthe early 1960s of the <a name="%_idx_5044"></a><em>unification algorithm</em> and the <a name="%_idx_5046"></a><em>resolution principle</em> (Robinson 1965).  Resolution was used, for\nexample, by <a name="%_idx_5048"></a><a name="%_idx_5050"></a>Green and Raphael (1968) (see also Green 1969) as the\nbasis for a deductive question-answering system.  During most of this\nperiod, researchers concentrated on algorithms that are guaranteed to\nfind a proof if one exists.  Such algorithms were difficult to control\nand to direct toward a proof.  <a name="%_idx_5052"></a>Hewitt (1969) recognized the\npossibility of merging the control structure of a programming language\nwith the operations of a logic-manipulation system, leading to the\nwork in automatic search mentioned in section&nbsp;<a href="book-Z-H-28.html#%_sec_4.3.1">4.3.1</a>\n(footnote&nbsp;<a href="book-Z-H-28.html#footnote_Temp_603">47</a>).  At the same time that this was being done,\n<a name="%_idx_5054"></a>Colmerauer, in Marseille, was developing rule-based systems for\nmanipulating natural language (see Colmerauer et al. 1973).  He\ninvented a programming language called <a name="%_idx_5056"></a>Prolog for representing those\nrules.  <a name="%_idx_5058"></a>Kowalski (1973; 1979), in Edinburgh, recognized that execution\nof a Prolog program could be interpreted as proving theorems (using a\nproof technique called linear <a name="%_idx_5060"></a>Horn-clause resolution).  The merging of\nthe last two strands led to the logic-programming movement.  Thus, in\nassigning credit for the development of logic programming, the French\ncan point to Prolog\'s genesis at the <a name="%_idx_5062"></a>University of Marseille, while\nthe British can highlight the work at the <a name="%_idx_5064"></a>University of Edinburgh.\nAccording to people at <a name="%_idx_5066"></a>MIT, logic programming was developed by these\ngroups in an attempt to figure out what Hewitt was talking about in\nhis brilliant but impenetrable Ph.D. thesis.  For a history of logic\n<a name="%_idx_5068"></a>programming, see Robinson 1983.\n\n<p><a name="footnote_Temp_646" href="#call_footnote_Temp_646"><sup><small>59</small></sup></a> To\nsee the correspondence between the rules and the procedure, let <tt>x</tt> in the procedure (where <tt>x</tt> is nonempty) correspond to <tt>(cons u v)</tt> in the rule.  Then <tt>z</tt> in the rule corresponds to the\n<tt>append</tt> of <tt>(cdr x)</tt> and <tt>y</tt>.\n\n<p><a name="footnote_Temp_647" href="#call_footnote_Temp_647"><sup><small>60</small></sup></a> This certainly does not\nrelieve the user of the entire problem of how to compute the answer.\nThere are many different mathematically equivalent sets of rules for\nformulating the <tt>append</tt> relation, only some of which can be\nturned into effective devices for computing in any direction.  In\naddition, sometimes ``what is\'\' information gives no clue ``how to\'\'\ncompute an answer.  For example, consider the problem of computing the\n<em>y</em> such that <em>y</em><sup>2</sup>  =  <em>x</em>.\n\n<p><a name="footnote_Temp_648" href="#call_footnote_Temp_648"><sup><small>61</small></sup></a> Interest in logic programming peaked\n<a name="%_idx_5080"></a><a name="%_idx_5082"></a><a name="%_idx_5084"></a>during the early 80s when the Japanese government began an ambitious\nproject aimed at building superfast computers optimized to run logic\nprogramming languages.  The speed of such computers was to be measured\nin LIPS (Logical Inferences Per Second) rather than the usual FLOPS\n(FLoating-point Operations Per Second).  Although the project\nsucceeded in developing hardware and software as originally planned,\nthe international computer industry moved in a different direction.\nSee <a name="%_idx_5086"></a><a name="%_idx_5088"></a>Feigenbaum and Shrobe 1993 for an overview evaluation of the\nJapanese project.  The logic programming community has also moved on\nto consider relational programming based on techniques other than\nsimple pattern matching, such as the ability to deal with numerical\nconstraints such as the ones illustrated in the constraint-propagation\nsystem of section&nbsp;<a href="book-Z-H-22.html#%_sec_3.3.5">3.3.5</a>.\n\n<p><a name="footnote_Temp_651" href="#call_footnote_Temp_651"><sup><small>62</small></sup></a> This uses the dotted-tail notation introduced in\nexercise&nbsp;<a href="book-Z-H-15.html#%_thm_2.20">2.20</a>.\n\n<p><a name="footnote_Temp_654" href="#call_footnote_Temp_654"><sup><small>63</small></sup></a> Actually, this description of <tt>not</tt> is valid only for simple cases.  The real behavior of <tt>not</tt>\nis more complex.  We will examine <tt>not</tt>\'s peculiarities in\nsections&nbsp;<a href="#%_sec_4.4.2">4.4.2</a> and&nbsp;<a href="#%_sec_4.4.3">4.4.3</a>.\n\n<p><a name="footnote_Temp_655" href="#call_footnote_Temp_655"><sup><small>64</small></sup></a> <tt>Lisp-value</tt> should be used only to perform an operation not\n<a name="%_idx_5134"></a>provided in the query language.  In particular, it should not\nbe used to test equality (since that is what the matching in the\nquery language is designed to do) or inequality (since that can\nbe done with the <tt>same</tt> rule shown below).\n\n<p><a name="footnote_Temp_658" href="#call_footnote_Temp_658"><sup><small>65</small></sup></a> Notice that we do not need <tt>same</tt> in order to make two things be\nthe same: We just use the same pattern variable for each -- in effect,\nwe have one thing instead of two things in the first place.  For\nexample, see <tt>?town</tt> in the <tt>lives-near</tt> rule and <tt>?middle-manager</tt> in the <tt>wheel</tt> rule below.\n<tt>Same</tt> is useful when we want to force two things to be\ndifferent, such as <tt>?person-1</tt> and <tt>?person-2</tt> in the <tt>lives-near</tt> rule.  Although using the same pattern variable in two\nparts of a query forces the same value to appear in both places, using\ndifferent pattern variables does not force different values to appear.\n(The values assigned to different pattern variables may be the same or\ndifferent.)\n\n<p><a name="footnote_Temp_659" href="#call_footnote_Temp_659"><sup><small>66</small></sup></a> We will also allow rules without bodies, as in <tt><a name="%_idx_5146"></a>same</tt>, and we will interpret such a rule to mean that the rule\nconclusion is satisfied by any values of the variables.\n\n<p><a name="footnote_Temp_670" href="#call_footnote_Temp_670"><sup><small>67</small></sup></a> Because matching is generally very expensive, we would\n<a name="%_idx_5188"></a>like to avoid applying the full matcher to every element of the data\nbase.  This is usually arranged by breaking up the process into a\nfast, coarse match and the final match.  The coarse match filters the\ndata base to produce a small set of candidates for the final match.\nWith care, we can arrange our data base so that some of the work of\ncoarse matching can be done when the data base is constructed rather\n<a name="%_idx_5190"></a><a name="%_idx_5192"></a>then when we want to select the candidates.  This is called <em>indexing</em> the data base.  There is a vast technology built around\ndata-base-indexing schemes.  Our implementation, described in\nsection&nbsp;<a href="#%_sec_4.4.4">4.4.4</a>, contains a\nsimple-minded form of such an optimization.\n\n<p><a name="footnote_Temp_672" href="#call_footnote_Temp_672"><sup><small>68</small></sup></a> But this kind of exponential explosion is not common in <tt>and</tt>\nqueries because the added conditions tend to reduce rather than expand\nthe number of frames produced.\n\n<p><a name="footnote_Temp_673" href="#call_footnote_Temp_673"><sup><small>69</small></sup></a> There is a large literature on data-base-management\nsystems that is concerned with how to handle complex queries\nefficiently.\n\n<p><a name="footnote_Temp_674" href="#call_footnote_Temp_674"><sup><small>70</small></sup></a> There is a subtle difference between this filter\nimplementation of <tt>not</tt> and the usual meaning of <tt>not</tt> in\nmathematical logic.  See section&nbsp;<a href="#%_sec_4.4.3">4.4.3</a>.\n\n<p><a name="footnote_Temp_676" href="#call_footnote_Temp_676"><sup><small>71</small></sup></a> In one-sided pattern matching, all the equations that\ncontain pattern variables are explicit and already solved for the\nunknown (the pattern variable).\n\n<p><a name="footnote_Temp_677" href="#call_footnote_Temp_677"><sup><small>72</small></sup></a> Another way to think of unification is that it generates the most\ngeneral pattern that is a specialization of the two input patterns.\nThat is, the unification of <tt>(?x a)</tt> and <tt>((b&nbsp;?y)&nbsp;?z)</tt> is <tt>((b ?y) a)</tt>, and the unification of <tt>(?x a ?y)</tt> and <tt>(?y ?z\na)</tt>, discussed above, is <tt>(a a a)</tt>.\nFor our implementation, it is more convenient to think of the result\nof unification as a frame rather than a pattern.\n\n<p><a name="footnote_Temp_680" href="#call_footnote_Temp_680"><sup><small>73</small></sup></a> Since unification is a\n<a name="%_idx_5222"></a><a name="%_idx_5224"></a>generalization of matching, we could simplify the system by using the\nunifier to produce both streams.  Treating the easy case with the\nsimple matcher, however, illustrates how matching (as opposed to\nfull-blown unification) can be useful in its own right.\n\n<p><a name="footnote_Temp_682" href="#call_footnote_Temp_682"><sup><small>74</small></sup></a> The reason we use streams (rather than lists) of frames is that the\n<a name="%_idx_5236"></a><a name="%_idx_5238"></a>recursive application of rules can generate\ninfinite numbers of values that satisfy a query.  The delayed\nevaluation embodied in streams is crucial here: The system will print\nresponses one by one as they are generated, regardless of whether\nthere are a finite or infinite number of responses.\n\n<p><a name="footnote_Temp_683" href="#call_footnote_Temp_683"><sup><small>75</small></sup></a> That a particular method of inference is\nlegitimate is not a trivial assertion.  One must prove that if one\nstarts with true premises, only true conclusions can be derived.  The\nmethod of inference represented by rule applications is <a name="%_idx_5250"></a><em>modus\nponens</em>, the familiar method of inference that says that if <em>A</em> is\ntrue and <em>A implies B</em> is true, then we may conclude that <em>B</em>\nis true.\n\n<p><a name="footnote_Temp_684" href="#call_footnote_Temp_684"><sup><small>76</small></sup></a> We must qualify this statement by\nagreeing that, in speaking of the ``inference\'\' accomplished by a\nlogic program, we assume that the computation terminates.\nUnfortunately, even this qualified statement is false for our\nimplementation of the query language (and also false for programs in\nProlog and most other current logic programming languages) because of\nour use of <tt>not</tt> and <tt>lisp-value</tt>.  As we will describe below,\nthe <tt>not</tt> implemented in the query language is not always\nconsistent with the <tt>not</tt> of mathematical logic, and <tt>lisp-value</tt> introduces additional complications.  We could implement a\nlanguage consistent with mathematical logic by simply removing <tt>not</tt> and <tt>lisp-value</tt> from the language and agreeing to write\nprograms using only simple queries, <tt>and</tt>, and <tt>or</tt>.  However,\nthis would greatly restrict the expressive power of the language.  One\nof the major concerns of research in logic programming is to find ways\nto achieve more consistency with mathematical logic without unduly\nsacrificing expressive power.\n\n<p><a name="footnote_Temp_686" href="#call_footnote_Temp_686"><sup><small>77</small></sup></a> This is not a problem of the logic but one of the\nprocedural interpretation of the logic provided by our interpreter.\nWe could write an interpreter that would not fall into a loop here.\nFor example, we could enumerate all the proofs derivable from our\nassertions and our rules in a breadth-first rather than a depth-first\norder.  However, such a system makes it more difficult to take\nadvantage of the order of deductions in our programs.  One attempt to\nbuild sophisticated control into such a program is described in\n<a name="%_idx_5264"></a>deKleer et al. 1977.  Another technique, which does not lead to such\nserious control problems, is to put in special knowledge, such as\ndetectors for particular kinds of loops\n(exercise&nbsp;<a href="#%_thm_4.67">4.67</a>).  However, there can be no\ngeneral scheme for reliably preventing a system from going down\ninfinite paths in performing deductions.  Imagine a diabolical rule of\nthe form ``To show <em>P</em>(<em>x</em>) is true, show that <em>P</em>(<em>f</em>(<em>x</em>)) is true,\'\' for\nsome suitably chosen function <em>f</em>.\n\n<p><a name="footnote_Temp_688" href="#call_footnote_Temp_688"><sup><small>78</small></sup></a> Consider the query <tt>(not (baseball-fan (Bitdiddle Ben)))</tt>.  The system finds that <tt>(baseball-fan (Bitdiddle Ben))</tt> is not in the data base, so the empty\nframe does not satisfy the pattern and is not filtered out of the\ninitial stream of frames.  The result of the query is thus the empty\nframe, which is used to instantiate the input query to produce <tt>(not (baseball-fan (Bitdiddle Ben)))</tt>.\n\n<p><a name="footnote_Temp_689" href="#call_footnote_Temp_689"><sup><small>79</small></sup></a> A discussion and justification of this\n<a name="%_idx_5274"></a>treatment of <tt>not</tt> can be found in the article by Clark (1978).\n\n<p><a name="footnote_Temp_700" href="#call_footnote_Temp_700"><sup><small>80</small></sup></a> In general, unifying <tt>?y</tt> with an expression involving\n<a name="%_idx_5366"></a><tt>?y</tt> would require our being able to find a fixed point of the\nequation <tt>?y</tt>  =  &lt;<em>expression involving <tt>?y</tt></em>&gt;.  It is\nsometimes possible to syntactically form an expression that appears to\nbe the solution.  For example, <tt>?y</tt>&nbsp; = &nbsp;<tt>(f ?y)</tt> seems to have\nthe fixed point <tt>(f (f (f <tt>...</tt> )))</tt>, which we can produce by\nbeginning with the expression <tt>(f ?y)</tt> and repeatedly substituting\n<tt>(f ?y)</tt> for <tt>?y</tt>.  Unfortunately, not every such equation has\na meaningful fixed point.  The issues that arise here are similar to\nthe issues of manipulating <a name="%_idx_5368"></a>infinite series in mathematics.  For\nexample, we know that 2 is the solution to the equation <em>y</em>  =  1  +  <em>y</em>/2.\nBeginning with the expression 1  +  <em>y</em>/2 and repeatedly substituting 1\n +  <em>y</em>/2 for <em>y</em> gives\n<p><div align=left><img src="ch4-Z-G-7.gif" border="0"></div><p>\nwhich leads to\n<p><div align=left><img src="ch4-Z-G-8.gif" border="0"></div><p>\nHowever, if we try the same manipulation beginning with the\nobservation that  - 1 is the solution to the equation <em>y</em>  =  1  +  2<em>y</em>, we\nobtain\n<p><div align=left><img src="ch4-Z-G-9.gif" border="0"></div><p>\nwhich leads to \n<p><div align=left><img src="ch4-Z-G-10.gif" border="0"></div><p>\nAlthough the formal manipulations used in deriving these two equations\nare identical, the first result is a valid assertion about infinite\nseries but the second is not.  Similarly, for our unification results,\nreasoning with an arbitrary syntactically constructed expression may\nlead to errors.\n\n<p><a name="footnote_Temp_702" href="#call_footnote_Temp_702"><sup><small>81</small></sup></a> Most Lisp systems give the user the ability to\nmodify the ordinary <tt>read</tt> procedure to perform such\ntransformations by defining <a name="%_idx_5402"></a><a name="%_idx_5404"></a><a name="%_idx_5406"></a><a name="%_idx_5408"></a><em>reader macro characters</em>.  Quoted\nexpressions are already handled in this way: The reader automatically\ntranslates <tt>\'expression</tt> into <tt>(quote expression)</tt> before the\nevaluator sees it.  We could arrange for <tt>?expression</tt> to be\ntransformed into <tt>(? expression)</tt> in the same way; however, for\nthe sake of clarity we have included the transformation procedure here\nexplicitly.<p>\n\n<a name="%_idx_5410"></a><tt>Expand-question-mark</tt> and <tt>contract-question-mark</tt> use\nseveral procedures with <tt>string</tt> in their names.\nThese are Scheme primitives.\n\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_chap_5"></a>\n<h1 class=chapter>\n<div class=chapterheading><a href="book-Z-H-4.html#%_toc_%_chap_5">Chapter 5</a></div><p>\n<a href="book-Z-H-4.html#%_toc_%_chap_5">Computing with Register Machines</a></h1><p>\n\n<p>\n<div align=right> \n<table width=60%><tr><td>\n<span class=epigraph>\n<p>\n\nMy aim is to show that the heavenly machine is not a kind of divine,\nlive being, but a kind of clockwork (and he who believes that a clock\nhas soul attributes the maker\'s glory to the work), insofar as nearly\nall the manifold motions are caused by a most simple and material\nforce, just as all motions of the clock are caused by a single weight.<p>\n\n<a name="%_idx_5456"></a>Johannes Kepler (letter to Herwart von Hohenburg, 1605)<p>\n\n</span>\n</td></tr></table>\n</div>\n\n<p><p>\n\n\nWe began this book by studying processes and by describing processes\nin terms of procedures written in Lisp.  To explain the meanings of\nthese procedures, we used a succession of models of evaluation: the\nsubstitution model of chapter&nbsp;1, the environment model of chapter&nbsp;3,\nand the metacircular evaluator of chapter&nbsp;4.  Our examination of the\nmetacircular evaluator, in particular, dispelled much of the mystery\nof how Lisp-like languages are interpreted.\nBut even the metacircular evaluator leaves important questions\nunanswered, because it fails to elucidate the mechanisms of control in\na Lisp system.  For instance, the evaluator does not explain how the\nevaluation of a subexpression manages to return a value to the\nexpression that uses this value, nor does the evaluator explain how\nsome recursive procedures generate iterative processes (that is, are evaluated\nusing constant space) whereas other recursive procedures generate recursive\nprocesses.  These questions remain unanswered because the metacircular\nevaluator is itself a Lisp program and hence inherits the control\nstructure of the underlying Lisp system.  In order to provide a more\ncomplete description of the control structure of the Lisp evaluator,\nwe must work at a more primitive level than Lisp itself.<p>\n\nIn this chapter we will describe processes in terms of the step-by-step\noperation of a traditional computer.  Such a computer, or <a name="%_idx_5458"></a><em>register\nmachine</em>, sequentially executes <em>instructions</em> that\nmanipulate the contents of a fixed set of storage elements called <a name="%_idx_5460"></a><em>registers</em>.  A typical register-machine instruction applies a\nprimitive operation to the contents of some registers and assigns the\nresult to another register.  Our descriptions of processes executed by\nregister machines will look very much like ``machine-language\'\'\nprograms for traditional computers.  However, instead of focusing on\nthe machine language of any particular computer, we will examine\nseveral Lisp procedures and design a specific register machine to\nexecute each procedure.  Thus, we will approach our task from the\nperspective of a hardware architect rather than that of a\nmachine-language computer programmer.  In designing register machines,\nwe will develop mechanisms for implementing important programming\nconstructs such as recursion.  We will also present a language for\ndescribing designs for register machines.  In\nsection&nbsp;<a href="book-Z-H-32.html#%_sec_5.2">5.2</a> we will\nimplement a Lisp program that\nuses these descriptions to simulate the machines we design.<p>\n\nMost of the primitive operations of our register machines are very\nsimple.  For example, an operation might add the numbers fetched from\ntwo registers, producing a result to be stored into a third register.\nSuch an operation can be performed by easily described hardware.  In\norder to deal with list structure, however, we will also use the\nmemory operations <tt>car</tt>, <tt>cdr</tt>, and <tt>cons</tt>, which require\nan elaborate storage-allocation mechanism.  In\nsection&nbsp;<a href="book-Z-H-33.html#%_sec_5.3">5.3</a> we study their implementation in\nterms of more elementary operations.<p>\n\nIn section&nbsp;<a href="book-Z-H-34.html#%_sec_5.4">5.4</a>, after we have accumulated experience\nformulating simple procedures as register machines, we will design a\nmachine that carries out the algorithm described by the metacircular\nevaluator of section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1">4.1</a>.  This will fill in the gap in\nour understanding of how Scheme expressions are interpreted, by\nproviding an explicit model for the mechanisms of control in the\nevaluator.\nIn section&nbsp;<a href="book-Z-H-35.html#%_sec_5.5">5.5</a> we will study a simple compiler that\ntranslates Scheme programs into sequences of instructions that can be\nexecuted directly with the registers and operations of the evaluator\nregister machine.<p>\n\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_5.1"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_5.1">5.1&nbsp;&nbsp;Designing Register Machines</a></h2><p>\n\n\n<a name="%_idx_5462"></a><a name="%_idx_5464"></a><a name="%_idx_5466"></a><a name="%_idx_5468"></a><a name="%_idx_5470"></a><a name="%_idx_5472"></a>\n\nTo design a register machine, we must design its <em>data paths</em>\n(registers and operations) and the <em>controller</em> that sequences\nthese operations.  To illustrate the design of a simple register\nmachine, let us examine Euclid\'s Algorithm, which is used to compute\n<a name="%_idx_5474"></a>the greatest common divisor (GCD) of two integers.  As we saw in\n<a name="%_idx_5476"></a>section&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.5">1.2.5</a>, Euclid\'s Algorithm can be carried out by an iterative\nprocess, as specified by the following procedure:<p>\n\n\n<p><p><tt>(define&nbsp;(gcd&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;b&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gcd&nbsp;b&nbsp;(remainder&nbsp;a&nbsp;b))))<br>\n</tt><p><p><p>\n\nA machine to carry out this algorithm must keep track of two numbers,\n<em>a</em> and <em>b</em>, so let us assume that these numbers are stored in two\nregisters with those names.  The basic operations required are testing\nwhether the contents of register <tt>b</tt> is zero and computing the\nremainder of the contents of register <tt>a</tt> divided by the contents\nof register <tt>b</tt>.  The remainder operation is a complex process,\nbut assume for the moment that we have a primitive device that\ncomputes remainders.  On each cycle of the GCD algorithm, the contents\nof register <tt>a</tt> must be replaced by the contents of register <tt>b</tt>, and the contents of <tt>b</tt> must be replaced by the remainder of\nthe old contents of <tt>a</tt> divided by the old contents of <tt>b</tt>.\nIt would be convenient if these replacements could be done\nsimultaneously, but in our model of register machines we will assume\nthat only one register can be assigned a new value at each step.  To\naccomplish the replacements, our machine will use a third\n``temporary\'\' register, which we call <tt>t</tt>.  (First the remainder\nwill be placed in <tt>t</tt>, then the contents of <tt>b</tt> will be placed\nin <tt>a</tt>, and finally the remainder stored in <tt>t</tt> will be placed\nin <tt>b</tt>.)<p>\n\n<a name="%_idx_5478"></a><a name="%_idx_5480"></a>We can illustrate the registers and operations required for this\nmachine by using the data-path diagram shown in\nfigure&nbsp;<a href="#%_fig_5.1">5.1</a>.  In this\ndiagram, the registers (<tt>a</tt>, <tt>b</tt>, and <tt>t</tt>) are represented\nby rectangles.  Each way to assign a value to a register is\nindicated by an arrow with an <tt>X</tt> behind the head, pointing from\nthe source of data to the register.  We can think of the <tt>X</tt> as a\nbutton that, when pushed, allows the value at the source to ``flow\'\'\ninto the designated register.  The label next to each button is the\nname we will use to refer to the button.  The names are arbitrary, and\ncan be chosen to have mnemonic value (for example, <tt>a&lt;-b</tt> denotes\npushing the button that assigns the contents of register <tt>b</tt> to\nregister <tt>a</tt>).  The source of data for a register can be another\nregister (as in the <tt>a&lt;-b</tt> assignment), an operation result (as in\nthe <tt>t&lt;-r</tt> assignment), or a constant (a built-in value that\ncannot be changed, represented in a data-path diagram by a triangle\ncontaining the constant).<p>\n\nAn operation that computes a value from constants and the contents\nof registers is represented in a data-path diagram by a trapezoid\ncontaining a name for the operation.  For example, the box marked <tt>rem</tt> in figure&nbsp;<a href="#%_fig_5.1">5.1</a> represents an\noperation that computes the remainder of the contents of the\nregisters <tt>a</tt> and <tt>b</tt> to which it is attached.  Arrows\n(without buttons) point from the input registers and constants to the\nbox, and arrows connect the operation\'s output value to registers.\nA test is represented by a circle containing a name for the test.  For\nexample, our GCD machine has an operation that\ntests whether the contents of register\n<tt>b</tt> is zero.  A test also has arrows from its input\n<a name="%_idx_5482"></a><a name="%_idx_5484"></a>registers and constants, but it has no output\narrows; its value is used by the controller rather than by the data\npaths.  Overall, the data-path diagram shows the registers and\noperations that are required for the machine and how they must be\nconnected.  If we view the arrows as wires and the <tt>X</tt> buttons as\nswitches, the data-path diagram is very like the wiring diagram for a\nmachine that could be constructed from electrical components.<p>\n\n<p>\n\n<a name="%_fig_5.1"></a><p><div align=left><table width=100%><tr><td><img src="ch5-Z-G-1.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 5.1:</b>&nbsp;&nbsp;Data paths for a GCD machine.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_idx_5486"></a><a name="%_idx_5488"></a>In order for the data paths to actually compute GCDs, the buttons must\nbe pushed in the correct sequence.  We will describe this sequence in\nterms of a controller diagram, as illustrated in\nfigure&nbsp;<a href="#%_fig_5.2">5.2</a>.  The elements of the controller\ndiagram indicate how the\ndata-path components should be operated.  The rectangular boxes in the\ncontroller diagram identify data-path buttons to be pushed, and the\narrows describe the sequencing from one step to the next.  The diamond\nin the diagram represents a decision.  One of the two sequencing\narrows will be followed, depending on the value of the data-path test\nidentified in the diamond.  We can interpret the controller in terms\nof a physical analogy: Think of the diagram as a maze in which a\nmarble is rolling.  When the marble rolls into a box, it pushes the\ndata-path button that is named by the box.  When the marble rolls into\na decision node (such as the test for <tt>b</tt>   = 0), it leaves the\nnode on the path determined by the result of the indicated test.\nTaken together, the data paths and the controller completely describe\na machine for computing GCDs.  We start the controller (the rolling\nmarble) at the place marked <tt>start</tt>, after placing numbers in\nregisters <tt>a</tt> and <tt>b</tt>.  When the controller reaches <tt>done</tt>, we will find the value of the GCD in register <tt>a</tt>.\n\n<a name="%_fig_5.2"></a><p><div align=left><table width=100%><tr><td>\n<img src="ch5-Z-G-2.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 5.2:</b>&nbsp;&nbsp;Controller for a GCD machine.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<p><a name="%_thm_5.1"></a>\n<b>Exercise 5.1.</b>&nbsp;&nbsp;<a name="%_idx_5490"></a>Design a register machine to compute factorials using the iterative\nalgorithm specified by the following procedure.  Draw data-path and\ncontroller diagrams for this machine.<p>\n\n<p><p><tt>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;product&nbsp;counter)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;counter&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;(*&nbsp;counter&nbsp;product)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;counter&nbsp;1))))<br>\n&nbsp;&nbsp;(iter&nbsp;1&nbsp;1))<br>\n</tt><p><p>\n<p>\n<p>\n\n<a name="%_sec_5.1.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.1.1">5.1.1&nbsp;&nbsp;A Language for Describing Register Machines</a></h3><p>\n\n\n<a name="%_idx_5492"></a>\nData-path and controller diagrams are adequate for representing simple\nmachines such as GCD, but they are unwieldy for describing large\nmachines such as a Lisp interpreter.  To make it possible to deal with\ncomplex machines, we will create a language that presents, in textual\nform, all the information given by the data-path and controller\ndiagrams.  We will start with a notation that directly mirrors the diagrams.<p>\n\n<p>\n\nWe define the data paths of a machine by describing the registers and\nthe operations.  To describe a register, we give it a name\nand specify the buttons that control assignment to it.  We give each\nof these buttons a name and specify the source of the data that enters\nthe register under the button\'s control.  (The source is a register, a\nconstant, or an operation.)\nTo describe an operation, we give\nit a name and specify its inputs (registers or constants).<p>\n\nWe define the controller of a machine as a sequence of <a name="%_idx_5494"></a><em>instructions</em> together with <a name="%_idx_5496"></a><a name="%_idx_5498"></a><em>labels</em> that identify <em>entry\npoints</em> in the sequence. An instruction is one of the following:\n<p><ul>\n<li>The name of a data-path button to push to assign a value to\na register.  (This corresponds to a box in the controller diagram.)<p>\n\n<a name="%_idx_5500"></a><a name="%_idx_5502"></a><li>A <tt>test</tt> instruction, that performs a specified test.<p>\n\n<a name="%_idx_5504"></a><a name="%_idx_5506"></a><a name="%_idx_5508"></a><a name="%_idx_5510"></a><li>A conditional branch (<tt>branch</tt> instruction) to a\nlocation indicated by a controller label, based on the result of the\nprevious test.  (The test and branch together correspond to a diamond\nin the controller diagram.)  If the test is false, the controller\nshould continue with the next instruction in the sequence.  Otherwise,\nthe controller should continue with the instruction after the label.<p>\n\n<a name="%_idx_5512"></a><a name="%_idx_5514"></a><li>An unconditional branch (<tt>goto</tt> instruction) naming a\ncontroller label at which to continue execution.\n</ul><p>\nThe machine starts at the beginning of the controller instruction\nsequence and stops when execution reaches the end of the sequence.\nExcept when a branch changes the flow of control, instructions are\nexecuted in the order in which they are listed.<p>\n\n<a name="%_fig_5.3"></a><p><div align=left><table width=100%><tr><td><p><p><tt>(data-paths<br>\n&nbsp;(registers<br>\n&nbsp;&nbsp;((name&nbsp;a)<br>\n&nbsp;&nbsp;&nbsp;(buttons&nbsp;((name&nbsp;a&lt;-b)&nbsp;(source&nbsp;(register&nbsp;b)))))<br>\n&nbsp;&nbsp;((name&nbsp;b)<br>\n&nbsp;&nbsp;&nbsp;(buttons&nbsp;((name&nbsp;b&lt;-t)&nbsp;(source&nbsp;(register&nbsp;t)))))<br>\n&nbsp;&nbsp;((name&nbsp;t)<br>\n&nbsp;&nbsp;&nbsp;(buttons&nbsp;((name&nbsp;t&lt;-r)&nbsp;(source&nbsp;(operation&nbsp;rem))))))<br>\n<br>\n&nbsp;(operations<br>\n&nbsp;&nbsp;((name&nbsp;rem)<br>\n&nbsp;&nbsp;&nbsp;(inputs&nbsp;(register&nbsp;a)&nbsp;(register&nbsp;b)))<br>\n&nbsp;&nbsp;((name&nbsp;=)<br>\n&nbsp;&nbsp;&nbsp;(inputs&nbsp;(register&nbsp;b)&nbsp;(constant&nbsp;0)))))<br>\n<br>\n(controller<br>\n&nbsp;test-b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;label</em><br>\n&nbsp;&nbsp;&nbsp;(test&nbsp;=)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;test</em><br>\n&nbsp;&nbsp;&nbsp;(branch&nbsp;(label&nbsp;gcd-done))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;conditional&nbsp;branch</em><br>\n&nbsp;&nbsp;&nbsp;(t&lt;-r)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;button&nbsp;push</em><br>\n&nbsp;&nbsp;&nbsp;(a&lt;-b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;button&nbsp;push</em><br>\n&nbsp;&nbsp;&nbsp;(b&lt;-t)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;button&nbsp;push</em><br>\n&nbsp;&nbsp;&nbsp;(goto&nbsp;(label&nbsp;test-b))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;unconditional&nbsp;branch</em><br>\n&nbsp;gcd-done)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;label</em><br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.3:</b>&nbsp;&nbsp;A specification of the GCD machine.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nFigure&nbsp;<a href="#%_fig_5.3">5.3</a> shows the GCD machine described in\nthis way.  This example only hints at the generality of these\ndescriptions, since the GCD machine is a very simple case: Each\nregister has only one button, and each button and test is used only\nonce in the controller.<p>\n\nUnfortunately, it is difficult to read such a description.  In order\nto understand the controller instructions we must constantly refer\nback to the definitions of the button names and the operation names,\nand to understand what the buttons do we may have to refer to the\ndefinitions of the operation names.  We will thus transform our\nnotation to combine the information from the data-path and controller\ndescriptions so that we see it all together.<p>\n\nTo obtain this form of description, we will replace the arbitrary\nbutton and operation names by the definitions of their behavior.  That\nis, instead of saying (in the controller) ``Push button <tt>t&lt;-r</tt>\'\'\nand separately saying (in the data paths) ``Button <tt>t&lt;-r</tt> assigns\nthe value of the <tt>rem</tt> operation to register <tt>t</tt>\'\' and ``The\n<tt>rem</tt> operation\'s inputs are the contents of registers\n<a name="%_idx_5516"></a><a name="%_idx_5518"></a><a name="%_idx_5520"></a><a name="%_idx_5522"></a><a name="%_idx_5524"></a><a name="%_idx_5526"></a><tt>a</tt> and <tt>b</tt>,\'\' we will say (in the controller) ``Push the\nbutton that assigns to register <tt>t</tt> the value of the <tt>rem</tt>\noperation on the contents of registers <tt>a</tt> and <tt>b</tt>.\'\'\nSimilarly, instead of saying (in the controller) ``Perform the <tt>=</tt> test\'\' and separately saying (in the data paths) ``The <tt>=</tt> test operates on the contents of register <tt>b</tt> and the\nconstant 0,\'\' we will say ``Perform the <tt>=</tt> test on the\n<a name="%_idx_5528"></a><a name="%_idx_5530"></a>contents of register <tt>b</tt> and the constant 0.\'\'  We will omit the\ndata-path description, leaving only the controller sequence.  Thus,\nthe GCD machine is described as follows:<p>\n\n<p><p><tt>(controller<br>\n&nbsp;test-b<br>\n&nbsp;&nbsp;&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;b)&nbsp;(const&nbsp;0))<br>\n&nbsp;&nbsp;&nbsp;(branch&nbsp;(label&nbsp;gcd-done))<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;t&nbsp;(op&nbsp;rem)&nbsp;(reg&nbsp;a)&nbsp;(reg&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;a&nbsp;(reg&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;b&nbsp;(reg&nbsp;t))<br>\n&nbsp;&nbsp;&nbsp;(goto&nbsp;(label&nbsp;test-b))<br>\n&nbsp;gcd-done)<br>\n</tt><p><p><p>\n\nThis form of description is easier to read than the kind illustrated\nin figure&nbsp;<a href="#%_fig_5.3">5.3</a>, but it also has disadvantages:\n\n<p><ul>\n<p>\n\n<li>It is more verbose for large machines,\nbecause complete descriptions of the data-path elements are repeated\nwhenever the elements are mentioned in the controller instruction\nsequence.  (This is not a problem in the GCD example, because each\noperation and button is used only once.)  Moreover, repeating the\ndata-path descriptions obscures the actual data-path structure of the\nmachine; it is not obvious for a large machine how many registers,\noperations, and buttons there are and how they are interconnected.<p>\n\n<li>Because the controller instructions in a machine definition\nlook like Lisp expressions, it is easy to forget that they are\nnot arbitrary Lisp expressions.  They can notate only legal machine\noperations.  For example, operations can operate directly only on\nconstants and the contents of registers, not on the results of other\noperations.\n</ul><p>\nIn spite of these disadvantages, we will use this register-machine\nlanguage throughout this chapter, because we will be more concerned with\nunderstanding controllers than with understanding the elements and\nconnections in data paths.  We should keep in mind,\nhowever, that data-path design is crucial in designing real machines.<p>\n\n<p><a name="%_thm_5.2"></a>\n<b>Exercise 5.2.</b>&nbsp;&nbsp;<a name="%_idx_5532"></a>Use the register-machine language to describe\nthe iterative factorial machine of exercise&nbsp;<a href="#%_thm_5.1">5.1</a>.\n<p><p>\n\n\n<a name="%_sec_Temp_714"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_714">Actions</a></h4><p>\n\n<a name="%_idx_5534"></a><a name="%_idx_5536"></a>\nLet us modify the GCD machine so that we can type in the numbers\nwhose GCD we want and get the answer printed at our terminal.  We will\nnot discuss how to make a machine that can read and print, but will\nassume (as we do when we use <tt>read</tt> and <tt>display</tt> in Scheme) that\nthey are available as primitive operations.<a name="call_footnote_Temp_715" href="#footnote_Temp_715"><sup><small>1</small></sup></a><p>\n\n<a name="%_idx_5538"></a><tt>Read</tt> is like the operations we have been using in that it\nproduces a value that can be stored in a register.  But <tt>read</tt>\ndoes not take inputs from any registers; its value depends on\nsomething that happens outside the parts of the machine we are\ndesigning.  We will allow our machine\'s operations to have such\nbehavior, and thus will draw and notate the use of <tt>read</tt> just as\nwe do any other operation that computes a value.<p>\n\n<a name="%_idx_5540"></a><tt>Print</tt>, on the other hand, differs from the operations we have\nbeen using in a fundamental way: It does not produce an output value\nto be stored in a register.  Though it has an effect, this effect is\nnot on a part of the machine we are designing.  We will refer to this\nkind of operation as an <em>action</em>.  We will represent an action in\na data-path diagram just as we represent an operation that computes a\nvalue -- as a trapezoid that contains the name of the action.\nArrows point to the action box from any inputs (registers or\nconstants).  We also associate a button with the action.  Pushing the\nbutton makes the action happen.  To make a controller push an action\n<a name="%_idx_5542"></a><a name="%_idx_5544"></a>button we use a new kind of instruction called <tt>perform</tt>.  Thus,\nthe action of printing the contents of register <tt>a</tt> is represented\nin a controller sequence by the instruction<p>\n\n<p><p><tt>(perform&nbsp;(op&nbsp;print)&nbsp;(reg&nbsp;a))<br>\n</tt><p><p><p>\n\nFigure&nbsp;<a href="#%_fig_5.4">5.4</a> shows the data paths and controller for\nthe new GCD machine.  Instead of having the machine stop after\nprinting the answer, we have made it start over, so that it repeatedly\nreads a pair of numbers, computes their GCD, and prints the result.\nThis structure is like the driver loops we used in the interpreters of\nchapter&nbsp;4.<p>\n\n<a name="%_fig_5.4"></a><p><div align=left><table width=100%><tr><td><img src="ch5-Z-G-3.gif" border="0">\n<p><p><tt>&nbsp;(controller<br>\n&nbsp;&nbsp;gcd-loop<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;a&nbsp;(op&nbsp;read))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;b&nbsp;(op&nbsp;read))<br>\n&nbsp;&nbsp;test-b<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;b)&nbsp;(const&nbsp;0))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(branch&nbsp;(label&nbsp;gcd-done))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;t&nbsp;(op&nbsp;rem)&nbsp;(reg&nbsp;a)&nbsp;(reg&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;a&nbsp;(reg&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;b&nbsp;(reg&nbsp;t))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(goto&nbsp;(label&nbsp;test-b))<br>\n&nbsp;&nbsp;gcd-done<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(perform&nbsp;(op&nbsp;print)&nbsp;(reg&nbsp;a))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(goto&nbsp;(label&nbsp;gcd-loop)))<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.4:</b>&nbsp;&nbsp;A GCD machine that reads inputs and prints results.</div></caption><tr><td>\n\n</td></tr></table></div><p>\n\n<a name="%_sec_5.1.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.1.2">5.1.2&nbsp;&nbsp;Abstraction in Machine Design</a></h3><p>\n\n<a name="%_idx_5546"></a>\nWe will often define a machine to include ``primitive\'\' operations that are\nactually very complex.  For example, in sections&nbsp;<a href="book-Z-H-34.html#%_sec_5.4">5.4</a> and\n<a href="book-Z-H-35.html#%_sec_5.5">5.5</a> we will treat Scheme\'s environment\nmanipulations as primitive.  Such abstraction is valuable because it\nallows us to ignore the details of parts of a machine so that we can\nconcentrate on other aspects of the design.  The fact that we have\nswept a lot of complexity under the rug, however, does not mean that a\nmachine design is unrealistic.  We can always replace the complex\n``primitives\'\' by simpler primitive operations.<p>\n\nConsider the GCD machine. The machine has an instruction that computes\nthe remainder of the contents of registers <tt>a</tt> and <tt>b</tt> and\nassigns the result to register <tt>t</tt>.  If we want to construct the\nGCD machine without using a primitive remainder operation,\nwe must specify how to compute remainders in terms of simpler\noperations, such as subtraction.  Indeed, we can write a Scheme\nprocedure that finds remainders in this way:<p>\n\n<p><p><tt>(define&nbsp;(remainder&nbsp;n&nbsp;d)<br>\n&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;d)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(remainder&nbsp;(-&nbsp;n&nbsp;d)&nbsp;d)))<br>\n</tt><p><p>\nWe can thus replace the remainder operation in the GCD machine\'s\ndata paths with a subtraction operation and a comparison test.\nFigure&nbsp;<a href="#%_fig_5.5">5.5</a> shows the data paths and controller\nfor the elaborated machine.\nThe instruction<p>\n\n<a name="%_fig_5.5"></a><p><div align=left><table width=100%><tr><td><img src="ch5-Z-G-4.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 5.5:</b>&nbsp;&nbsp;Data paths and controller for the elaborated GCD  machine.</div></caption><tr><td>\n\n\n</td></tr></table></div><p>                                <p>\n\n<p><p><tt>(assign&nbsp;t&nbsp;(op&nbsp;rem)&nbsp;(reg&nbsp;a)&nbsp;(reg&nbsp;b))<br>\n</tt><p><p>\nin the GCD controller definition is replaced by a sequence of\ninstructions that contains a loop, as shown in\nfigure&nbsp;<a href="#%_fig_5.6">5.6</a>.<p>\n\n<a name="%_fig_5.6"></a><p><div align=left><table width=100%><tr><td><p><p><tt>(controller<br>\n&nbsp;test-b<br>\n&nbsp;&nbsp;&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;b)&nbsp;(const&nbsp;0))<br>\n&nbsp;&nbsp;&nbsp;(branch&nbsp;(label&nbsp;gcd-done))<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;t&nbsp;(reg&nbsp;a))<br>\n&nbsp;rem-loop<br>\n&nbsp;&nbsp;&nbsp;(test&nbsp;(op&nbsp;&lt;)&nbsp;(reg&nbsp;t)&nbsp;(reg&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;(branch&nbsp;(label&nbsp;rem-done))<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;t&nbsp;(op&nbsp;-)&nbsp;(reg&nbsp;t)&nbsp;(reg&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;(goto&nbsp;(label&nbsp;rem-loop))<br>\n&nbsp;rem-done<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;a&nbsp;(reg&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;b&nbsp;(reg&nbsp;t))<br>\n&nbsp;&nbsp;&nbsp;(goto&nbsp;(label&nbsp;test-b))<br>\n&nbsp;gcd-done)<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.6:</b>&nbsp;&nbsp;Controller instruction sequence for the GCD machine in\nfigure&nbsp;<a href="#%_fig_5.5">5.5</a>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<p><a name="%_thm_5.3"></a>\n<b>Exercise 5.3.</b>&nbsp;&nbsp;<a name="%_idx_5548"></a>Design a machine to compute square roots using Newton\'s method, as\ndescribed in section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>:<p>\n\n<p><p><tt>(define&nbsp;(sqrt&nbsp;x)<br>\n&nbsp;&nbsp;(define&nbsp;(good-enough?&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&nbsp;(abs&nbsp;(-&nbsp;(square&nbsp;guess)&nbsp;x))&nbsp;0.001))<br>\n&nbsp;&nbsp;(define&nbsp;(improve&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(average&nbsp;guess&nbsp;(/&nbsp;x&nbsp;guess)))<br>\n&nbsp;&nbsp;(define&nbsp;(sqrt-iter&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(good-enough?&nbsp;guess)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guess<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt-iter&nbsp;(improve&nbsp;guess))))<br>\n&nbsp;&nbsp;(sqrt-iter&nbsp;1.0))<br>\n</tt><p><p>\nBegin by assuming that <tt>good-enough?</tt> and <tt>improve</tt> operations\nare available as primitives.  Then show how to expand these in terms\nof arithmetic operations.  Describe each version of the <tt>sqrt</tt>\nmachine design by drawing a data-path diagram and writing a controller\ndefinition in the register-machine language.\n<p>\n<p>\n\n<a name="%_sec_5.1.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.1.3">5.1.3&nbsp;&nbsp;Subroutines</a></h3><p>\n\n\n<a name="%_idx_5550"></a><a name="%_idx_5552"></a>\nWhen designing a machine to perform a computation, we would often\nprefer to arrange for components to be shared by different parts of\nthe computation rather than duplicate the components.  Consider a\nmachine that includes two GCD computations -- one that finds the GCD of\nthe contents of registers <tt>a</tt> and <tt>b</tt> and one that finds the\nGCD of the contents of registers <tt>c</tt> and <tt>d</tt>.  We might start\nby assuming we have a primitive <tt>gcd</tt> operation, then expand the\ntwo instances of <tt>gcd</tt> in terms of more primitive operations.\nFigure&nbsp;<a href="#%_fig_5.7">5.7</a> shows just the GCD portions of the\nresulting machine\'s data paths, without showing how they connect to\nthe rest of the machine.  The figure also shows the corresponding\nportions of the machine\'s controller sequence.<p>\n\n<a name="%_fig_5.7"></a><p><div align=left><table width=100%><tr><td><img src="ch5-Z-G-5.gif" border="0">\n<p><p><tt>gcd-1<br>\n&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;b)&nbsp;(const&nbsp;0))<br>\n&nbsp;(branch&nbsp;(label&nbsp;after-gcd-1))<br>\n&nbsp;(assign&nbsp;t&nbsp;(op&nbsp;rem)&nbsp;(reg&nbsp;a)&nbsp;(reg&nbsp;b))<br>\n&nbsp;(assign&nbsp;a&nbsp;(reg&nbsp;b))<br>\n&nbsp;(assign&nbsp;b&nbsp;(reg&nbsp;t))<br>\n&nbsp;(goto&nbsp;(label&nbsp;gcd-1))<br>\nafter-gcd-1<br>\n&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-18.gif" border="0">&nbsp;<br>\ngcd-2<br>\n&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;d)&nbsp;(const&nbsp;0))<br>\n&nbsp;(branch&nbsp;(label&nbsp;after-gcd-2))<br>\n&nbsp;(assign&nbsp;s&nbsp;(op&nbsp;rem)&nbsp;(reg&nbsp;c)&nbsp;(reg&nbsp;d))<br>\n&nbsp;(assign&nbsp;c&nbsp;(reg&nbsp;d))<br>\n&nbsp;(assign&nbsp;d&nbsp;(reg&nbsp;s))<br>\n&nbsp;(goto&nbsp;(label&nbsp;gcd-2))<br>\nafter-gcd-2<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.7:</b>&nbsp;&nbsp;Portions of the data paths and controller sequence for\na machine with two GCD computations.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nThis machine has two remainder operation boxes and two boxes for\ntesting equality.  If the duplicated components are complicated, as is the\nremainder box, this will not be an economical way to build the\nmachine.  We can avoid duplicating the data-path components by using\nthe same components for both GCD computations, provided that doing so\nwill not affect the rest of the larger machine\'s computation.  If the\nvalues in registers <tt>a</tt> and <tt>b</tt> are not needed by the time the\ncontroller gets to <tt>gcd-2</tt> (or if these values can be moved to\nother registers for safekeeping), we can change the machine so that\nit uses registers <tt>a</tt> and <tt>b</tt>, rather than registers <tt>c</tt>\nand <tt>d</tt>, in computing the second GCD as well as the first.  If we\ndo this, we obtain the controller sequence shown in\nfigure&nbsp;<a href="#%_fig_5.8">5.8</a>.<p>\n\nWe have removed the duplicate data-path components\n(so that the data paths are again as in figure&nbsp;<a href="#%_fig_5.1">5.1</a>),\nbut the controller\nnow has two GCD sequences that differ only in their entry-point\nlabels.  It would be better to replace these two sequences by branches\nto a single sequence -- a <tt>gcd</tt> <em>subroutine</em> -- at the end of\nwhich we branch back to the correct place in the main instruction\nsequence.  We can accomplish this as follows: Before branching to <tt>gcd</tt>, we place a distinguishing value (such as 0 or&nbsp;1) into a special\nregister, <a name="%_idx_5554"></a><tt>continue</tt>.  At the end of the <tt>gcd</tt> subroutine we\nreturn either to <tt>after-gcd-1</tt> or to <tt>after-gcd-2</tt>, depending\non the value of the <tt>continue</tt> register.\nFigure&nbsp;<a href="#%_fig_5.9">5.9</a> shows the relevant portion of the\nresulting controller sequence, which includes only a single copy of the\n<tt>gcd</tt> instructions.<p>\n\n<a name="%_fig_5.8"></a><p><div align=left><table width=100%><tr><td><p><p><tt>gcd-1<br>\n&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;b)&nbsp;(const&nbsp;0))<br>\n&nbsp;(branch&nbsp;(label&nbsp;after-gcd-1))<br>\n&nbsp;(assign&nbsp;t&nbsp;(op&nbsp;rem)&nbsp;(reg&nbsp;a)&nbsp;(reg&nbsp;b))<br>\n&nbsp;(assign&nbsp;a&nbsp;(reg&nbsp;b))<br>\n&nbsp;(assign&nbsp;b&nbsp;(reg&nbsp;t))<br>\n&nbsp;(goto&nbsp;(label&nbsp;gcd-1))<br>\nafter-gcd-1<br>\n&nbsp;&nbsp;<img src="book-Z-G-D-18.gif" border="0"><br>\ngcd-2<br>\n&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;b)&nbsp;(const&nbsp;0))<br>\n&nbsp;(branch&nbsp;(label&nbsp;after-gcd-2))<br>\n&nbsp;(assign&nbsp;t&nbsp;(op&nbsp;rem)&nbsp;(reg&nbsp;a)&nbsp;(reg&nbsp;b))<br>\n&nbsp;(assign&nbsp;a&nbsp;(reg&nbsp;b))<br>\n&nbsp;(assign&nbsp;b&nbsp;(reg&nbsp;t))<br>\n&nbsp;(goto&nbsp;(label&nbsp;gcd-2))<br>\nafter-gcd-2<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.8:</b>&nbsp;&nbsp;Portions of the controller sequence for a machine that\nuses the same data-path components for two different GCD\ncomputations.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_fig_5.9"></a><p><div align=left><table width=100%><tr><td><p><p><tt>gcd<br>\n&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;b)&nbsp;(const&nbsp;0))<br>\n&nbsp;(branch&nbsp;(label&nbsp;gcd-done))<br>\n&nbsp;(assign&nbsp;t&nbsp;(op&nbsp;rem)&nbsp;(reg&nbsp;a)&nbsp;(reg&nbsp;b))<br>\n&nbsp;(assign&nbsp;a&nbsp;(reg&nbsp;b))<br>\n&nbsp;(assign&nbsp;b&nbsp;(reg&nbsp;t))<br>\n&nbsp;(goto&nbsp;(label&nbsp;gcd))<br>\ngcd-done<br>\n&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;continue)&nbsp;(const&nbsp;0))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>\n&nbsp;(branch&nbsp;(label&nbsp;after-gcd-1))<br>\n&nbsp;(goto&nbsp;(label&nbsp;after-gcd-2))<br>\n&nbsp;&nbsp;<img src="book-Z-G-D-18.gif" border="0"><br>\n<em>;;&nbsp;Before&nbsp;branching&nbsp;to&nbsp;<tt>gcd</tt>&nbsp;from&nbsp;the&nbsp;first&nbsp;place&nbsp;where</em><br>\n<em>;;&nbsp;it&nbsp;is&nbsp;needed,&nbsp;we&nbsp;place&nbsp;0&nbsp;in&nbsp;the&nbsp;<tt>continue</tt>&nbsp;register</em><br>\n&nbsp;(assign&nbsp;continue&nbsp;(const&nbsp;0))<br>\n&nbsp;(goto&nbsp;(label&nbsp;gcd))<br>\nafter-gcd-1<br>\n&nbsp;&nbsp;<img src="book-Z-G-D-18.gif" border="0"><br>\n<em>;;&nbsp;Before&nbsp;the&nbsp;second&nbsp;use&nbsp;of&nbsp;<tt>gcd</tt>,&nbsp;we&nbsp;place&nbsp;1&nbsp;in&nbsp;the&nbsp;<tt>continue</tt>&nbsp;register</em><br>\n&nbsp;(assign&nbsp;continue&nbsp;(const&nbsp;1))<br>\n&nbsp;(goto&nbsp;(label&nbsp;gcd))<br>\nafter-gcd-2<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.9:</b>&nbsp;&nbsp;Using a <tt>continue</tt> register to avoid\nthe duplicate controller sequence in figure&nbsp;<a href="#%_fig_5.8">5.8</a>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_fig_5.10"></a><p><div align=left><table width=100%><tr><td><p><p>\n<p><p><tt>gcd<br>\n&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;b)&nbsp;(const&nbsp;0))<br>\n&nbsp;(branch&nbsp;(label&nbsp;gcd-done))<br>\n&nbsp;(assign&nbsp;t&nbsp;(op&nbsp;rem)&nbsp;(reg&nbsp;a)&nbsp;(reg&nbsp;b))<br>\n&nbsp;(assign&nbsp;a&nbsp;(reg&nbsp;b))<br>\n&nbsp;(assign&nbsp;b&nbsp;(reg&nbsp;t))<br>\n&nbsp;(goto&nbsp;(label&nbsp;gcd))<br>\ngcd-done<br>\n&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\n&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-18.gif" border="0"><br>\n<em>;;&nbsp;Before&nbsp;calling&nbsp;<tt>gcd</tt>,&nbsp;we&nbsp;assign&nbsp;to&nbsp;<tt>continue</tt></em><br>\n<em>;;&nbsp;the&nbsp;label&nbsp;to&nbsp;which&nbsp;<tt>gcd</tt>&nbsp;should&nbsp;return.</em><br>\n&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;after-gcd-1))<br>\n&nbsp;(goto&nbsp;(label&nbsp;gcd))<br>\nafter-gcd-1<br>\n&nbsp;&nbsp;&nbsp;<img src="book-Z-G-D-18.gif" border="0"><br>\n<em>;;&nbsp;Here&nbsp;is&nbsp;the&nbsp;second&nbsp;call&nbsp;to&nbsp;<tt>gcd</tt>,&nbsp;with&nbsp;a&nbsp;different&nbsp;continuation.</em><br>\n&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;after-gcd-2))<br>\n&nbsp;(goto&nbsp;(label&nbsp;gcd))<br>\nafter-gcd-2<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.10:</b>&nbsp;&nbsp;Assigning labels to the <tt>continue</tt> register simplifies\nand generalizes the strategy shown in figure&nbsp;<a href="#%_fig_5.9">5.9</a>.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nThis is a reasonable approach for handling small problems, but it\nwould be awkward if there were many instances of GCD computations in\nthe controller sequence.  To decide where to continue executing after\nthe <tt>gcd</tt> subroutine, we would need tests in the data paths and\nbranch instructions in the controller for all the places that use <tt>gcd</tt>.  A more powerful method for implementing subroutines is to have\nthe <tt>continue</tt> register hold the label of the entry point in the\ncontroller sequence at which execution should continue when the\nsubroutine is finished.  Implementing this strategy requires a new\nkind of connection between the data paths and the controller of a\nregister machine: There must be a way to assign to a register a label\nin the controller sequence in such a way that this value can be fetched\nfrom the register and used to continue execution at the designated\nentry point.<p>\n\n<a name="%_idx_5556"></a><a name="%_idx_5558"></a>To reflect this ability, we will extend the <tt>assign</tt>\ninstruction of the register-machine language to allow a register to be\nassigned as value a label from the controller sequence (as a special\nkind of constant).  We will also extend the <tt>goto</tt> instruction to\nallow execution to continue at the entry point described by the\ncontents of a register rather than only at an entry point described by\na constant label.  Using these new constructs we can terminate the\n<tt>gcd</tt> subroutine with a branch to the location stored in the <tt>continue</tt> register.  This leads to the controller sequence shown in\nfigure&nbsp;<a href="#%_fig_5.10">5.10</a>.<p>\n\nA machine with more than one subroutine could use multiple\ncontinuation registers (e.g., <tt>gcd-continue</tt>, <tt>factorial-continue</tt>) or we could have all subroutines share a single\n<tt>continue</tt> register.  Sharing is more economical, but we must be\ncareful if we have a subroutine (<tt>sub1</tt>) that calls another\nsubroutine (<tt>sub2</tt>).  Unless <tt>sub1</tt> saves the contents of <tt>continue</tt> in some other register before setting up <tt>continue</tt> for\nthe call to <tt>sub2</tt>, <tt>sub1</tt> will not know where to go when it\nis finished.  The mechanism developed in the next section to handle\nrecursion also provides a better solution to this problem of nested\nsubroutine calls.\n<p>\n\n<a name="%_sec_5.1.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.1.4">5.1.4&nbsp;&nbsp;Using a Stack to Implement Recursion</a></h3><p>\n\n\n<a name="%_idx_5560"></a><a name="%_idx_5562"></a><a name="%_idx_5564"></a>\n<a name="%_idx_5566"></a>With the ideas illustrated so far, we can implement any iterative\nprocess by specifying a register machine that has a register\ncorresponding to each state variable of the process.  The machine\nrepeatedly executes a controller loop, changing the contents\nof the registers, until some termination condition is satisfied.  At\neach point in the controller sequence, the state of the machine\n(representing the state of the iterative process) is completely\ndetermined by the contents of the registers (the values of the state\nvariables).<p>\n\n\n<a name="%_idx_5568"></a><a name="%_idx_5570"></a><a name="%_idx_5572"></a>Implementing recursive processes, however, requires an additional\nmechanism.  Consider the following recursive method for computing\nfactorials, which we first examined in\nsection&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a>:<p>\n\n<p><p><tt>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1))&nbsp;n)))<br>\n</tt><p><p>\nAs we see from the procedure, computing <em>n</em>! requires computing\n(<em>n</em> - 1)!.  Our GCD machine, modeled on the procedure<p>\n\n<p><p><tt>(define&nbsp;(gcd&nbsp;a&nbsp;b)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;b&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gcd&nbsp;b&nbsp;(remainder&nbsp;a&nbsp;b))))<br>\n</tt><p><p>\nsimilarly had to compute another GCD.  But there is an important\ndifference between the <tt>gcd</tt> procedure, which reduces the original\ncomputation to a new GCD computation, and <tt>factorial</tt>, which\nrequires computing another factorial as a subproblem.  In GCD, the\nanswer to the new GCD computation is the answer to the original\nproblem.  To compute the next GCD, we simply place the new arguments\nin the input registers of the GCD machine and reuse the\nmachine\'s data paths by executing the same controller sequence.  When\nthe machine is finished solving the final GCD problem, it has\ncompleted the entire computation.<p>\n\nIn the case of factorial (or any recursive process) the answer to the\nnew factorial subproblem is not the answer to the original problem.\nThe value obtained for (<em>n</em> - 1)! must be multiplied by <em>n</em> to get the\nfinal answer.  If we try to imitate the GCD design, and solve\nthe factorial subproblem by decrementing the <tt>n</tt> register and\nrerunning the factorial machine, we will no longer have available the\nold value of <tt>n</tt> by which to multiply the result.  We thus need a\nsecond factorial machine to work on the subproblem.  This second\nfactorial computation itself has a factorial subproblem, which\nrequires a third factorial machine, and so on.  Since each factorial\nmachine contains another factorial machine within it, the total\nmachine contains an infinite nest of similar machines and hence cannot\nbe constructed from a fixed, finite number of parts.<p>\n\nNevertheless, we can implement the factorial process as a register\nmachine if we can arrange to use the same components for each nested\ninstance of the machine.  Specifically, the machine that computes <em>n</em>!\nshould use the same components to work on the subproblem of computing\n(<em>n</em> - 1)!, on the subproblem for (<em>n</em> - 2)!, and so on.  This is\nplausible because, although the factorial process dictates that an\nunbounded number of copies of the same machine are needed to perform a\ncomputation, only one of these copies needs to be active at any given\ntime.  When the machine encounters a recursive subproblem, it can\nsuspend work on the main problem, reuse the same physical parts to\nwork on the subproblem, then continue the suspended computation.<p>\n\nIn the subproblem, the contents of the registers will be different\nthan they were in the main problem. (In this case the <tt>n</tt> register\nis decremented.)  In order to be able to continue the suspended\ncomputation, the machine must save the contents of any registers that\nwill be needed after the subproblem is solved so that these can be\nrestored to continue the suspended computation.  In the case of\nfactorial, we will save the old value of <tt>n</tt>, to be restored when\nwe are finished computing the factorial of the decremented <tt>n</tt>\nregister.<a name="call_footnote_Temp_717" href="#footnote_Temp_717"><sup><small>2</small></sup></a><p>\n\nSince there is no <em>a priori</em> limit on the depth of nested\nrecursive calls, we may need to save an arbitrary number of register\nvalues.  These values must be restored in the reverse of the order in\nwhich they were saved, since in a nest of recursions the last\nsubproblem to be entered is the first to be finished.  This dictates\nthe use of a <em>stack</em>, or ``last in, first out\'\' data structure, to\nsave register values.  We can extend the register-machine language to\ninclude a stack by adding two kinds of instructions: Values are placed\n<a name="%_idx_5574"></a><a name="%_idx_5576"></a><a name="%_idx_5578"></a><a name="%_idx_5580"></a>on the stack using a <tt>save</tt> instruction and restored from the\nstack using a <tt>restore</tt> instruction.  After a sequence of values\nhas been <tt>save</tt>d on the stack, a sequence of <tt>restore</tt>s will\nretrieve these values in reverse order.<a name="call_footnote_Temp_718" href="#footnote_Temp_718"><sup><small>3</small></sup></a><p>\n\n\nWith the aid of the stack, we can reuse a single copy of the factorial\nmachine\'s data paths for each factorial subproblem.  There is a\nsimilar design issue in reusing the controller sequence that operates\nthe data paths.  To reexecute the factorial computation, the\ncontroller cannot simply loop back to the beginning, as with\nan iterative process, because after solving the (<em>n</em> - 1)! subproblem\nthe machine must still multiply the result by <em>n</em>.  The controller\nmust suspend its computation of <em>n</em>!, solve the (<em>n</em> - 1)! subproblem,\nthen continue its computation of <em>n</em>!.  This view of the factorial\ncomputation suggests the use of the subroutine mechanism described in\nsection&nbsp;<a href="#%_sec_5.1.3">5.1.3</a>, which has the controller use a\n<a name="%_idx_5582"></a><tt>continue</tt> register to transfer to the part of the sequence that\nsolves a subproblem and then continue where it left off on the main\nproblem.  We can thus make a factorial subroutine that returns to the\nentry point stored in the <tt>continue</tt> register.  Around each subroutine\ncall, we save and restore <tt>continue</tt> just as we do the <tt>n</tt>\nregister, since each ``level\'\' of the factorial computation will use\nthe same <tt>continue</tt> register.  That is, the factorial subroutine\nmust put a new value in <tt>continue</tt> when it calls itself for a\nsubproblem, but it will need the old value in order to return to the\nplace that called it to solve a subproblem.<p>\n\n\nFigure&nbsp;<a href="#%_fig_5.11">5.11</a> shows the data paths and controller for\na machine that implements the recursive <tt>factorial</tt> procedure.\nThe machine has a stack and three registers, called <tt>n</tt>, <tt>val</tt>, and <tt>continue</tt>.  To simplify the data-path diagram, we have\nnot named the register-assignment buttons, only the stack-operation\nbuttons (<tt>sc</tt> and <tt>sn</tt> to save registers, <tt>rc</tt> and <tt>rn</tt> to restore registers).  To operate the machine, we put in register\n<tt>n</tt> the number whose factorial we wish to compute and start the\nmachine.  When the machine reaches <tt>fact-done</tt>, the computation is\nfinished and the answer will be found in the <tt>val</tt> register.  In\nthe controller sequence, <tt>n</tt> and <tt>continue</tt> are saved before\neach recursive call and restored upon return from the call.  Returning\nfrom a call is accomplished by branching to the location stored in\n<tt>continue</tt>.  <tt>Continue</tt> is initialized when the machine starts\nso that the last return will go to <tt>fact-done</tt>.  The <tt>val</tt>\nregister, which holds the result of the factorial computation, is not\nsaved before the recursive call, because the old contents of <tt>val</tt>\nis not useful after the subroutine returns.  Only the new value, which\nis the value produced by the subcomputation, is needed.\n\nAlthough in principle the factorial computation requires an infinite\nmachine, the machine in figure&nbsp;<a href="#%_fig_5.11">5.11</a> is actually\nfinite except for the stack, which is potentially unbounded.  Any\nparticular physical implementation of a stack, however, will be of\nfinite size, and this will limit the depth of recursive calls that can\nbe handled by the machine.  This implementation of factorial\nillustrates the general strategy for realizing recursive algorithms as\nordinary register machines augmented by stacks.  When a recursive\nsubproblem is encountered, we save on the stack the registers whose\ncurrent values will be required after the subproblem is solved, solve\nthe recursive subproblem, then restore the saved registers and\ncontinue execution on the main problem.  The <tt>continue</tt> register\nmust always be saved.  Whether there are other registers that need to\nbe saved depends on the particular machine, since not all recursive\ncomputations need the original values of registers that are modified\nduring solution of the subproblem (see exercise&nbsp;<a href="#%_thm_5.4">5.4</a>).<p>\n\n<a name="%_sec_Temp_719"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_719">A double recursion</a></h4><p>\n\n<a name="%_idx_5584"></a>Let us examine a more complex recursive process, the tree-recursive\ncomputation of the Fibonacci numbers, which we introduced in\nsection&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a>:\n<p><p><tt>(define&nbsp;(fib&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(fib&nbsp;(-&nbsp;n&nbsp;1))&nbsp;(fib&nbsp;(-&nbsp;n&nbsp;2)))))<br>\n</tt><p><p>\nJust as with factorial, we can implement the recursive Fibonacci\ncomputation as a register machine with registers <tt>n</tt>, <tt>val</tt>,\nand <tt>continue</tt>.  The machine is more complex than the one for\nfactorial, because there are two places in the controller sequence\nwhere we need to perform recursive calls -- once to compute Fib(<em>n</em> - 1)\nand once to compute Fib(<em>n</em> - 2).  To set up for each of these calls, we\nsave the registers whose values will be needed later, set the <tt>n</tt>\nregister to the number whose Fib we need to compute recursively (<em>n</em> - 1\nor <em>n</em> - 2), and assign to <tt>continue</tt> the entry point in the main sequence\nto which to return (<tt>afterfib-n-1</tt> or <tt>afterfib-n-2</tt>,\nrespectively).  We then go to <tt>fib-loop</tt>.  When we return from the\nrecursive call, the answer is in <tt>val</tt>.\nFigure&nbsp;<a href="#%_fig_5.12">5.12</a> shows the controller sequence for this\nmachine.<p>\n\n<a name="%_fig_5.11"></a><p><div align=left><table width=100%><tr><td><img src="ch5-Z-G-6.gif" border="0">\n<p><p><tt>(controller<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;fact-done))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;set&nbsp;up&nbsp;final&nbsp;return&nbsp;address</em><br>\n&nbsp;fact-loop<br>\n&nbsp;&nbsp;&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;n)&nbsp;(const&nbsp;1))<br>\n&nbsp;&nbsp;&nbsp;(branch&nbsp;(label&nbsp;base-case))<br>\n&nbsp;&nbsp;&nbsp;<em>;;&nbsp;Set&nbsp;up&nbsp;for&nbsp;the&nbsp;recursive&nbsp;call&nbsp;by&nbsp;saving&nbsp;<tt>n</tt>&nbsp;and&nbsp;<tt>continue</tt>.</em><br>\n&nbsp;&nbsp;&nbsp;<em>;;&nbsp;Set&nbsp;up&nbsp;<tt>continue</tt>&nbsp;so&nbsp;that&nbsp;the&nbsp;computation&nbsp;will&nbsp;continue</em><br>\n&nbsp;&nbsp;&nbsp;<em>;;&nbsp;at&nbsp;<tt>after-fact</tt>&nbsp;when&nbsp;the&nbsp;subroutine&nbsp;returns.</em><br>\n&nbsp;&nbsp;&nbsp;(save&nbsp;continue)<br>\n&nbsp;&nbsp;&nbsp;(save&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;n&nbsp;(op&nbsp;-)&nbsp;(reg&nbsp;n)&nbsp;(const&nbsp;1))<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;after-fact))<br>\n&nbsp;&nbsp;&nbsp;(goto&nbsp;(label&nbsp;fact-loop))<br>\n&nbsp;after-fact<br>\n&nbsp;&nbsp;&nbsp;(restore&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;(restore&nbsp;continue)<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;*)&nbsp;(reg&nbsp;n)&nbsp;(reg&nbsp;val))&nbsp;&nbsp;&nbsp;<em>;&nbsp;<tt>val</tt>&nbsp;now&nbsp;contains</em>&nbsp;<em>n</em>(<em>n</em> - 1)!<br>\n&nbsp;&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;return&nbsp;to&nbsp;caller</em><br>\n&nbsp;base-case<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;1))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;base&nbsp;case: </em>1! = 1<br>\n&nbsp;&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;return&nbsp;to&nbsp;caller</em><br>\n&nbsp;fact-done)<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.11:</b>&nbsp;&nbsp;A recursive factorial machine.</div></caption><tr><td>\n<a name="%_idx_5586"></a>\n</td></tr></table></div><p><p>\n\n<a name="%_fig_5.12"></a><p><div align=left><table width=100%><tr><td><p><p><tt>(controller<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;fib-done))<br>\n&nbsp;fib-loop<br>\n&nbsp;&nbsp;&nbsp;(test&nbsp;(op&nbsp;&lt;)&nbsp;(reg&nbsp;n)&nbsp;(const&nbsp;2))<br>\n&nbsp;&nbsp;&nbsp;(branch&nbsp;(label&nbsp;immediate-answer))<br>\n&nbsp;&nbsp;&nbsp;<em>;;&nbsp;set&nbsp;up&nbsp;to&nbsp;compute&nbsp;<em>F</em><em>i</em><em>b</em>(<em>n</em> - 1)</em><br>\n&nbsp;&nbsp;&nbsp;(save&nbsp;continue)<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;afterfib-n-1))<br>\n&nbsp;&nbsp;&nbsp;(save&nbsp;n)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;save&nbsp;old&nbsp;value&nbsp;of&nbsp;<tt>n</tt></em><br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;n&nbsp;(op&nbsp;-)&nbsp;(reg&nbsp;n)&nbsp;(const&nbsp;1))<em>;&nbsp;clobber&nbsp;<tt>n</tt>&nbsp;to&nbsp;<em>n</em> - 1</em><br>\n&nbsp;&nbsp;&nbsp;(goto&nbsp;(label&nbsp;fib-loop))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;perform&nbsp;recursive&nbsp;call</em><br>\n&nbsp;afterfib-n-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;upon&nbsp;return,&nbsp;<tt>val</tt>&nbsp;contains&nbsp;<em>F</em><em>i</em><em>b</em>(<em>n</em> - 1)</em><br>\n&nbsp;&nbsp;&nbsp;(restore&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;(restore&nbsp;continue)<br>\n&nbsp;&nbsp;&nbsp;<em>;;&nbsp;set&nbsp;up&nbsp;to&nbsp;compute&nbsp;<em>F</em><em>i</em><em>b</em>(<em>n</em> - 2)</em><br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;n&nbsp;(op&nbsp;-)&nbsp;(reg&nbsp;n)&nbsp;(const&nbsp;2))<br>\n&nbsp;&nbsp;&nbsp;(save&nbsp;continue)<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;afterfib-n-2))<br>\n&nbsp;&nbsp;&nbsp;(save&nbsp;val)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;save&nbsp;<em>F</em><em>i</em><em>b</em>(<em>n</em> - 1)</em><br>\n&nbsp;&nbsp;&nbsp;(goto&nbsp;(label&nbsp;fib-loop))<br>\n&nbsp;afterfib-n-2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;upon&nbsp;return,&nbsp;<tt>val</tt>&nbsp;contains&nbsp;<em>F</em><em>i</em><em>b</em>(<em>n</em> - 2)</em><br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;n&nbsp;(reg&nbsp;val))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;<tt>n</tt>&nbsp;now&nbsp;contains&nbsp;<em>F</em><em>i</em><em>b</em>(<em>n</em> - 2)</em><br>\n&nbsp;&nbsp;&nbsp;(restore&nbsp;val)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;<tt>val</tt>&nbsp;now&nbsp;contains&nbsp;<em>F</em><em>i</em><em>b</em>(<em>n</em> - 1)</em><br>\n&nbsp;&nbsp;&nbsp;(restore&nbsp;continue)<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;val&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;&nbsp;<em>F</em><em>i</em><em>b</em>(<em>n</em> - 1) + &nbsp;<em>F</em><em>i</em><em>b</em>(<em>n</em> - 2)</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;+)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;n))&nbsp;<br>\n&nbsp;&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;return&nbsp;to&nbsp;caller,&nbsp;answer&nbsp;is&nbsp;in&nbsp;<tt>val</tt></em><br>\n&nbsp;immediate-answer<br>\n&nbsp;&nbsp;&nbsp;(assign&nbsp;val&nbsp;(reg&nbsp;n))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;base&nbsp;case:&nbsp;&nbsp;<em>F</em><em>i</em><em>b</em>(<em>n</em>) = <em>n</em></em><br>\n&nbsp;&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\n&nbsp;fib-done)<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.12:</b>&nbsp;&nbsp;Controller for a machine to compute Fibonacci\nnumbers.</div></caption><tr><td>\n<a name="%_idx_5588"></a>\n</td></tr></table></div><p><p>\n\n<p><a name="%_thm_5.4"></a>\n<b>Exercise 5.4.</b>&nbsp;&nbsp;Specify register machines that implement each of the following\nprocedures.  For each machine, write a controller instruction sequence\nand draw a diagram showing the data paths.<p>\n\n<p><p>a. Recursive exponentiation:<p>\n\n<p><p><tt><a name="%_idx_5590"></a>(define&nbsp;(expt&nbsp;b&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;b&nbsp;(expt&nbsp;b&nbsp;(-&nbsp;n&nbsp;1)))))<br>\n</tt><p><p>\n<p><p>b. Iterative exponentiation:<p>\n\n<p><p><tt>(define&nbsp;(expt&nbsp;b&nbsp;n)<br>\n&nbsp;&nbsp;(define&nbsp;(expt-iter&nbsp;counter&nbsp;product)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;counter&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(expt-iter&nbsp;(-&nbsp;counter&nbsp;1)&nbsp;(*&nbsp;b&nbsp;product))))<br>\n&nbsp;&nbsp;(expt-iter&nbsp;n&nbsp;1))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_5.5"></a>\n<b>Exercise 5.5.</b>&nbsp;&nbsp;Hand-simulate the factorial and Fibonacci machines, using some\nnontrivial input (requiring execution of at least one recursive call).\nShow the contents of the stack at each significant point in the\nexecution.\n\n<p><p>\n\n<p><a name="%_thm_5.6"></a>\n<b>Exercise 5.6.</b>&nbsp;&nbsp;Ben Bitdiddle observes that the Fibonacci machine\'s controller sequence\nhas an extra <tt>save</tt> and an extra <tt>restore</tt>, which can be\nremoved to make a faster machine.  Where are these instructions?\n<p>\n\n<a name="%_sec_5.1.5"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.1.5">5.1.5&nbsp;&nbsp;Instruction Summary</a></h3><p>\n\n<a name="%_idx_5592"></a>\n<a name="%_idx_5594"></a><a name="%_idx_5596"></a>A controller instruction in our register-machine language\nhas one of the following forms, where each\n&lt;<em>input<sub><em>i</em></sub></em>&gt; is either <tt>(reg &lt;<em>register-name</em>&gt;)</tt>\nor <tt>(const &lt;<em>constant-value</em>&gt;)</tt>.\n<p>\n\nThese instructions were introduced in\nsection&nbsp;<a href="#%_sec_5.1.1">5.1.1</a>:\n<p><p><tt><a name="%_idx_5598"></a>(assign&nbsp;&lt;<em>register-name</em>&gt;&nbsp;(reg&nbsp;&lt;<em>register-name</em>&gt;))<br>\n<br>\n(assign&nbsp;&lt;<em>register-name</em>&gt;&nbsp;(const&nbsp;&lt;<em>constant-value</em>&gt;))<br>\n<br>\n<a name="%_idx_5600"></a>(assign&nbsp;&lt;<em>register-name</em>&gt;&nbsp;(op&nbsp;&lt;<em>operation-name</em>&gt;)&nbsp;&lt;<em>input<sub>1</sub></em>&gt;&nbsp;<tt>...</tt> &lt;<em>input<sub><em>n</em></sub></em>&gt;)<br>\n<br>\n<a name="%_idx_5602"></a>(perform&nbsp;(op&nbsp;&lt;<em>operation-name</em>&gt;)&nbsp;&lt;<em>input<sub>1</sub></em>&gt;&nbsp;<tt>...</tt> &lt;<em>input<sub><em>n</em></sub></em>&gt;)<br>\n<br>\n<a name="%_idx_5604"></a>(test&nbsp;(op&nbsp;&lt;<em>operation-name</em>&gt;)&nbsp;&lt;<em>input<sub>1</sub></em>&gt;&nbsp;<tt>...</tt> &lt;<em>input<sub><em>n</em></sub></em>&gt;)<br>\n<br>\n<a name="%_idx_5606"></a><a name="%_idx_5608"></a>(branch&nbsp;(label&nbsp;&lt;<em>label-name</em>&gt;))<br>\n<br>\n<a name="%_idx_5610"></a>(goto&nbsp;(label&nbsp;&lt;<em>label-name</em>&gt;))<br>\n</tt><p><p>\n<p>\n\nThe use of registers to hold labels was introduced in\nsection&nbsp;<a href="#%_sec_5.1.3">5.1.3</a>:\n<p><p><tt>(assign&nbsp;&lt;<em>register-name</em>&gt;&nbsp;(label&nbsp;&lt;<em>label-name</em>&gt;))<br>\n<br>\n(goto&nbsp;(reg&nbsp;&lt;<em>register-name</em>&gt;))<br>\n</tt><p><p><p>\n\nInstructions to use the stack were introduced in\nsection&nbsp;<a href="#%_sec_5.1.4">5.1.4</a>:\n<p><p><tt><a name="%_idx_5612"></a>(save&nbsp;&lt;<em>register-name</em>&gt;)<br>\n<br>\n<a name="%_idx_5614"></a>(restore&nbsp;&lt;<em>register-name</em>&gt;)<br>\n</tt><p><p><p>\n\n<a name="%_idx_5616"></a><a name="%_idx_5618"></a><a name="%_idx_5620"></a>The only kind of &lt;<em>constant-value</em>&gt; we have seen so far is a number,\nbut later we will use strings, symbols, and lists.\nFor example,\n<tt>(const&nbsp;&quot;abc&quot;)</tt> is the string <tt>&quot;abc&quot;</tt>,\n<tt>(const&nbsp;abc)</tt> is the symbol <tt>abc</tt>,\n<tt>(const&nbsp;(a b c))</tt> is the list <tt>(a b c)</tt>,\nand <tt>(const&nbsp;())</tt> is the empty list.\n<p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_715" href="#call_footnote_Temp_715"><sup><small>1</small></sup></a> This assumption\nglosses over a great deal of complexity.  Usually a large portion of\nthe implementation of a Lisp system is dedicated to making reading\nand printing work.\n\n<p><a name="footnote_Temp_717" href="#call_footnote_Temp_717"><sup><small>2</small></sup></a> One might argue that we don\'t need to save the old\n<tt>n</tt>; after we decrement it and solve the subproblem, we could\nsimply increment it to recover the old value.  Although this strategy\nworks for factorial, it cannot work in general, since the old value of\na register cannot always be computed from the new one.\n\n<p><a name="footnote_Temp_718" href="#call_footnote_Temp_718"><sup><small>3</small></sup></a> In\nsection&nbsp;<a href="book-Z-H-33.html#%_sec_5.3">5.3</a> we will see how to implement a\nstack in terms of more primitive operations.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_5.2"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_5.2">5.2&nbsp;&nbsp;A Register-Machine Simulator</a></h2><p>\n\n\n<a name="%_idx_5622"></a><a name="%_idx_5624"></a>\nIn order to gain a good understanding of the design of register\nmachines, we must test the machines we design to see if they perform\nas expected.  One way to test a design is to hand-simulate the\noperation of the controller, as in exercise&nbsp;<a href="book-Z-H-31.html#%_thm_5.5">5.5</a>.  But this is\nextremely tedious for all but the simplest machines.  In this section\nwe construct a simulator for machines described in the\nregister-machine language.  The simulator is a Scheme program with\nfour interface procedures.  The first uses a description of a register\nmachine to construct a model of the machine (a data structure whose\nparts correspond to the parts of the machine to be simulated), and the\nother three allow us to simulate the machine by manipulating the\nmodel:<p>\n\n<blockquote>\n<p><a name="%_idx_5626"></a><tt>(make-machine &lt;<em>register-names</em>&gt; &lt;<em>operations</em>&gt; &lt;<em>controller</em>&gt;)</tt><br>\nconstructs and returns a model of the machine with the given\nregisters, operations, and controller.<p>\n\n<p><a name="%_idx_5628"></a><tt>(set-register-contents! &lt;<em>machine-model</em>&gt; &lt;<em>register-name</em>&gt; &lt;<em>value</em>&gt;)</tt><br>\nstores a value in a simulated register in the given\nmachine.<p>\n\n<a name="%_idx_5630"></a><p><tt>(get-register-contents &lt;<em>machine-model</em>&gt; &lt;<em>register-name</em>&gt;)</tt><br>\nreturns the contents of a simulated register in the given machine.<p>\n\n<a name="%_idx_5632"></a><p><tt>(start &lt;<em>machine-model</em>&gt;)</tt><br>\nsimulates the execution of the given\nmachine, starting from the beginning of the controller sequence and\nstopping when it reaches the end of the sequence.\n</blockquote><p>\n\nAs an example of how these procedures are used, we can define\n<tt>gcd-machine</tt> to be a model of the GCD machine\nof section&nbsp;<a href="book-Z-H-31.html#%_sec_5.1.1">5.1.1</a> as follows:<p>\n\n<p><p><tt><a name="%_idx_5634"></a>(define&nbsp;gcd-machine<br>\n&nbsp;&nbsp;(make-machine<br>\n&nbsp;&nbsp;&nbsp;\'(a&nbsp;b&nbsp;t)<br>\n&nbsp;&nbsp;&nbsp;(list&nbsp;(list&nbsp;\'rem&nbsp;remainder)&nbsp;(list&nbsp;\'=&nbsp;=))<br>\n&nbsp;&nbsp;&nbsp;\'(test-b<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;b)&nbsp;(const&nbsp;0))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(branch&nbsp;(label&nbsp;gcd-done))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;t&nbsp;(op&nbsp;rem)&nbsp;(reg&nbsp;a)&nbsp;(reg&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;a&nbsp;(reg&nbsp;b))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;b&nbsp;(reg&nbsp;t))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(goto&nbsp;(label&nbsp;test-b))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcd-done)))<br>\n</tt><p><p>\nThe first argument to <tt>make-machine</tt> is a list of register names.\nThe next argument is a table (a list of two-element lists) that pairs\neach operation name with a Scheme procedure that implements the operation\n(that is, produces the same output value given the same input values).\nThe last argument specifies the controller as a list of labels and\nmachine instructions, as in section&nbsp;<a href="book-Z-H-31.html#%_sec_5.1">5.1</a>.<p>\n\n\nTo compute GCDs with this machine, we set the\ninput registers, start the machine, and examine the result when the\nsimulation terminates:\n<p><p><tt>(set-register-contents!&nbsp;gcd-machine&nbsp;\'a&nbsp;206)<br>\n<i>done</i><br>\n(set-register-contents!&nbsp;gcd-machine&nbsp;\'b&nbsp;40)<br>\n<i>done</i><br>\n(start&nbsp;gcd-machine)<br>\n<i>done</i><br>\n(get-register-contents&nbsp;gcd-machine&nbsp;\'a)<br>\n<i>2</i><br>\n</tt><p><p>\nThis computation will run much more slowly than a <tt>gcd</tt> procedure\nwritten in Scheme, because we will simulate low-level machine\ninstructions, such as <tt>assign</tt>, by much more complex operations.<p>\n\n<p><a name="%_thm_5.7"></a>\n<b>Exercise 5.7.</b>&nbsp;&nbsp;Use the simulator to test the machines you designed in\nexercise&nbsp;<a href="book-Z-H-31.html#%_thm_5.4">5.4</a>.\n<p><p>\n\n<a name="%_sec_5.2.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.2.1">5.2.1&nbsp;&nbsp;The Machine Model</a></h3><p>\n\n<p>\n\nThe machine model generated by <tt>make-machine</tt> is represented as a\nprocedure with local state using the message-passing techniques\ndeveloped in chapter&nbsp;3.  To build this model, <tt>make-machine</tt>\nbegins by calling the procedure <tt>make-new-machine</tt> to construct\nthe parts of the machine model that are common to all register\nmachines.  This basic machine model constructed by <tt>make-new-machine</tt> is essentially a container for some registers and a\nstack, together with an execution mechanism that processes the controller\ninstructions one by one.<p>\n\n<tt>Make-machine</tt> then extends this basic model (by sending it\nmessages) to include the registers, operations, and controller of the\nparticular machine being defined.  First it allocates a register in\nthe new machine for each of the supplied register names and installs\nthe designated operations in the machine.  Then it uses an <a name="%_idx_5636"></a><em>assembler</em> (described below in section&nbsp;<a href="#%_sec_5.2.2">5.2.2</a>) to\ntransform the controller list into instructions for the new machine\nand installs these as the machine\'s instruction sequence.  <tt>Make-machine</tt> returns as its value the modified machine model.<p>\n\n<p><p><tt><a name="%_idx_5638"></a>(define&nbsp;(make-machine&nbsp;register-names&nbsp;ops&nbsp;controller-text)<br>\n&nbsp;&nbsp;(let&nbsp;((machine&nbsp;(make-new-machine)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(for-each&nbsp;(lambda&nbsp;(register-name)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((machine&nbsp;\'allocate-register)&nbsp;register-name))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;register-names)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;((machine&nbsp;\'install-operations)&nbsp;ops)&nbsp;&nbsp;&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;((machine&nbsp;\'install-instruction-sequence)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assemble&nbsp;controller-text&nbsp;machine))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;machine))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_724"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_724">Registers</a></h4><p>\n\n<a name="%_idx_5640"></a>\nWe will represent a register as a procedure with local state, as in\nchapter&nbsp;3.  The procedure <tt>make-register</tt> creates a register that\nholds a value that can be accessed or changed:<p>\n\n<p><p><tt><a name="%_idx_5642"></a>(define&nbsp;(make-register&nbsp;name)<br>\n&nbsp;&nbsp;(let&nbsp;((contents&nbsp;\'*unassigned*))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;message)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;message&nbsp;\'get)&nbsp;contents)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;message&nbsp;\'set)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(value)&nbsp;(set!&nbsp;contents&nbsp;value)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;REGISTER&quot;&nbsp;message))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dispatch))<br>\n</tt><p><p>\nThe following procedures are used to access registers:<p>\n\n<p><p><tt><a name="%_idx_5644"></a>(define&nbsp;(get-contents&nbsp;register)<br>\n&nbsp;&nbsp;(register&nbsp;\'get))<br>\n<br>\n<a name="%_idx_5646"></a>(define&nbsp;(set-contents!&nbsp;register&nbsp;value)<br>\n&nbsp;&nbsp;((register&nbsp;\'set)&nbsp;value))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_725"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_725">The stack</a></h4><p>\n\n<a name="%_idx_5648"></a>\nWe can also represent a stack as a procedure with local state.  The\nprocedure <tt>make-stack</tt> creates a stack whose local state consists\nof a list of the items on the stack.  A stack accepts requests to <tt>push</tt> an item onto the stack, to <tt>pop</tt> the top item off the stack\nand return it, and to <tt>initialize</tt> the stack to empty.<p>\n\n<p><p><tt><a name="%_idx_5650"></a>(define&nbsp;(make-stack)<br>\n&nbsp;&nbsp;(let&nbsp;((s&nbsp;\'()))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(push&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;s&nbsp;(cons&nbsp;x&nbsp;s)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(pop)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;s)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Empty&nbsp;stack&nbsp;--&nbsp;POP&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((top&nbsp;(car&nbsp;s)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;s&nbsp;(cdr&nbsp;s))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(initialize)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;s&nbsp;\'())<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'done)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;message)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;message&nbsp;\'push)&nbsp;push)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;message&nbsp;\'pop)&nbsp;(pop))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;message&nbsp;\'initialize)&nbsp;(initialize))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;STACK&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dispatch))<br>\n</tt><p><p>\nThe following procedures are used to access stacks:<p>\n\n<p><p><tt><a name="%_idx_5652"></a>(define&nbsp;(pop&nbsp;stack)<br>\n&nbsp;&nbsp;(stack&nbsp;\'pop))<br>\n<br>\n<a name="%_idx_5654"></a>(define&nbsp;(push&nbsp;stack&nbsp;value)<br>\n&nbsp;&nbsp;((stack&nbsp;\'push)&nbsp;value))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_726"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_726">The basic machine</a></h4><p>\n\nThe <tt>make-new-machine</tt> procedure, shown in\nfigure&nbsp;<a href="#%_fig_5.13">5.13</a>, constructs an object whose local\nstate consists of a stack, an initially empty instruction sequence, a\nlist of operations that initially contains an operation to <a name="%_idx_5656"></a>initialize\nthe stack, and a <a name="%_idx_5658"></a><em>register table</em> that initially contains two\n<a name="%_idx_5660"></a><a name="%_idx_5662"></a>registers, named <tt>flag</tt> and <tt>pc</tt> <a name="%_idx_5664"></a>(for ``program counter\'\').\nThe internal procedure <tt>allocate-register</tt> adds new entries to the\nregister table, and the internal procedure <tt>lookup-register</tt> looks\nup registers in the table.<p>\n\n\nThe <tt>flag</tt> register is used to control branching in the simulated\nmachine.  <tt>Test</tt> instructions set the contents of <tt>flag</tt> to\nthe result of the test (true or false).  <tt>Branch</tt> instructions\ndecide whether or not to branch by examining the contents of <tt>flag</tt>.<p>\n\nThe <tt>pc</tt> register determines the sequencing of instructions as\nthe machine runs.  This sequencing is implemented by the internal\nprocedure <tt>execute</tt>.\nIn the simulation model, each machine instruction is a data structure\nthat includes a procedure of no arguments, called the <a name="%_idx_5666"></a><a name="%_idx_5668"></a><em>instruction\nexecution procedure</em>, such that calling this procedure simulates\nexecuting the instruction.  As the simulation runs, <tt>pc</tt> points to\nthe place in the instruction sequence beginning with the next\ninstruction to be executed.  <a name="%_idx_5670"></a><tt>Execute</tt> gets that instruction,\nexecutes it by calling the instruction execution procedure, and\nrepeats this cycle until there are no more instructions to execute\n(i.e., until <tt>pc</tt> points to the end of the instruction sequence).<p>\n\n<a name="%_fig_5.13"></a><p><div align=left><table width=100%><tr><td><p><p><tt><a name="%_idx_5672"></a>(define&nbsp;(make-new-machine)<br>\n&nbsp;&nbsp;(let&nbsp;((pc&nbsp;(make-register&nbsp;\'pc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flag&nbsp;(make-register&nbsp;\'flag))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stack&nbsp;(make-stack))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(the-instruction-sequence&nbsp;\'()))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((the-ops<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(list&nbsp;\'initialize-stack<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(stack&nbsp;\'initialize)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(register-table<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(list&nbsp;\'pc&nbsp;pc)&nbsp;(list&nbsp;\'flag&nbsp;flag))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(allocate-register&nbsp;name)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(assoc&nbsp;name&nbsp;register-table)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Multiply&nbsp;defined&nbsp;register:&nbsp;&quot;&nbsp;name)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;register-table<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(list&nbsp;name&nbsp;(make-register&nbsp;name))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;register-table)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'register-allocated)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(lookup-register&nbsp;name)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((val&nbsp;(assoc&nbsp;name&nbsp;register-table)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;val<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cadr&nbsp;val)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;register:&quot;&nbsp;name))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(execute)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((insts&nbsp;(get-contents&nbsp;pc)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;insts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'done<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((instruction-execution-proc&nbsp;(car&nbsp;insts)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(execute)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;message)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;message&nbsp;\'start)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-contents!&nbsp;pc&nbsp;the-instruction-sequence)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(execute))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;message&nbsp;\'install-instruction-sequence)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(seq)&nbsp;(set!&nbsp;the-instruction-sequence&nbsp;seq)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;message&nbsp;\'allocate-register)&nbsp;allocate-register)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;message&nbsp;\'get-register)&nbsp;lookup-register)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;message&nbsp;\'install-operations)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ops)&nbsp;(set!&nbsp;the-ops&nbsp;(append&nbsp;the-ops&nbsp;ops))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;message&nbsp;\'stack)&nbsp;stack)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;message&nbsp;\'operations)&nbsp;the-ops)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;MACHINE&quot;&nbsp;message))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch)))<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.13:</b>&nbsp;&nbsp;The <tt>make-new-machine</tt> procedure, which implements\nthe basic machine model.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\nAs part of its operation, each instruction execution procedure\nmodifies <tt>pc</tt> to indicate the next instruction to be executed.\n<tt>Branch</tt> and <tt>goto</tt> instructions change <tt>pc</tt> to point to\nthe new destination.  All other instructions simply advance <tt>pc</tt>,\nmaking it point to the next instruction in the sequence.  Observe that\neach call to <tt>execute</tt> calls <tt>execute</tt> again, but this does\nnot produce an infinite loop because running the instruction execution\nprocedure changes the contents of <tt>pc</tt>.<p>\n\n<tt>Make-new-machine</tt> returns a\n<tt>dispatch</tt> procedure that implements message-passing\naccess to the internal state.  Notice that starting the machine is\naccomplished by setting <tt>pc</tt> to the beginning of the instruction\nsequence and calling <tt>execute</tt>.<p>\n\nFor convenience, we provide an alternate procedural interface to a\nmachine\'s <tt>start</tt> operation,\nas well as procedures to set and examine register contents,\nas specified at the beginning of section&nbsp;<a href="#%_sec_5.2">5.2</a>:<p>\n\n<p><p><tt><a name="%_idx_5674"></a>(define&nbsp;(start&nbsp;machine)<br>\n&nbsp;&nbsp;(machine&nbsp;\'start))<br>\n<a name="%_idx_5676"></a>(define&nbsp;(get-register-contents&nbsp;machine&nbsp;register-name)<br>\n&nbsp;&nbsp;(get-contents&nbsp;(get-register&nbsp;machine&nbsp;register-name)))<br>\n<a name="%_idx_5678"></a>(define&nbsp;(set-register-contents!&nbsp;machine&nbsp;register-name&nbsp;value)<br>\n&nbsp;&nbsp;(set-contents!&nbsp;(get-register&nbsp;machine&nbsp;register-name)&nbsp;value)<br>\n&nbsp;&nbsp;\'done)<br>\n</tt><p><p>\nThese procedures (and many procedures in sections&nbsp;<a href="#%_sec_5.2.2">5.2.2</a>\nand <a href="#%_sec_5.2.3">5.2.3</a>) use the following to look up the register with a\ngiven name in a given machine:\n<p><p><tt><a name="%_idx_5680"></a>(define&nbsp;(get-register&nbsp;machine&nbsp;reg-name)<br>\n&nbsp;&nbsp;((machine&nbsp;\'get-register)&nbsp;reg-name))<br>\n</tt><p><p><p>\n\n<p>\n\n<a name="%_sec_5.2.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.2.2">5.2.2&nbsp;&nbsp;The Assembler</a></h3><p>\n\n\n<a name="%_idx_5682"></a>\nThe assembler transforms the sequence of controller expressions for a\nmachine into a corresponding list of machine instructions, each with\nits execution procedure.  Overall, the assembler is much like the\nevaluators we studied in chapter&nbsp;4 -- there is an input language (in\nthis case, the register-machine language) and we must perform an\nappropriate action for each type of expression in the language.<p>\n\n<a name="%_idx_5684"></a>The technique of producing an execution procedure for each instruction\nis just what we used in section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a> to speed\nup the evaluator by separating analysis from runtime execution.  As we\nsaw in chapter&nbsp;4, much useful analysis of Scheme expressions could be\nperformed without knowing the actual values of variables.  Here,\nanalogously, much useful analysis of register-machine-language\nexpressions can be performed without knowing the actual contents of\nmachine registers.  For example, we can replace references to\nregisters by pointers to the register objects, and we can\nreplace references to labels by pointers to the place in the\ninstruction sequence that the label designates.<p>\n\nBefore it can generate the instruction execution procedures, the\nassembler must know what all the labels refer to, so it begins by\nscanning the controller text to separate the labels from the\ninstructions.  As it scans the text, it constructs both a list of\ninstructions and a table that associates each label with a pointer\ninto that list.  Then the assembler augments the instruction list by\ninserting the execution procedure for each instruction.<p>\n\nThe <tt>assemble</tt> procedure is the main entry to the assembler.\nIt takes the controller text and the machine model as arguments and\nreturns the instruction sequence to be stored in the model.\n<tt>Assemble</tt> calls <tt>extract-labels</tt> to build the initial instruction list\nand label table from the supplied controller text.  The second argument\nto <tt>extract-labels</tt> is a procedure to be called to process these results:\nThis procedure uses <tt>update-insts!</tt> to generate the instruction execution\nprocedures and insert them into the instruction list,\nand returns the modified list.\n<p><p><tt><a name="%_idx_5686"></a>(define&nbsp;(assemble&nbsp;controller-text&nbsp;machine)<br>\n&nbsp;&nbsp;(extract-labels&nbsp;controller-text<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(insts&nbsp;labels)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(update-insts!&nbsp;insts&nbsp;labels&nbsp;machine)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insts)))<br>\n</tt><p><p><p>\n\n<tt>Extract-labels</tt>\ntakes as arguments a list <tt>text</tt> (the sequence of controller\ninstruction expressions) and a <tt>receive</tt> procedure.  <tt>Receive</tt>\nwill be called with two values: (1) a list <tt>insts</tt> of instruction\ndata structures, each containing an instruction from <tt>text</tt>; and\n(2) a table called <tt>labels</tt>, which associates each label from <tt>text</tt>\nwith the position in the list <tt>insts</tt> that the label designates.<p>\n\n<p><p><tt><a name="%_idx_5688"></a>(define&nbsp;(extract-labels&nbsp;text&nbsp;receive)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;text)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(receive&nbsp;\'()&nbsp;\'())<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(extract-labels&nbsp;(cdr&nbsp;text)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(insts&nbsp;labels)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((next-inst&nbsp;(car&nbsp;text)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(symbol?&nbsp;next-inst)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(receive&nbsp;insts<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(make-label-entry&nbsp;next-inst<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(receive&nbsp;(cons&nbsp;(make-instruction&nbsp;next-inst)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels)))))))<br>\n</tt><p><p>\n<tt>Extract-labels</tt> works by sequentially scanning the elements of\nthe <tt>text</tt> and accumulating the <tt>insts</tt> and the <tt>labels</tt>.\nIf an element is a symbol (and thus a label) an appropriate entry is\nadded to the <tt>labels</tt> table.  Otherwise the element is accumulated\nonto the <tt>insts</tt> list.<a name="call_footnote_Temp_727" href="#footnote_Temp_727"><sup><small>4</small></sup></a><p>\n\n<tt>Update-insts!</tt> modifies the instruction list, which initially\ncontains only the text of the instructions, to include the\ncorresponding execution procedures:<p>\n\n\n<p><p><tt><a name="%_idx_5702"></a>(define&nbsp;(update-insts!&nbsp;insts&nbsp;labels&nbsp;machine)<br>\n&nbsp;&nbsp;(let&nbsp;((pc&nbsp;(get-register&nbsp;machine&nbsp;\'pc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(flag&nbsp;(get-register&nbsp;machine&nbsp;\'flag))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stack&nbsp;(machine&nbsp;\'stack))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ops&nbsp;(machine&nbsp;\'operations)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(for-each<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(inst)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-instruction-execution-proc!&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-execution-procedure<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(instruction-text&nbsp;inst)&nbsp;labels&nbsp;machine<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc&nbsp;flag&nbsp;stack&nbsp;ops)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insts)))<br>\n</tt><p><p><p>\n\n\nThe machine instruction data structure simply pairs the\ninstruction text with the corresponding execution procedure.\nThe execution procedure is not yet available when <tt>extract-labels</tt>\nconstructs the instruction, and is inserted later by <tt>update-insts!</tt>.\n\n<p><p><tt><a name="%_idx_5704"></a>(define&nbsp;(make-instruction&nbsp;text)<br>\n&nbsp;&nbsp;(cons&nbsp;text&nbsp;\'()))<br>\n<a name="%_idx_5706"></a>(define&nbsp;(instruction-text&nbsp;inst)<br>\n&nbsp;&nbsp;(car&nbsp;inst))<br>\n<a name="%_idx_5708"></a>(define&nbsp;(instruction-execution-proc&nbsp;inst)<br>\n&nbsp;&nbsp;(cdr&nbsp;inst))<br>\n<a name="%_idx_5710"></a>(define&nbsp;(set-instruction-execution-proc!&nbsp;inst&nbsp;proc)<br>\n&nbsp;&nbsp;(set-cdr!&nbsp;inst&nbsp;proc))<br>\n</tt><p><p>\nThe instruction text is not used by our simulator, but it is handy to keep\naround for debugging (see exercise&nbsp;<a href="#%_thm_5.16">5.16</a>).<p>\n\nElements of the label table are pairs:\n\n<p><p><tt><a name="%_idx_5712"></a>(define&nbsp;(make-label-entry&nbsp;label-name&nbsp;insts)<br>\n&nbsp;&nbsp;(cons&nbsp;label-name&nbsp;insts))<br>\n</tt><p><p>\nEntries will be looked up in the table with\n\n<p><p><tt><a name="%_idx_5714"></a>(define&nbsp;(lookup-label&nbsp;labels&nbsp;label-name)<br>\n&nbsp;&nbsp;(let&nbsp;((val&nbsp;(assoc&nbsp;label-name&nbsp;labels)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;val<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;val)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Undefined&nbsp;label&nbsp;--&nbsp;ASSEMBLE&quot;&nbsp;label-name))))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_5.8"></a>\n<b>Exercise 5.8.</b>&nbsp;&nbsp;The following register-machine code is ambiguous, because the label\n<tt>here</tt> is defined more than once:\n<p><p><tt>start<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;here))<br>\nhere<br>\n&nbsp;&nbsp;(assign&nbsp;a&nbsp;(const&nbsp;3))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;there))<br>\nhere<br>\n&nbsp;&nbsp;(assign&nbsp;a&nbsp;(const&nbsp;4))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;there))<br>\nthere<br>\n</tt><p><p>\nWith the simulator as written, what will the contents of register <tt>a</tt>\nbe when control reaches <tt>there</tt>?  Modify the <tt>extract-labels</tt>\nprocedure so that the assembler will signal an error if the same label\nname is used to indicate two different locations.\n<p>\n<p>\n\n<a name="%_sec_5.2.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.2.3">5.2.3&nbsp;&nbsp;Generating Execution Procedures for Instructions</a></h3><p>\n\n\n<a name="%_idx_5716"></a>\nThe assembler calls <tt>make-execution-procedure</tt> to\ngenerate the execution procedure for an instruction.\nLike the <tt>analyze</tt> procedure in the evaluator of\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>, this dispatches on the type of\ninstruction to generate the appropriate execution procedure.\n<p><p><tt><a name="%_idx_5718"></a>(define&nbsp;(make-execution-procedure&nbsp;inst&nbsp;labels&nbsp;machine<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pc&nbsp;flag&nbsp;stack&nbsp;ops)<br>\n&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;(car&nbsp;inst)&nbsp;\'assign)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-assign&nbsp;inst&nbsp;machine&nbsp;labels&nbsp;ops&nbsp;pc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;(car&nbsp;inst)&nbsp;\'test)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-test&nbsp;inst&nbsp;machine&nbsp;labels&nbsp;ops&nbsp;flag&nbsp;pc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;(car&nbsp;inst)&nbsp;\'branch)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-branch&nbsp;inst&nbsp;machine&nbsp;labels&nbsp;flag&nbsp;pc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;(car&nbsp;inst)&nbsp;\'goto)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-goto&nbsp;inst&nbsp;machine&nbsp;labels&nbsp;pc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;(car&nbsp;inst)&nbsp;\'save)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-save&nbsp;inst&nbsp;machine&nbsp;stack&nbsp;pc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;(car&nbsp;inst)&nbsp;\'restore)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-restore&nbsp;inst&nbsp;machine&nbsp;stack&nbsp;pc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;(car&nbsp;inst)&nbsp;\'perform)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-perform&nbsp;inst&nbsp;machine&nbsp;labels&nbsp;ops&nbsp;pc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Unknown&nbsp;instruction&nbsp;type&nbsp;--&nbsp;ASSEMBLE&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst))))<br>\n</tt><p><p><p>\n\nFor each type of instruction in the register-machine language, there\nis a generator that builds an appropriate execution procedure.  The\ndetails of these procedures determine both the syntax and meaning of\nthe individual instructions in the register-machine language.\nWe use data abstraction to isolate the detailed syntax of\nregister-machine expressions from the general execution mechanism, as\nwe did for evaluators in section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.2">4.1.2</a>,\nby using syntax procedures to extract and classify the parts of an instruction.<p>\n\n\n<a name="%_sec_Temp_729"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_729"><tt>Assign</tt> instructions</a></h4><p>\n\n<a name="%_idx_5720"></a>\nThe <tt>make-assign</tt> procedure handles <tt>assign</tt> instructions:\n<p><p><tt><a name="%_idx_5722"></a>(define&nbsp;(make-assign&nbsp;inst&nbsp;machine&nbsp;labels&nbsp;operations&nbsp;pc)<br>\n&nbsp;&nbsp;(let&nbsp;((target<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-register&nbsp;machine&nbsp;(assign-reg-name&nbsp;inst)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(value-exp&nbsp;(assign-value-exp&nbsp;inst)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((value-proc<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(operation-exp?&nbsp;value-exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-operation-exp<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value-exp&nbsp;machine&nbsp;labels&nbsp;operations)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-primitive-exp<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;value-exp)&nbsp;machine&nbsp;labels))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;execution&nbsp;procedure&nbsp;for&nbsp;<tt>assign</tt></em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-contents!&nbsp;target&nbsp;(value-proc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(advance-pc&nbsp;pc)))))<br>\n</tt><p><p>\n<tt>Make-assign</tt> extracts the target register name (the\nsecond element of the instruction) and the value expression\n(the rest of the list that forms the instruction)\nfrom the <tt>assign</tt> instruction using the selectors\n<p><p><tt><a name="%_idx_5724"></a>(define&nbsp;(assign-reg-name&nbsp;assign-instruction)<br>\n&nbsp;&nbsp;(cadr&nbsp;assign-instruction))<br>\n<a name="%_idx_5726"></a>(define&nbsp;(assign-value-exp&nbsp;assign-instruction)<br>\n&nbsp;&nbsp;(cddr&nbsp;assign-instruction))<br>\n</tt><p><p>\nThe register name is looked up with <tt>get-register</tt> to produce the\ntarget register object.  The value expression is passed to <tt>make-operation-exp</tt> if the value is the result of an operation, and to\n<tt>make-primitive-exp</tt> otherwise.  These procedures (shown below)\nparse the value expression and produce an execution procedure for the\nvalue.  This is a procedure of no arguments, called <a name="%_idx_5728"></a><tt>value-proc</tt>,\nwhich will be evaluated during the simulation to produce the actual\nvalue to be assigned to the register.  Notice that the work of looking\nup the register name and parsing the value expression is performed\njust once, at assembly time, not every time the instruction is\nsimulated.  This saving of work is the reason we use execution\n<a name="%_idx_5730"></a>procedures, and corresponds directly to the saving in work we obtained\nby separating program analysis from execution in the evaluator of\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>.<p>\n\nThe result returned by <tt>make-assign</tt> is the execution\nprocedure for the <tt>assign</tt> instruction.  When this procedure is\ncalled (by the machine model\'s <tt>execute</tt> procedure),\nit sets the contents of the target register to the result\nobtained by executing <tt>value-proc</tt>.  Then it advances\nthe <tt>pc</tt> to the next instruction by running the procedure\n<p><p><tt><a name="%_idx_5732"></a>(define&nbsp;(advance-pc&nbsp;pc)<br>\n&nbsp;&nbsp;(set-contents!&nbsp;pc&nbsp;(cdr&nbsp;(get-contents&nbsp;pc))))<br>\n</tt><p><p>\n<tt>Advance-pc</tt> is the normal termination for all instructions except\n<tt>branch</tt> and <tt>goto</tt>.<p>\n\n<a name="%_sec_Temp_730"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_730"><tt>Test</tt>, <tt>branch</tt>, and <tt>goto</tt> instructions</a></h4><p>\n\n<a name="%_idx_5734"></a><tt>Make-test</tt> handles <tt>test</tt> instructions in a similar way.  It\nextracts the expression that specifies the condition to be tested and\ngenerates an execution procedure for it.  At simulation time, the\nprocedure for the condition is called, the result is assigned to the\n<tt>flag</tt> register, and the <tt>pc</tt> is advanced:\n<p><p><tt><a name="%_idx_5736"></a>(define&nbsp;(make-test&nbsp;inst&nbsp;machine&nbsp;labels&nbsp;operations&nbsp;flag&nbsp;pc)<br>\n&nbsp;&nbsp;(let&nbsp;((condition&nbsp;(test-condition&nbsp;inst)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(operation-exp?&nbsp;condition)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((condition-proc<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-operation-exp<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;condition&nbsp;machine&nbsp;labels&nbsp;operations)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-contents!&nbsp;flag&nbsp;(condition-proc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(advance-pc&nbsp;pc)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Bad&nbsp;TEST&nbsp;instruction&nbsp;--&nbsp;ASSEMBLE&quot;&nbsp;inst))))<br>\n<a name="%_idx_5738"></a>(define&nbsp;(test-condition&nbsp;test-instruction)<br>\n&nbsp;&nbsp;(cdr&nbsp;test-instruction))<br>\n</tt><p><p><p>\n\n<a name="%_idx_5740"></a>The execution procedure for a <tt>branch</tt> instruction checks the\ncontents of the <tt>flag</tt> register and either sets the contents of\nthe <tt>pc</tt> to the branch destination (if the branch is taken) or\nelse just advances the <tt>pc</tt> (if the branch is not taken).  Notice\nthat the indicated destination in a <tt>branch</tt> instruction must be a\nlabel, and the <tt>make-branch</tt> procedure enforces this.  Notice\nalso that the label is looked up at assembly time, not each time the\n<tt>branch</tt> instruction is simulated.<p>\n\n<p><p><tt><a name="%_idx_5742"></a>(define&nbsp;(make-branch&nbsp;inst&nbsp;machine&nbsp;labels&nbsp;flag&nbsp;pc)<br>\n&nbsp;&nbsp;(let&nbsp;((dest&nbsp;(branch-dest&nbsp;inst)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(label-exp?&nbsp;dest)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((insts<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lookup-label&nbsp;labels&nbsp;(label-exp-label&nbsp;dest))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(get-contents&nbsp;flag)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-contents!&nbsp;pc&nbsp;insts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(advance-pc&nbsp;pc))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Bad&nbsp;BRANCH&nbsp;instruction&nbsp;--&nbsp;ASSEMBLE&quot;&nbsp;inst))))<br>\n<a name="%_idx_5744"></a>(define&nbsp;(branch-dest&nbsp;branch-instruction)<br>\n&nbsp;&nbsp;(cadr&nbsp;branch-instruction))<br>\n</tt><p><p><p>\n\n<a name="%_idx_5746"></a>A <tt>goto</tt> instruction is similar to a branch, except that the\ndestination may be specified either as a label or as a register, and\nthere is no condition to check -- the <tt>pc</tt> is always set to the\nnew destination.\n<p><p><tt><a name="%_idx_5748"></a>(define&nbsp;(make-goto&nbsp;inst&nbsp;machine&nbsp;labels&nbsp;pc)<br>\n&nbsp;&nbsp;(let&nbsp;((dest&nbsp;(goto-dest&nbsp;inst)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((label-exp?&nbsp;dest)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((insts<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lookup-label&nbsp;labels<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(label-exp-label&nbsp;dest))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(set-contents!&nbsp;pc&nbsp;insts))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((register-exp?&nbsp;dest)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((reg<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-register&nbsp;machine<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(register-exp-reg&nbsp;dest))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-contents!&nbsp;pc&nbsp;(get-contents&nbsp;reg)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(error&nbsp;&quot;Bad&nbsp;GOTO&nbsp;instruction&nbsp;--&nbsp;ASSEMBLE&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst)))))<br>\n<a name="%_idx_5750"></a>(define&nbsp;(goto-dest&nbsp;goto-instruction)<br>\n&nbsp;&nbsp;(cadr&nbsp;goto-instruction))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_731"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_731">Other instructions</a></h4><p>\n\nThe stack instructions <tt>save</tt> and <tt>restore</tt> simply use the\nstack with the designated register and advance the <tt>pc</tt>:\n\n<p><p><tt><a name="%_idx_5752"></a><a name="%_idx_5754"></a>(define&nbsp;(make-save&nbsp;inst&nbsp;machine&nbsp;stack&nbsp;pc)<br>\n&nbsp;&nbsp;(let&nbsp;((reg&nbsp;(get-register&nbsp;machine<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stack-inst-reg-name&nbsp;inst))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(push&nbsp;stack&nbsp;(get-contents&nbsp;reg))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(advance-pc&nbsp;pc))))<br>\n<a name="%_idx_5756"></a><a name="%_idx_5758"></a>(define&nbsp;(make-restore&nbsp;inst&nbsp;machine&nbsp;stack&nbsp;pc)<br>\n&nbsp;&nbsp;(let&nbsp;((reg&nbsp;(get-register&nbsp;machine<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stack-inst-reg-name&nbsp;inst))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set-contents!&nbsp;reg&nbsp;(pop&nbsp;stack))&nbsp;&nbsp;&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(advance-pc&nbsp;pc))))<br>\n<a name="%_idx_5760"></a>(define&nbsp;(stack-inst-reg-name&nbsp;stack-instruction)<br>\n&nbsp;&nbsp;(cadr&nbsp;stack-instruction))<br>\n</tt><p><p><p>\n\n<a name="%_idx_5762"></a>The final instruction type, handled by <tt>make-perform</tt>, generates\nan execution procedure for the action to be performed.  At simulation\ntime, the action procedure is executed and the <tt>pc</tt> advanced.\n\n<p><p><tt><a name="%_idx_5764"></a>(define&nbsp;(make-perform&nbsp;inst&nbsp;machine&nbsp;labels&nbsp;operations&nbsp;pc)<br>\n&nbsp;&nbsp;(let&nbsp;((action&nbsp;(perform-action&nbsp;inst)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(operation-exp?&nbsp;action)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((action-proc<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-operation-exp<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action&nbsp;machine&nbsp;labels&nbsp;operations)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(action-proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(advance-pc&nbsp;pc)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Bad&nbsp;PERFORM&nbsp;instruction&nbsp;--&nbsp;ASSEMBLE&quot;&nbsp;inst))))<br>\n<a name="%_idx_5766"></a>(define&nbsp;(perform-action&nbsp;inst)&nbsp;(cdr&nbsp;inst))<br>\n</tt><p><p><p>\n\n\n<a name="%_sec_Temp_732"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_732">Execution procedures for subexpressions</a></h4><p>\n\n<a name="%_idx_5768"></a><a name="%_idx_5770"></a><a name="%_idx_5772"></a>The value of a <tt>reg</tt>, <tt>label</tt>, or <tt>const</tt> expression\nmay be needed for assignment to a register (<tt>make-assign</tt>) or for input to\nan operation (<tt>make-operation-exp</tt>, below).  The following procedure\ngenerates execution procedures to produce values for these expressions\nduring the simulation:\n\n<p><p><tt><a name="%_idx_5774"></a>(define&nbsp;(make-primitive-exp&nbsp;exp&nbsp;machine&nbsp;labels)<br>\n&nbsp;&nbsp;(cond&nbsp;((constant-exp?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((c&nbsp;(constant-exp-value&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;c)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((label-exp?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((insts<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lookup-label&nbsp;labels<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(label-exp-label&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;insts)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((register-exp?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((r&nbsp;(get-register&nbsp;machine<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(register-exp-reg&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(get-contents&nbsp;r))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;expression&nbsp;type&nbsp;--&nbsp;ASSEMBLE&quot;&nbsp;exp))))<br>\n</tt><p><p>\nThe syntax of <tt>reg</tt>, <tt>label</tt>, and <tt>const</tt> expressions\nis determined by\n<p><p><tt><a name="%_idx_5776"></a>(define&nbsp;(register-exp?&nbsp;exp)&nbsp;(tagged-list?&nbsp;exp&nbsp;\'reg))<br>\n<a name="%_idx_5778"></a>(define&nbsp;(register-exp-reg&nbsp;exp)&nbsp;(cadr&nbsp;exp))<br>\n<a name="%_idx_5780"></a>(define&nbsp;(constant-exp?&nbsp;exp)&nbsp;(tagged-list?&nbsp;exp&nbsp;\'const))<br>\n<a name="%_idx_5782"></a>(define&nbsp;(constant-exp-value&nbsp;exp)&nbsp;(cadr&nbsp;exp))<br>\n<a name="%_idx_5784"></a>(define&nbsp;(label-exp?&nbsp;exp)&nbsp;(tagged-list?&nbsp;exp&nbsp;\'label))<br>\n<a name="%_idx_5786"></a>(define&nbsp;(label-exp-label&nbsp;exp)&nbsp;(cadr&nbsp;exp))<br>\n</tt><p><p>\n<p>\n\n\n<a name="%_idx_5788"></a><tt>Assign</tt>, <tt>perform</tt>, and <tt>test</tt> instructions\nmay include the application of a machine operation (specified by\nan <tt>op</tt> expression) to some operands (specified by <tt>reg</tt>\nand <tt>const</tt> expressions).\nThe following procedure produces an execution procedure\nfor an ``operation expression\'\' -- a list containing the operation and\noperand expressions from the instruction:\n<p><p><tt><a name="%_idx_5790"></a>(define&nbsp;(make-operation-exp&nbsp;exp&nbsp;machine&nbsp;labels&nbsp;operations)<br>\n&nbsp;&nbsp;(let&nbsp;((op&nbsp;(lookup-prim&nbsp;(operation-exp-op&nbsp;exp)&nbsp;operations))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(aprocs<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(e)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-primitive-exp&nbsp;e&nbsp;machine&nbsp;labels))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(operation-exp-operands&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;op&nbsp;(map&nbsp;(lambda&nbsp;(p)&nbsp;(p))&nbsp;aprocs)))))<br>\n</tt><p><p>\nThe syntax of operation expressions is determined by\n<p><p><tt><a name="%_idx_5792"></a>(define&nbsp;(operation-exp?&nbsp;exp)<br>\n&nbsp;&nbsp;(and&nbsp;(pair?&nbsp;exp)&nbsp;(tagged-list?&nbsp;(car&nbsp;exp)&nbsp;\'op)))<br>\n<a name="%_idx_5794"></a>(define&nbsp;(operation-exp-op&nbsp;operation-exp)<br>\n&nbsp;&nbsp;(cadr&nbsp;(car&nbsp;operation-exp)))<br>\n<a name="%_idx_5796"></a>(define&nbsp;(operation-exp-operands&nbsp;operation-exp)<br>\n&nbsp;&nbsp;(cdr&nbsp;operation-exp))<br>\n</tt><p><p>\nObserve that the treatment of operation expressions is very much like\nthe treatment of procedure applications by the <tt>analyze-application</tt> procedure in the evaluator of\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a> in that we generate an execution\nprocedure for each operand.  At simulation time, we call the\noperand procedures and apply the Scheme procedure that simulates\nthe operation to the resulting values.\nThe simulation procedure is found by looking up the operation name in\nthe operation table for the machine:\n<p><p><tt><a name="%_idx_5798"></a>(define&nbsp;(lookup-prim&nbsp;symbol&nbsp;operations)<br>\n&nbsp;&nbsp;(let&nbsp;((val&nbsp;(assoc&nbsp;symbol&nbsp;operations)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;val<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cadr&nbsp;val)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;operation&nbsp;--&nbsp;ASSEMBLE&quot;&nbsp;symbol))))<br>\n</tt><p><p><p>\n\n<p><a name="%_thm_5.9"></a>\n<b>Exercise 5.9.</b>&nbsp;&nbsp;The treatment of machine operations above permits them to operate\non labels as well as on constants and the contents of registers.\nModify the expression-processing procedures to enforce the condition\nthat operations can be used only with registers and constants.\n<p><p>\n\n<p><a name="%_thm_5.10"></a>\n<b>Exercise 5.10.</b>&nbsp;&nbsp;Design a new syntax for register-machine instructions and modify the\nsimulator to use your new syntax.  Can you implement your new\nsyntax without changing any part of the simulator except the\nsyntax procedures in this section?\n<p><p>\n\n<p><a name="%_thm_5.11"></a>\n<b>Exercise 5.11.</b>&nbsp;&nbsp;<a name="%_idx_5800"></a><a name="%_idx_5802"></a>When we introduced <tt>save</tt> and <tt>restore</tt> in\nsection&nbsp;<a href="book-Z-H-31.html#%_sec_5.1.4">5.1.4</a>, we didn\'t specify what would happen\nif you tried to restore a register that was not the last one saved, as\nin the sequence<p>\n\n<p><p><tt>(save&nbsp;y)<br>\n(save&nbsp;x)<br>\n(restore&nbsp;y)<br>\n</tt><p><p>\nThere are several reasonable possibilities for the meaning of <tt>restore</tt>:<p>\n\na.&nbsp;&nbsp;<tt>(restore y)</tt> puts into <tt>y</tt> the last value saved on the\nstack, regardless of what register that value came from.  This is the\nway our simulator behaves.  Show how to take advantage of this\nbehavior to eliminate one instruction from the Fibonacci machine of\nsection&nbsp;<a href="book-Z-H-31.html#%_sec_5.1.4">5.1.4</a> (figure&nbsp;<a href="book-Z-H-31.html#%_fig_5.12">5.12</a>).<p>\n\nb.&nbsp;&nbsp;<tt>(restore y)</tt> puts into <tt>y</tt> the last value saved on the\nstack, but only if that value was saved from <tt>y</tt>; otherwise, it\nsignals an error.  Modify the simulator to behave this way.  You will\nhave to change <tt>save</tt> to put the register name on the stack along\nwith the value.<p>\n\nc.&nbsp;&nbsp;<tt>(restore y)</tt> puts into <tt>y</tt> the last value saved from <tt>y</tt> regardless of what other registers were saved after <tt>y</tt> and not\nrestored.  Modify the simulator to behave this way.  You will have to\nassociate a separate stack with each register.  You should make the\n<tt>initialize-stack</tt> operation initialize all the register stacks.\n<p><p>\n\n<p><a name="%_thm_5.12"></a>\n<b>Exercise 5.12.</b>&nbsp;&nbsp;The simulator can be used to help determine the data paths required\nfor implementing a machine with a given controller.  Extend\nthe assembler to store the following information in the machine model:\n<p><ul>\n<li>a list of all instructions, with duplicates removed, sorted by\ninstruction type (<tt>assign</tt>, <tt>goto</tt>, and so on);<p>\n\n<li>a list (without duplicates) of the registers used to hold entry\npoints (these are the registers referenced by <tt>goto</tt>\ninstructions);<p>\n\n<li>a list (without duplicates) of the registers that are <tt>save</tt>d\nor <tt>restore</tt>d;<p>\n\n<li>for each register, a list (without duplicates) of the sources from\nwhich it is assigned (for example, the sources for register <tt>val</tt>\nin the factorial machine of figure&nbsp;<a href="book-Z-H-31.html#%_fig_5.11">5.11</a> are\n<tt>(const 1)</tt> and <tt>((op *) (reg n) (reg val))</tt>).\n</ul><p>\nExtend the\nmessage-passing interface to the machine to provide access to this new\ninformation.  To test your analyzer, define the Fibonacci machine from\nfigure&nbsp;<a href="book-Z-H-31.html#%_fig_5.12">5.12</a> and examine the lists you constructed.\n<p><p>\n\n<p><a name="%_thm_5.13"></a>\n<b>Exercise 5.13.</b>&nbsp;&nbsp;Modify the simulator so that it uses the controller sequence to\ndetermine what registers the machine has rather than requiring a list\nof registers as an argument to <tt>make-machine</tt>.  Instead of\npre-allocating the registers in <tt>make-machine</tt>, you can allocate\nthem one at a time when they are first seen during assembly of the\ninstructions.\n<p>\n\n<a name="%_sec_5.2.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.2.4">5.2.4&nbsp;&nbsp;Monitoring Machine Performance</a></h3><p>\n\n\n<a name="%_idx_5804"></a>\n<a name="%_idx_5806"></a>Simulation is useful not only for verifying the correctness of a\nproposed machine design but also for measuring the machine\'s\nperformance.  For example, we can install in our simulation program a\n``meter\'\' that measures the number of stack operations used in a\ncomputation.  To do this, we modify our simulated stack to keep track\nof the number of times registers are saved on the stack and the\nmaximum depth reached by the stack, and add a message to the stack\'s\ninterface that prints the statistics, as shown below.\nWe also add an operation to the basic machine model to print the\nstack statistics, by initializing <tt>the-ops</tt> in <tt>make-new-machine</tt> to\n<p><p><tt><a name="%_idx_5808"></a><a name="%_idx_5810"></a>(list&nbsp;(list&nbsp;\'initialize-stack<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(stack&nbsp;\'initialize)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;\'print-stack-statistics<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(stack&nbsp;\'print-statistics))))<br>\n</tt><p><p>\nHere is the new version of <tt>make-stack</tt>:\n<p><p><tt><a name="%_idx_5812"></a>(define&nbsp;(make-stack)<br>\n&nbsp;&nbsp;(let&nbsp;((s&nbsp;\'())<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(number-pushes&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(max-depth&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(current-depth&nbsp;0))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(push&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;s&nbsp;(cons&nbsp;x&nbsp;s))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;number-pushes&nbsp;(+&nbsp;1&nbsp;number-pushes))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;current-depth&nbsp;(+&nbsp;1&nbsp;current-depth))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;max-depth&nbsp;(max&nbsp;current-depth&nbsp;max-depth)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(pop)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;s)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Empty&nbsp;stack&nbsp;--&nbsp;POP&quot;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((top&nbsp;(car&nbsp;s)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;s&nbsp;(cdr&nbsp;s))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;current-depth&nbsp;(-&nbsp;current-depth&nbsp;1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top)))&nbsp;&nbsp;&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(initialize)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;s&nbsp;\'())<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;number-pushes&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;max-depth&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;current-depth&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'done)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(print-statistics)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;(list&nbsp;\'total-pushes&nbsp;&nbsp;\'=&nbsp;number-pushes<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'maximum-depth&nbsp;\'=&nbsp;max-depth)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;(dispatch&nbsp;message)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;message&nbsp;\'push)&nbsp;push)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;message&nbsp;\'pop)&nbsp;(pop))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;message&nbsp;\'initialize)&nbsp;(initialize))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;message&nbsp;\'print-statistics)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(print-statistics))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;request&nbsp;--&nbsp;STACK&quot;&nbsp;message))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;dispatch))<br>\n</tt><p><p>\n<p>\n\nExercises&nbsp;<a href="#%_thm_5.15">5.15</a> through&nbsp;<a href="#%_thm_5.19">5.19</a>\ndescribe other useful monitoring and debugging features that can be\nadded to the register-machine simulator.<p>\n\n<p>\n\n<p><a name="%_thm_5.14"></a>\n<b>Exercise 5.14.</b>&nbsp;&nbsp;<a name="%_idx_5814"></a>Measure the number of pushes and the maximum stack depth required to\ncompute <em>n</em>! for various small values of <em>n</em> using the factorial\nmachine shown in figure&nbsp;<a href="book-Z-H-31.html#%_fig_5.11">5.11</a>.  From your data\ndetermine formulas in terms of <em>n</em> for the total number of push\noperations and the maximum stack depth used in computing <em>n</em>! for any\n<em>n</em> &gt; 1. Note that each of these is a linear function of <em>n</em> and is\nthus determined by two constants.  In order to get the statistics\nprinted, you will have to augment the factorial machine with instructions to\ninitialize the stack and print the statistics.\nYou may want to also modify the\nmachine so that it repeatedly reads a value for <em>n</em>, computes the\nfactorial, and prints the result (as we did for the GCD machine in\nfigure&nbsp;<a href="book-Z-H-31.html#%_fig_5.4">5.4</a>), so that you will not have to repeatedly\ninvoke <tt>get-register-contents</tt>, <tt>set-register-contents!</tt>, and\n<tt>start</tt>.\n\n<p><p>\n\n<p><a name="%_thm_5.15"></a>\n<b>Exercise 5.15.</b>&nbsp;&nbsp;Add <a name="%_idx_5816"></a><em>instruction counting</em> to the register machine simulation.\nThat is, have the machine model keep track of the number of\ninstructions executed.  Extend the machine model\'s interface to accept\na new message that prints the value of the instruction count and\nresets the count to zero.\n<p><p>\n\n<p><a name="%_thm_5.16"></a>\n<b>Exercise 5.16.</b>&nbsp;&nbsp;Augment the simulator to provide for <a name="%_idx_5818"></a><a name="%_idx_5820"></a><em>instruction tracing</em>.\nThat is, before each instruction is executed, the simulator should print\nthe text of the instruction.  Make the machine model accept <tt>trace-on</tt> and\n<tt>trace-off</tt> messages to turn tracing on and off.\n<p><p>\n\n<p><a name="%_thm_5.17"></a>\n<b>Exercise 5.17.</b>&nbsp;&nbsp;Extend the instruction tracing of\nexercise&nbsp;<a href="#%_thm_5.16">5.16</a> so that before\nprinting an instruction, the simulator prints any labels that\nimmediately precede that instruction in the controller sequence.  Be\ncareful to do this in a way that does not interfere with instruction\ncounting (exercise&nbsp;<a href="#%_thm_5.15">5.15</a>).\nYou will have to make the simulator retain the necessary label information.\n<p><p>\n\n<p><a name="%_thm_5.18"></a>\n<b>Exercise 5.18.</b>&nbsp;&nbsp;<a name="%_idx_5822"></a><a name="%_idx_5824"></a>Modify the <tt>make-register</tt> procedure of\nsection&nbsp;<a href="#%_sec_5.2.1">5.2.1</a> so that registers can be traced.\nRegisters should accept messages that turn tracing on and off.  When a\nregister is traced, assigning a value to the register should print the\nname of the register, the old contents of the register, and the new\ncontents being assigned.  Extend the interface to the machine model\nto permit you to turn tracing on and off for designated machine registers.\n<p><p>\n\n<p><a name="%_thm_5.19"></a>\n<b>Exercise 5.19.</b>&nbsp;&nbsp;Alyssa P. Hacker wants a <a name="%_idx_5826"></a><em>breakpoint</em> feature in the simulator to\nhelp her debug her machine designs.  You have been hired to install\nthis feature for her.  She wants to be able to specify a place in the\ncontroller sequence where the simulator will stop and allow her to\nexamine the state of the machine.  You are to implement a procedure<p>\n\n<p>\n\n<p><p><tt>(set-breakpoint&nbsp;&lt;<em>machine</em>&gt;&nbsp;&lt;<em>label</em>&gt;&nbsp;&lt;<em>n</em>&gt;)<br>\n</tt><p><p>\nthat sets a breakpoint just before the <em>n</em>th instruction after the\ngiven label.  For example,<p>\n\n<p><p><tt>(set-breakpoint&nbsp;gcd-machine&nbsp;\'test-b&nbsp;4)<br>\n</tt><p><p>\ninstalls a breakpoint in <tt>gcd-machine</tt> just before the\nassignment to register <tt>a</tt>.  When the simulator reaches the\nbreakpoint it should print the label and the offset of the breakpoint\nand stop executing instructions.  Alyssa can then use <tt>get-register-contents</tt> and <tt>set-register-contents!</tt> to manipulate\nthe state of the simulated machine.  She should then be able to\ncontinue execution by saying<p>\n\n<p><p><tt>(proceed-machine&nbsp;&lt;<em>machine</em>&gt;)<br>\n</tt><p><p>\nShe should also be able to remove a specific breakpoint by means of<p>\n\n<p><p><tt>(cancel-breakpoint&nbsp;&lt;<em>machine</em>&gt;&nbsp;&lt;<em>label</em>&gt;&nbsp;&lt;<em>n</em>&gt;)<br>\n</tt><p><p>\nor to remove all breakpoints by means of<p>\n\n<p><p><tt>(cancel-all-breakpoints&nbsp;&lt;<em>machine</em>&gt;)<br>\n</tt><p><p>\n<p>\n<p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_727" href="#call_footnote_Temp_727"><sup><small>4</small></sup></a> <a name="%_idx_5690"></a>Using the <tt>receive</tt> procedure here is a way to get <tt>extract-labels</tt> to effectively return two values -- <tt>labels</tt> and\n<tt>insts</tt> -- without explicitly making a compound data structure to\nhold them.  An alternative implementation, which returns an explicit\npair of values, is\n<p><p><tt><a name="%_idx_5692"></a>(define&nbsp;(extract-labels&nbsp;text)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;text)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;\'()&nbsp;\'())<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((result&nbsp;(extract-labels&nbsp;(cdr&nbsp;text))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((insts&nbsp;(car&nbsp;result))&nbsp;(labels&nbsp;(cdr&nbsp;result)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((next-inst&nbsp;(car&nbsp;text)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(symbol?&nbsp;next-inst)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;insts<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(make-label-entry&nbsp;next-inst&nbsp;insts)&nbsp;labels))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(cons&nbsp;(make-instruction&nbsp;next-inst)&nbsp;insts)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;labels)))))))<br>\n</tt><p><p>\nwhich would be called by <tt>assemble</tt> as follows:\n<p><p><tt><a name="%_idx_5694"></a>(define&nbsp;(assemble&nbsp;controller-text&nbsp;machine)<br>\n&nbsp;&nbsp;(let&nbsp;((result&nbsp;(extract-labels&nbsp;controller-text)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((insts&nbsp;(car&nbsp;result))&nbsp;(labels&nbsp;(cdr&nbsp;result)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(update-insts!&nbsp;insts&nbsp;labels&nbsp;machine)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insts)))<br>\n</tt><p><p>\n<a name="%_idx_5696"></a><a name="%_idx_5698"></a><a name="%_idx_5700"></a>You can consider our use of <tt>receive</tt> as demonstrating an elegant\nway to return multiple values, or simply an excuse to show off a\nprogramming trick.  An argument like <tt>receive</tt> that is the next\nprocedure to be invoked is called a ``continuation.\'\'  Recall that we\nalso used continuations to implement the backtracking control\nstructure in the <tt>amb</tt> evaluator in section&nbsp;<a href="book-Z-H-28.html#%_sec_4.3.3">4.3.3</a>.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_5.3"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_5.3">5.3&nbsp;&nbsp;Storage Allocation and Garbage Collection</a></h2><p>\n\n\n<a name="%_idx_5828"></a><a name="%_idx_5830"></a>\nIn section&nbsp;<a href="book-Z-H-34.html#%_sec_5.4">5.4</a>, we will show how to implement a Scheme\nevaluator as a register machine.  In order to simplify the discussion,\nwe will assume that our register machines can be equipped with a <em>list-structured memory</em>, in which the basic operations for\nmanipulating list-structured data are primitive.  Postulating the\nexistence of such a memory is a useful abstraction when one is\nfocusing on the mechanisms of control in a Scheme interpreter, but\nthis does not reflect a realistic view of the actual primitive data\noperations of contemporary computers.  To obtain a more complete\npicture of how a Lisp system operates, we must investigate how list\nstructure can be represented in a way that is compatible with\nconventional computer memories.<p>\n\nThere are two considerations in implementing list structure.  The\nfirst is purely an issue of representation: how to represent the\n``box-and-pointer\'\' structure of Lisp pairs, using only the storage\nand addressing capabilities of typical computer memories.  The second\nissue concerns the management of memory as a computation proceeds.\nThe operation of a Lisp system depends crucially on the ability to\ncontinually create new data objects.  These include objects that are\nexplicitly created by the Lisp procedures being interpreted as well\nas structures created by the interpreter itself, such as environments\nand argument lists.  Although the constant creation of new data\nobjects would pose no problem on a computer with an infinite amount of\nrapidly addressable memory, computer memories are available only in\nfinite sizes (more\'s the pity).  Lisp systems\nthus provide an <a name="%_idx_5832"></a><em>automatic storage allocation</em> facility to\nsupport the illusion of an infinite memory.  When a data object is no\nlonger needed, the memory allocated to it is automatically recycled\nand used to construct new data objects.  There are various\ntechniques for providing such automatic storage allocation.  The\nmethod we shall discuss in this section is called <em>garbage\ncollection</em>.<p>\n\n<a name="%_sec_5.3.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.3.1">5.3.1&nbsp;&nbsp;Memory as Vectors</a></h3><p>\n\n<p>\n\nA conventional computer memory can be thought of as an array of\ncubbyholes, each of which can contain a piece of information.  Each\ncubbyhole has a unique name, called its <a name="%_idx_5834"></a><em>address</em> or <a name="%_idx_5836"></a><em>location</em>.  Typical memory systems provide two primitive operations:\none that fetches the data stored in a specified location and one that\nassigns new data to a specified location.  Memory addresses can be\nincremented to support sequential access to some set of the\ncubbyholes.  More generally, many important data operations require\nthat memory addresses be treated as data, which can be stored in\nmemory locations and manipulated in machine registers.  The\nrepresentation of list structure is one application of such <a name="%_idx_5838"></a><a name="%_idx_5840"></a><em>address arithmetic</em>.<p>\n\nTo model computer memory, we use a new kind of data\nstructure called a <a name="%_idx_5842"></a><em>vector</em>.  Abstractly, a vector is a compound\ndata object whose individual elements can be accessed by means of an\ninteger index in an amount of time that is independent of the\nindex.<a name="call_footnote_Temp_744" href="#footnote_Temp_744"><sup><small>5</small></sup></a> In order to describe memory operations, we use two\nprimitive Scheme procedures for manipulating vectors:<p>\n\n<p><ul>\n<a name="%_idx_5844"></a><a name="%_idx_5846"></a><li><tt>(vector-ref &lt;<em>vector</em>&gt; &lt;<em>n</em>&gt;)</tt> returns the <em>n</em>th\nelement of the vector.<p>\n\n<a name="%_idx_5848"></a><a name="%_idx_5850"></a><li><tt>(vector-set! &lt;<em>vector</em>&gt; &lt;<em>n</em>&gt; &lt;<em>value</em>&gt;)</tt> sets\nthe <em>n</em>th element of the vector to the designated value.\n</ul><p>\nFor example, if <tt>v</tt> is a vector, then <tt>(vector-ref v 5)</tt> gets\nthe fifth entry in the vector <tt>v</tt> and <tt>(vector-set! v 5 7)</tt>\nchanges the value of the fifth entry of the vector <tt>v</tt> to 7.<a name="call_footnote_Temp_745" href="#footnote_Temp_745"><sup><small>6</small></sup></a>\nFor computer memory, this access can be implemented\nthrough the use of address arithmetic to combine a <em>base address</em>\nthat specifies the beginning location of a vector in memory with an\n<em>index</em> that specifies the offset of a particular element of the vector.<p>\n\n<a name="%_sec_Temp_746"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_746">Representing Lisp data</a></h4><p>\n\n<a name="%_idx_5852"></a><a name="%_idx_5854"></a>\nWe can use vectors to implement the basic pair structures required for\na list-structured memory.  Let us imagine that computer memory is\ndivided into two vectors: <a name="%_idx_5856"></a><tt>the-cars</tt> and <a name="%_idx_5858"></a><tt>the-cdrs</tt>.  We will\nrepresent list structure as follows: A pointer to a pair is an index\ninto the two vectors.  The <tt>car</tt> of the pair is the entry in <tt>the-cars</tt> with the designated index, and the <tt>cdr</tt> of the pair is\nthe entry in <tt>the-cdrs</tt> with the designated index.  We also need a\nrepresentation for objects other than pairs (such as numbers and\nsymbols) and a way to distinguish one kind of data from another.\nThere are many methods of accomplishing this, but they all reduce to\nusing <a name="%_idx_5860"></a><a name="%_idx_5862"></a><em>typed pointers</em>, that is, to extending the notion of\n``pointer\'\' to include information on data type.<a name="call_footnote_Temp_747" href="#footnote_Temp_747"><sup><small>7</small></sup></a> The data type enables the system to\ndistinguish a pointer to a pair (which consists of the ``pair\'\' data\ntype and an index into the memory vectors) from pointers to other\nkinds of data (which consist of some other data type and whatever is\nbeing used to represent data of that type).  Two data objects are\n<a name="%_idx_5868"></a>considered to be the same (<tt>eq?</tt>) if their pointers are\nidentical.<a name="call_footnote_Temp_748" href="#footnote_Temp_748"><sup><small>8</small></sup></a> Figure&nbsp;<a href="#%_fig_5.14">5.14</a>\nillustrates the use of this method to represent the list <tt>((1 2) 3\n4)</tt>, whose box-and-pointer diagram is also shown.  We use letter\nprefixes to denote the data-type information.  Thus, a pointer to the\npair with index 5 is denoted <tt>p5</tt>, the empty list is denoted by\nthe pointer <tt>e0</tt>, and a pointer to the number 4 is denoted <tt>n4</tt>.  In the box-and-pointer diagram, we have indicated at the lower\nleft of each pair the vector index that specifies where the <tt>car</tt>\nand <tt>cdr</tt> of the pair are stored.  The blank locations in <tt>the-cars</tt> and <tt>the-cdrs</tt> may contain parts of other list\nstructures (not of interest here).<p>\n\n<a name="%_fig_5.14"></a><p><div align=left><table width=100%><tr><td><img src="ch5-Z-G-7.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 5.14:</b>&nbsp;&nbsp;Box-and-pointer and memory-vector representations \nof the list <tt>((1 2) 3 4)</tt>.</div></caption><tr><td>\n\n</td></tr></table></div><p>                                                         <p>\n\nA pointer to a number, such as <tt>n4</tt>,\nmight consist of a type indicating numeric data together with the\nactual representation of the number 4.<a name="call_footnote_Temp_749" href="#footnote_Temp_749"><sup><small>9</small></sup></a>\nTo deal with numbers that are too large to\nbe represented in the fixed amount of space allocated for a single\npointer, we could use a distinct <a name="%_idx_5880"></a><em>bignum</em> data type, for which the\npointer designates a list in which the parts of the number are\nstored.<a name="call_footnote_Temp_750" href="#footnote_Temp_750"><sup><small>10</small></sup></a><p>\n\n\n<a name="%_idx_5882"></a>A symbol might be represented as a typed pointer that designates a\nsequence of the characters that form the symbol\'s printed representation.\nThis sequence is constructed by the Lisp reader when the character string\nis initially encountered in input.  Since we want two instances of a\nsymbol to be recognized as the ``same\'\' symbol by <tt>eq?</tt> and we\n<a name="%_idx_5884"></a>want <tt>eq?</tt> to be a simple test for equality of pointers, we must\nensure that if the reader sees the same character string twice, it\nwill use the same pointer (to the same sequence of characters) to\nrepresent both occurrences.  To accomplish this, the reader maintains\na table, traditionally called the <a name="%_idx_5886"></a><em>obarray</em>, of all the symbols it\nhas ever encountered.  When the reader encounters a character string\nand is about to construct a symbol, it checks the obarray to see if it\nhas ever before seen the same character string.  If it has not, it\nuses the characters to construct a new symbol (a typed pointer to a\nnew character sequence) and enters this pointer in the obarray.  If the\nreader has seen the string before, it returns the symbol pointer\nstored in the obarray.  This process of replacing character strings by\nunique pointers is called <a name="%_idx_5888"></a><a name="%_idx_5890"></a><em>interning</em> symbols.<p>\n\n\n<a name="%_sec_Temp_751"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_751">Implementing the primitive list operations</a></h4><p>\n\n<p>\n\n<a name="%_idx_5892"></a><a name="%_idx_5894"></a>Given the above representation scheme, we can replace each\n``primitive\'\' list operation of a register machine with one or more\nprimitive vector operations.  We will use two registers, <tt>the-cars</tt> and <tt>the-cdrs</tt>, to identify the memory vectors, and will\nassume that <tt>vector-ref</tt> and <tt>vector-set!</tt> are available as\nprimitive operations.  We also assume that numeric operations on\npointers (such as incrementing a pointer, using a pair pointer to\nindex a vector, or adding two numbers) use only the index portion of\nthe typed pointer.<p>\n\nFor example, we can make a register machine support the instructions<p>\n\n<a name="%_idx_5896"></a><a name="%_idx_5898"></a>\n<p><p><tt>(assign&nbsp;&lt;<em>reg<sub>1</sub></em>&gt;&nbsp;(op&nbsp;car)&nbsp;(reg&nbsp;&lt;<em>reg<sub>2</sub></em>&gt;))<br>\n<br>\n(assign&nbsp;&lt;<em>reg<sub>1</sub></em>&gt;&nbsp;(op&nbsp;cdr)&nbsp;(reg&nbsp;&lt;<em>reg<sub>2</sub></em>&gt;))<br>\n</tt><p><p>\nif we implement these, respectively, as<p>\n\n\n<p><p><tt>(assign&nbsp;&lt;<em>reg<sub>1</sub></em>&gt;&nbsp;(op&nbsp;vector-ref)&nbsp;(reg&nbsp;the-cars)&nbsp;(reg&nbsp;&lt;<em>reg<sub>2</sub></em>&gt;))<br>\n<br>\n(assign&nbsp;&lt;<em>reg<sub>1</sub></em>&gt;&nbsp;(op&nbsp;vector-ref)&nbsp;(reg&nbsp;the-cdrs)&nbsp;(reg&nbsp;&lt;<em>reg<sub>2</sub></em>&gt;))<br>\n</tt><p><p>\nThe instructions<p>\n\n<a name="%_idx_5900"></a><a name="%_idx_5902"></a>\n<p><p><tt>(perform&nbsp;(op&nbsp;set-car!)&nbsp;(reg&nbsp;&lt;<em>reg<sub>1</sub></em>&gt;)&nbsp;(reg&nbsp;&lt;<em>reg<sub>2</sub></em>&gt;))<br>\n<br>\n(perform&nbsp;(op&nbsp;set-cdr!)&nbsp;(reg&nbsp;&lt;<em>reg<sub>1</sub></em>&gt;)&nbsp;(reg&nbsp;&lt;<em>reg<sub>2</sub></em>&gt;))<br>\n</tt><p><p>\nare implemented as\n\n<p><p><tt>(perform<br>\n&nbsp;(op&nbsp;vector-set!)&nbsp;(reg&nbsp;the-cars)&nbsp;(reg&nbsp;&lt;<em>reg<sub>1</sub></em>&gt;)&nbsp;(reg&nbsp;&lt;<em>reg<sub>2</sub></em>&gt;))<br>\n<br>\n(perform<br>\n&nbsp;(op&nbsp;vector-set!)&nbsp;(reg&nbsp;the-cdrs)&nbsp;(reg&nbsp;&lt;<em>reg<sub>1</sub></em>&gt;)&nbsp;(reg&nbsp;&lt;<em>reg<sub>2</sub></em>&gt;))<br>\n</tt><p><p>\n<p>\n\n<a name="%_idx_5904"></a><tt>Cons</tt> is performed by allocating an unused index and storing the\narguments to <tt>cons</tt> in <tt>the-cars</tt> and <tt>the-cdrs</tt> at that\nindexed vector position.  We presume that there is a special register,\n<a name="%_idx_5906"></a><tt>free</tt>, that always holds a pair pointer containing the next\navailable index, and that we can increment the index part of that\npointer to find the next free location.<a name="call_footnote_Temp_752" href="#footnote_Temp_752"><sup><small>11</small></sup></a>\nFor example, the instruction<p>\n\n<p><p><tt>(assign&nbsp;&lt;<em>reg<sub>1</sub></em>&gt;&nbsp;(op&nbsp;cons)&nbsp;(reg&nbsp;&lt;<em>reg<sub>2</sub></em>&gt;)&nbsp;(reg&nbsp;&lt;<em>reg<sub>3</sub></em>&gt;))<br>\n</tt><p><p>\nis implemented as the following sequence of vector\noperations:<a name="call_footnote_Temp_753" href="#footnote_Temp_753"><sup><small>12</small></sup></a><p>\n\n<p><p><tt>(perform<br>\n&nbsp;(op&nbsp;vector-set!)&nbsp;(reg&nbsp;the-cars)&nbsp;(reg&nbsp;free)&nbsp;(reg&nbsp;&lt;<em>reg<sub>2</sub></em>&gt;))<br>\n(perform<br>\n&nbsp;(op&nbsp;vector-set!)&nbsp;(reg&nbsp;the-cdrs)&nbsp;(reg&nbsp;free)&nbsp;(reg&nbsp;&lt;<em>reg<sub>3</sub></em>&gt;))<br>\n(assign&nbsp;&lt;<em>reg<sub>1</sub></em>&gt;&nbsp;(reg&nbsp;free))<br>\n(assign&nbsp;free&nbsp;(op&nbsp;+)&nbsp;(reg&nbsp;free)&nbsp;(const&nbsp;1))<br>\n</tt><p><p>\nThe <tt>eq?</tt> operation<p>\n\n<p><p><tt>(op&nbsp;eq?)&nbsp;(reg&nbsp;&lt;<em>reg<sub>1</sub></em>&gt;)&nbsp;(reg&nbsp;&lt;<em>reg<sub>2</sub></em>&gt;)<br>\n</tt><p><p>\nsimply tests the equality of all fields in the registers, and\n<a name="%_idx_5910"></a><a name="%_idx_5912"></a><a name="%_idx_5914"></a><a name="%_idx_5916"></a>predicates such as <tt>pair?</tt>, <tt>null?</tt>, <tt>symbol?</tt>, and <tt>number?</tt> need only check the type field.<p>\n\n<a name="%_sec_Temp_754"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_754">Implementing stacks</a></h4><p>\n\n<a name="%_idx_5918"></a>\nAlthough our register machines use stacks, we need do nothing special\nhere, since stacks can be modeled in terms of lists.  The stack can be\na list of the saved values, pointed to by a special register <tt>the-stack</tt>.  Thus, <tt>(save &lt;<em>reg</em>&gt;)</tt> can be implemented as<p>\n\n<a name="%_idx_5920"></a><p><p><tt>(assign&nbsp;the-stack&nbsp;(op&nbsp;cons)&nbsp;(reg&nbsp;&lt;<em>reg</em>&gt;)&nbsp;(reg&nbsp;the-stack))<br>\n</tt><p><p>\n<a name="%_idx_5922"></a>Similarly, <tt>(restore &lt;<em>reg</em>&gt;)</tt> can be implemented as\n<p><p><tt>(assign&nbsp;&lt;<em>reg</em>&gt;&nbsp;(op&nbsp;car)&nbsp;(reg&nbsp;the-stack))<br>\n(assign&nbsp;the-stack&nbsp;(op&nbsp;cdr)&nbsp;(reg&nbsp;the-stack))<br>\n</tt><p><p>\nand <tt>(perform (op initialize-stack))</tt> can be implemented as\n<p><p><tt>(assign&nbsp;the-stack&nbsp;(const&nbsp;()))<br>\n</tt><p><p>\nThese operations can be further expanded in terms of the vector\noperations given above.  In conventional computer architectures,\nhowever, it is usually advantageous to allocate the stack as a\nseparate vector.  Then pushing and popping the stack can be\naccomplished by incrementing or decrementing an index into that\nvector.<p>\n\n<p><a name="%_thm_5.20"></a>\n<b>Exercise 5.20.</b>&nbsp;&nbsp;Draw the box-and-pointer representation and the memory-vector\nrepresentation (as in figure&nbsp;<a href="#%_fig_5.14">5.14</a>) of the\nlist structure produced by<p>\n\n<p><p><tt>(define&nbsp;x&nbsp;(cons&nbsp;1&nbsp;2))<br>\n(define&nbsp;y&nbsp;(list&nbsp;x&nbsp;x))<br>\n</tt><p><p>\nwith the <tt>free</tt> pointer initially <tt>p1</tt>.  What is the final\nvalue of <tt>free</tt> ?  What pointers represent the values of <tt>x</tt> and <tt>y</tt> ?\n<p><p>\n\n<p><a name="%_thm_5.21"></a>\n<b>Exercise 5.21.</b>&nbsp;&nbsp;<a name="%_idx_5924"></a>Implement register machines for the following procedures.\nAssume that the list-structure memory operations are available as\nmachine primitives.<p>\n\n<p><p>a. Recursive <tt>count-leaves</tt>:<p>\n\n<p><p><tt>(define&nbsp;(count-leaves&nbsp;tree)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;tree)&nbsp;0)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((not&nbsp;(pair?&nbsp;tree))&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(+&nbsp;(count-leaves&nbsp;(car&nbsp;tree))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(count-leaves&nbsp;(cdr&nbsp;tree))))))<br>\n</tt><p><p>\n<p><p>b. Recursive <tt>count-leaves</tt> with explicit counter:<p>\n\n<p><p><tt>(define&nbsp;(count-leaves&nbsp;tree)<br>\n&nbsp;&nbsp;(define&nbsp;(count-iter&nbsp;tree&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;tree)&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((not&nbsp;(pair?&nbsp;tree))&nbsp;(+&nbsp;n&nbsp;1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(count-iter&nbsp;(cdr&nbsp;tree)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(count-iter&nbsp;(car&nbsp;tree)&nbsp;n)))))<br>\n&nbsp;&nbsp;(count-iter&nbsp;tree&nbsp;0))<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_5.22"></a>\n<b>Exercise 5.22.</b>&nbsp;&nbsp;<a name="%_idx_5926"></a><a name="%_idx_5928"></a>Exercise&nbsp;<a href="book-Z-H-22.html#%_thm_3.12">3.12</a> of section&nbsp;<a href="book-Z-H-22.html#%_sec_3.3.1">3.3.1</a>\npresented an <tt>append</tt> procedure that appends two lists to form a\nnew list and an <tt>append!</tt> procedure that splices two lists\ntogether.  Design a register machine to implement each of these\nprocedures.  Assume that the list-structure memory operations are\navailable as primitive operations.\n<p>\n\n<a name="%_sec_5.3.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.3.2">5.3.2&nbsp;&nbsp;Maintaining the Illusion of Infinite Memory</a></h3><p>\n\n<a name="%_idx_5930"></a><p>\n\nThe representation method outlined in\nsection&nbsp;<a href="#%_sec_5.3.1">5.3.1</a> solves the problem of implementing\nlist structure, provided that we have an infinite amount of memory.\nWith a real computer we will eventually run out of free space in which\nto construct new pairs.<a name="call_footnote_Temp_758" href="#footnote_Temp_758"><sup><small>13</small></sup></a>\nHowever, most of the pairs generated in a typical\ncomputation are used only to hold intermediate results.  After these\nresults are accessed, the pairs are no longer needed -- they are <em>garbage</em>.  For instance, the computation<p>\n\n<p><p><tt>(accumulate&nbsp;+&nbsp;0&nbsp;(filter&nbsp;odd?&nbsp;(enumerate-interval&nbsp;0&nbsp;n)))<br>\n</tt><p><p>\nconstructs two lists: the enumeration and the result of filtering\nthe enumeration.  When the accumulation is complete, these lists are\nno longer needed, and the allocated memory can be reclaimed.  If we\ncan arrange to collect all the garbage periodically, and if this turns\nout to recycle memory at about the same rate at which we construct new\npairs, we will have preserved the illusion that there is an infinite\namount of memory.<p>\n\nIn order to recycle pairs, we must have a way to determine which\nallocated pairs are not needed (in the sense that their contents can\nno longer influence the future of the computation).  The method we\nshall examine for accomplishing this is known as <em>garbage\ncollection</em>.  Garbage collection is based on the observation that, at\nany moment in a Lisp interpretation, the only objects that can\naffect the future of the computation are those that can be reached by\nsome succession of <tt>car</tt> and <tt>cdr</tt> operations starting from\nthe pointers that are currently in the machine registers.<a name="call_footnote_Temp_759" href="#footnote_Temp_759"><sup><small>14</small></sup></a>  Any memory cell\nthat is not so accessible may be recycled.<p>\n\nThere are many ways to perform garbage collection.  The method we\nshall examine here is called <a name="%_idx_5932"></a><a name="%_idx_5934"></a><em>stop-and-copy</em>.  The basic idea is\nto divide memory into two halves: ``working memory\'\' and ``free\nmemory.\'\'  When <tt>cons</tt> constructs pairs, it allocates these in\nworking memory.  When working memory is full, we perform garbage\ncollection by locating all the useful pairs in working memory and\ncopying these into consecutive locations in free memory.  (The useful\npairs are located by tracing all the <tt>car</tt> and <tt>cdr</tt> pointers,\nstarting with the machine registers.)  Since we do not copy the\ngarbage, there will presumably be additional free memory that we can\nuse to allocate new pairs.  In addition, nothing in the working memory\nis needed, since all the useful pairs in it have been copied.  Thus,\nif we interchange the roles of working memory and free memory, we can\ncontinue processing; new pairs will be allocated in the new working\nmemory (which was the old free memory).  When this is full, we can\ncopy the useful pairs into the new free memory (which was the old\nworking memory).<a name="call_footnote_Temp_760" href="#footnote_Temp_760"><sup><small>15</small></sup></a><p>\n\n<a name="%_sec_Temp_761"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_761">Implementation of a stop-and-copy garbage collector</a></h4><p>\n\nWe now use our register-machine language to describe the stop-and-copy\nalgorithm in more detail.  We will assume that there is a register\ncalled <a name="%_idx_5966"></a><tt>root</tt> that contains a pointer to a structure that\neventually points at all accessible data.  This can be arranged by\nstoring the contents of all the machine registers in a\npre-allocated list pointed at by <tt>root</tt> just before starting\ngarbage collection.<a name="call_footnote_Temp_762" href="#footnote_Temp_762"><sup><small>16</small></sup></a> We also assume that, in addition to the\ncurrent working memory, there is free memory available into which we\ncan copy the useful data.  The current working memory consists of\nvectors whose base addresses are in <a name="%_idx_5968"></a><a name="%_idx_5970"></a>registers called <tt>the-cars</tt>\nand <tt>the-cdrs</tt>, and the free memory is in registers called <a name="%_idx_5972"></a><a name="%_idx_5974"></a><tt>new-cars</tt> and <tt>new-cdrs</tt>.<p>\n\nGarbage collection is triggered when we exhaust the free cells in the\ncurrent working memory, that is, when a <tt>cons</tt> operation attempts\nto increment the <tt>free</tt> pointer beyond the end of the memory\nvector.  When the garbage-collection process is complete, the <tt>root</tt> pointer will point into the new memory, all objects accessible\nfrom the <tt>root</tt> will have been moved to the new memory, and the\n<tt>free</tt> pointer will indicate the next place in the new memory\nwhere a new pair can be allocated.  In addition, the roles of working\nmemory and new memory will have been interchanged -- new pairs will be\nconstructed in the new memory, beginning at the place indicated by\n<tt>free</tt>, and the (previous) working memory will be available as the\nnew memory for the next garbage collection.\nFigure&nbsp;<a href="#%_fig_5.15">5.15</a> shows the arrangement of memory just\nbefore and just after garbage collection.<p>\n\n<a name="%_fig_5.15"></a><p><div align=left><table width=100%><tr><td><img src="ch5-Z-G-8.gif" border="0">\n</td></tr><caption align=bottom><div align=left><b>Figure 5.15:</b>&nbsp;&nbsp;Reconfiguration of memory by the garbage-collection \nprocess.</div></caption><tr><td>\n\n</td></tr></table></div><p><p>\n\n<a name="%_idx_5976"></a><a name="%_idx_5978"></a>The state of the garbage-collection process is controlled by\nmaintaining two pointers: <tt>free</tt> and <tt>scan</tt>.  These are\ninitialized to point to the beginning of the new memory.  The\nalgorithm begins by relocating the pair pointed at by <tt>root</tt> to\nthe beginning of the new memory.  The pair is copied, the <tt>root</tt>\npointer is adjusted to point to the new location, and the <tt>free</tt>\npointer is incremented.  In addition, the old location of the pair is\nmarked to show that its contents have been moved.  This marking is\ndone as follows: In the <tt>car</tt> position, we place a special tag\nthat signals that this is an already-moved object.  (Such an object is\ntraditionally called a <a name="%_idx_5980"></a><em>broken heart</em>.)<a name="call_footnote_Temp_763" href="#footnote_Temp_763"><sup><small>17</small></sup></a>  In the <tt>cdr</tt> position we place a <a name="%_idx_5988"></a><em>forwarding\naddress</em> that points at the location to which the object has been\nmoved.<p>\n\n\nAfter relocating the root, the garbage collector enters its basic\ncycle.  At each step in the algorithm, the <tt>scan</tt> pointer\n(initially pointing at the relocated root) points at a pair that has\nbeen moved to the new memory but whose <tt>car</tt> and <tt>cdr</tt>\npointers still refer to objects in the old memory.  These objects are\neach relocated, and the <tt>scan</tt> pointer is incremented.  To\nrelocate an object (for example, the object indicated by the <tt>car</tt>\npointer of the pair we are scanning) we check to see if the object has\nalready been moved (as indicated by the presence of a broken-heart tag\nin the <tt>car</tt> position of the object).  If the object has not\nalready been moved, we copy it to the place indicated by <tt>free</tt>,\nupdate <tt>free</tt>, set up a broken heart at the object\'s old location,\nand update the pointer to the object (in this\nexample, the <tt>car</tt> pointer of the pair we are scanning) to point\nto the new location.  If the object has already been moved, its\nforwarding address (found in the <tt>cdr</tt> position of the broken\nheart) is substituted for the pointer in the pair being scanned.\nEventually, all accessible objects will have been moved and scanned,\nat which point the <tt>scan</tt> pointer will overtake the <tt>free</tt>\npointer and the process will terminate.<p>\n\n<p>\n\nWe can specify the stop-and-copy algorithm as a sequence of\ninstructions for a register\nmachine.  The basic step of relocating an object is accomplished by a\nsubroutine called <tt>relocate-old-result-in-new</tt>.  This\nsubroutine gets its argument, a pointer to the object to be relocated,\nfrom a register named <a name="%_idx_5990"></a><tt>old</tt>.  It relocates the designated object\n(incrementing <tt>free</tt> in the process),\nputs a pointer to the relocated object into a register called <a name="%_idx_5992"></a><tt>new</tt>, and returns by branching to the entry point stored in the register\n<tt>relocate-continue</tt>.  To begin garbage collection, we invoke this\nsubroutine to relocate the <tt>root</tt> pointer, after initializing <tt>free</tt> and <tt>scan</tt>.  When the relocation of <tt>root</tt> has been\naccomplished, we install the new pointer as the new <tt>root</tt> and\nenter the main loop of the garbage collector.<p>\n\n<p><p><tt>begin-garbage-collection<br>\n&nbsp;&nbsp;(assign&nbsp;free&nbsp;(const&nbsp;0))<br>\n&nbsp;&nbsp;(assign&nbsp;scan&nbsp;(const&nbsp;0))<br>\n&nbsp;&nbsp;(assign&nbsp;old&nbsp;(reg&nbsp;root))<br>\n&nbsp;&nbsp;(assign&nbsp;relocate-continue&nbsp;(label&nbsp;reassign-root))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;relocate-old-result-in-new))<br>\nreassign-root<br>\n&nbsp;&nbsp;(assign&nbsp;root&nbsp;(reg&nbsp;new))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;gc-loop))<br>\n</tt><p><p><p>\n\nIn the main loop of the garbage collector we must determine whether\nthere are any more objects to be scanned.  We do this by testing\nwhether the <tt>scan</tt> pointer is coincident with the <tt>free</tt>\npointer.  If the pointers are equal, then all accessible objects have\nbeen relocated, and we branch to <tt>gc-flip</tt>, which cleans things up\nso that we can continue the interrupted computation.  If there are\nstill pairs to be scanned, we call the relocate subroutine to relocate\nthe <tt>car</tt> of the next pair (by placing the <tt>car</tt> pointer in <tt>old</tt>).  The <tt>relocate-continue</tt> register is set up so that the\nsubroutine will return to update the <tt>car</tt> pointer.<p>\n\n<p><p><tt>gc-loop<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;=)&nbsp;(reg&nbsp;scan)&nbsp;(reg&nbsp;free))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;gc-flip))<br>\n&nbsp;&nbsp;(assign&nbsp;old&nbsp;(op&nbsp;vector-ref)&nbsp;(reg&nbsp;new-cars)&nbsp;(reg&nbsp;scan))<br>\n&nbsp;&nbsp;(assign&nbsp;relocate-continue&nbsp;(label&nbsp;update-car))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;relocate-old-result-in-new))<br>\n</tt><p><p><p>\n\n<p>\n\nAt <tt>update-car</tt>, we modify the <tt>car</tt> pointer of the pair being\nscanned, then proceed to relocate the <tt>cdr</tt> of the pair.  We\nreturn to <tt>update-cdr</tt> when that relocation has been accomplished.\nAfter relocating and updating the <tt>cdr</tt>, we are finished scanning\nthat pair, so we continue with the main loop.<p>\n\n<p><p><tt>update-car<br>\n&nbsp;&nbsp;(perform<br>\n&nbsp;&nbsp;&nbsp;(op&nbsp;vector-set!)&nbsp;(reg&nbsp;new-cars)&nbsp;(reg&nbsp;scan)&nbsp;(reg&nbsp;new))<br>\n&nbsp;&nbsp;(assign&nbsp;old&nbsp;(op&nbsp;vector-ref)&nbsp;(reg&nbsp;new-cdrs)&nbsp;(reg&nbsp;scan))<br>\n&nbsp;&nbsp;(assign&nbsp;relocate-continue&nbsp;(label&nbsp;update-cdr))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;relocate-old-result-in-new))<br>\n<br>\nupdate-cdr<br>\n&nbsp;&nbsp;(perform<br>\n&nbsp;&nbsp;&nbsp;(op&nbsp;vector-set!)&nbsp;(reg&nbsp;new-cdrs)&nbsp;(reg&nbsp;scan)&nbsp;(reg&nbsp;new))<br>\n&nbsp;&nbsp;(assign&nbsp;scan&nbsp;(op&nbsp;+)&nbsp;(reg&nbsp;scan)&nbsp;(const&nbsp;1))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;gc-loop))<br>\n</tt><p><p><p>\n\nThe subroutine <tt>relocate-old-result-in-new</tt> relocates objects as\nfollows: If the object to be relocated (pointed at by <tt>old</tt>) is\nnot a pair, then we return the same pointer to the object unchanged\n(in <tt>new</tt>).  (For example, we may be scanning a pair whose <tt>car</tt> is the number 4.  If we represent the <tt>car</tt> by <tt>n4</tt>, as\ndescribed in section&nbsp;<a href="#%_sec_5.3.1">5.3.1</a>, then we want the\n``relocated\'\' <tt>car</tt> pointer to still be <tt>n4</tt>.)  Otherwise, we\nmust perform the relocation.  If the <tt>car</tt> position of the pair to\nbe relocated contains a broken-heart tag, then the pair has in fact\nalready been moved, so we retrieve the forwarding address (from the\n<tt>cdr</tt> position of the broken heart) and return this in <tt>new</tt>.\nIf the pointer in <tt>old</tt> points at a yet-unmoved pair, then we move\nthe pair to the first free cell in new memory (pointed at by <tt>free</tt>) and set up the broken heart by storing a broken-heart tag and\nforwarding address at the old location.\n<tt>Relocate-old-result-in-new</tt> uses a register <a name="%_idx_5994"></a><tt>oldcr</tt>\nto hold the <tt>car</tt> or the <tt>cdr</tt> of the object pointed at by\n<tt>old</tt>.<a name="call_footnote_Temp_764" href="#footnote_Temp_764"><sup><small>18</small></sup></a><p>\n\n<p><p><tt>relocate-old-result-in-new<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;pointer-to-pair?)&nbsp;(reg&nbsp;old))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;pair))<br>\n&nbsp;&nbsp;(assign&nbsp;new&nbsp;(reg&nbsp;old))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;relocate-continue))<br>\npair<br>\n&nbsp;&nbsp;(assign&nbsp;oldcr&nbsp;(op&nbsp;vector-ref)&nbsp;(reg&nbsp;the-cars)&nbsp;(reg&nbsp;old))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;broken-heart?)&nbsp;(reg&nbsp;oldcr))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;already-moved))<br>\n&nbsp;&nbsp;(assign&nbsp;new&nbsp;(reg&nbsp;free))&nbsp;<em>;&nbsp;new&nbsp;location&nbsp;for&nbsp;pair</em><br>\n&nbsp;&nbsp;<em>;;&nbsp;Update&nbsp;<tt>free</tt>&nbsp;pointer.</em><br>\n&nbsp;&nbsp;(assign&nbsp;free&nbsp;(op&nbsp;+)&nbsp;(reg&nbsp;free)&nbsp;(const&nbsp;1))<br>\n&nbsp;&nbsp;<em>;;&nbsp;Copy&nbsp;the&nbsp;<tt>car</tt>&nbsp;and&nbsp;<tt>cdr</tt>&nbsp;to&nbsp;new&nbsp;memory.</em><br>\n&nbsp;&nbsp;(perform&nbsp;(op&nbsp;vector-set!)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;new-cars)&nbsp;(reg&nbsp;new)&nbsp;(reg&nbsp;oldcr))<br>\n&nbsp;&nbsp;(assign&nbsp;oldcr&nbsp;(op&nbsp;vector-ref)&nbsp;(reg&nbsp;the-cdrs)&nbsp;(reg&nbsp;old))<br>\n&nbsp;&nbsp;(perform&nbsp;(op&nbsp;vector-set!)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;new-cdrs)&nbsp;(reg&nbsp;new)&nbsp;(reg&nbsp;oldcr))<br>\n&nbsp;&nbsp;<em>;;&nbsp;Construct&nbsp;the&nbsp;broken&nbsp;heart.</em><br>\n&nbsp;&nbsp;(perform&nbsp;(op&nbsp;vector-set!)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;the-cars)&nbsp;(reg&nbsp;old)&nbsp;(const&nbsp;broken-heart))<br>\n&nbsp;&nbsp;(perform<br>\n&nbsp;&nbsp;&nbsp;(op&nbsp;vector-set!)&nbsp;(reg&nbsp;the-cdrs)&nbsp;(reg&nbsp;old)&nbsp;(reg&nbsp;new))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;relocate-continue))<br>\nalready-moved<br>\n&nbsp;&nbsp;(assign&nbsp;new&nbsp;(op&nbsp;vector-ref)&nbsp;(reg&nbsp;the-cdrs)&nbsp;(reg&nbsp;old))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;relocate-continue))<br>\n</tt><p><p><p>\n\nAt the very end of the garbage-collection process, we interchange the\nrole of old and new memories by interchanging pointers: interchanging\n<tt>the-cars</tt> with <tt>new-cars</tt>, and <tt>the-cdrs</tt> with <tt>new-cdrs</tt>.  We will then be ready to perform another garbage\ncollection the next time memory runs out.<p>\n\n<p><p><tt>gc-flip<br>\n&nbsp;&nbsp;(assign&nbsp;temp&nbsp;(reg&nbsp;the-cdrs))<br>\n&nbsp;&nbsp;(assign&nbsp;the-cdrs&nbsp;(reg&nbsp;new-cdrs))<br>\n&nbsp;&nbsp;(assign&nbsp;new-cdrs&nbsp;(reg&nbsp;temp))<br>\n&nbsp;&nbsp;(assign&nbsp;temp&nbsp;(reg&nbsp;the-cars))<br>\n&nbsp;&nbsp;(assign&nbsp;the-cars&nbsp;(reg&nbsp;new-cars))<br>\n&nbsp;&nbsp;(assign&nbsp;new-cars&nbsp;(reg&nbsp;temp))<br>\n</tt><p><p>\n\n<p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_744" href="#call_footnote_Temp_744"><sup><small>5</small></sup></a> We could represent memory as lists of items.\nHowever, the access time would then not be independent of the index,\nsince accessing the <em>n</em>th element of a list requires <em>n</em> - 1 <tt>cdr</tt>\noperations.\n\n<p><a name="footnote_Temp_745" href="#call_footnote_Temp_745"><sup><small>6</small></sup></a> For completeness, we should specify a <tt>make-vector</tt>\noperation that constructs vectors.  However, in the present\napplication we will use vectors only to model fixed divisions of the\ncomputer memory.\n\n<p><a name="footnote_Temp_747" href="#call_footnote_Temp_747"><sup><small>7</small></sup></a> This is\nprecisely the same <a name="%_idx_5864"></a><a name="%_idx_5866"></a>``tagged data\'\' idea we introduced in chapter&nbsp;2 for\ndealing with generic operations.  Here, however, the data types are\nincluded at the primitive machine level rather than constructed\nthrough the use of lists.\n\n<p><a name="footnote_Temp_748" href="#call_footnote_Temp_748"><sup><small>8</small></sup></a> Type information may be encoded in a variety of\nways, depending on the details of the machine on which the Lisp\nsystem is to be implemented.  The execution efficiency of Lisp\nprograms will be strongly dependent on how cleverly this choice is\nmade, but it is difficult to formulate general design rules for good\nchoices.  The most straightforward way to implement typed pointers is\nto allocate a fixed set of bits in each pointer to be a <a name="%_idx_5870"></a><em>type\nfield</em> that encodes the data type.  Important questions to be\naddressed in designing such a representation include the following:\nHow many type bits are required?  How large must the vector indices\nbe?  How efficiently can the primitive machine instructions be used to\nmanipulate the type fields of pointers?  Machines that include special\nhardware for the efficient handling of type fields are said to have\n<a name="%_idx_5872"></a><em>tagged architectures</em>.\n\n<p><a name="footnote_Temp_749" href="#call_footnote_Temp_749"><sup><small>9</small></sup></a> This decision on the\n<a name="%_idx_5874"></a><a name="%_idx_5876"></a><a name="%_idx_5878"></a>representation of numbers determines whether <tt>eq?</tt>, which tests\nequality of pointers, can be used to test for equality of numbers.  If\nthe pointer contains the number itself, then equal numbers will have\nthe same pointer.  But if the pointer contains the index of a location\nwhere the number is stored, equal numbers will be guaranteed to have\nequal pointers only if we are careful never to store the same number\nin more than one location.\n\n<p><a name="footnote_Temp_750" href="#call_footnote_Temp_750"><sup><small>10</small></sup></a> This is just like writing a number as a sequence of\ndigits, except that each ``digit\'\' is a number between 0 and the\nlargest number that can be stored in a single pointer.\n\n<p><a name="footnote_Temp_752" href="#call_footnote_Temp_752"><sup><small>11</small></sup></a> There are other ways\nof finding free storage.  For example, we could link together all the\nunused pairs into a <a name="%_idx_5908"></a><em>free list</em>.  Our free locations are\nconsecutive (and hence can be accessed by incrementing a pointer)\nbecause we are using a compacting garbage collector, as we will see in\nsection&nbsp;<a href="#%_sec_5.3.2">5.3.2</a>.\n\n<p><a name="footnote_Temp_753" href="#call_footnote_Temp_753"><sup><small>12</small></sup></a> This is essentially the implementation of <tt>cons</tt> in terms of <tt>set-car!</tt> and <tt>set-cdr!</tt>, as described in\nsection&nbsp;<a href="book-Z-H-22.html#%_sec_3.3.1">3.3.1</a>.  The operation <tt>get-new-pair</tt> used in that implementation is realized here by the <tt>free</tt> pointer.\n\n<p><a name="footnote_Temp_758" href="#call_footnote_Temp_758"><sup><small>13</small></sup></a> This may not be true eventually,\nbecause memories may get large enough so that it would be impossible\nto run out of free memory in the lifetime of the computer.  For\nexample, there are about 3&times; 10<sup>13</sup>, microseconds in a year, so\nif we were to <tt>cons</tt> once per microsecond we would need about\n10<sup>15</sup> cells of memory to build a machine that could operate for 30\nyears without running out of memory.  That much memory seems absurdly\nlarge by today\'s standards, but it is not physically impossible.  On\nthe other hand, processors are getting faster and a future computer\nmay have large numbers of processors operating in parallel on a single\nmemory, so it may be possible to use up memory much faster than we\nhave postulated.\n\n<p><a name="footnote_Temp_759" href="#call_footnote_Temp_759"><sup><small>14</small></sup></a> We\nassume here that the stack is represented as a list as described in\nsection&nbsp;<a href="#%_sec_5.3.1">5.3.1</a>, so that items on the stack are\naccessible via the pointer in the stack register.\n\n<p><a name="footnote_Temp_760" href="#call_footnote_Temp_760"><sup><small>15</small></sup></a> This idea was invented and first implemented\n<a name="%_idx_5936"></a>by Minsky, as part of the implementation of <a name="%_idx_5938"></a>Lisp for the PDP-1 at the\n<a name="%_idx_5940"></a>MIT Research Laboratory of Electronics.  It was further developed by\n<a name="%_idx_5942"></a><a name="%_idx_5944"></a>Fenichel and Yochelson (1969) for use in the Lisp implementation for\n<a name="%_idx_5946"></a>the Multics time-sharing system.  Later, <a name="%_idx_5948"></a>Baker (1978) developed a\n``real-time\'\' version of the method, which does not require the\ncomputation to stop during garbage collection.  Baker\'s idea was\nextended by <a name="%_idx_5950"></a><a name="%_idx_5952"></a><a name="%_idx_5954"></a>Hewitt, Lieberman, and Moon (see Lieberman and Hewitt\n1983) to take advantage of the fact that some structure is more volatile\nand other structure is more permanent.  <p>\n\nAn alternative commonly used garbage-collection technique is the <a name="%_idx_5956"></a><a name="%_idx_5958"></a><em>mark-sweep</em> method.  This consists of tracing all the structure\naccessible from the machine registers and marking each pair we reach.\nWe then scan all of memory, and any location that is unmarked is\n``swept up\'\' as garbage and made available for reuse.  A full\n<a name="%_idx_5960"></a>discussion of the mark-sweep method can be found in Allen 1978.<p>\n\nThe Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in\nuse for large-memory systems because it examines only the useful part\nof memory.  This is in contrast to mark-sweep, in which the sweep\nphase must check all of memory.  A second advantage of stop-and-copy\nis that it is a <a name="%_idx_5962"></a><a name="%_idx_5964"></a><em>compacting</em> garbage collector.  That is, at the\nend of the garbage-collection phase the useful data will have been\nmoved to consecutive memory locations, with all garbage pairs\ncompressed out.  This can be an extremely important performance\nconsideration in machines with virtual memory, in which accesses to\nwidely separated memory addresses may require extra paging\noperations.\n\n<p><a name="footnote_Temp_762" href="#call_footnote_Temp_762"><sup><small>16</small></sup></a> This list of registers does not include\nthe registers used by the storage-allocation system -- <tt>root</tt>, <tt>the-cars</tt>, <tt>the-cdrs</tt>, and the other registers that will be\nintroduced in this section.\n\n<p><a name="footnote_Temp_763" href="#call_footnote_Temp_763"><sup><small>17</small></sup></a> The term <em><a name="%_idx_5982"></a>broken heart</em> was coined by David Cressey, who wrote a garbage\ncollector for <a name="%_idx_5984"></a><a name="%_idx_5986"></a>MDL, a dialect of Lisp developed at MIT during the early\n1970s.\n\n<p><a name="footnote_Temp_764" href="#call_footnote_Temp_764"><sup><small>18</small></sup></a> The garbage collector uses the low-level predicate\n<tt>pointer-to-pair?</tt> instead of the list-structure <tt>pair?</tt>\noperation because in a real system there might be various things\nthat are treated as pairs for garbage-collection purposes.\nFor example, in a Scheme system that conforms to the IEEE standard\na procedure object may be implemented as a special kind of ``pair\'\'\nthat doesn\'t satisfy the <tt>pair?</tt> predicate.\nFor simulation purposes, <tt>pointer-to-pair?</tt> can be implemented as\n<tt>pair?</tt>.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_5.4"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_5.4">5.4&nbsp;&nbsp;The Explicit-Control Evaluator</a></h2><p>\n\n\n<a name="%_idx_5996"></a>\nIn section&nbsp;<a href="book-Z-H-31.html#%_sec_5.1">5.1</a> we saw how to\ntransform simple Scheme programs into descriptions of register\nmachines.  We will now perform this transformation on a more complex\nprogram, the metacircular evaluator of\nsections <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>-<a href="book-Z-H-26.html#%_sec_4.1.4">4.1.4</a>,\nwhich shows how\nthe behavior of a Scheme interpreter can be described in terms of the\nprocedures <tt>eval</tt> and <tt>apply</tt>.\nThe <em>explicit-control\nevaluator</em> that we develop in this section shows how the underlying\nprocedure-calling and argument-passing mechanisms used in the\nevaluation process can be described in terms of operations on\nregisters and stacks.  In addition, the explicit-control evaluator can\nserve as an implementation of a Scheme interpreter, written in a\nlanguage that is very similar to the native machine language of\nconventional computers.  The evaluator can be executed by the\nregister-machine simulator of section&nbsp;<a href="book-Z-H-32.html#%_sec_5.2">5.2</a>.\nAlternatively, it can be used as a starting point for building a\nmachine-language implementation of a Scheme evaluator, or even a\n<a name="%_idx_5998"></a><a name="%_idx_6000"></a><a name="%_idx_6002"></a>special-purpose machine for evaluating Scheme expressions.\nFigure&nbsp;<a href="#%_fig_5.16">5.16</a> shows such a hardware implementation: a\nsilicon chip that acts as an evaluator for Scheme.  The chip designers\nstarted with the data-path and controller specifications for a\nregister machine similar to the evaluator described in this section\nand used design automation programs to construct the\nintegrated-circuit layout.<a name="call_footnote_Temp_765" href="#footnote_Temp_765"><sup><small>19</small></sup></a><p>\n\n<p>\n\n<a name="%_sec_Temp_766"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_766">Registers and operations</a></h4><p>\n\n<a name="%_idx_6006"></a>\n<a name="%_idx_6008"></a>In designing the explicit-control evaluator, we must specify the\noperations to be used in our register machine.  We described the\nmetacircular evaluator in terms of abstract syntax, using procedures\nsuch as <tt>quoted?</tt> and <tt>make-procedure</tt>.  In implementing the\nregister machine, we could expand these procedures into sequences of\nelementary list-structure memory operations, and implement these\noperations on our register machine.  However, this would make our\nevaluator very long, obscuring the basic structure with\ndetails.  To clarify the presentation, we will include as primitive\noperations of the register machine the syntax procedures given in\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.2">4.1.2</a> and the procedures for\nrepresenting environments and other run-time data given in\nsections&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.3">4.1.3</a> and&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.4">4.1.4</a>.\nIn order to completely specify an evaluator that could be programmed\nin a low-level machine language or implemented in hardware, we would\nreplace these operations by more elementary operations, using the\nlist-structure implementation we described in\nsection&nbsp;<a href="book-Z-H-33.html#%_sec_5.3">5.3</a>.<p>\n\n<a name="%_fig_5.16"></a><p><div align=left><table width=100%><tr><td><img src="chip.jpg" border="0" height=310>\n</td></tr><caption align=bottom><div align=left><b>Figure 5.16:</b>&nbsp;&nbsp;A silicon-chip implementation of an evaluator for\nScheme.</div></caption><tr><td>\n<a name="%_idx_6010"></a><a name="%_idx_6012"></a><a name="%_idx_6014"></a>\n</td></tr></table></div><p><p>\n\n<a name="%_idx_6016"></a><a name="%_idx_6018"></a><a name="%_idx_6020"></a><a name="%_idx_6022"></a><a name="%_idx_6024"></a><a name="%_idx_6026"></a><a name="%_idx_6028"></a><a name="%_idx_6030"></a>Our Scheme evaluator register machine includes a stack and seven\nregisters: <tt>exp</tt>, <tt>env</tt>, <tt>val</tt>, <tt>continue</tt>, <tt>proc</tt>,\n<tt>argl</tt>, and <tt>unev</tt>.  <tt>Exp</tt> is used to hold the expression\nto be evaluated, and <tt>env</tt> contains the environment in which the\nevaluation is to be performed.  At the end of an evaluation, <tt>val</tt>\ncontains the value obtained by evaluating the expression in the\ndesignated environment.  The <tt>continue</tt> register is used to\nimplement recursion, as explained in\nsection&nbsp;<a href="book-Z-H-31.html#%_sec_5.1.4">5.1.4</a>.  (The evaluator needs to call\nitself recursively, since evaluating an expression requires evaluating\nits subexpressions.)  The registers <tt>proc</tt>, <tt>argl</tt>, and <tt>unev</tt> are used in evaluating combinations.<p>\n\n\nWe will not provide a data-path diagram to show how the registers and\noperations of the evaluator are connected, nor will we give the\ncomplete list of machine operations.  These are implicit in the\nevaluator\'s controller, which will be presented in detail.<p>\n\n<a name="%_sec_5.4.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.4.1">5.4.1&nbsp;&nbsp;The Core of the Explicit-Control Evaluator</a></h3><p>\n\n\n<a name="%_idx_6032"></a>\nThe central element in the evaluator is the sequence of instructions\nbeginning at <tt>eval-dispatch</tt>.  This corresponds to the <tt>eval</tt>\nprocedure of the metacircular evaluator described in\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>.  When the controller starts at <tt>eval-dispatch</tt>, it evaluates the expression specified by <tt>exp</tt> in\nthe environment specified by <tt>env</tt>.  When evaluation is complete,\nthe controller will go to the entry point stored in <tt>continue</tt>, and the\n<tt>val</tt> register will hold the value of the expression.  As with the\nmetacircular <tt>eval</tt>, the structure of <tt>eval-dispatch</tt> is a\ncase analysis on the syntactic type of the expression to be\nevaluated.<a name="call_footnote_Temp_767" href="#footnote_Temp_767"><sup><small>20</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_6034"></a>eval-dispatch<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;self-evaluating?)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-self-eval))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;variable?)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-variable))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;quoted?)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-quoted))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;assignment?)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-assignment))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;definition?)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-definition))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;if?)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-if))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;lambda?)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-lambda))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;begin?)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-begin))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;application?)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-application))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;unknown-expression-type))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_768"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_768">Evaluating simple expressions</a></h4><p>\n\n<a name="%_idx_6036"></a>\nNumbers and strings (which are self-evaluating),\nvariables, quotations, and <tt>lambda</tt> expressions have no\nsubexpressions to be evaluated.  For these, the evaluator simply\nplaces the correct value in the <tt>val</tt> register and continues\nexecution at the entry point specified by <tt>continue</tt>.  Evaluation\nof simple expressions is performed by the following controller code:<p>\n\n<p><p><tt><a name="%_idx_6038"></a>ev-self-eval<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\n<a name="%_idx_6040"></a>ev-variable<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(reg&nbsp;exp)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\n<a name="%_idx_6042"></a>ev-quoted<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;text-of-quotation)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\n<a name="%_idx_6044"></a>ev-lambda<br>\n&nbsp;&nbsp;(assign&nbsp;unev&nbsp;(op&nbsp;lambda-parameters)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(assign&nbsp;exp&nbsp;(op&nbsp;lambda-body)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;make-procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;unev)&nbsp;(reg&nbsp;exp)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\n</tt><p><p>\nObserve how <tt>ev-lambda</tt> uses the <tt>unev</tt> and <tt>exp</tt>\nregisters to hold the parameters and body of the lambda expression so\nthat they can be passed to the <tt>make-procedure</tt> operation, along\nwith the environment in <tt>env</tt>.<p>\n\n<a name="%_sec_Temp_769"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_769">Evaluating procedure applications</a></h4><p>\n\n<a name="%_idx_6046"></a><a name="%_idx_6048"></a>\nA procedure application is specified by a combination containing an\noperator and operands.  The operator is a subexpression whose value is\na procedure, and the operands are subexpressions whose values are the\narguments to which the procedure should be applied.  The metacircular\n<tt>eval</tt> handles applications by calling itself recursively to\nevaluate each element of the combination, and then passing the results\nto <tt>apply</tt>, which performs the actual procedure application.  The\nexplicit-control evaluator does the same thing; these recursive calls\nare implemented by <tt>goto</tt> instructions, together with <a name="%_idx_6050"></a>use of the\nstack to save registers that will be restored after the recursive call\nreturns.  Before each call we will be careful to identify which\nregisters must be saved (because their values will be needed\nlater).<a name="call_footnote_Temp_770" href="#footnote_Temp_770"><sup><small>21</small></sup></a><p>\n\nWe begin the evaluation of an application by evaluating the operator\nto produce a procedure, which will later be applied to the evaluated\noperands.  To evaluate the operator, we move it to the <tt>exp</tt>\nregister and go to <tt>eval-dispatch</tt>.  The environment in the <tt>env</tt> register is already the correct one in which to evaluate the\noperator.  However, we save <tt>env</tt> because we will need it later to\nevaluate the operands.  We also extract the operands into <tt>unev</tt>\nand save this on the stack.  We set up <tt>continue</tt> so that <tt>eval-dispatch</tt> will resume at <tt>ev-appl-did-operator</tt> after the\noperator has been evaluated.  First, however, we save the old value of\n<tt>continue</tt>, which tells the controller where to continue after the\napplication.<p>\n\n<p><p><tt><a name="%_idx_6056"></a>ev-application<br>\n&nbsp;&nbsp;(save&nbsp;continue)<br>\n&nbsp;&nbsp;(save&nbsp;env)<br>\n&nbsp;&nbsp;(assign&nbsp;unev&nbsp;(op&nbsp;operands)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(save&nbsp;unev)<br>\n&nbsp;&nbsp;(assign&nbsp;exp&nbsp;(op&nbsp;operator)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;ev-appl-did-operator))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;eval-dispatch))<br>\n</tt><p><p><p>\n\n<a name="%_idx_6058"></a>Upon returning from evaluating the operator subexpression, we proceed\nto evaluate the operands of the combination and to accumulate the\nresulting arguments in a list, held in <tt>argl</tt>.  First we restore\nthe unevaluated operands and the environment.  We initialize <tt>argl</tt> to an empty list.  Then we assign to the <tt>proc</tt> register the\nprocedure that was produced by evaluating the operator.  If there are\nno operands, we go directly to <tt>apply-dispatch</tt>.  Otherwise we\nsave <tt>proc</tt> on the stack and start the argument-evaluation\nloop:<a name="call_footnote_Temp_771" href="#footnote_Temp_771"><sup><small>22</small></sup></a><p>\n\n<p><p><tt>ev-appl-did-operator<br>\n&nbsp;&nbsp;(restore&nbsp;unev)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;the&nbsp;operands</em><br>\n&nbsp;&nbsp;(restore&nbsp;env)<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;empty-arglist))<br>\n&nbsp;&nbsp;(assign&nbsp;proc&nbsp;(reg&nbsp;val))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;the&nbsp;operator</em><br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;no-operands?)&nbsp;(reg&nbsp;unev))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;apply-dispatch))<br>\n&nbsp;&nbsp;(save&nbsp;proc)<br>\n</tt><p><p><p>\n\nEach cycle of the argument-evaluation loop evaluates an operand\nfrom the list in <tt>unev</tt> and accumulates the result into <tt>argl</tt>.\nTo evaluate an operand, we place it in the <tt>exp</tt> register\nand go to <tt>eval-dispatch</tt>, after setting <tt>continue</tt> so that\nexecution will resume with the argument-accumulation phase.  But first\nwe save the arguments accumulated so far (held in <tt>argl</tt>), the\nenvironment (held in <tt>env</tt>), and the remaining operands to be evaluated\n(held in <tt>unev</tt>).  A special case is made for the evaluation of the\nlast operand, which is handled at <tt>ev-appl-last-arg</tt>.<p>\n\n<p><p><tt>ev-appl-operand-loop<br>\n&nbsp;&nbsp;(save&nbsp;argl)<br>\n&nbsp;&nbsp;(assign&nbsp;exp&nbsp;(op&nbsp;first-operand)&nbsp;(reg&nbsp;unev))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;last-operand?)&nbsp;(reg&nbsp;unev))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-appl-last-arg))<br>\n&nbsp;&nbsp;(save&nbsp;env)<br>\n&nbsp;&nbsp;(save&nbsp;unev)<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;ev-appl-accumulate-arg))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;eval-dispatch))<br>\n</tt><p><p><p>\n\nWhen an operand has been evaluated, the value is accumulated into the\nlist held in <tt>argl</tt>.  The operand is then removed from the list of\nunevaluated operands in <tt>unev</tt>, and the argument-evaluation continues.<p>\n\n<p><p><tt>ev-appl-accumulate-arg<br>\n&nbsp;&nbsp;(restore&nbsp;unev)<br>\n&nbsp;&nbsp;(restore&nbsp;env)<br>\n&nbsp;&nbsp;(restore&nbsp;argl)<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;adjoin-arg)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;argl))<br>\n&nbsp;&nbsp;(assign&nbsp;unev&nbsp;(op&nbsp;rest-operands)&nbsp;(reg&nbsp;unev))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;ev-appl-operand-loop))<br>\n</tt><p><p><p>\n\nEvaluation of the last argument is handled differently.  There is no\nneed to save the environment or the list of unevaluated operands\nbefore going to <tt>eval-dispatch</tt>,\nsince they will not be required after the last operand is evaluated.\nThus, we return from the evaluation to a special entry point <tt>ev-appl-accum-last-arg</tt>, which restores the argument list, accumulates\nthe new argument, restores the saved procedure, and goes off to\nperform the application.<a name="call_footnote_Temp_772" href="#footnote_Temp_772"><sup><small>23</small></sup></a><p>\n\n<p><p><tt>ev-appl-last-arg<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;ev-appl-accum-last-arg))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;eval-dispatch))<br>\nev-appl-accum-last-arg<br>\n&nbsp;&nbsp;(restore&nbsp;argl)<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;adjoin-arg)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;argl))<br>\n&nbsp;&nbsp;(restore&nbsp;proc)<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;apply-dispatch))<br>\n</tt><p><p><p>\n\n<a name="%_idx_6070"></a>The details of the argument-evaluation loop determine the order in\nwhich the interpreter evaluates the operands of a combination (e.g.,\nleft to right or right to left -- see\nexercise&nbsp;<a href="book-Z-H-20.html#%_thm_3.8">3.8</a>).  This order is not determined\nby the metacircular evaluator, which inherits its control structure\nfrom the underlying Scheme in which it is implemented.<a name="call_footnote_Temp_773" href="#footnote_Temp_773"><sup><small>24</small></sup></a> Because the <tt>first-operand</tt>\nselector (used in <tt>ev-appl-operand-loop</tt> to extract successive operands\nfrom <tt>unev</tt>) is implemented as <tt>car</tt> and the <tt>rest-operands</tt> selector is implemented as <tt>cdr</tt>, the\nexplicit-control evaluator will evaluate the operands of a combination\nin left-to-right order.<p>\n\n<a name="%_sec_Temp_774"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_774">Procedure application</a></h4><p>\n\n<p>\n\nThe entry point <tt>apply-dispatch</tt> corresponds to the <tt>apply</tt>\nprocedure of the metacircular evaluator.  By the time we get to <tt>apply-dispatch</tt>, the <tt>proc</tt> register contains the procedure to\napply and <tt>argl</tt> contains the list of evaluated arguments to which\nit must be applied.  The saved value of <tt>continue</tt> (originally\npassed to <tt>eval-dispatch</tt> and saved at <tt>ev-application</tt>),\nwhich tells where to return with the result of the procedure\napplication, is on the stack.  When the application is complete, the\ncontroller transfers to the entry point specified by the saved <tt>continue</tt>, with the result of the application in <tt>val</tt>.  As with\nthe metacircular <tt>apply</tt>, there are two cases to consider.  Either\nthe procedure to be applied is a primitive or it is a compound\nprocedure.<p>\n\n<p><p><tt><a name="%_idx_6072"></a>apply-dispatch<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;primitive-procedure?)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;primitive-apply))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;compound-procedure?)&nbsp;(reg&nbsp;proc))&nbsp;&nbsp;<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;compound-apply))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;unknown-procedure-type))<br>\n</tt><p><p><p>\n\n<a name="%_idx_6074"></a>We assume that each primitive is implemented so as to obtain its\narguments from <tt>argl</tt> and place its result in <tt>val</tt>.  To\nspecify how the machine handles primitives, we would have to provide a\nsequence of controller instructions to implement each primitive and\narrange for <tt>primitive-apply</tt> to dispatch to the\ninstructions for the primitive identified by the\ncontents of <tt>proc</tt>.  Since we are interested in the structure of\nthe evaluation process rather than the details of the primitives, we\nwill instead just use an <tt>apply-primitive-procedure</tt> operation\nthat applies the procedure in <tt>proc</tt> to the arguments in <tt>argl</tt>.  For the purpose of simulating the evaluator with the simulator\nof section&nbsp;<a href="book-Z-H-32.html#%_sec_5.2">5.2</a> we use the procedure <tt>apply-primitive-procedure</tt>, which calls on the underlying Scheme\nsystem to perform the application, just as we did for the metacircular\nevaluator in section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.4">4.1.4</a>.  After computing the\nvalue of the primitive application, we restore <tt>continue</tt> and go\nto the designated entry point.<p>\n\n<p><p><tt><a name="%_idx_6076"></a>primitive-apply<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;apply-primitive-procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;argl))<br>\n&nbsp;&nbsp;(restore&nbsp;continue)<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\n</tt><p><p><p>\n\n<a name="%_idx_6078"></a>To apply a compound procedure, we proceed just as with the\nmetacircular evaluator.  We construct a frame that binds the\nprocedure\'s parameters to the arguments, use this frame to\nextend the environment carried by the procedure, and evaluate in this\nextended environment the sequence of expressions that forms the body\nof the procedure.  <tt>Ev-sequence</tt>, described below in\nsection&nbsp;<a href="#%_sec_5.4.2">5.4.2</a>, handles the evaluation\nof the sequence.<p>\n\n<p><p><tt><a name="%_idx_6080"></a>compound-apply<br>\n&nbsp;&nbsp;(assign&nbsp;unev&nbsp;(op&nbsp;procedure-parameters)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(assign&nbsp;env&nbsp;(op&nbsp;procedure-environment)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(assign&nbsp;env&nbsp;(op&nbsp;extend-environment)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;unev)&nbsp;(reg&nbsp;argl)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;unev&nbsp;(op&nbsp;procedure-body)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;ev-sequence))<br>\n</tt><p><p><p>\n\n<tt>Compound-apply</tt> is the only place in the interpreter where the\n<tt>env</tt> register is ever assigned a new value.  Just as in the\nmetacircular evaluator, the new environment is constructed from the\nenvironment carried by the procedure, together with the argument list\nand the corresponding list of variables to be bound.<p>\n\n<a name="%_sec_5.4.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.4.2">5.4.2&nbsp;&nbsp;Sequence Evaluation and Tail Recursion</a></h3><p>\n\n\n<a name="%_idx_6082"></a>\nThe portion of the explicit-control evaluator at <tt>ev-sequence</tt> is\nanalogous to the metacircular evaluator\'s <tt>eval-sequence</tt> procedure.  It\nhandles sequences of expressions in procedure bodies or in explicit\n<tt>begin</tt> expressions.<p>\n\nExplicit <tt>begin</tt> expressions are evaluated by placing the sequence\nof expressions to be evaluated in <tt>unev</tt>, saving <tt>continue</tt> on the\nstack, and jumping to <tt>ev-sequence</tt>.\n<p><p><tt><a name="%_idx_6084"></a>ev-begin<br>\n&nbsp;&nbsp;(assign&nbsp;unev&nbsp;(op&nbsp;begin-actions)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(save&nbsp;continue)<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;ev-sequence))<br>\n</tt><p><p>\nThe implicit sequences in procedure bodies are handled by jumping to\n<tt>ev-sequence</tt> from <tt>compound-apply</tt>, at which point <tt>continue</tt> is already on the stack, having been saved at\n<tt>ev-application</tt>.<p>\n\nThe entries at <tt>ev-sequence</tt>\nand <tt>ev-sequence-continue</tt> form a loop that\nsuccessively evaluates each expression in a sequence.  The list of\nunevaluated expressions is kept in <tt>unev</tt>.  Before evaluating each\nexpression, we check to see if there are additional expressions to be\nevaluated in the sequence.  If so, we save the rest of the unevaluated\nexpressions (held in <tt>unev</tt>) and the environment in which these\nmust be evaluated (held in <tt>env</tt>) and call <tt>eval-dispatch</tt> to\nevaluate the expression.  The two saved registers are restored upon\nthe return from this evaluation, at <tt>ev-sequence-continue</tt>.<p>\n\nThe final expression in the sequence is handled differently, at the\nentry point <tt>ev-sequence-last-exp</tt>.  Since there are no more\nexpressions to be evaluated after this one, we need not save <tt>unev</tt> or <tt>env</tt> before going to <tt>eval-dispatch</tt>.  The value of\nthe whole sequence is the value of the last expression, so after the\nevaluation of the last expression there is nothing left to do except\ncontinue at the entry point currently held on the stack (which was saved\nby <tt>ev-application</tt> or <tt>ev-begin</tt>.)\nRather than setting up <tt>continue</tt> to arrange for <tt>eval-dispatch</tt> to return here and then restoring <tt>continue</tt> from\nthe stack and continuing at that entry point, we restore <tt>continue</tt> from\nthe stack before going to <tt>eval-dispatch</tt>, so that <tt>eval-dispatch</tt> will continue at that entry point after evaluating the\nexpression.<p>\n\n<p><p><tt><a name="%_idx_6086"></a>ev-sequence<br>\n&nbsp;&nbsp;(assign&nbsp;exp&nbsp;(op&nbsp;first-exp)&nbsp;(reg&nbsp;unev))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;last-exp?)&nbsp;(reg&nbsp;unev))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-sequence-last-exp))<br>\n&nbsp;&nbsp;(save&nbsp;unev)<br>\n&nbsp;&nbsp;(save&nbsp;env)<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;ev-sequence-continue))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;eval-dispatch))<br>\nev-sequence-continue<br>\n&nbsp;&nbsp;(restore&nbsp;env)<br>\n&nbsp;&nbsp;(restore&nbsp;unev)<br>\n&nbsp;&nbsp;(assign&nbsp;unev&nbsp;(op&nbsp;rest-exps)&nbsp;(reg&nbsp;unev))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;ev-sequence))<br>\nev-sequence-last-exp<br>\n&nbsp;&nbsp;(restore&nbsp;continue)<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;eval-dispatch))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_775"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_775">Tail recursion</a></h4><p>\n\n<a name="%_idx_6088"></a><a name="%_idx_6090"></a>\nIn chapter&nbsp;1 we said that the process described by a procedure such as<p>\n\n<p><p><tt>(define&nbsp;(sqrt-iter&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;(if&nbsp;(good-enough?&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guess<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sqrt-iter&nbsp;(improve&nbsp;guess&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)))<br>\n</tt><p><p>\nis an iterative process.  Even though the procedure is syntactically\nrecursive (defined in terms of itself), it is not logically necessary\nfor an evaluator to save information in passing from one call to <tt>sqrt-iter</tt> to the next.<a name="call_footnote_Temp_776" href="#footnote_Temp_776"><sup><small>25</small></sup></a> An evaluator that can\nexecute a procedure such as <tt>sqrt-iter</tt> without requiring\nincreasing storage as the procedure continues to call itself is called\na <a name="%_idx_6092"></a><em>tail-recursive</em> evaluator.  <a name="%_idx_6094"></a><a name="%_idx_6096"></a>The metacircular implementation of\nthe evaluator in chapter&nbsp;4 does not specify whether the evaluator is\ntail-recursive, because that evaluator inherits its mechanism for\nsaving state from the underlying Scheme.  With the explicit-control\nevaluator, however, we can trace through the evaluation process to see\nwhen procedure calls cause a net accumulation of information on the\nstack.<p>\n\n\nOur evaluator is tail-recursive, because in order to evaluate the final\nexpression of a sequence we transfer directly to <tt>eval-dispatch</tt> without\nsaving any information on the stack.  Hence, evaluating the final expression\nin a sequence -- even if it is a procedure call (as in <tt>sqrt-iter</tt>, where\nthe <tt>if</tt> expression, which is the last expression in the procedure body,\nreduces to a call to <tt>sqrt-iter</tt>) -- will not cause any information to be\naccumulated on the stack.<a name="call_footnote_Temp_777" href="#footnote_Temp_777"><sup><small>26</small></sup></a><p>\n\nIf we did not think to take advantage of the fact that it was\nunnecessary to save information in this case, we might have\nimplemented <tt>eval-sequence</tt> by treating all the expressions in a\nsequence in the same way -- saving the registers, evaluating the expression,\nreturning to restore the registers, and repeating this until all the\nexpressions have been evaluated:<a name="call_footnote_Temp_778" href="#footnote_Temp_778"><sup><small>27</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_6100"></a>ev-sequence<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;no-more-exps?)&nbsp;(reg&nbsp;unev))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-sequence-end))<br>\n&nbsp;&nbsp;(assign&nbsp;exp&nbsp;(op&nbsp;first-exp)&nbsp;(reg&nbsp;unev))<br>\n&nbsp;&nbsp;(save&nbsp;unev)<br>\n&nbsp;&nbsp;(save&nbsp;env)<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;ev-sequence-continue))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;eval-dispatch))<br>\nev-sequence-continue<br>\n&nbsp;&nbsp;(restore&nbsp;env)<br>\n&nbsp;&nbsp;(restore&nbsp;unev)<br>\n&nbsp;&nbsp;(assign&nbsp;unev&nbsp;(op&nbsp;rest-exps)&nbsp;(reg&nbsp;unev))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;ev-sequence))<br>\nev-sequence-end<br>\n&nbsp;&nbsp;(restore&nbsp;continue)<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\n</tt><p><p><p>\n\n\nThis may seem like a minor change to our previous code for evaluation\nof a sequence:  The only difference is that we go through the\nsave-restore cycle for the last expression in a sequence as well as\nfor the\nothers.  The interpreter will still give the same value for\nany expression.  But this change is fatal to the tail-recursive\nimplementation, because we must now return after evaluating the final\nexpression in a sequence in order to undo the (useless) register\nsaves.  These extra saves will accumulate during a nest of procedure\ncalls.  Consequently, processes such as <tt>sqrt-iter</tt> will require\nspace proportional to the number of iterations rather than requiring\nconstant space.  This difference can be significant.  For example,\n<a name="%_idx_6102"></a>with tail recursion, an infinite loop can be expressed using only the\nprocedure-call mechanism:<p>\n\n<p><p><tt>(define&nbsp;(count&nbsp;n)<br>\n&nbsp;&nbsp;(newline)<br>\n&nbsp;&nbsp;(display&nbsp;n)<br>\n&nbsp;&nbsp;(count&nbsp;(+&nbsp;n&nbsp;1)))<br>\n</tt><p><p>\nWithout tail recursion, such a procedure would eventually run out of\nstack space, and expressing a true iteration would require some\ncontrol mechanism other than procedure call.<p>\n\n<a name="%_sec_5.4.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.4.3">5.4.3&nbsp;&nbsp;Conditionals, Assignments, and Definitions</a></h3><p>\n\n<a name="%_idx_6104"></a>As with the metacircular evaluator, special forms are handled by\nselectively evaluating fragments of the expression.  For an <tt>if</tt>\nexpression, we must evaluate the predicate and decide, based on the\nvalue of predicate, whether to evaluate the consequent or the\nalternative.<p>\n\nBefore evaluating the predicate, we save the <tt>if</tt> expression\nitself so that we can later extract the consequent or alternative.  We\nalso save the environment, which we will need later in order to\nevaluate the consequent or the alternative, and we save <tt>continue</tt>, which we will need later in order to return to the\nevaluation of the expression that is waiting for the value of the <tt>if</tt>.<p>\n\n\n<p><p><tt><a name="%_idx_6106"></a>ev-if<br>\n&nbsp;&nbsp;(save&nbsp;exp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;save&nbsp;expression&nbsp;for&nbsp;later</em><br>\n&nbsp;&nbsp;(save&nbsp;env)<br>\n&nbsp;&nbsp;(save&nbsp;continue)<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;ev-if-decide))<br>\n&nbsp;&nbsp;(assign&nbsp;exp&nbsp;(op&nbsp;if-predicate)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;eval-dispatch))&nbsp;&nbsp;<em>;&nbsp;evaluate&nbsp;the&nbsp;predicate</em><br>\n</tt><p><p><p>\n\n\nWhen we return from evaluating the predicate, we test whether it was\ntrue or false and, depending on the result, place either the\nconsequent or the alternative in <tt>exp</tt> before going to <tt>eval-dispatch</tt>.  Notice that restoring <tt>env</tt> and <tt>continue</tt>\nhere sets up <tt>eval-dispatch</tt> to have the correct environment and\nto continue at the right place to receive the value of the <tt>if</tt>\nexpression. <p>\n\n\n<p><p><tt>ev-if-decide<br>\n&nbsp;&nbsp;(restore&nbsp;continue)<br>\n&nbsp;&nbsp;(restore&nbsp;env)<br>\n&nbsp;&nbsp;(restore&nbsp;exp)<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;true?)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;ev-if-consequent))<br>\n<br>\nev-if-alternative<br>\n&nbsp;&nbsp;(assign&nbsp;exp&nbsp;(op&nbsp;if-alternative)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;eval-dispatch))<br>\nev-if-consequent<br>\n&nbsp;&nbsp;(assign&nbsp;exp&nbsp;(op&nbsp;if-consequent)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;eval-dispatch))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_779"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_779">Assignments and definitions</a></h4><p>\n\n<a name="%_idx_6108"></a>Assignments are handled by <tt>ev-assignment</tt>, which is reached from\n<tt>eval-dispatch</tt> with the assignment expression in <tt>exp</tt>.  The code at <tt>ev-assignment</tt> first evaluates the value part of the expression and\nthen installs the new value in the environment.  <tt>Set-variable-value!</tt> is assumed to be available as a machine\noperation.<p>\n\n\n<p><p><tt><a name="%_idx_6110"></a>ev-assignment<br>\n&nbsp;&nbsp;(assign&nbsp;unev&nbsp;(op&nbsp;assignment-variable)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(save&nbsp;unev)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;save&nbsp;variable&nbsp;for&nbsp;later</em><br>\n&nbsp;&nbsp;(assign&nbsp;exp&nbsp;(op&nbsp;assignment-value)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(save&nbsp;env)<br>\n&nbsp;&nbsp;(save&nbsp;continue)<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;ev-assignment-1))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;eval-dispatch))&nbsp;&nbsp;<em>;&nbsp;evaluate&nbsp;the&nbsp;assignment&nbsp;value</em><br>\nev-assignment-1<br>\n&nbsp;&nbsp;(restore&nbsp;continue)<br>\n&nbsp;&nbsp;(restore&nbsp;env)<br>\n&nbsp;&nbsp;(restore&nbsp;unev)<br>\n&nbsp;&nbsp;(perform<br>\n&nbsp;&nbsp;&nbsp;(op&nbsp;set-variable-value!)&nbsp;(reg&nbsp;unev)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;ok))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\n</tt><p><p><p>\n\n\n<a name="%_idx_6112"></a>Definitions are handled in a similar way:\n\n<p><p><tt><a name="%_idx_6114"></a>ev-definition<br>\n&nbsp;&nbsp;(assign&nbsp;unev&nbsp;(op&nbsp;definition-variable)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(save&nbsp;unev)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;save&nbsp;variable&nbsp;for&nbsp;later</em><br>\n&nbsp;&nbsp;(assign&nbsp;exp&nbsp;(op&nbsp;definition-value)&nbsp;(reg&nbsp;exp))<br>\n&nbsp;&nbsp;(save&nbsp;env)<br>\n&nbsp;&nbsp;(save&nbsp;continue)<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;ev-definition-1))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;eval-dispatch))&nbsp;&nbsp;<em>;&nbsp;evaluate&nbsp;the&nbsp;definition&nbsp;value</em><br>\nev-definition-1<br>\n&nbsp;&nbsp;(restore&nbsp;continue)<br>\n&nbsp;&nbsp;(restore&nbsp;env)<br>\n&nbsp;&nbsp;(restore&nbsp;unev)<br>\n&nbsp;&nbsp;(perform<br>\n&nbsp;&nbsp;&nbsp;(op&nbsp;define-variable!)&nbsp;(reg&nbsp;unev)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;ok))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\n</tt><p><p>\n<p>\n\n<p><a name="%_thm_5.23"></a>\n<b>Exercise 5.23.</b>&nbsp;&nbsp;<a name="%_idx_6116"></a><a name="%_idx_6118"></a><a name="%_idx_6120"></a>Extend the evaluator to handle derived expressions such as <tt>cond</tt>,\n<tt>let</tt>, and so on (section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.2">4.1.2</a>).\nYou may ``cheat\'\' and assume that the syntax\ntransformers such as <tt>cond-&gt;if</tt> are available as machine\noperations.<a name="call_footnote_Temp_781" href="#footnote_Temp_781"><sup><small>28</small></sup></a>\n\n<p><p>\n\n<p><a name="%_thm_5.24"></a>\n<b>Exercise 5.24.</b>&nbsp;&nbsp;<a name="%_idx_6122"></a>Implement <tt>cond</tt> as a new basic special form without\nreducing it to <tt>if</tt>.  You will have to construct a loop that tests\nthe predicates of successive <tt>cond</tt> clauses until you find one\nthat is true, and then use <tt>ev-sequence</tt> to evaluate the actions\nof the clause.\n\n<p><p>\n\n<p><a name="%_thm_5.25"></a>\n<b>Exercise 5.25.</b>&nbsp;&nbsp;<a name="%_idx_6124"></a><a name="%_idx_6126"></a>Modify the evaluator so that it uses normal-order evaluation,\nbased on the lazy evaluator of section&nbsp;<a href="book-Z-H-27.html#%_sec_4.2">4.2</a>.\n<p><p>\n\n<a name="%_sec_5.4.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.4.4">5.4.4&nbsp;&nbsp;Running the Evaluator</a></h3><p>\n\n\n<a name="%_idx_6128"></a>\n<a name="%_idx_6130"></a><a name="%_idx_6132"></a>With the implementation of the explicit-control evaluator we come to\nthe end of a development, begun in chapter&nbsp;1, in which we have\nexplored successively more precise models of the evaluation process.\nWe started with the relatively informal substitution model, then\nextended this in chapter&nbsp;3 to the environment model, which enabled us\nto deal with state and change.  In the metacircular evaluator of\nchapter&nbsp;4, we used Scheme itself as a language for making more explicit\nthe environment structure constructed during evaluation of an\nexpression.  Now, with register machines, we have taken a close look\nat the evaluator\'s mechanisms for storage management,\nargument passing, and control.  At\neach new level of description, we have had to raise issues and resolve\nambiguities that were not apparent at the previous, less precise\ntreatment of evaluation.  To understand the behavior of the\nexplicit-control evaluator, we can simulate it and monitor its\nperformance.<p>\n\n\n<a name="%_idx_6134"></a><a name="%_idx_6136"></a>We will install a driver loop in our evaluator machine.  This plays\nthe role of the <tt>driver-loop</tt> procedure of\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.4">4.1.4</a>.  The evaluator will repeatedly print a\nprompt, read an expression, evaluate the expression by going to <tt>eval-dispatch</tt>, and print the result.  The following instructions form\nthe beginning of the explicit-control evaluator\'s controller\nsequence:<a name="call_footnote_Temp_784" href="#footnote_Temp_784"><sup><small>29</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_6142"></a><a name="%_idx_6144"></a>read-eval-print-loop<br>\n&nbsp;&nbsp;(perform&nbsp;(op&nbsp;initialize-stack))<br>\n&nbsp;&nbsp;(perform<br>\n&nbsp;&nbsp;&nbsp;(op&nbsp;prompt-for-input)&nbsp;(const&nbsp;&quot;;;;&nbsp;EC-Eval&nbsp;input:&quot;))<br>\n&nbsp;&nbsp;(assign&nbsp;exp&nbsp;(op&nbsp;read))<br>\n&nbsp;&nbsp;(assign&nbsp;env&nbsp;(op&nbsp;get-global-environment))<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;print-result))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;eval-dispatch))<br>\n<a name="%_idx_6146"></a>print-result<br>\n&nbsp;&nbsp;(perform<br>\n&nbsp;&nbsp;&nbsp;(op&nbsp;announce-output)&nbsp;(const&nbsp;&quot;;;;&nbsp;EC-Eval&nbsp;value:&quot;))<br>\n&nbsp;&nbsp;(perform&nbsp;(op&nbsp;user-print)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;read-eval-print-loop))<br>\n</tt><p><p><p>\n\n<a name="%_idx_6148"></a><a name="%_idx_6150"></a>When we encounter an error in a procedure (such as the ``unknown\nprocedure type error\'\' indicated at <tt>apply-dispatch</tt>), we print an\nerror message and return to the driver loop.<a name="call_footnote_Temp_785" href="#footnote_Temp_785"><sup><small>30</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_6152"></a>unknown-expression-type<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;unknown-expression-type-error))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;signal-error))<br>\n<a name="%_idx_6154"></a>unknown-procedure-type<br>\n&nbsp;&nbsp;(restore&nbsp;continue)&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;clean&nbsp;up&nbsp;stack&nbsp;(from&nbsp;<tt>apply-dispatch</tt>)</em><br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;unknown-procedure-type-error))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;signal-error))<br>\n<a name="%_idx_6156"></a>signal-error<br>\n&nbsp;&nbsp;(perform&nbsp;(op&nbsp;user-print)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;read-eval-print-loop))<br>\n</tt><p><p><p>\n\nFor the purposes of the simulation, we initialize the stack each time\nthrough the driver loop, since it might not be empty after an error\n(such as an undefined variable) interrupts an evaluation.<a name="call_footnote_Temp_786" href="#footnote_Temp_786"><sup><small>31</small></sup></a><p>\n\n<a name="%_idx_6158"></a>If we combine all the code fragments presented in sections\n<a href="#%_sec_5.4.1">5.4.1</a>-<a href="#%_sec_5.4.4">5.4.4</a>, we can create an\nevaluator machine model that we can run using the register-machine simulator\nof section&nbsp;<a href="book-Z-H-32.html#%_sec_5.2">5.2</a>.<p>\n\n<p><p><tt>(define&nbsp;eceval<br>\n&nbsp;&nbsp;(make-machine<br>\n&nbsp;&nbsp;&nbsp;\'(exp&nbsp;env&nbsp;val&nbsp;proc&nbsp;argl&nbsp;continue&nbsp;unev)<br>\n&nbsp;&nbsp;&nbsp;eceval-operations<br>\n&nbsp;&nbsp;\'(<br>\n&nbsp;&nbsp;&nbsp;&nbsp;read-eval-print-loop<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>entire&nbsp;machine&nbsp;controller&nbsp;as&nbsp;given&nbsp;above</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;)))<br>\n</tt><p><p>\nWe must define Scheme procedures to simulate the\noperations used as primitives by the evaluator.  These are\nthe same procedures we used for the metacircular evaluator in\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1">4.1</a>, together with the few additional ones\ndefined in footnotes throughout section&nbsp;<a href="#%_sec_5.4">5.4</a>.\n<p><p><tt>(define&nbsp;eceval-operations<br>\n&nbsp;&nbsp;(list&nbsp;(list&nbsp;\'self-evaluating?&nbsp;self-evaluating)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>&lt;complete&nbsp;list&nbsp;of&nbsp;operations&nbsp;for&nbsp;eceval&nbsp;machine&gt;</em>))<br>\n</tt><p><p><p>\n\n\nFinally, we can initialize the global environment and run the evaluator:\n<p><p><tt>(define&nbsp;the-global-environment&nbsp;(setup-environment))<br>\n<br>\n(start&nbsp;eceval)<br>\n<i>;;;&nbsp;EC-Eval&nbsp;input:</i><br>\n(define&nbsp;(append&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append&nbsp;(cdr&nbsp;x)&nbsp;y))))<br>\n<i>;;;&nbsp;EC-Eval&nbsp;value:</i><br>\n<i>ok</i><br>\n<i>;;;&nbsp;EC-Eval&nbsp;input:</i><br>\n(append&nbsp;\'(a&nbsp;b&nbsp;c)&nbsp;\'(d&nbsp;e&nbsp;f))<br>\n<i>;;;&nbsp;EC-Eval&nbsp;value:</i><br>\n<i>(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e&nbsp;f)</i><br>\n</tt><p><p><p>\n\nOf course, evaluating expressions in this way will take much longer\nthan if we had directly typed them into Scheme, because of the\nmultiple levels of simulation involved.  Our expressions are evaluated\nby the explicit-control-evaluator machine, which is being simulated by\na Scheme program, which is itself being evaluated by the Scheme\ninterpreter.<p>\n\n<a name="%_sec_Temp_787"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_787">Monitoring the performance of the evaluator</a></h4><p>\n\n<a name="%_idx_6160"></a>\n<a name="%_idx_6162"></a>Simulation can be a powerful tool to guide the implementation of\nevaluators.  Simulations make it easy not only to explore variations\nof the register-machine design but also to monitor the performance of\nthe simulated evaluator.  For example, one important factor in\nperformance is how efficiently the evaluator uses the stack.  We can\nobserve the number of stack operations required to evaluate various\nexpressions by defining the evaluator register machine with the\nversion of the simulator that collects statistics on stack use\n(section&nbsp;<a href="book-Z-H-32.html#%_sec_5.2.4">5.2.4</a>), and adding an instruction at the\nevaluator\'s <tt>print-result</tt> entry point to print the\nstatistics:<p>\n\n<p><p><tt><a name="%_idx_6164"></a>print-result<br>\n&nbsp;&nbsp;(perform&nbsp;(op&nbsp;print-stack-statistics))<em>;&nbsp;added&nbsp;instruction</em><br>\n&nbsp;&nbsp;(perform<br>\n&nbsp;&nbsp;&nbsp;(op&nbsp;announce-output)&nbsp;(const&nbsp;&quot;;;;&nbsp;EC-Eval&nbsp;value:&quot;))<br>\n&nbsp;&nbsp;<tt>...</tt>&nbsp;<em>;&nbsp;same&nbsp;as&nbsp;before</em><br>\n</tt><p><p>\nInteractions with the evaluator now look like this:\n<p><p><tt><i>;;;&nbsp;EC-Eval&nbsp;input:</i><br>\n(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1))&nbsp;n)))<br>\n<i>(total-pushes&nbsp;=&nbsp;3&nbsp;maximum-depth&nbsp;=&nbsp;3)</i><br>\n<i>;;;&nbsp;EC-Eval&nbsp;value:</i><br>\n<i>ok</i><br>\n<i>;;;&nbsp;EC-Eval&nbsp;input:</i><br>\n(factorial&nbsp;5)<br>\n<i>(total-pushes&nbsp;=&nbsp;144&nbsp;maximum-depth&nbsp;=&nbsp;28)</i><br>\n<i>;;;&nbsp;EC-Eval&nbsp;value:</i><br>\n<i>120</i><br>\n</tt><p><p>\nNote that the driver loop of the evaluator reinitializes the stack\nat the start of\neach interaction, so that the statistics printed will refer only to\nstack operations used to evaluate the previous expression.<p>\n\n<p><a name="%_thm_5.26"></a>\n<b>Exercise 5.26.</b>&nbsp;&nbsp;<a name="%_idx_6166"></a><a name="%_idx_6168"></a><a name="%_idx_6170"></a>Use the monitored stack to explore the tail-recursive property of the\nevaluator (section&nbsp;<a href="#%_sec_5.4.2">5.4.2</a>).  Start the\nevaluator and define the iterative <tt>factorial</tt> procedure from\nsection&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a>:<p>\n\n<p><p><tt>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;product&nbsp;counter)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;counter&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;(*&nbsp;counter&nbsp;product)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;counter&nbsp;1))))<br>\n&nbsp;&nbsp;(iter&nbsp;1&nbsp;1))<br>\n</tt><p><p>\nRun the procedure with some small values of <em>n</em>.  Record the maximum\nstack depth and the number of pushes required to compute <em>n</em>! for each of\nthese values.<p>\n\n<p><p>a.  You will find that the maximum depth required to evaluate <em>n</em>! is\nindependent of <em>n</em>.  What is that depth?<p>\n\n<p><p>b.  Determine from your data a formula in terms of <em>n</em> for the total\nnumber of push operations used in evaluating <em>n</em>! for any <em>n</em> <u>&gt;</u> 1.\nNote that the number of operations used is a linear function of <em>n</em>\nand is thus determined by two constants.\n<p><p>\n\n<p><a name="%_thm_5.27"></a>\n<b>Exercise 5.27.</b>&nbsp;&nbsp;<a name="%_idx_6172"></a>For comparison with exercise&nbsp;<a href="#%_thm_5.26">5.26</a>, explore the\nbehavior of the following procedure for computing factorials\nrecursively:\n<p><p><tt>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1))&nbsp;n)))<br>\n</tt><p><p>\nBy running this procedure with the monitored stack, determine, as a\nfunction of <em>n</em>, the maximum depth of the stack and the total number\nof pushes used in evaluating <em>n</em>! for <em>n</em> <u>&gt;</u> 1.  (Again, these functions\nwill be linear.)  Summarize your experiments by filling in the\nfollowing table with the appropriate expressions in terms of <em>n</em>:<p>\n\n<table border=1><tr><td valign=top ></td><td valign=top >Maximum depth </td><td valign=top >Number of pushes</td></tr>\n<tr><td valign=top >Recursive </td><td valign=top ></td><td valign=top ></td></tr>\n<tr><td valign=top >factorial </td><td valign=top ></td><td valign=top ></td></tr>\n<tr><td valign=top >Iterative </td><td valign=top ></td><td valign=top ></td></tr>\n<tr><td valign=top >factorial </td><td valign=top ></td><td valign=top ></td></tr>\n<tr><td valign=top ></td></tr></table><p>\n\nThe maximum depth is a measure of the amount of space used by the\nevaluator in carrying out the computation, and the number of pushes\ncorrelates well with the time required.\n\n<p><p>\n\n<p>\n\n<p><a name="%_thm_5.28"></a>\n<b>Exercise 5.28.</b>&nbsp;&nbsp;<a name="%_idx_6174"></a><a name="%_idx_6176"></a>Modify the definition of the evaluator by changing\n<tt>eval-sequence</tt> as described in\nsection&nbsp;<a href="#%_sec_5.4.2">5.4.2</a> so that the evaluator is no\nlonger tail-recursive.  Rerun your experiments from\nexercises&nbsp;<a href="#%_thm_5.26">5.26</a> and&nbsp;<a href="#%_thm_5.27">5.27</a> to demonstrate\nthat both versions of the <tt>factorial</tt> procedure now require space\nthat grows linearly with their input.\n<p><p>\n\n<p><a name="%_thm_5.29"></a>\n<b>Exercise 5.29.</b>&nbsp;&nbsp;<a name="%_idx_6178"></a>Monitor the stack operations in the tree-recursive Fibonacci computation:<p>\n\n<p><p><tt><a name="%_idx_6180"></a>(define&nbsp;(fib&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(fib&nbsp;(-&nbsp;n&nbsp;1))&nbsp;(fib&nbsp;(-&nbsp;n&nbsp;2)))))<br>\n</tt><p><p>\na.  Give a formula in terms of <em>n</em> for the maximum depth of the stack\nrequired to compute  <em>F</em><em>i</em><em>b</em>(<em>n</em>) for <em>n</em> <u>&gt;</u> 2.  Hint: In\nsection&nbsp;<a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a> we argued that the space used by this\nprocess grows linearly with <em>n</em>.<p>\n\n<p><p>b.  Give a formula for the total number of pushes used to compute\n <em>F</em><em>i</em><em>b</em>(<em>n</em>) for <em>n</em> <u>&gt;</u> 2.  You should find that the number of\npushes (which correlates well with the time used) grows exponentially\nwith <em>n</em>.  Hint: Let <em>S</em>(<em>n</em>) be the number of pushes used in computing\n <em>F</em><em>i</em><em>b</em>(<em>n</em>).  You should be able to argue that there is a formula\nthat expresses <em>S</em>(<em>n</em>) in terms of <em>S</em>(<em>n</em> - 1), <em>S</em>(<em>n</em> - 2), and some fixed\n``overhead\'\' constant <em>k</em> that is independent of <em>n</em>.  Give the\nformula, and say what <em>k</em> is.  Then show that <em>S</em>(<em>n</em>) can be expressed\nas <em>a</em>  <em>F</em><em>i</em><em>b</em>(<em>n</em> + 1)  +  <em>b</em> and give the values of <em>a</em> and <em>b</em>.\n\n<p><p>\n\n<p><a name="%_thm_5.30"></a>\n<b>Exercise 5.30.</b>&nbsp;&nbsp;<a name="%_idx_6182"></a><a name="%_idx_6184"></a>Our evaluator currently catches and signals only two kinds of\nerrors -- unknown expression types and unknown procedure types.  Other\nerrors will take us out of the evaluator read-eval-print loop.  When\nwe run the evaluator using the register-machine simulator, these\nerrors are caught by the underlying Scheme system.  This is analogous\nto the computer crashing when a user program makes an\nerror.<a name="call_footnote_Temp_793" href="#footnote_Temp_793"><sup><small>32</small></sup></a>  It is a large project to make a real\nerror system work, but it is well worth the effort to understand what\nis involved here.<p>\n\n<p><p>a. Errors that occur in the evaluation process, such as an attempt to\naccess an unbound variable, could be caught by changing the lookup\noperation to make it return a distinguished condition code, which cannot\nbe a possible value of any user variable.  The evaluator can test\nfor this condition code and then do what is necessary to go to <tt>signal-error</tt>.  Find all of the places in the evaluator where such a\nchange is necessary and fix them.  This is lots of work.<p>\n\n<p><p>b. Much worse is the problem of handling errors that are signaled by\napplying primitive procedures, such as an attempt to divide by zero or\nan attempt to extract the <tt>car</tt> of a symbol.  In a professionally\nwritten high-quality system, each primitive application is checked for\nsafety as part of the primitive.  For example, every call to <tt>car</tt>\ncould first check that the argument is a pair.  If the argument is not\na pair, the application would return a distinguished condition code to\nthe evaluator, which would then report the failure.  We could arrange\nfor this in our register-machine simulator by making each primitive\nprocedure\ncheck for applicability and returning an appropriate distinguished\ncondition code on failure. Then the <tt>primitive-apply</tt> code in the\nevaluator can check for the condition code and go to <tt>signal-error</tt> if necessary.  Build this structure and make it work.\nThis is a major project.\n\n<p><p>\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_765" href="#call_footnote_Temp_765"><sup><small>19</small></sup></a> See Batali et al. 1982 for more\n<a name="%_idx_6004"></a>information on the chip and the method by which it was designed.\n\n<p><a name="footnote_Temp_767" href="#call_footnote_Temp_767"><sup><small>20</small></sup></a> In our controller, the dispatch is written as a\nsequence of <tt>test</tt> and <tt>branch</tt> instructions.  Alternatively,\nit could have been written in a data-directed style (and in a real\nsystem it probably would have been) to avoid the need to perform\nsequential tests and to facilitate the definition of new expression\ntypes.  A machine designed to run Lisp would probably include a <tt>dispatch-on-type</tt> instruction that would efficiently execute such\ndata-directed dispatches.\n\n<p><a name="footnote_Temp_770" href="#call_footnote_Temp_770"><sup><small>21</small></sup></a> This is an important but subtle point in translating\nalgorithms from a procedural language, such as Lisp, to a\nregister-machine language.  As an alternative to saving only what is\nneeded, we could save all the registers (except <tt>val</tt>) before each\nrecursive call. This is called a <a name="%_idx_6052"></a><a name="%_idx_6054"></a><em>framed-stack</em> discipline.  This\nwould work but might save more registers than necessary; this could be\nan important consideration in a system where stack operations are\nexpensive.  Saving registers whose contents will not be needed later\nmay also hold onto useless data that could otherwise be\ngarbage-collected, freeing space to be reused.\n\n<p><a name="footnote_Temp_771" href="#call_footnote_Temp_771"><sup><small>22</small></sup></a> We add to the evaluator data-structure procedures in\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.3">4.1.3</a> the following two procedures\nfor manipulating argument lists:\n<p><p><tt><a name="%_idx_6060"></a>(define&nbsp;(empty-arglist)&nbsp;\'())<br>\n<br>\n<a name="%_idx_6062"></a>(define&nbsp;(adjoin-arg&nbsp;arg&nbsp;arglist)<br>\n&nbsp;&nbsp;(append&nbsp;arglist&nbsp;(list&nbsp;arg)))<br>\n</tt><p><p>\nWe also use an additional syntax procedure to test for the\nlast operand in a combination:\n<p><p><tt><a name="%_idx_6064"></a>(define&nbsp;(last-operand?&nbsp;ops)<br>\n&nbsp;&nbsp;(null?&nbsp;(cdr&nbsp;ops)))<br>\n</tt><p><p>\n\n\n<p><a name="footnote_Temp_772" href="#call_footnote_Temp_772"><sup><small>23</small></sup></a> The optimization of treating the last operand\n<a name="%_idx_6066"></a>specially is known as <i>evlis tail recursion</i> (see <a name="%_idx_6068"></a>Wand 1980).\nWe could be somewhat more efficient\nin the argument evaluation loop if we made evaluation of the first\noperand a special case too.  This would permit us to postpone\ninitializing <tt>argl</tt> until after evaluating the first operand, so\nas to avoid saving <tt>argl</tt> in this case.  The compiler in\nsection&nbsp;<a href="book-Z-H-35.html#%_sec_5.5">5.5</a> performs this optimization.  (Compare\nthe <tt>construct-arglist</tt> procedure of\nsection&nbsp;<a href="book-Z-H-35.html#%_sec_5.5.3">5.5.3</a>.)\n\n<p><a name="footnote_Temp_773" href="#call_footnote_Temp_773"><sup><small>24</small></sup></a> The\norder of operand evaluation in the metacircular evaluator is\ndetermined by the order of evaluation of the arguments to <tt>cons</tt>\nin the procedure <tt>list-of-values</tt> of section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>\n(see exercise&nbsp;<a href="book-Z-H-26.html#%_thm_4.1">4.1</a>).\n\n<p><a name="footnote_Temp_776" href="#call_footnote_Temp_776"><sup><small>25</small></sup></a> We saw in\nsection&nbsp;<a href="book-Z-H-31.html#%_sec_5.1">5.1</a> how to implement such a\nprocess with a register machine that had no stack; the state of the\nprocess was stored in a fixed set of registers.\n\n<p><a name="footnote_Temp_777" href="#call_footnote_Temp_777"><sup><small>26</small></sup></a> This implementation of tail recursion in\n<tt>ev-sequence</tt> is one variety of a well-known optimization technique used\nby many compilers.  In compiling a procedure that ends with a procedure call,\none can replace the call by a jump to the called procedure\'s entry point.\nBuilding this strategy into the interpreter, as we have done in this section,\nprovides the optimization uniformly throughout the language.\n\n<p><a name="footnote_Temp_778" href="#call_footnote_Temp_778"><sup><small>27</small></sup></a> We can define <tt>no-more-exps?</tt> as follows:\n<p><p><tt><a name="%_idx_6098"></a>(define&nbsp;(no-more-exps?&nbsp;seq)&nbsp;(null?&nbsp;seq))<br>\n</tt><p><p>\n\n\n<p><a name="footnote_Temp_781" href="#call_footnote_Temp_781"><sup><small>28</small></sup></a> This isn\'t really cheating.  In an actual\nimplementation built from scratch, we would use our explicit-control\nevaluator to interpret a Scheme program that performs source-level\ntransformations like <tt>cond-&gt;if</tt> in a syntax phase that runs before\nexecution.\n\n<p><a name="footnote_Temp_784" href="#call_footnote_Temp_784"><sup><small>29</small></sup></a> We assume here that <tt>read</tt> and the\nvarious printing operations are\navailable as primitive machine operations, which is useful for our\nsimulation, but completely unrealistic in practice.  These\nare actually extremely complex operations.  In practice, they would be\nimplemented using low-level input-output operations\nsuch as transferring single characters to and from a device.<p>\n\nTo support the <tt>get-global-environment</tt> operation we define\n<p><p><tt><a name="%_idx_6138"></a>(define&nbsp;the-global-environment&nbsp;(setup-environment))<br>\n<br>\n<a name="%_idx_6140"></a>(define&nbsp;(get-global-environment)<br>\n&nbsp;&nbsp;the-global-environment)<br>\n</tt><p><p>\n\n\n<p><a name="footnote_Temp_785" href="#call_footnote_Temp_785"><sup><small>30</small></sup></a> There are other\nerrors that we would like the interpreter to handle, but these are not\nso simple.  See exercise&nbsp;<a href="#%_thm_5.30">5.30</a>.\n\n<p><a name="footnote_Temp_786" href="#call_footnote_Temp_786"><sup><small>31</small></sup></a> We\ncould perform the stack initialization only after errors, but doing it in\nthe driver loop will be convenient for monitoring the evaluator\'s\nperformance, as described below.\n\n<p><a name="footnote_Temp_793" href="#call_footnote_Temp_793"><sup><small>32</small></sup></a> Regrettably, this is the normal state of affairs in\n<a name="%_idx_6186"></a>conventional compiler-based language systems such as C.  \n<a name="%_idx_6188"></a><a name="%_idx_6190"></a><a name="%_idx_6192"></a>In UNIX<sup> <em>T</em><em>M</em></sup> the system ``dumps core,\'\' and in \nDOS/Windows<sup> <em>T</em><em>M</em></sup> it becomes catatonic.\nThe Macintosh<sup> <em>T</em><em>M</em></sup> displays a\npicture of an exploding bomb and offers you the opportunity to reboot\nthe computer -- if you\'re lucky.\n\n</div>\n\n<p><div class=navigation></div><p>\n\n<a name="%_sec_5.5"></a>\n<h2><a href="book-Z-H-4.html#%_toc_%_sec_5.5">5.5&nbsp;&nbsp;Compilation</a></h2><p>\n\n\n<a name="%_idx_6194"></a>\nThe explicit-control evaluator of section&nbsp;<a href="book-Z-H-34.html#%_sec_5.4">5.4</a> is a\nregister machine whose controller interprets Scheme programs.  In this\nsection we will see how to run Scheme programs on a register machine\nwhose controller is not a Scheme interpreter.<p>\n\n<a name="%_idx_6196"></a><a name="%_idx_6198"></a>The explicit-control evaluator machine is universal -- it can carry out\nany computational process that can be described in Scheme.  The\nevaluator\'s controller orchestrates the use of its data paths to\nperform the desired computation.  Thus, the evaluator\'s data paths are\nuniversal: They are sufficient to perform any computation we desire,\ngiven an appropriate controller.<a name="call_footnote_Temp_794" href="#footnote_Temp_794"><sup><small>33</small></sup></a><p>\n\n<a name="%_idx_6200"></a><a name="%_idx_6202"></a>Commercial general-purpose computers are register machines organized\naround a collection of registers and operations that constitute\nan efficient and convenient universal set of data paths.\nThe controller for a general-purpose machine is an interpreter for\na register-machine language like the one we have been using.  This\nlanguage is called the <a name="%_idx_6204"></a><em>native language</em> of the machine, or simply\n<a name="%_idx_6206"></a><em>machine language</em>.  Programs written in machine language are\nsequences of instructions that use the machine\'s data paths.\nFor example, the <a name="%_idx_6208"></a>explicit-control evaluator\'s instruction sequence\ncan be thought of as a machine-language program for a general-purpose\ncomputer rather than as the controller for a specialized interpreter\nmachine.<p>\n\n<a name="%_idx_6210"></a><a name="%_idx_6212"></a>There are two common strategies for bridging the gap between\nhigher-level languages and register-machine languages.  The\nexplicit-control evaluator illustrates the\nstrategy of interpretation.  An interpreter written in the native\nlanguage of a machine configures the machine to execute programs\nwritten in a language (called the <a name="%_idx_6214"></a><em>source language</em>) that may\ndiffer from the native language of the machine performing the\nevaluation.  The primitive procedures of the source language are\nimplemented as a library of subroutines written in the native language\nof the given machine.  A program to be interpreted (called the <a name="%_idx_6216"></a><em>source program</em>) is represented as a data structure.  The interpreter\ntraverses this data structure, analyzing the source program.  As it\ndoes so, it simulates the intended behavior of the source program by\ncalling appropriate primitive subroutines from the library.<p>\n\n\nIn this section, we explore the alternative strategy of <em>compilation</em>.  A compiler for a given source language and machine\ntranslates a source program into an equivalent program (called the\n<a name="%_idx_6218"></a><em>object program</em>) written in the machine\'s native language.  The\ncompiler that we implement in this section translates programs written\nin Scheme into sequences of instructions to be executed using\nthe explicit-control evaluator machine\'s data paths.<a name="call_footnote_Temp_795" href="#footnote_Temp_795"><sup><small>34</small></sup></a><p>\n\nCompared with interpretation, compilation can provide a great increase\nin the efficiency of program execution, as we will explain below in\nthe overview of the compiler.  On the other hand, an interpreter\nprovides a more powerful environment for interactive program\ndevelopment and debugging, because the source program being executed\nis available at run time to be examined and modified.  In addition,\nbecause the entire library of primitives is present, new programs can\nbe constructed and added to the system during debugging.<p>\n\nIn view of the complementary advantages of compilation and\ninterpretation, modern program-development environments pursue a mixed\nstrategy.  Lisp interpreters are generally organized so that\ninterpreted procedures and compiled procedures can call each other.\nThis enables a programmer to compile those parts of a program that are\nassumed to be debugged, thus gaining the efficiency advantage of\ncompilation, while retaining the interpretive mode of execution for\nthose parts of the program that are in the flux of interactive\ndevelopment and debugging.  In\nsection&nbsp;<a href="#%_sec_5.5.7">5.5.7</a>, after we have implemented\nthe compiler, we will show how to interface it with our interpreter to\nproduce an integrated interpreter-compiler development system.<p>\n\n<a name="%_sec_Temp_796"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_796">An overview of the compiler</a></h4><p>\n\n<a name="%_idx_6224"></a><a name="%_idx_6226"></a>\nOur compiler is much like our interpreter, both in its structure and in\nthe function it performs.  Accordingly, the mechanisms used by the\ncompiler for analyzing expressions will be similar to those used by\nthe interpreter.  Moreover, to make it easy to interface compiled and\ninterpreted code, we will design the compiler to generate code that\nobeys the same conventions of <a name="%_idx_6228"></a>register usage as the interpreter: The\nenvironment will be kept in the <tt>env</tt> register, argument lists\nwill be accumulated in <tt>argl</tt>, a procedure to be applied will be\nin <tt>proc</tt>, procedures will return their answers in <tt>val</tt>,\nand the location to which a procedure should return will be kept in\n<tt>continue</tt>.\nIn general, the compiler translates a source program into an object\nprogram that performs essentially the same register operations as\nwould the interpreter in evaluating the same source program.<p>\n\nThis description suggests a strategy for implementing a rudimentary\ncompiler: We traverse the expression in the same way the\ninterpreter does.  When we encounter a register instruction that the\ninterpreter would perform in evaluating the expression, we do not\nexecute the instruction but instead accumulate it into a sequence.  The\nresulting sequence of instructions will be the object code.  Observe\nthe <a name="%_idx_6230"></a><a name="%_idx_6232"></a>efficiency advantage of compilation over interpretation.  Each\ntime the interpreter evaluates an expression -- for example,\n<tt>(f 84 96)</tt> -- it performs the work of\nclassifying the expression (discovering that this\nis a procedure application) and testing for the end of the operand list\n(discovering that there are two operands).  With a\ncompiler, the expression is analyzed only once, when the\ninstruction sequence is generated at compile time.  The object code\nproduced by the compiler contains only the instructions that evaluate\nthe operator and the two operands, assemble the argument list,\nand apply the procedure (in <tt>proc</tt>) to the arguments (in <tt>argl</tt>).<p>\n\n\n<a name="%_idx_6234"></a>This is the same kind of optimization we implemented in the\nanalyzing evaluator of section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>.\nBut there are further opportunities to gain efficiency in compiled code.\nAs the interpreter runs, it follows a process that must be applicable\nto any expression in the language.  In contrast, a given segment of\ncompiled code is meant to execute some particular expression.  This\ncan make a big difference, for example in the use of the stack to\nsave registers.  When the interpreter evaluates an expression, it must\nbe prepared for any contingency.  Before evaluating a subexpression,\nthe interpreter saves all\nregisters that will be needed later, because\nthe subexpression might require an arbitrary evaluation.\nA compiler, on the other hand, can exploit the structure of the\nparticular expression it is processing to generate code that avoids\nunnecessary stack operations.<p>\n\nAs a case in point, consider the combination <tt>(f 84 96)</tt>.  Before\nthe interpreter evaluates the operator of the combination, it prepares\nfor this evaluation by saving the registers containing the operands\nand the environment, whose values will be needed later.  The\ninterpreter then evaluates the operator to obtain the result in <tt>val</tt>, restores the saved registers, and finally moves the result from\n<tt>val</tt> to <tt>proc</tt>.  However, in the particular expression we are\ndealing with, the operator is the symbol <tt>f</tt>, whose evaluation is\naccomplished by the machine operation <tt>lookup-variable-value</tt>,\nwhich does not alter any registers.  The compiler that we implement in\nthis section will take advantage of this fact and generate code that\nevaluates the operator using the instruction\n<p><p><tt>(assign&nbsp;proc&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;f)&nbsp;(reg&nbsp;env))<br>\n</tt><p><p>\nThis code not only avoids the unnecessary saves and\nrestores but also assigns the value of the lookup directly to\n<tt>proc</tt>, whereas the interpreter would obtain the result in <tt>val</tt>\nand then move this to <tt>proc</tt>.<p>\n\n\nA compiler can also optimize access to the environment.  Having\nanalyzed the code, the compiler can in many cases know in which frame\na particular variable will be located and access that frame directly,\nrather than performing the <tt>lookup-variable-value</tt> search.  We\nwill discuss how to implement such variable access in\nsection&nbsp;<a href="#%_sec_5.5.6">5.5.6</a>.  Until then, however, we will\nfocus on the kind of register and stack optimizations described above.\nThere are many other optimizations that can be performed by a\ncompiler, such as coding primitive operations ``in line\'\' instead of\nusing a general <tt>apply</tt> mechanism (see\nexercise&nbsp;<a href="#%_thm_5.38">5.38</a>); but we will not emphasize these here.\nOur main goal in this section is to illustrate the compilation process\nin a simplified (but still interesting) context.<p>\n\n<a name="%_sec_5.5.1"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.1">5.5.1&nbsp;&nbsp;Structure of the Compiler</a></h3><p>\n\n\n<a name="%_idx_6236"></a>\n<a name="%_idx_6238"></a>In section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a> we modified our original\nmetacircular interpreter to separate analysis from execution.  We\nanalyzed each expression to produce an execution procedure that took\nan environment as argument and performed the required operations.  In\nour compiler, we will do essentially the same analysis.  Instead of\nproducing execution procedures, however, we will generate sequences of\ninstructions to be run by our register machine.<p>\n\n\nThe procedure <tt>compile</tt> is the top-level dispatch in the compiler.\nIt corresponds to the <tt>eval</tt> procedure of\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>, the <tt>analyze</tt> procedure of\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>, and the <tt>eval-dispatch</tt>\nentry point of the explicit-control-evaluator in\nsection&nbsp;<a href="book-Z-H-34.html#%_sec_5.4.1">5.4.1</a>.\nThe compiler, like the interpreters, uses the <a name="%_idx_6240"></a>expression-syntax\nprocedures defined in section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.2">4.1.2</a>.<a name="call_footnote_Temp_797" href="#footnote_Temp_797"><sup><small>35</small></sup></a>\n<tt>Compile</tt> performs a case\nanalysis on the syntactic type of the expression to be compiled.  For\neach type of expression, it dispatches to a specialized <a name="%_idx_6242"></a><em>code\ngenerator</em>:<p>\n\n<p><p><tt><a name="%_idx_6244"></a>(define&nbsp;(compile&nbsp;exp&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;(cond&nbsp;((self-evaluating?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile-self-evaluating&nbsp;exp&nbsp;target&nbsp;linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((quoted?&nbsp;exp)&nbsp;(compile-quoted&nbsp;exp&nbsp;target&nbsp;linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((variable?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile-variable&nbsp;exp&nbsp;target&nbsp;linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((assignment?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile-assignment&nbsp;exp&nbsp;target&nbsp;linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((definition?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile-definition&nbsp;exp&nbsp;target&nbsp;linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((if?&nbsp;exp)&nbsp;(compile-if&nbsp;exp&nbsp;target&nbsp;linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda?&nbsp;exp)&nbsp;(compile-lambda&nbsp;exp&nbsp;target&nbsp;linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((begin?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile-sequence&nbsp;(begin-actions&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((cond?&nbsp;exp)&nbsp;(compile&nbsp;(cond-&gt;if&nbsp;exp)&nbsp;target&nbsp;linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((application?&nbsp;exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile-application&nbsp;exp&nbsp;target&nbsp;linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;Unknown&nbsp;expression&nbsp;type&nbsp;--&nbsp;COMPILE&quot;&nbsp;exp))))<br>\n</tt><p><p><p>\n\n\n<a name="%_sec_Temp_798"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_798">Targets and linkages</a></h4><p>\n\n<a name="%_idx_6246"></a><tt>Compile</tt> and the code generators that it calls take two arguments\nin addition to the expression to compile.  There is a <a name="%_idx_6248"></a><em>target</em>,\nwhich specifies the register in which the compiled code is to return\nthe value of the expression.  There is also a <a name="%_idx_6250"></a><em>linkage\ndescriptor</em>, which describes how the code resulting from the\ncompilation of the expression should proceed when it has finished its\nexecution.  The linkage descriptor can require that the code do one of\nthe following three things:<p>\n\n<p><ul>\n<li>continue at the next instruction in sequence (this is\n<a name="%_idx_6252"></a>specified by the linkage descriptor <tt>next</tt>),<p>\n\n<li>return from the procedure being compiled (this is specified\n<a name="%_idx_6254"></a>by the linkage descriptor <tt>return</tt>), or<p>\n\n<li>jump to a named entry point (this is specified by using the\ndesignated label as the linkage descriptor).\n</ul><p><p>\n\nFor example, compiling the expression <tt>5</tt> (which is\nself-evaluating) with a target of the <tt>val</tt> register and a\nlinkage of <tt>next</tt> should produce the instruction<p>\n\n<p><p><tt>(assign&nbsp;val&nbsp;(const&nbsp;5))<br>\n</tt><p><p>\nCompiling the same expression with a linkage of <tt>return</tt> should\nproduce the instructions<p>\n\n<p><p><tt>(assign&nbsp;val&nbsp;(const&nbsp;5))<br>\n(goto&nbsp;(reg&nbsp;continue))<br>\n</tt><p><p>\nIn the first case, execution will continue with the next instruction\nin the sequence. In the second case, we will return from a procedure\ncall.  In both cases, the value of the expression will be placed into\nthe target <tt>val</tt> register.<p>\n\n<a name="%_sec_Temp_799"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_799">Instruction sequences and stack usage</a></h4><p>\n\n<p>\n\n<a name="%_idx_6256"></a><a name="%_idx_6258"></a>Each code generator returns an <em>instruction sequence</em> containing\nthe object code it has generated for the expression.  Code generation\nfor a compound expression is accomplished by combining the output from\nsimpler code generators for component expressions, just as\nevaluation of a compound expression is accomplished by evaluating the\ncomponent expressions.<p>\n\n\nThe simplest method for combining instruction sequences is a procedure\n<a name="%_idx_6260"></a>called <tt>append-instruction-sequences</tt>.  It takes as arguments any\nnumber of instruction sequences that are to be executed sequentially;\nit appends them and returns the combined sequence.  That is, if\n&lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt; and &lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt; are sequences of instructions, then\nevaluating\n<p><p><tt>(append-instruction-sequences&nbsp;&lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt;&nbsp;&lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt;)<br>\n</tt><p><p>\nproduces the sequence\n<p><p><tt>&lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt;<br>\n&lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt;<br>\n</tt><p><p><p>\n\n<a name="%_idx_6262"></a>Whenever registers might need to be saved, the compiler\'s code generators use\n<a name="%_idx_6264"></a><tt>preserving</tt>, which is a more subtle method for combining\ninstruction sequences.  <tt>Preserving</tt> takes three arguments: a set\nof registers and two instruction sequences that are to be executed\nsequentially.  It appends the sequences in such a way that the\ncontents of each register in the set is preserved over the execution\nof the first sequence, if this is needed for the execution of the\nsecond sequence.  That is, if the first sequence modifies the register\nand the second sequence actually needs the register\'s original\ncontents, then <tt>preserving</tt> wraps a <tt>save</tt> and a <tt>restore</tt>\nof the register around the first sequence before appending the\nsequences.  Otherwise, <tt>preserving</tt> simply returns the appended\ninstruction sequences.  Thus, for example,\n<p><p><tt>(preserving&nbsp;(list&nbsp;&lt;<em><em>r</em><em>e</em><em>g</em><sub>1</sub></em>&gt;&nbsp;&lt;<em><em>r</em><em>e</em><em>g</em><sub>2</sub></em>&gt;)&nbsp;&lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt;&nbsp;&lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt;)<br>\n</tt><p><p>\nproduces one of the following four sequences of instructions, depending on how\n&lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt; and &lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt; use &lt;<em><em>r</em><em>e</em><em>g</em><sub>1</sub></em>&gt; and &lt;<em><em>r</em><em>e</em><em>g</em><sub>2</sub></em>&gt;:<p>\n\n<p><p><p><div align=left><img src="ch5-Z-G-9.gif" border="0"></div><p><p>\n\nBy using <tt>preserving</tt> to combine instruction sequences the\ncompiler avoids unnecessary stack operations.  This also isolates the\ndetails of whether or not to generate <tt>save</tt> and <tt>restore</tt>\ninstructions within the <tt>preserving</tt> procedure, separating them\nfrom the concerns that arise in writing each of the individual code\ngenerators.\nIn fact no <tt>save</tt> or <tt>restore</tt> instructions are explicitly\nproduced by the code generators.<p>\n\nIn principle, we could represent an instruction sequence simply as a\nlist of instructions.  <tt>Append-instruction-sequences</tt> could then\ncombine instruction sequences by performing an ordinary list <tt>append</tt>.  However, <tt>preserving</tt> would then be a complex operation,\nbecause it would have to analyze each instruction sequence to\ndetermine how the sequence uses its registers.  <tt>Preserving</tt>\nwould be inefficient as well as complex, because it would have to\nanalyze each of its instruction sequence arguments, even though these\nsequences might themselves have been constructed by calls to <tt>preserving</tt>, in which case their parts would have already been\nanalyzed.  To avoid such repetitious analysis we will associate with each\ninstruction sequence some information about its register use.\nWhen we construct a basic instruction sequence we\nwill provide this information explicitly,\nand the procedures that combine instruction sequences will derive\nregister-use information for the combined sequence from the\ninformation associated with the component sequences.<p>\n\nAn instruction sequence will contain three pieces of information:\n<p><ul>\n<li>the set of registers that must be initialized before the\ninstructions in the sequence are executed (these registers are said to\nbe <em>needed</em> by the sequence),<p>\n\n<li>the set of registers whose values are modified by the\ninstructions in the sequence, and<p>\n\n<li>the actual instructions (also called <em>statements</em>) in\nthe sequence.\n</ul><p><p>\n\nWe will represent an instruction sequence as a list of its three\nparts.  The constructor for instruction sequences is thus<p>\n\n<p><p><tt><a name="%_idx_6266"></a>(define&nbsp;(make-instruction-sequence&nbsp;needs&nbsp;modifies&nbsp;statements)<br>\n&nbsp;&nbsp;(list&nbsp;needs&nbsp;modifies&nbsp;statements))<br>\n</tt><p><p><p>\n\nFor example, the two-instruction sequence that looks up the value of\nthe variable <tt>x</tt> in the current environment, assigns the result\nto <tt>val</tt>, and then returns, requires registers <tt>env</tt> and <tt>continue</tt> to have been initialized, and modifies register <tt>val</tt>.\nThis sequence would therefore be constructed as<p>\n\n<p><p><tt>(make-instruction-sequence&nbsp;\'(env&nbsp;continue)&nbsp;\'(val)<br>\n&nbsp;\'((assign&nbsp;val<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;x)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))))<br>\n</tt><p><p><p>\n\nWe sometimes need to construct an instruction sequence with no statements:\n<p><p><tt><a name="%_idx_6268"></a>(define&nbsp;(empty-instruction-sequence)<br>\n&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'()&nbsp;\'()&nbsp;\'()))<br>\n</tt><p><p>\n<p>\n\nThe procedures for combining instruction sequences are shown in\nsection&nbsp;<a href="#%_sec_5.5.4">5.5.4</a>.<p>\n\n<p><a name="%_thm_5.31"></a>\n<b>Exercise 5.31.</b>&nbsp;&nbsp;<a name="%_idx_6270"></a><a name="%_idx_6272"></a>In evaluating a procedure application, the explicit-control evaluator\nalways saves and restores\nthe <tt>env</tt> register around the evaluation of the operator, saves and\nrestores <tt>env</tt> around the evaluation of each operand (except the\nfinal one), saves and restores <tt>argl</tt> around the evaluation of each\noperand, and saves and restores <tt>proc</tt> around the evaluation of the\noperand sequence.  For each of the following combinations, say which\nof these <tt>save</tt> and <tt>restore</tt> operations are superfluous and\nthus could be eliminated by the compiler\'s <tt>preserving</tt> mechanism:<p>\n\n<p><p><tt>(f&nbsp;\'x&nbsp;\'y)<br>\n<br>\n((f)&nbsp;\'x&nbsp;\'y)<br>\n<br>\n(f&nbsp;(g&nbsp;\'x)&nbsp;y)<br>\n<br>\n(f&nbsp;(g&nbsp;\'x)&nbsp;\'y)<br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_5.32"></a>\n<b>Exercise 5.32.</b>&nbsp;&nbsp;<a name="%_idx_6274"></a><a name="%_idx_6276"></a>Using the <tt>preserving</tt> mechanism, the compiler will avoid saving\nand restoring <tt>env</tt> around the evaluation of the operator of a\ncombination in the case where the operator is a symbol.  We could also\nbuild such optimizations into the evaluator.  Indeed, the\nexplicit-control evaluator of section&nbsp;<a href="book-Z-H-34.html#%_sec_5.4">5.4</a> already\nperforms a similar optimization, by treating combinations with no\noperands as a special case.<p>\n\n<p><p>a. Extend the explicit-control evaluator to recognize as a separate class\nof expressions combinations whose operator is a symbol, and to take\nadvantage of this fact in evaluating such expressions.<p>\n\n<p><p>b. Alyssa P. Hacker suggests that by extending the evaluator to recognize\nmore and more special cases we could incorporate all the compiler\'s\noptimizations, and that this would eliminate the advantage of compilation\naltogether.  What do you think of this idea?\n<p><p>\n\n<a name="%_sec_5.5.2"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.2">5.5.2&nbsp;&nbsp;Compiling Expressions</a></h3><p>\n\nIn this section and the next we implement the code generators to which the <tt>compile</tt> procedure dispatches.<p>\n\n<a name="%_sec_Temp_802"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_802">Compiling linkage code</a></h4><p>\n\n<a name="%_idx_6278"></a>In general, the output of each code generator will end with\ninstructions -- generated by the procedure <tt>compile-linkage</tt> -- that\nimplement the required linkage.  If the linkage is <tt>return</tt> then\nwe must generate the instruction <tt>(goto (reg continue))</tt>.  This\nneeds the <tt>continue</tt> register and does not modify any registers.\nIf the linkage is <tt>next</tt>, then we needn\'t include any additional\ninstructions.  Otherwise, the linkage is a label, and we generate a\n<tt>goto</tt> to that label, an instruction that does not need or modify\nany registers.<a name="call_footnote_Temp_803" href="#footnote_Temp_803"><sup><small>36</small></sup></a><p>\n\n\n<p><p><tt><a name="%_idx_6292"></a>(define&nbsp;(compile-linkage&nbsp;linkage)<br>\n&nbsp;&nbsp;(cond&nbsp;((eq?&nbsp;linkage&nbsp;\'return)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(continue)&nbsp;\'()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'((goto&nbsp;(reg&nbsp;continue)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((eq?&nbsp;linkage&nbsp;\'next)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(empty-instruction-sequence))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'()&nbsp;\'()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`((goto&nbsp;(label&nbsp;,linkage)))))))<br>\n</tt><p><p>\nThe linkage code is appended to an instruction sequence by <tt>preserving</tt>\nthe <tt>continue</tt> register, since a <tt>return</tt> linkage will\nrequire the <tt>continue</tt> register:\nIf the given instruction sequence modifies <tt>continue</tt> and the\nlinkage code needs it, <tt>continue</tt> will be saved and restored.<p>\n\n\n<p><p><tt><a name="%_idx_6294"></a>(define&nbsp;(end-with-linkage&nbsp;linkage&nbsp;instruction-sequence)<br>\n&nbsp;&nbsp;(preserving&nbsp;\'(continue)<br>\n&nbsp;&nbsp;&nbsp;instruction-sequence<br>\n&nbsp;&nbsp;&nbsp;(compile-linkage&nbsp;linkage)))<br>\n</tt><p><p><p>\n\n<p>\n\n<a name="%_sec_Temp_804"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_804">Compiling simple expressions</a></h4><p>\n\n<a name="%_idx_6296"></a><a name="%_idx_6298"></a><a name="%_idx_6300"></a>The code generators for self-evaluating expressions,\nquotations, and variables construct instruction\nsequences that assign the required value to the target register\nand then proceed as specified by the linkage descriptor.<p>\n\n\n<p><p><tt><a name="%_idx_6302"></a>(define&nbsp;(compile-self-evaluating&nbsp;exp&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;(end-with-linkage&nbsp;linkage<br>\n&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'()&nbsp;(list&nbsp;target)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;`((assign&nbsp;,target&nbsp;(const&nbsp;,exp))))))<br>\n<a name="%_idx_6304"></a>(define&nbsp;(compile-quoted&nbsp;exp&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;(end-with-linkage&nbsp;linkage<br>\n&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'()&nbsp;(list&nbsp;target)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;`((assign&nbsp;,target&nbsp;(const&nbsp;,(text-of-quotation&nbsp;exp)))))))<br>\n<a name="%_idx_6306"></a>(define&nbsp;(compile-variable&nbsp;exp&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;(end-with-linkage&nbsp;linkage<br>\n&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(env)&nbsp;(list&nbsp;target)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;`((assign&nbsp;,target<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;lookup-variable-value)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(const&nbsp;,exp)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;env))))))<br>\n</tt><p><p>\nAll these assignment instructions modify the target register,\nand the one that looks up a variable needs the <tt>env</tt> register.<p>\n\n<a name="%_idx_6308"></a><a name="%_idx_6310"></a>Assignments and definitions are handled much as they are in the\ninterpreter.  We recursively generate code that computes the value to\nbe assigned to the variable, and append to it a two-instruction\nsequence that actually sets or defines the variable and assigns the\nvalue of the whole expression (the symbol <tt>ok</tt>) to the target\nregister.  The recursive compilation has target <tt>val</tt> and linkage\n<tt>next</tt> so that the code will put its result into <tt>val</tt> and\ncontinue with the code that is appended after it.  The appending is\ndone preserving <tt>env</tt>, since the environment is needed for setting\nor defining the variable and the code for the variable value could be\nthe compilation of a complex expression that might modify the\nregisters in arbitrary ways.<p>\n\n<p><p><tt><a name="%_idx_6312"></a>(define&nbsp;(compile-assignment&nbsp;exp&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;(let&nbsp;((var&nbsp;(assignment-variable&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-value-code<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile&nbsp;(assignment-value&nbsp;exp)&nbsp;\'val&nbsp;\'next)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(end-with-linkage&nbsp;linkage<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(preserving&nbsp;\'(env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get-value-code<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(env&nbsp;val)&nbsp;(list&nbsp;target)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`((perform&nbsp;(op&nbsp;set-variable-value!)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(const&nbsp;,var)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;val)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;,target&nbsp;(const&nbsp;ok))))))))<br>\n<a name="%_idx_6314"></a>(define&nbsp;(compile-definition&nbsp;exp&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;(let&nbsp;((var&nbsp;(definition-variable&nbsp;exp))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get-value-code<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile&nbsp;(definition-value&nbsp;exp)&nbsp;\'val&nbsp;\'next)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(end-with-linkage&nbsp;linkage<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(preserving&nbsp;\'(env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get-value-code<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(env&nbsp;val)&nbsp;(list&nbsp;target)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`((perform&nbsp;(op&nbsp;define-variable!)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(const&nbsp;,var)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;val)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;,target&nbsp;(const&nbsp;ok))))))))<br>\n</tt><p><p>\nThe appended two-instruction sequence requires <tt>env</tt> and <tt>val</tt>\nand modifies the target.  Note that although we preserve <tt>env</tt> for\nthis sequence, we do not preserve <tt>val</tt>, because the <tt>get-value-code</tt> is designed to explicitly place its result in <tt>val</tt> for use by this sequence.\n(In fact, if we did preserve <tt>val</tt>, we would\nhave a bug, because this would cause the previous contents of <tt>val</tt> to be restored right after the <tt>get-value-code</tt> is run.)<p>\n\n<a name="%_sec_Temp_805"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_805">Compiling conditional expressions</a></h4><p>\n\n<a name="%_idx_6316"></a>The code for an <tt>if</tt> expression\ncompiled with a given target and linkage has the form<p>\n\n<p><p><tt>&nbsp;&lt;<em>compilation&nbsp;of&nbsp;predicate,&nbsp;target&nbsp;<tt>val</tt>,&nbsp;linkage&nbsp;<tt>next</tt></em>&gt;<br>\n&nbsp;(test&nbsp;(op&nbsp;false?)&nbsp;(reg&nbsp;val))<br>\n&nbsp;(branch&nbsp;(label&nbsp;false-branch))<br>\ntrue-branch<br>\n&nbsp;&lt;<em>compilation&nbsp;of&nbsp;consequent&nbsp;with&nbsp;given&nbsp;target&nbsp;and&nbsp;given&nbsp;linkage&nbsp;or&nbsp;<tt>after-if</tt></em>&gt;<br>\nfalse-branch<br>\n&nbsp;&lt;<em>compilation&nbsp;of&nbsp;alternative&nbsp;with&nbsp;given&nbsp;target&nbsp;and&nbsp;linkage</em>&gt;<br>\nafter-if<br>\n</tt><p><p><p>\n\nTo generate this code, we compile the predicate, consequent,\nand alternative, and combine the resulting code with instructions\nto test the predicate result and with newly generated labels\nto mark the true and false branches and the end of the conditional.<a name="call_footnote_Temp_806" href="#footnote_Temp_806"><sup><small>37</small></sup></a>\nIn this arrangement of code, we must branch around the true branch\nif the test is false.  The only slight complication is in how the\nlinkage for the true branch should be handled.  If the linkage for the\nconditional is <tt>return</tt> or a label, then the true and false\nbranches will both use this same linkage.  If the linkage is <tt>next</tt>, the true branch ends with a jump around the code for the false\nbranch to the label at the end of the conditional.<p>\n\n\n\n<p><p><tt><a name="%_idx_6324"></a>(define&nbsp;(compile-if&nbsp;exp&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;(let&nbsp;((t-branch&nbsp;(make-label&nbsp;\'true-branch))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f-branch&nbsp;(make-label&nbsp;\'false-branch))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(after-if&nbsp;(make-label&nbsp;\'after-if)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((consequent-linkage<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;linkage&nbsp;\'next)&nbsp;after-if&nbsp;linkage)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((p-code&nbsp;(compile&nbsp;(if-predicate&nbsp;exp)&nbsp;\'val&nbsp;\'next))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c-code<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if-consequent&nbsp;exp)&nbsp;target&nbsp;consequent-linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a-code<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile&nbsp;(if-alternative&nbsp;exp)&nbsp;target&nbsp;linkage)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(preserving&nbsp;\'(env&nbsp;continue)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-code<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append-instruction-sequences<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(val)&nbsp;\'()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`((test&nbsp;(op&nbsp;false?)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(branch&nbsp;(label&nbsp;,f-branch))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parallel-instruction-sequences<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append-instruction-sequences&nbsp;t-branch&nbsp;c-code)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append-instruction-sequences&nbsp;f-branch&nbsp;a-code))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;after-if))))))<br>\n</tt><p><p>\n<tt>Env</tt> is preserved around the predicate code because it could be needed by\nthe true and false branches, and <tt>continue</tt> is preserved because it could\nbe needed by the linkage code in those branches.  The code for the true and\nfalse branches (which are not executed sequentially) is appended using a\nspecial combiner <tt>parallel-instruction-sequences</tt> described in\nsection&nbsp;<a href="#%_sec_5.5.4">5.5.4</a>.<p>\n\n\nNote that <tt>cond</tt> is a derived expression, so all that the\ncompiler needs to do handle it is to apply the <tt>cond-&gt;if</tt>\ntransformer (from section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.2">4.1.2</a>) and\ncompile the resulting <tt>if</tt> expression.<p>\n\n<a name="%_sec_Temp_807"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_807">Compiling sequences</a></h4><p>\n\n<a name="%_idx_6326"></a>The compilation of sequences (from procedure bodies or explicit <tt>begin</tt> expressions) parallels their evaluation.  Each expression of the\nsequence is compiled -- the last expression with the linkage specified\nfor the sequence, and the other expressions with linkage <tt>next</tt>\n(to execute the rest of the sequence).\nThe instruction sequences for the individual expressions are appended\nto form a single instruction sequence, such that <tt>env</tt> (needed for\nthe rest of the sequence) and <tt>continue</tt> (possibly needed for the\nlinkage at the end of the sequence) are preserved.<p>\n\n<p><p><tt><a name="%_idx_6328"></a>(define&nbsp;(compile-sequence&nbsp;seq&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;(if&nbsp;(last-exp?&nbsp;seq)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile&nbsp;(first-exp&nbsp;seq)&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(preserving&nbsp;\'(env&nbsp;continue)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile&nbsp;(first-exp&nbsp;seq)&nbsp;target&nbsp;\'next)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile-sequence&nbsp;(rest-exps&nbsp;seq)&nbsp;target&nbsp;linkage))))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_808"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_808">Compiling <tt>lambda</tt> expressions</a></h4><p>\n\n<a name="%_idx_6330"></a><tt>Lambda</tt> expressions construct procedures.\nThe object code for a <tt>lambda</tt> expression must have the form<p>\n\n<p><p><tt>&lt;<em>construct&nbsp;procedure&nbsp;object&nbsp;and&nbsp;assign&nbsp;it&nbsp;to&nbsp;target&nbsp;register</em>&gt;<br>\n&lt;<em>linkage</em>&gt;<br>\n</tt><p><p>\nWhen we compile the <tt>lambda</tt> expression, we also generate the code for the\nprocedure body.  Although the body won\'t be executed at the time of procedure\nconstruction, it is convenient to insert it into the object code right after\nthe code for the <tt>lambda</tt>.  If the linkage for the <tt>lambda</tt> expression\nis a label or <tt>return</tt>, this is fine.  But if the linkage is <tt>next</tt>,\nwe will need to skip around the code for the procedure body by using a linkage\nthat jumps to a label that is inserted after the body.  The object code thus\nhas the form<p>\n\n<p><p><tt>&nbsp;&lt;<em>construct&nbsp;procedure&nbsp;object&nbsp;and&nbsp;assign&nbsp;it&nbsp;to&nbsp;target&nbsp;register</em>&gt;<br>\n&nbsp;&lt;<em>code&nbsp;for&nbsp;given&nbsp;linkage</em>&gt;<em>or</em>&nbsp;<tt>(goto&nbsp;(label&nbsp;after-lambda))</tt><br>\n&nbsp;&lt;<em>compilation&nbsp;of&nbsp;procedure&nbsp;body</em>&gt;<br>\nafter-lambda<br>\n</tt><p><p><p>\n\n<tt>Compile-lambda</tt> generates the code for constructing the procedure\nobject followed by the code for the procedure body.\nThe procedure object will be constructed at run time by combining\nthe current environment (the environment at the point of definition)\nwith the entry point to the compiled procedure body (a newly generated\nlabel).<a name="call_footnote_Temp_809" href="#footnote_Temp_809"><sup><small>38</small></sup></a><p>\n\n<p><p><tt><a name="%_idx_6340"></a>(define&nbsp;(compile-lambda&nbsp;exp&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;(let&nbsp;((proc-entry&nbsp;(make-label&nbsp;\'entry))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(after-lambda&nbsp;(make-label&nbsp;\'after-lambda)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((lambda-linkage<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;linkage&nbsp;\'next)&nbsp;after-lambda&nbsp;linkage)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append-instruction-sequences<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tack-on-instruction-sequence<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(end-with-linkage&nbsp;lambda-linkage<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(env)&nbsp;(list&nbsp;target)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`((assign&nbsp;,target<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;make-compiled-procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(label&nbsp;,proc-entry)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;env)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile-lambda-body&nbsp;exp&nbsp;proc-entry))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;after-lambda))))<br>\n</tt><p><p>\n<tt>Compile-lambda</tt> uses the special combiner <tt>tack-on-instruction-sequence</tt>\n(section&nbsp;<a href="#%_sec_5.5.4">5.5.4</a>) rather than <tt>append-instruction-sequences</tt> to append the procedure body to the <tt>lambda</tt>\nexpression code, because the body is not part of the sequence of instructions\nthat will be executed when the combined sequence is entered; rather, it is in\nthe sequence only because that was a convenient place to put it.<p>\n\n\n<tt>Compile-lambda-body</tt> constructs the code for the body of the\nprocedure.  This code begins with a label for the entry point.  Next\ncome instructions that will cause the run-time evaluation environment\nto switch to the correct environment for evaluating the procedure\nbody -- namely, the definition environment of the procedure, extended\nto include the bindings of the formal parameters to the arguments with\nwhich the procedure is called.  After this comes the code for the\nsequence of expressions that makes up the procedure body.\nThe sequence is compiled with linkage <tt>return</tt> and target <tt>val</tt>\nso that it will end by returning from the procedure with the\nprocedure result in <tt>val</tt>.<p>\n\n<p><p><tt>(define&nbsp;(compile-lambda-body&nbsp;exp&nbsp;proc-entry)<br>\n&nbsp;&nbsp;(let&nbsp;((formals&nbsp;(lambda-parameters&nbsp;exp)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(append-instruction-sequences<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(env&nbsp;proc&nbsp;argl)&nbsp;\'(env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`(,proc-entry<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;env&nbsp;(op&nbsp;compiled-procedure-env)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;extend-environment)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(const&nbsp;,formals)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;argl)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;env))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile-sequence&nbsp;(lambda-body&nbsp;exp)&nbsp;\'val&nbsp;\'return))))<br>\n</tt><p><p><p>\n\n<a name="%_sec_5.5.3"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.3">5.5.3&nbsp;&nbsp;Compiling Combinations</a></h3><p>\n\n\n<a name="%_idx_6342"></a><a name="%_idx_6344"></a>\nThe essence of the compilation process is the compilation of procedure\napplications.\nThe code for a combination compiled with a given target and linkage\nhas the form\n<p><p><tt>&lt;<em>compilation&nbsp;of&nbsp;operator,&nbsp;target&nbsp;<tt>proc</tt>,&nbsp;linkage&nbsp;<tt>next</tt></em>&gt;<br>\n&lt;<em>evaluate&nbsp;operands&nbsp;and&nbsp;construct&nbsp;argument&nbsp;list&nbsp;in&nbsp;<tt>argl</tt></em>&gt;<br>\n&lt;<em>compilation&nbsp;of&nbsp;procedure&nbsp;call&nbsp;with&nbsp;given&nbsp;target&nbsp;and&nbsp;linkage</em>&gt;<br>\n</tt><p><p>\nThe registers <tt>env</tt>, <tt>proc</tt>, and <tt>argl</tt> may have to be\nsaved and restored during evaluation of the operator and operands.\nNote that this is the only place in the compiler where a target other\nthan <tt>val</tt> is specified.<p>\n\nThe required code is generated by <tt>compile-application</tt>.  This\nrecursively compiles the operator, to produce code that puts the\nprocedure to be applied into <tt>proc</tt>, and compiles the operands, to\nproduce code that evaluates the individual operands of the\napplication.  The instruction sequences for the operands are combined\n(by <tt>construct-arglist</tt>) with code that constructs the list of\narguments in <tt>argl</tt>, and the resulting argument-list code is\ncombined with the procedure code and the code that performs the\nprocedure call (produced by <tt>compile-procedure-call</tt>).  In\nappending the code sequences, the <tt>env</tt> register must be preserved\naround the evaluation of the operator (since evaluating the operator\nmight modify <tt>env</tt>, which will be needed to evaluate the\noperands), and the <tt>proc</tt> register must be preserved around the\nconstruction of the argument list (since evaluating the operands might\nmodify <tt>proc</tt>, which will be needed for the actual procedure\napplication).  <tt>Continue</tt> must also be preserved throughout, since\nit is needed for the linkage in the procedure call.<p>\n\n<p><p><tt><a name="%_idx_6346"></a>(define&nbsp;(compile-application&nbsp;exp&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;(let&nbsp;((proc-code&nbsp;(compile&nbsp;(operator&nbsp;exp)&nbsp;\'proc&nbsp;\'next))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(operand-codes<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(operand)&nbsp;(compile&nbsp;operand&nbsp;\'val&nbsp;\'next))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(operands&nbsp;exp))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(preserving&nbsp;\'(env&nbsp;continue)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proc-code<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(preserving&nbsp;\'(proc&nbsp;continue)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(construct-arglist&nbsp;operand-codes)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile-procedure-call&nbsp;target&nbsp;linkage)))))<br>\n</tt><p><p><p>\n\nThe code to construct the argument list will evaluate each operand into\n<tt>val</tt> and then <tt>cons</tt> that value onto the argument list being\naccumulated in <tt>argl</tt>.\nSince we <tt>cons</tt> the arguments onto <tt>argl</tt> in sequence, we must\nstart with the last argument and end with the first, so that the\narguments will appear in order from first to last in the resulting list.\nRather than waste an instruction by initializing <tt>argl</tt> to the empty list\nto set up for this sequence of evaluations,\nwe make the first code sequence construct the initial <tt>argl</tt>.\nThe general form of the argument-list construction is thus as follows:<p>\n\n<p><p><tt>&lt;<em>compilation&nbsp;of&nbsp;last&nbsp;operand,&nbsp;targeted&nbsp;to&nbsp;<tt>val</tt></em>&gt;<br>\n(assign&nbsp;argl&nbsp;(op&nbsp;list)&nbsp;(reg&nbsp;val))<br>\n&lt;<em>compilation&nbsp;of&nbsp;next&nbsp;operand,&nbsp;targeted&nbsp;to&nbsp;<tt>val</tt></em>&gt;<br>\n(assign&nbsp;argl&nbsp;(op&nbsp;cons)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;argl))<br>\n<tt>...</tt>&lt;<em>compilation&nbsp;of&nbsp;first&nbsp;operand,&nbsp;targeted&nbsp;to&nbsp;<tt>val</tt></em>&gt;<br>\n(assign&nbsp;argl&nbsp;(op&nbsp;cons)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;argl))<br>\n</tt><p><p>\n<tt>Argl</tt> must be preserved around each operand evaluation except\nthe first (so that arguments accumulated so far won\'t be lost), and\n<tt>env</tt> must be preserved around each operand evaluation\nexcept the last (for use by subsequent operand evaluations).<p>\n\nCompiling this argument code is a bit tricky, because of\nthe special treatment of the first operand to be evaluated and the\nneed to preserve <tt>argl</tt> and <tt>env</tt> in different places.\nThe <tt>construct-arglist</tt> procedure takes as arguments the code that\nevaluates the individual operands.  If there are no operands at all, it simply\nemits the instruction<p>\n\n<p><p><tt>(assign&nbsp;argl&nbsp;(const&nbsp;()))<br>\n</tt><p><p>\nOtherwise, <tt>construct-arglist</tt> creates code that initializes <tt>argl</tt> with the last argument, and appends code that evaluates\nthe rest of the arguments and adjoins them to <tt>argl</tt> in\nsuccession.  In order to process the arguments from last to\nfirst, we must reverse the list of operand code sequences from the order\nsupplied by <tt>compile-application</tt>.<p>\n\n<p><p><tt><a name="%_idx_6348"></a>(define&nbsp;(construct-arglist&nbsp;operand-codes)<br>\n&nbsp;&nbsp;(let&nbsp;((operand-codes&nbsp;(reverse&nbsp;operand-codes)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;operand-codes)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'()&nbsp;\'(argl)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'((assign&nbsp;argl&nbsp;(const&nbsp;()))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((code-to-get-last-arg<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append-instruction-sequences<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;operand-codes)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(val)&nbsp;\'(argl)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'((assign&nbsp;argl&nbsp;(op&nbsp;list)&nbsp;(reg&nbsp;val)))))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;(cdr&nbsp;operand-codes))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code-to-get-last-arg<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(preserving&nbsp;\'(env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code-to-get-last-arg<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(code-to-get-rest-args<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;operand-codes))))))))<br>\n(define&nbsp;(code-to-get-rest-args&nbsp;operand-codes)<br>\n&nbsp;&nbsp;(let&nbsp;((code-for-next-arg<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(preserving&nbsp;\'(argl)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;operand-codes)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(val&nbsp;argl)&nbsp;\'(argl)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'((assign&nbsp;argl<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;cons)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;argl)))))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;(cdr&nbsp;operand-codes))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code-for-next-arg<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(preserving&nbsp;\'(env)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code-for-next-arg<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(code-to-get-rest-args&nbsp;(cdr&nbsp;operand-codes))))))<br>\n</tt><p><p><p>\n\n<a name="%_sec_Temp_810"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_810">Applying procedures</a></h4><p>\n\nAfter evaluating the elements of a combination, the compiled code must\napply the procedure in <tt>proc</tt> to the arguments in <tt>argl</tt>.  The\ncode performs essentially the same dispatch as the <tt>apply</tt> procedure in the\nmetacircular evaluator of section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a> or the\n<tt>apply-dispatch</tt> entry point in the explicit-control evaluator of\nsection&nbsp;<a href="book-Z-H-34.html#%_sec_5.4.1">5.4.1</a>.  It checks whether the\nprocedure to be applied is a primitive procedure or a compiled\nprocedure.  For a primitive procedure, it uses <tt>apply-primitive-procedure</tt>; we will see shortly how it handles\ncompiled procedures.  The procedure-application code has the following\nform:<p>\n\n<p><p><tt>&nbsp;(test&nbsp;(op&nbsp;primitive-procedure?)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;(branch&nbsp;(label&nbsp;primitive-branch))<br>\ncompiled-branch<br>\n&nbsp;&lt;<em>code&nbsp;to&nbsp;apply&nbsp;compiled&nbsp;procedure&nbsp;with&nbsp;given&nbsp;target&nbsp;and&nbsp;appropriate&nbsp;linkage</em>&gt;<br>\nprimitive-branch<br>\n&nbsp;(assign&nbsp;&lt;<em>target</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;apply-primitive-procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;argl))<br>\n&nbsp;&lt;<em>linkage</em>&gt;<br>\nafter-call<br>\n</tt><p><p>\nObserve that the compiled branch must skip around the primitive\nbranch.  Therefore, if the linkage for the original procedure call was\n<tt>next</tt>, the compound branch must use a linkage that jumps to a\nlabel that is inserted after the primitive branch.  (This is similar\nto the linkage used for the true branch in <tt>compile-if</tt>.)<p>\n\n<p><p><tt><a name="%_idx_6350"></a>(define&nbsp;(compile-procedure-call&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;(let&nbsp;((primitive-branch&nbsp;(make-label&nbsp;\'primitive-branch))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compiled-branch&nbsp;(make-label&nbsp;\'compiled-branch))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(after-call&nbsp;(make-label&nbsp;\'after-call)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((compiled-linkage<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;linkage&nbsp;\'next)&nbsp;after-call&nbsp;linkage)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append-instruction-sequences<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(proc)&nbsp;\'()<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`((test&nbsp;(op&nbsp;primitive-procedure?)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(branch&nbsp;(label&nbsp;,primitive-branch))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(parallel-instruction-sequences<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append-instruction-sequences<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compiled-branch<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile-proc-appl&nbsp;target&nbsp;compiled-linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append-instruction-sequences<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primitive-branch<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(end-with-linkage&nbsp;linkage<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(proc&nbsp;argl)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;target)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`((assign&nbsp;,target<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;apply-primitive-procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;argl)))))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;after-call))))<br>\n</tt><p><p>\nThe primitive and compound branches, like the true\nand false branches in <tt>compile-if</tt>, are appended using\n<tt>parallel-instruction-sequences</tt> rather than the ordinary <tt>append-instruction-sequences</tt>, because they will\nnot be executed sequentially.<p>\n\n<a name="%_sec_Temp_811"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_811">Applying compiled procedures</a></h4><p>\n\nThe code that handles procedure application is the most subtle part of\nthe compiler, even though the instruction sequences it generates are\nvery short.  A compiled procedure (as constructed by <tt>compile-lambda</tt>) has an entry point, which is a label that designates\nwhere the code for the procedure starts.  The code at this entry point\ncomputes a result in <tt>val</tt> and returns by executing the\ninstruction <tt>(goto (reg continue))</tt>.  Thus, we might expect the\ncode for a compiled-procedure application (to be generated by <tt>compile-proc-appl</tt>) with a given target and linkage to look like this\nif the linkage is a label\n\n\n<p><p><tt>&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;proc-return))<br>\n&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\nproc-return<br>\n&nbsp;(assign&nbsp;&lt;<em>target</em>&gt;&nbsp;(reg&nbsp;val))&nbsp;&nbsp;&nbsp;<em>;&nbsp;included&nbsp;if&nbsp;target&nbsp;is&nbsp;not&nbsp;<tt>val</tt></em><br>\n&nbsp;(goto&nbsp;(label&nbsp;&lt;<em>linkage</em>&gt;))&nbsp;&nbsp;&nbsp;<em>;&nbsp;linkage&nbsp;code</em><br>\n</tt><p><p>\nor like this if the linkage is <tt>return</tt>.\n\n<p><p><tt>&nbsp;(save&nbsp;continue)<br>\n&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;proc-return))<br>\n&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\nproc-return<br>\n&nbsp;(assign&nbsp;&lt;<em>target</em>&gt;&nbsp;(reg&nbsp;val))&nbsp;&nbsp;&nbsp;<em>;&nbsp;included&nbsp;if&nbsp;target&nbsp;is&nbsp;not&nbsp;<tt>val</tt></em><br>\n&nbsp;(restore&nbsp;continue)<br>\n&nbsp;(goto&nbsp;(reg&nbsp;continue))&nbsp;&nbsp;&nbsp;<em>;&nbsp;linkage&nbsp;code</em><br>\n</tt><p><p>\nThis code sets up <tt>continue</tt> so that the procedure will return to a\nlabel <tt>proc-return</tt> and jumps to the procedure\'s entry point.  The code\nat <tt>proc-return</tt> transfers the procedure\'s result from <tt>val</tt>\nto the target register (if necessary) and then jumps to\nthe location specified by the linkage.\n(The linkage is always <tt>return</tt> or a label, because <tt>compile-procedure-call</tt> replaces a <tt>next</tt> linkage for the\ncompound-procedure branch by an <tt>after-call</tt> label.)<p>\n\n\nIn fact, if the target is not <tt>val</tt>, that is exactly the code our\ncompiler will generate.<a name="call_footnote_Temp_812" href="#footnote_Temp_812"><sup><small>39</small></sup></a>\nUsually, however, the target is <tt>val</tt> (the only time the compiler\nspecifies a different register is when targeting the evaluation of an\noperator to <tt>proc</tt>), so the procedure result is put directly into\nthe target register and there is no need to return to a special\nlocation that copies it.  Instead, we simplify the code by\nsetting up <tt>continue</tt> so that the procedure will ``return\'\'\ndirectly to the place specified by the caller\'s linkage:\n\n<p><p><tt>&lt;<em>set&nbsp;up&nbsp;<tt>continue</tt>&nbsp;for&nbsp;linkage</em>&gt;<br>\n(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n(goto&nbsp;(reg&nbsp;val))<br>\n</tt><p><p>\nIf the linkage is a label, we set up <tt>continue</tt> so that the procedure will return to\nthat label.  (That is, the <tt>(goto (reg continue))</tt> the procedure\nends with becomes equivalent to the <tt>(goto (label &lt;<em>linkage</em>&gt;))</tt> at\n<tt>proc-return</tt> above.)\n\n<p><p><tt>(assign&nbsp;continue&nbsp;(label&nbsp;&lt;<em>linkage</em>&gt;))<br>\n(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n(goto&nbsp;(reg&nbsp;val))<br>\n</tt><p><p>\nIf the linkage is <tt>return</tt>, we don\'t need to set up <tt>continue</tt>\nat all: It already holds the desired location.  (That is, the <tt>(goto (reg continue))</tt> the procedure ends with goes directly to the\nplace where the <tt>(goto (reg continue))</tt> at <tt>proc-return</tt> would\nhave gone.)\n\n<p><p><tt>(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n(goto&nbsp;(reg&nbsp;val))<br>\n</tt><p><p>\n<a name="%_idx_6352"></a><a name="%_idx_6354"></a>With this implementation of the <tt>return</tt> linkage, the compiler\ngenerates tail-recursive code.  Calling a procedure as the final step\nin a procedure body does a direct transfer, without saving any\ninformation on the stack.<p>\n\n\nSuppose instead that we had handled the case of a procedure call with\na linkage of <tt>return</tt> and a target of <tt>val</tt> as shown above for\na non-<tt>val</tt> target.  This would destroy tail recursion.  Our\nsystem would still give the same value for any expression.  But each\ntime we called a procedure, we would save <tt>continue</tt> and return\nafter the call to undo the (useless) save.  These extra saves would\naccumulate during a nest of procedure calls.<a name="call_footnote_Temp_813" href="#footnote_Temp_813"><sup><small>40</small></sup></a><p>\n\n<tt>Compile-proc-appl</tt> generates the above procedure-application code by\nconsidering four cases, depending on whether the target for the call\nis <tt>val</tt> and whether the linkage is <tt>return</tt>.\nObserve that the instruction sequences are\ndeclared to modify all the registers, since executing the procedure\nbody can change the registers in arbitrary ways.<a name="call_footnote_Temp_814" href="#footnote_Temp_814"><sup><small>41</small></sup></a>\nAlso note that the code sequence for the case with target <tt>val</tt>\nand linkage <tt>return</tt> is declared to need <tt>continue</tt>:  Even\nthough <tt>continue</tt> is not explicitly used in the two-instruction\nsequence, we must be sure that <tt>continue</tt> will have the correct\nvalue when we enter the compiled procedure.<p>\n\n\n<p><p><tt><a name="%_idx_6376"></a>(define&nbsp;(compile-proc-appl&nbsp;target&nbsp;linkage)<br>\n&nbsp;&nbsp;(cond&nbsp;((and&nbsp;(eq?&nbsp;target&nbsp;\'val)&nbsp;(not&nbsp;(eq?&nbsp;linkage&nbsp;\'return)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(proc)&nbsp;all-regs<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`((assign&nbsp;continue&nbsp;(label&nbsp;,linkage))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(not&nbsp;(eq?&nbsp;target&nbsp;\'val))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(not&nbsp;(eq?&nbsp;linkage&nbsp;\'return)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((proc-return&nbsp;(make-label&nbsp;\'proc-return)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(proc)&nbsp;all-regs<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`((assign&nbsp;continue&nbsp;(label&nbsp;,proc-return))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,proc-return<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assign&nbsp;,target&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(goto&nbsp;(label&nbsp;,linkage))))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(eq?&nbsp;target&nbsp;\'val)&nbsp;(eq?&nbsp;linkage&nbsp;\'return))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence&nbsp;\'(proc&nbsp;continue)&nbsp;all-regs<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'((assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val)))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;(not&nbsp;(eq?&nbsp;target&nbsp;\'val))&nbsp;(eq?&nbsp;linkage&nbsp;\'return))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(error&nbsp;&quot;return&nbsp;linkage,&nbsp;target&nbsp;not&nbsp;val&nbsp;--&nbsp;COMPILE&quot;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target))))<br>\n</tt><p><p>\n<p>\n\n<a name="%_sec_5.5.4"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.4">5.5.4&nbsp;&nbsp;Combining Instruction Sequences</a></h3><p>\n\n\n<a name="%_idx_6378"></a>\nThis section describes the details on how instruction sequences are\nrepresented and combined.  Recall from\nsection&nbsp;<a href="#%_sec_5.5.1">5.5.1</a> that an instruction sequence\nis represented as a list of the registers needed, the registers\nmodified, and the actual instructions.  We will also consider a label\n(symbol) to be a degenerate case of an instruction sequence, which doesn\'t\nneed or modify any registers.\nSo to determine the registers needed\nand modified by instruction sequences we use the selectors\n<p><p><tt><a name="%_idx_6380"></a>(define&nbsp;(registers-needed&nbsp;s)<br>\n&nbsp;&nbsp;(if&nbsp;(symbol?&nbsp;s)&nbsp;\'()&nbsp;(car&nbsp;s)))<br>\n<a name="%_idx_6382"></a>(define&nbsp;(registers-modified&nbsp;s)<br>\n&nbsp;&nbsp;(if&nbsp;(symbol?&nbsp;s)&nbsp;\'()&nbsp;(cadr&nbsp;s)))<br>\n<a name="%_idx_6384"></a>(define&nbsp;(statements&nbsp;s)<br>\n&nbsp;&nbsp;(if&nbsp;(symbol?&nbsp;s)&nbsp;(list&nbsp;s)&nbsp;(caddr&nbsp;s)))<br>\n</tt><p><p>\nand to determine whether a given\nsequence needs or modifies a given register we use the predicates\n<p><p><tt><a name="%_idx_6386"></a>(define&nbsp;(needs-register?&nbsp;seq&nbsp;reg)<br>\n&nbsp;&nbsp;(memq&nbsp;reg&nbsp;(registers-needed&nbsp;seq)))<br>\n<a name="%_idx_6388"></a>(define&nbsp;(modifies-register?&nbsp;seq&nbsp;reg)<br>\n&nbsp;&nbsp;(memq&nbsp;reg&nbsp;(registers-modified&nbsp;seq)))<br>\n</tt><p><p>\nIn terms of these predicates and selectors, we can implement the\nvarious instruction sequence combiners used throughout the compiler.<p>\n\nThe basic combiner is <tt>append-instruction-sequences</tt>.  This takes as\narguments an arbitrary number of instruction sequences that are to be executed\nsequentially and returns an instruction sequence whose statements are the\nstatements of all the sequences appended together.  The subtle point is to\ndetermine the registers that are needed and modified by the resulting\nsequence.  It modifies those registers that are modified by any of the\nsequences; it needs those registers that must be initialized before the first\nsequence can be run (the registers needed by the first sequence), together\nwith those registers needed by any of the other sequences that are not\ninitialized (modified) by sequences preceding it.<p>\n\nThe sequences are appended two at a time by <tt>append-2-sequences</tt>.  This\ntakes two instruction sequences <tt>seq1</tt> and <tt>seq2</tt> and returns the\ninstruction sequence whose statements are the statements of <tt>seq1</tt>\nfollowed by the statements of <tt>seq2</tt>, whose modified registers are those\nregisters that are modified by either <tt>seq1</tt> or <tt>seq2</tt>, and whose\nneeded registers are the registers needed by <tt>seq1</tt> together with those\nregisters needed by <tt>seq2</tt> that are not modified by <tt>seq1</tt>.  (In terms\nof set operations, the new set of needed registers is the union of the set of\nregisters needed by <tt>seq1</tt> with the set difference of the registers needed\nby <tt>seq2</tt> and the registers modified by <tt>seq1</tt>.)  Thus, <tt>append-instruction-sequences</tt> is implemented as follows:<p>\n\n<p><p><tt><a name="%_idx_6390"></a>(define&nbsp;(append-instruction-sequences&nbsp;.&nbsp;seqs)<br>\n&nbsp;&nbsp;(define&nbsp;(append-2-sequences&nbsp;seq1&nbsp;seq2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-union&nbsp;(registers-needed&nbsp;seq1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-difference&nbsp;(registers-needed&nbsp;seq2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(registers-modified&nbsp;seq1)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-union&nbsp;(registers-modified&nbsp;seq1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(registers-modified&nbsp;seq2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append&nbsp;(statements&nbsp;seq1)&nbsp;(statements&nbsp;seq2))))<br>\n&nbsp;&nbsp;(define&nbsp;(append-seq-list&nbsp;seqs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;seqs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(empty-instruction-sequence)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append-2-sequences&nbsp;(car&nbsp;seqs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append-seq-list&nbsp;(cdr&nbsp;seqs)))))<br>\n&nbsp;&nbsp;(append-seq-list&nbsp;seqs))<br>\n</tt><p><p><p>\n\nThis procedure uses some simple operations for manipulating sets\nrepresented as lists, similar to the (unordered) set representation\ndescribed in section&nbsp;<a href="book-Z-H-16.html#%_sec_2.3.3">2.3.3</a>:\n<p><p><tt><a name="%_idx_6392"></a>(define&nbsp;(list-union&nbsp;s1&nbsp;s2)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;s1)&nbsp;s2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((memq&nbsp;(car&nbsp;s1)&nbsp;s2)&nbsp;(list-union&nbsp;(cdr&nbsp;s1)&nbsp;s2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(cons&nbsp;(car&nbsp;s1)&nbsp;(list-union&nbsp;(cdr&nbsp;s1)&nbsp;s2)))))<br>\n<a name="%_idx_6394"></a>(define&nbsp;(list-difference&nbsp;s1&nbsp;s2)<br>\n&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;s1)&nbsp;\'())<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((memq&nbsp;(car&nbsp;s1)&nbsp;s2)&nbsp;(list-difference&nbsp;(cdr&nbsp;s1)&nbsp;s2))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(cons&nbsp;(car&nbsp;s1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-difference&nbsp;(cdr&nbsp;s1)&nbsp;s2)))))<br>\n</tt><p><p><p>\n\n\n<tt>Preserving</tt>, the second major instruction sequence combiner, takes a list\nof registers <tt>regs</tt> and two instruction sequences <tt>seq1</tt> and <tt>seq2</tt> that are to be executed sequentially.  It returns an instruction\nsequence whose statements are the statements of <tt>seq1</tt> followed by the\nstatements of <tt>seq2</tt>, with appropriate <tt>save</tt> and <tt>restore</tt>\ninstructions around <tt>seq1</tt> to protect the registers in <tt>regs</tt> that are\nmodified by <tt>seq1</tt> but needed by <tt>seq2</tt>.  To accomplish this, <tt>preserving</tt> first creates a sequence that has the required <tt>save</tt>s\nfollowed by the statements of <tt>seq1</tt> followed by the required <tt>restore</tt>s.  This sequence needs the registers being saved and restored in\naddition to the registers needed by <tt>seq1</tt>, and modifies the registers\nmodified by <tt>seq1</tt> except for the ones being saved and restored.  This\naugmented sequence and <tt>seq2</tt> are then appended in the usual way.  The\nfollowing procedure implements this strategy recursively, walking down the\nlist of registers to be preserved:<a name="call_footnote_Temp_815" href="#footnote_Temp_815"><sup><small>42</small></sup></a>\n<p><p><tt><a name="%_idx_6398"></a>(define&nbsp;(preserving&nbsp;regs&nbsp;seq1&nbsp;seq2)<br>\n&nbsp;&nbsp;(if&nbsp;(null?&nbsp;regs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append-instruction-sequences&nbsp;seq1&nbsp;seq2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((first-reg&nbsp;(car&nbsp;regs)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(and&nbsp;(needs-register?&nbsp;seq2&nbsp;first-reg)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(modifies-register?&nbsp;seq1&nbsp;first-reg))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(preserving&nbsp;(cdr&nbsp;regs)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-instruction-sequence<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-union&nbsp;(list&nbsp;first-reg)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(registers-needed&nbsp;seq1))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-difference&nbsp;(registers-modified&nbsp;seq1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;first-reg))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(append&nbsp;`((save&nbsp;,first-reg))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(statements&nbsp;seq1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`((restore&nbsp;,first-reg))))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(preserving&nbsp;(cdr&nbsp;regs)&nbsp;seq1&nbsp;seq2)))))<br>\n</tt><p><p><p>\n\nAnother sequence combiner, <tt>tack-on-instruction-sequence</tt>,\nis used by <tt>compile-lambda</tt> to append a procedure body to another\nsequence.  Because the procedure body is not ``in line\'\' to be\nexecuted as part of the combined sequence, its register use has no\nimpact on the register use of the sequence in which it is embedded.\nWe thus ignore the procedure body\'s sets of needed and modified\nregisters when we tack it onto the other sequence.<p>\n\n<p><p><tt><a name="%_idx_6400"></a>(define&nbsp;(tack-on-instruction-sequence&nbsp;seq&nbsp;body-seq)<br>\n&nbsp;&nbsp;(make-instruction-sequence<br>\n&nbsp;&nbsp;&nbsp;(registers-needed&nbsp;seq)<br>\n&nbsp;&nbsp;&nbsp;(registers-modified&nbsp;seq)<br>\n&nbsp;&nbsp;&nbsp;(append&nbsp;(statements&nbsp;seq)&nbsp;(statements&nbsp;body-seq))))<br>\n</tt><p><p><p>\n\n<tt>Compile-if</tt> and <tt>compile-procedure-call</tt> use a special\ncombiner called <tt>parallel-instruction-sequences</tt> to append the two\nalternative branches that follow a test.  The two branches will never be\nexecuted sequentially; for any particular evaluation of the test, one\nbranch or the other will be entered.  Because of this, the registers\nneeded by the second branch are still needed by the combined sequence,\neven if these are modified by the first branch.<p>\n\n<p><p><tt><a name="%_idx_6402"></a>(define&nbsp;(parallel-instruction-sequences&nbsp;seq1&nbsp;seq2)<br>\n&nbsp;&nbsp;(make-instruction-sequence<br>\n&nbsp;&nbsp;&nbsp;(list-union&nbsp;(registers-needed&nbsp;seq1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(registers-needed&nbsp;seq2))<br>\n&nbsp;&nbsp;&nbsp;(list-union&nbsp;(registers-modified&nbsp;seq1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(registers-modified&nbsp;seq2))<br>\n&nbsp;&nbsp;&nbsp;(append&nbsp;(statements&nbsp;seq1)&nbsp;(statements&nbsp;seq2))))<br>\n</tt><p><p><p>\n\n<a name="%_sec_5.5.5"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.5">5.5.5&nbsp;&nbsp;An Example of Compiled Code</a></h3><p>\n\n<a name="%_idx_6404"></a><a name="%_idx_6406"></a>\nNow that we have seen all the elements of the compiler, let us examine\nan example of compiled code to see how things fit together.  We will\ncompile the definition of a recursive <tt>factorial</tt> procedure by\ncalling <tt>compile</tt>:<p>\n\n<p><p><tt>(compile<br>\n&nbsp;\'(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1))&nbsp;n)))<br>\n&nbsp;\'val<br>\n&nbsp;\'next)<br>\n</tt><p><p>\nWe have specified that the value of the <tt>define</tt> expression should\nbe placed in the <tt>val</tt> register.  We don\'t care what the compiled\ncode does after executing the <tt>define</tt>, so our choice of <tt>next</tt> as the linkage descriptor is arbitrary.<p>\n\n<tt>Compile</tt> determines that the expression is a definition, so it calls <tt>compile-definition</tt> to compile code to compute the value to be assigned\n(targeted to <tt>val</tt>), followed by code to install the definition, followed\nby code to put the value of the <tt>define</tt> (which is the symbol <tt>ok</tt>)\ninto the target register, followed finally by the linkage code.  <tt>Env</tt> is\npreserved around the computation of the value, because it is needed in order\nto install the definition.  Because the linkage is <tt>next</tt>, there is no\nlinkage code in this case.  The skeleton of the compiled code is thus<p>\n\n<p><p><tt>&nbsp;&nbsp;&lt;<em>save&nbsp;<tt>env</tt>&nbsp;if&nbsp;modified&nbsp;by&nbsp;code&nbsp;to&nbsp;compute&nbsp;value</em>&gt;<br>\n&nbsp;&nbsp;&lt;<em>compilation&nbsp;of&nbsp;definition&nbsp;value,&nbsp;target&nbsp;<tt>val</tt>,&nbsp;linkage&nbsp;<tt>next</tt></em>&gt;<br>\n&nbsp;&nbsp;&lt;<em>restore&nbsp;<tt>env</tt>&nbsp;if&nbsp;saved&nbsp;above</em>&gt;<br>\n&nbsp;&nbsp;(perform&nbsp;(op&nbsp;define-variable!)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(const&nbsp;factorial)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;val)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;ok))<br>\n</tt><p><p><p>\n\nThe expression that is to be compiled to produce the value for the\nvariable <tt>factorial</tt> is a <tt>lambda</tt> expression whose value is\nthe procedure that computes factorials.  <tt>Compile</tt> handles this by\ncalling <tt>compile-lambda</tt>, which compiles the procedure body,\nlabels it as a new entry point, and generates the instruction that\nwill combine the procedure body at the new entry point with the\nrun-time environment and assign the result to <tt>val</tt>.  The sequence\nthen skips around the compiled procedure code, which is inserted at\nthis point.  The procedure code itself begins by extending the\nprocedure\'s definition environment by a frame that binds\nthe formal parameter <tt>n</tt> to the procedure argument.  Then comes the actual\nprocedure body.  Since this code for the value of the variable\ndoesn\'t modify the <tt>env</tt> register, the optional <tt>save</tt>\nand <tt>restore</tt> shown above aren\'t generated.  (The procedure code at\n<tt>entry2</tt> isn\'t executed at this point, so its use of <tt>env</tt>\nis irrelevant.)\nTherefore, the skeleton for the compiled code becomes<p>\n\n<p><p><tt>&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;make-compiled-procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(label&nbsp;entry2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;after-lambda1))<br>\nentry2<br>\n&nbsp;&nbsp;(assign&nbsp;env&nbsp;(op&nbsp;compiled-procedure-env)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(assign&nbsp;env&nbsp;(op&nbsp;extend-environment)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(const&nbsp;(n))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;argl)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;&lt;<em>compilation&nbsp;of&nbsp;procedure&nbsp;body</em>&gt;<br>\nafter-lambda1<br>\n&nbsp;&nbsp;(perform&nbsp;(op&nbsp;define-variable!)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(const&nbsp;factorial)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;val)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;ok))<br>\n</tt><p><p><p>\n\nA procedure body is always compiled (by <tt>compile-lambda-body</tt>) as\na sequence with target <tt>val</tt> and linkage <tt>return</tt>.  The\nsequence in this case consists of a single <tt>if</tt> expression:<p>\n\n<p><p><tt>(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1))&nbsp;n))<br>\n</tt><p><p>\n<tt>Compile-if</tt> generates code that first computes the predicate (targeted to\n<tt>val</tt>), then checks the result and branches around the true branch if the\npredicate is false.  <tt>Env</tt> and <tt>continue</tt> are preserved around the\npredicate code, since they may be needed for the rest of the <tt>if</tt>\nexpression.  Since the <tt>if</tt> expression is the final expression (and only\nexpression) in the sequence making up the procedure body, its target is <tt>val</tt> and its linkage is <tt>return</tt>, so the true and false branches are both\ncompiled with target <tt>val</tt> and linkage <tt>return</tt>.\n(That is, the value of the conditional, which is the value computed by\neither of its branches, is the value of the procedure.)<p>\n\n<p><p><tt>&nbsp;&nbsp;&lt;<em>save&nbsp;<tt>continue</tt>,&nbsp;<tt>env</tt>&nbsp;if&nbsp;modified&nbsp;by&nbsp;predicate&nbsp;and&nbsp;needed&nbsp;by&nbsp;branches</em>&gt;<br>\n&nbsp;&nbsp;&lt;<em>compilation&nbsp;of&nbsp;predicate,&nbsp;target&nbsp;<tt>val</tt>,&nbsp;linkage&nbsp;<tt>next</tt></em>&gt;<br>\n&nbsp;&nbsp;&lt;<em>restore&nbsp;<tt>continue</tt>,&nbsp;<tt>env</tt>&nbsp;if&nbsp;saved&nbsp;above</em>&gt;<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;false?)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;false-branch4))<br>\ntrue-branch5<br>\n&nbsp;&nbsp;&lt;<em>compilation&nbsp;of&nbsp;true&nbsp;branch,&nbsp;target&nbsp;<tt>val</tt>,&nbsp;linkage&nbsp;<tt>return</tt></em>&gt;<br>\nfalse-branch4<br>\n&nbsp;&nbsp;&lt;<em>compilation&nbsp;of&nbsp;false&nbsp;branch,&nbsp;target&nbsp;<tt>val</tt>,&nbsp;linkage&nbsp;<tt>return</tt></em>&gt;<br>\nafter-if3<br>\n</tt><p><p><p>\n\nThe predicate <tt>(= n 1)</tt> is a procedure call.  This\nlooks up the operator (the symbol <tt>=</tt>) and places this value in\n<tt>proc</tt>.  It then assembles the arguments <tt>1</tt> and the value of\n<tt>n</tt> into <tt>argl</tt>.  Then it tests whether <tt>proc</tt> contains a\nprimitive or a compound procedure, and dispatches to a primitive branch\nor a compound branch accordingly.  Both branches resume at the <tt>after-call</tt> label.  The requirements to preserve registers\naround the evaluation of the operator and operands don\'t result in\nany saving of registers, because in this case those evaluations don\'t\nmodify the registers in question.<p>\n\n<p><p><tt>&nbsp;&nbsp;(assign&nbsp;proc<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;=)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;1))<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;list)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;n)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;cons)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;argl))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;primitive-procedure?)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;primitive-branch17))<br>\ncompiled-branch16<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;after-call15))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\nprimitive-branch17<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;apply-primitive-procedure)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;proc)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;argl))<br>\nafter-call15<br>\n</tt><p><p><p>\n\nThe true branch, which is the constant 1, compiles (with target\n<tt>val</tt> and linkage <tt>return</tt>) to<p>\n\n<p><p><tt>&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;1))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\n</tt><p><p>\nThe code for the false branch is another a procedure call, where the\nprocedure is the value of the symbol <tt>*</tt>, and the arguments are\n<tt>n</tt> and the result of another procedure call (a call to <tt>factorial</tt>).\nEach of these calls sets up <tt>proc</tt> and <tt>argl</tt> and its own primitive\nand compound branches.  Figure&nbsp;<a href="#%_fig_5.17">5.17</a>\nshows the complete compilation of the\ndefinition of the <tt>factorial</tt> procedure.\nNotice that the possible <tt>save</tt> and <tt>restore</tt> of\n<tt>continue</tt> and <tt>env</tt> around the predicate, shown above,\nare in fact generated, because these registers are modified by the procedure\ncall in the predicate and needed for the procedure call and the\n<tt>return</tt> linkage in the branches.\n\n\n<p><a name="%_thm_5.33"></a>\n<b>Exercise 5.33.</b>&nbsp;&nbsp;Consider the following definition of a factorial procedure, which is\nslightly different from the one given above:\n<p><p><tt>(define&nbsp;(factorial-alt&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;n&nbsp;(factorial-alt&nbsp;(-&nbsp;n&nbsp;1)))))<br>\n</tt><p><p>\nCompile this procedure and compare the resulting code with that produced for\n<tt>factorial</tt>.  Explain any differences you find.  Does either\nprogram execute more efficiently than the other?\n<p><p>\n\n<p><a name="%_thm_5.34"></a>\n<b>Exercise 5.34.</b>&nbsp;&nbsp;<a name="%_idx_6408"></a><a name="%_idx_6410"></a>Compile the iterative factorial procedure\n<p><p><tt>(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;(define&nbsp;(iter&nbsp;product&nbsp;counter)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&gt;&nbsp;counter&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(iter&nbsp;(*&nbsp;counter&nbsp;product)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;counter&nbsp;1))))<br>\n&nbsp;&nbsp;(iter&nbsp;1&nbsp;1))<br>\n</tt><p><p>\nAnnotate the resulting code, showing the essential difference between\nthe code for iterative and recursive versions of <tt>factorial</tt> that\nmakes one process build up stack space and the other run in constant\nstack space.\n<p>\n\n\n<p>\n\n<a name="%_fig_5.17"></a><p><div align=left><table width=100%><tr><td><p><p><tt><em>;;&nbsp;construct&nbsp;the&nbsp;procedure&nbsp;and&nbsp;skip&nbsp;over&nbsp;code&nbsp;for&nbsp;the&nbsp;procedure&nbsp;body</em><br>\n&nbsp;&nbsp;(assign&nbsp;val<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;make-compiled-procedure)&nbsp;(label&nbsp;entry2)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;after-lambda1))<br>\n<br>\nentry2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;calls&nbsp;to&nbsp;<tt>factorial</tt>&nbsp;will&nbsp;enter&nbsp;here</em><br>\n&nbsp;&nbsp;(assign&nbsp;env&nbsp;(op&nbsp;compiled-procedure-env)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(assign&nbsp;env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;extend-environment)&nbsp;(const&nbsp;(n))&nbsp;(reg&nbsp;argl)&nbsp;(reg&nbsp;env))<br>\n<em>;;&nbsp;begin&nbsp;actual&nbsp;procedure&nbsp;body</em><br>\n&nbsp;&nbsp;(save&nbsp;continue)<br>\n&nbsp;&nbsp;(save&nbsp;env)<br>\n<br>\n<em>;;&nbsp;compute&nbsp;<tt>(=&nbsp;n&nbsp;1)</tt></em><br>\n&nbsp;&nbsp;(assign&nbsp;proc&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;=)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;1))<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;list)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;n)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;cons)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;argl))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;primitive-procedure?)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;primitive-branch17))<br>\ncompiled-branch16<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;after-call15))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\nprimitive-branch17<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;apply-primitive-procedure)&nbsp;(reg&nbsp;proc)&nbsp;(reg&nbsp;argl))<br>\n<br>\nafter-call15&nbsp;&nbsp;&nbsp;<em>;&nbsp;<tt>val</tt>&nbsp;now&nbsp;contains&nbsp;result&nbsp;of&nbsp;<tt>(=&nbsp;n&nbsp;1)</tt></em><br>\n&nbsp;&nbsp;(restore&nbsp;env)<br>\n&nbsp;&nbsp;(restore&nbsp;continue)<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;false?)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;false-branch4))<br>\ntrue-branch5&nbsp;&nbsp;<em>;&nbsp;return&nbsp;1</em><br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;1))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\n<br>\nfalse-branch4<br>\n<em>;;&nbsp;compute&nbsp;and&nbsp;return&nbsp;<tt>(*&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1))&nbsp;n)</tt></em><br>\n&nbsp;&nbsp;(assign&nbsp;proc&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;*)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(save&nbsp;continue)<br>\n&nbsp;&nbsp;(save&nbsp;proc)&nbsp;&nbsp;&nbsp;<em>;&nbsp;save&nbsp;<tt>*</tt></em>&nbsp;procedure<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;n)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;list)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(save&nbsp;argl)&nbsp;&nbsp;&nbsp;<em>;&nbsp;save&nbsp;partial&nbsp;argument&nbsp;list&nbsp;for&nbsp;<tt>*</tt></em><br>\n<br>\n<em>;;&nbsp;compute&nbsp;<tt>(factorial&nbsp;(-&nbsp;n&nbsp;1))</tt>,&nbsp;which&nbsp;is&nbsp;the&nbsp;other&nbsp;argument&nbsp;for&nbsp;<tt>*</tt></em><br>\n&nbsp;&nbsp;(assign&nbsp;proc<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;factorial)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(save&nbsp;proc)&nbsp;&nbsp;<em>;&nbsp;save&nbsp;<tt>factorial</tt>&nbsp;procedure</em><br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.17:</b>&nbsp;&nbsp;Compilation of the definition of the <tt>factorial</tt>\nprocedure (continued on next page).</div></caption><tr><td>\n<a name="%_idx_6412"></a>\n\n</td></tr></table></div><p><p>\n\n<a name="%_fig_5.17"></a><p><div align=left><table width=100%><tr><td><p><p><tt><em>;;&nbsp;compute&nbsp;<tt>(-&nbsp;n&nbsp;1)</tt>,&nbsp;which&nbsp;is&nbsp;the&nbsp;argument&nbsp;for&nbsp;<tt>factorial</tt></em><br>\n&nbsp;&nbsp;(assign&nbsp;proc&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;-)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;1))<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;list)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;n)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;cons)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;argl))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;primitive-procedure?)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;primitive-branch8))<br>\ncompiled-branch7<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;after-call6))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\nprimitive-branch8<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;apply-primitive-procedure)&nbsp;(reg&nbsp;proc)&nbsp;(reg&nbsp;argl))<br>\n<br>\nafter-call6&nbsp;&nbsp;&nbsp;<em>;&nbsp;<tt>val</tt>&nbsp;now&nbsp;contains&nbsp;result&nbsp;of&nbsp;<tt>(-&nbsp;n&nbsp;1)</tt></em><br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;list)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(restore&nbsp;proc)&nbsp;<em>;&nbsp;restore&nbsp;<tt>factorial</tt></em><br>\n<em>;;&nbsp;apply&nbsp;<tt>factorial</tt></em><br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;primitive-procedure?)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;primitive-branch11))<br>\ncompiled-branch10<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;after-call9))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\nprimitive-branch11<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;apply-primitive-procedure)&nbsp;(reg&nbsp;proc)&nbsp;(reg&nbsp;argl))<br>\n<br>\nafter-call9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;<tt>val</tt>&nbsp;now&nbsp;contains&nbsp;result&nbsp;of&nbsp;<tt>(factorial&nbsp;(-&nbsp;n&nbsp;1))</tt></em><br>\n&nbsp;&nbsp;(restore&nbsp;argl)&nbsp;<em>;&nbsp;restore&nbsp;partial&nbsp;argument&nbsp;list&nbsp;for&nbsp;<tt>*</tt></em><br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;cons)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;argl))<br>\n&nbsp;&nbsp;(restore&nbsp;proc)&nbsp;<em>;&nbsp;restore&nbsp;<tt>*</tt></em><br>\n&nbsp;&nbsp;(restore&nbsp;continue)<br>\n<em>;;&nbsp;apply&nbsp;<tt>*</tt></em>&nbsp;and&nbsp;return&nbsp;its&nbsp;value<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;primitive-procedure?)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;primitive-branch14))<br>\ncompiled-branch13<br>\n<em>;;&nbsp;note&nbsp;that&nbsp;a&nbsp;compound&nbsp;procedure&nbsp;here&nbsp;is&nbsp;called&nbsp;tail-recursively</em><br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\nprimitive-branch14<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;apply-primitive-procedure)&nbsp;(reg&nbsp;proc)&nbsp;(reg&nbsp;argl))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\nafter-call12<br>\nafter-if3<br>\nafter-lambda1<br>\n<em>;;&nbsp;assign&nbsp;the&nbsp;procedure&nbsp;to&nbsp;the&nbsp;variable&nbsp;<tt>factorial</tt></em><br>\n&nbsp;&nbsp;(perform<br>\n&nbsp;&nbsp;&nbsp;(op&nbsp;define-variable!)&nbsp;(const&nbsp;factorial)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;ok))<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.17:</b>&nbsp;&nbsp;(continued)</div></caption><tr><td>\n</td></tr></table></div><p><p>\n\n<p><a name="%_thm_5.35"></a>\n<b>Exercise 5.35.</b>&nbsp;&nbsp;What expression was compiled to produce the code shown in\nfigure&nbsp;<a href="#%_fig_5.18">5.18</a>?\n<a name="%_fig_5.18"></a><p><div align=left><table width=100%><tr><td><p><p><tt>&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;make-compiled-procedure)&nbsp;(label&nbsp;entry16)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;after-lambda15))<br>\nentry16<br>\n&nbsp;&nbsp;(assign&nbsp;env&nbsp;(op&nbsp;compiled-procedure-env)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(assign&nbsp;env<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(op&nbsp;extend-environment)&nbsp;(const&nbsp;(x))&nbsp;(reg&nbsp;argl)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;proc&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;+)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(save&nbsp;continue)<br>\n&nbsp;&nbsp;(save&nbsp;proc)<br>\n&nbsp;&nbsp;(save&nbsp;env)<br>\n&nbsp;&nbsp;(assign&nbsp;proc&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;g)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(save&nbsp;proc)<br>\n&nbsp;&nbsp;(assign&nbsp;proc&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;+)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;2))<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;list)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;x)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;cons)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;argl))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;primitive-procedure?)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;primitive-branch19))<br>\ncompiled-branch18<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;after-call17))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\nprimitive-branch19<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;apply-primitive-procedure)&nbsp;(reg&nbsp;proc)&nbsp;(reg&nbsp;argl))<br>\nafter-call17<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;list)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(restore&nbsp;proc)<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;primitive-procedure?)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;primitive-branch22))<br>\ncompiled-branch21<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;after-call20))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\nprimitive-branch22<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;apply-primitive-procedure)&nbsp;(reg&nbsp;proc)&nbsp;(reg&nbsp;argl))<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.18:</b>&nbsp;&nbsp;An example of compiler output (continued on next page).\nSee exercise&nbsp;<a href="#%_thm_5.35">5.35</a>.</div></caption><tr><td>\n\n\n</td></tr></table></div><p><p>\n\n<a name="%_fig_5.18"></a><p><div align=left><table width=100%><tr><td><p><p><tt>after-call20<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;list)&nbsp;(reg&nbsp;val))<br>\n&nbsp;&nbsp;(restore&nbsp;env)<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;x)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;argl&nbsp;(op&nbsp;cons)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;argl))<br>\n&nbsp;&nbsp;(restore&nbsp;proc)<br>\n&nbsp;&nbsp;(restore&nbsp;continue)<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;primitive-procedure?)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;primitive-branch25))<br>\ncompiled-branch24<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\nprimitive-branch25<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;apply-primitive-procedure)&nbsp;(reg&nbsp;proc)&nbsp;(reg&nbsp;argl))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;continue))<br>\nafter-call23<br>\nafter-lambda15<br>\n&nbsp;&nbsp;(perform&nbsp;(op&nbsp;define-variable!)&nbsp;(const&nbsp;f)&nbsp;(reg&nbsp;val)&nbsp;(reg&nbsp;env))<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(const&nbsp;ok))<br>\n</tt><p><p>\n<p><p></td></tr><caption align=bottom><div align=left><b>Figure 5.18:</b>&nbsp;&nbsp;(continued)</div></caption><tr><td>\n</td></tr></table></div><p>\n<p><p>\n\n<p><a name="%_thm_5.36"></a>\n<b>Exercise 5.36.</b>&nbsp;&nbsp;<a name="%_idx_6414"></a><a name="%_idx_6416"></a>What order of evaluation does our compiler produce for operands of a\ncombination?  Is it left-to-right, right-to-left, or some other order?\nWhere in the compiler is this order determined?  Modify the compiler\nso that it produces some other order of evaluation.  (See the\ndiscussion of order of evaluation for the explicit-control evaluator\nin section&nbsp;<a href="book-Z-H-34.html#%_sec_5.4.1">5.4.1</a>.)  How does changing the order of\noperand evaluation affect the efficiency of the code that constructs\nthe argument list?\n<p><p>\n\n<p><a name="%_thm_5.37"></a>\n<b>Exercise 5.37.</b>&nbsp;&nbsp;<a name="%_idx_6418"></a><a name="%_idx_6420"></a>One way to understand the compiler\'s <tt>preserving</tt> mechanism for\noptimizing stack usage is to see what extra operations would\nbe generated if we did not use this idea.  Modify <tt>preserving</tt> so\nthat it always generates the <tt>save</tt> and <tt>restore</tt> operations.\nCompile some simple expressions and identify the unnecessary stack\noperations that are generated.\nCompare the code to that generated with the <tt>preserving</tt> mechanism intact.\n<p><p>\n\n<p><a name="%_thm_5.38"></a>\n<b>Exercise 5.38.</b>&nbsp;&nbsp;<a name="%_idx_6422"></a><a name="%_idx_6424"></a>Our compiler is clever about avoiding unnecessary stack operations,\nbut it is not clever at all when it comes to compiling calls to the primitive\nprocedures of the language in terms of the primitive operations\nsupplied by the machine.  For example, consider how much code is\ncompiled to compute <tt>(+ a 1)</tt>: The code sets up an argument list\nin <tt>argl</tt>, puts the primitive addition procedure (which it finds\nby looking up the symbol <tt>+</tt> in the environment) into <tt>proc</tt>,\nand tests whether the procedure is primitive or compound.  The\ncompiler always generates code to perform the test, as well as code\nfor primitive and compound branches (only one of which will be executed).\nWe have not shown the part of the controller that implements\nprimitives, but we presume that these instructions make use of\nprimitive arithmetic operations in the machine\'s data paths.  Consider\nhow much less code would be generated if the compiler could <em>open-code</em> primitives -- that is, if it could generate code to directly\nuse these primitive machine operations.  The expression <tt>(+ a 1)</tt>\nmight be compiled into something as simple as&nbsp;<a name="call_footnote_Temp_822" href="#footnote_Temp_822"><sup><small>43</small></sup></a>\n<p><p><tt>(assign&nbsp;val&nbsp;(op&nbsp;lookup-variable-value)&nbsp;(const&nbsp;a)&nbsp;(reg&nbsp;env))<br>\n(assign&nbsp;val&nbsp;(op&nbsp;+)&nbsp;(reg&nbsp;val)&nbsp;(const&nbsp;1))<br>\n</tt><p><p>\nIn this exercise we will extend our compiler to support open coding of\nselected primitives.  Special-purpose code will be generated\nfor calls to these primitive procedures instead of the general\nprocedure-application code.  In order to support this, we will augment\nour machine with special argument registers <tt>arg1</tt> and <tt>arg2</tt>.\nThe primitive arithmetic operations of the machine will take their\ninputs from <tt>arg1</tt> and <tt>arg2</tt>. The results may be put into\n<tt>val</tt>, <tt>arg1</tt>, or <tt>arg2</tt>.<p>\n\nThe compiler must be able to recognize the application of an\nopen-coded primitive in the source program.  We will augment the\ndispatch in the <tt>compile</tt> procedure to recognize the names of\nthese primitives in addition to the <a name="%_idx_6426"></a>reserved words (the special forms)\nit currently recognizes.<a name="call_footnote_Temp_823" href="#footnote_Temp_823"><sup><small>44</small></sup></a> For each special form our compiler has a code generator.  In\nthis exercise we will construct a family of code generators for the\nopen-coded primitives.<p>\n\n\na.&nbsp;&nbsp;The open-coded primitives, unlike the special forms, all need their\noperands evaluated.  Write a code generator <tt>spread-arguments</tt> for use by\nall the open-coding code generators.  <tt>Spread-arguments</tt> should take an\noperand list and compile the given operands targeted to successive argument\nregisters.  Note that an operand may contain a call to an open-coded\nprimitive, so argument registers will have to be preserved during operand\nevaluation.<p>\n\nb.&nbsp;&nbsp;For each of the primitive procedures <tt>=</tt>, <tt>*</tt>, <tt>-</tt>, and\n<tt>+</tt>, write a code generator that takes a combination with that\noperator, together with a target and a linkage descriptor, and\nproduces code to spread the arguments into the registers and then\nperform the operation targeted to the given target with the given\nlinkage.  You need only handle expressions with two operands.  Make\n<tt>compile</tt> dispatch to these code generators.<p>\n\nc.&nbsp;&nbsp;Try your new compiler on the <tt>factorial</tt> example.  Compare the\nresulting code with the result produced without open coding.<p>\n\nd.&nbsp;&nbsp;Extend your code generators for <tt>+</tt> and <tt>*</tt> so that they\ncan handle expressions with arbitrary numbers of operands.  An\nexpression with more than two operands will have to be compiled into a\nsequence of operations, each with only two inputs.\n\n<p><p>\n\n<a name="%_sec_5.5.6"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.6">5.5.6&nbsp;&nbsp;Lexical Addressing</a></h3><p>\n\n\n<a name="%_idx_6428"></a><a name="%_idx_6430"></a>\n\nOne of the most common optimizations performed by compilers is the\noptimization of variable lookup.  Our compiler, as we have implemented\nit so far, generates code that uses the <tt>lookup-variable-value</tt>\noperation of the evaluator machine.  This searches for a variable by\ncomparing it with each variable that is currently bound, working frame\nby frame outward through the run-time environment.  This search can be\nexpensive if the frames are deeply nested or if there are many\nvariables.  For example, consider the problem of looking up the value\nof <tt>x</tt> while evaluating the expression <tt>(* x y z)</tt> in an\napplication of the procedure that is returned by<p>\n\n<p><p><tt>(let&nbsp;((x&nbsp;3)&nbsp;(y&nbsp;4))<br>\n&nbsp;&nbsp;(lambda&nbsp;(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((y&nbsp;(*&nbsp;a&nbsp;b&nbsp;x))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(z&nbsp;(+&nbsp;c&nbsp;d&nbsp;x)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;x&nbsp;y&nbsp;z))))<br>\n</tt><p><p>\nSince a <tt>let</tt> expression is just syntactic sugar for a <tt>lambda</tt> combination, this expression is equivalent to<p>\n\n<p><p><tt>((lambda&nbsp;(x&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;(lambda&nbsp;(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(y&nbsp;z)&nbsp;(*&nbsp;x&nbsp;y&nbsp;z))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;a&nbsp;b&nbsp;x)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;c&nbsp;d&nbsp;x))))<br>\n&nbsp;3<br>\n&nbsp;4)<br>\n</tt><p><p>\nEach time <tt>lookup-variable-value</tt> searches for <tt>x</tt>, it must\ndetermine that the symbol <tt>x</tt> is not <tt>eq?</tt> to <tt>y</tt> or <tt>z</tt> (in the first frame), nor to <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, <tt>d</tt>, or\n<tt>e</tt> (in the second frame).  We will assume, for the moment, that\nour programs do not use <tt>define</tt> -- that variables are\nbound only with <tt>lambda</tt>.  Because our language is <a name="%_idx_6432"></a>lexically\nscoped, the run-time environment for any expression will have a\nstructure that parallels the lexical structure of the program in which\nthe expression appears.<a name="call_footnote_Temp_824" href="#footnote_Temp_824"><sup><small>45</small></sup></a>\nThus, the compiler can know, when it analyzes the\nabove expression, that each time the procedure is applied the variable\n<tt>x</tt> in <tt>(* x y z)</tt> will be found two frames out from the\ncurrent frame and will be the first variable in that frame.<p>\n\n<a name="%_idx_6434"></a>We can exploit this fact by inventing a new kind of variable-lookup\noperation, <tt>lexical-address-lookup</tt>, that takes as arguments an\nenvironment and a <em>lexical address</em> that consists of two numbers:\na <em>frame number</em>, which specifies how many frames to pass over,\nand a <em>displacement number</em>, which specifies how many variables to\npass over in that frame.  <a name="%_idx_6436"></a><tt>Lexical-address-lookup</tt> will produce\nthe value of the variable stored at that lexical address relative to\nthe current environment.  If we add the <tt>lexical-address-lookup</tt>\noperation to our machine, we can make the compiler generate code that\nreferences variables using this operation, rather than <tt>lookup-variable-value</tt>.  Similarly, our compiled code can use a new\n<a name="%_idx_6438"></a><tt>lexical-address-set!</tt>  operation instead of <tt>set-variable-value!</tt>.<p>\n\nIn order to generate such code, the compiler must be able to determine\nthe lexical address of a variable it is about to compile a reference\nto.  The lexical address of a variable in a program depends on where\none is in the code.  For example, in the following program, the\naddress of <tt>x</tt> in expression &lt;<em>e1</em>&gt; is (2,0) -- two frames back\nand the first variable in the frame.  At that point <tt>y</tt> is at\naddress (0,0) and <tt>c</tt> is at address (1,2).  In expression\n&lt;<em>e2</em>&gt;,  <tt>x</tt> is at (1,0),   <tt>y</tt> is at (1,1), and <tt>c</tt> is at (0,2).<p>\n\n<p><p><tt>((lambda&nbsp;(x&nbsp;y)<br>\n&nbsp;&nbsp;&nbsp;(lambda&nbsp;(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(y&nbsp;z)&nbsp;&lt;<em>e1</em>&gt;)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<em>e2</em>&gt;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;c&nbsp;d&nbsp;x))))<br>\n&nbsp;3<br>\n&nbsp;4)<br>\n</tt><p><p><p>\n\n<a name="%_idx_6440"></a>One way for the compiler to produce code that uses lexical addressing\nis to maintain a data structure called a <em>compile-time\nenvironment</em>.  This keeps track of which variables will be at which\npositions in which frames in the run-time environment when a\nparticular variable-access operation is executed.  The compile-time\nenvironment is a list of frames, each containing a list of variables.\n(There will of course be no values bound to the variables, since\nvalues are not computed at compile time.)  The compile-time\nenvironment becomes an additional argument to <tt>compile</tt> and is\npassed along to each code generator.  The top-level call to <tt>compile</tt> uses an empty compile-time environment.\nWhen a <tt>lambda</tt> body is compiled, <tt>compile-lambda-body</tt>\nextends the compile-time environment by a frame containing the\nprocedure\'s parameters, so that the sequence making up the body\nis compiled with that extended environment.\nAt each point in the compilation, <tt>compile-variable</tt> and <tt>compile-assignment</tt> use the compile-time\nenvironment in order to generate the appropriate lexical addresses.<p>\n\nExercises&nbsp;<a href="#%_thm_5.39">5.39</a>\nthrough&nbsp;<a href="#%_thm_5.43">5.43</a> describe how to complete this sketch of\nthe lexical-addressing strategy in order to incorporate lexical lookup\ninto the compiler.\nExercise&nbsp;<a href="#%_thm_5.44">5.44</a> describes another use for the\ncompile-time environment.<p>\n\n<p><a name="%_thm_5.39"></a>\n<b>Exercise 5.39.</b>&nbsp;&nbsp;<a name="%_idx_6442"></a><a name="%_idx_6444"></a>Write a procedure <tt>lexical-address-lookup</tt> that implements the new\nlookup operation.  It should take two arguments -- a lexical address\nand a run-time environment -- and return the value of the variable\nstored at the specified lexical address.  <tt>Lexical-address-lookup</tt>\nshould signal an error if the value of the variable is the symbol <tt>*unassigned*</tt>.<a name="call_footnote_Temp_826" href="#footnote_Temp_826"><sup><small>46</small></sup></a> Also write a procedure <tt>lexical-address-set!</tt> that\nimplements the operation that changes the value of the variable at a\nspecified lexical address.\n\n\n<p><p>\n\n<p><a name="%_thm_5.40"></a>\n<b>Exercise 5.40.</b>&nbsp;&nbsp;<a name="%_idx_6450"></a>Modify the compiler to maintain the compile-time environment as\ndescribed above.  That is, add a compile-time-environment argument to\n<tt>compile</tt> and the various code generators, and extend it in\n<tt>compile-lambda-body</tt>.\n<p><p>\n\n<p><a name="%_thm_5.41"></a>\n<b>Exercise 5.41.</b>&nbsp;&nbsp;<a name="%_idx_6452"></a>Write a procedure <tt>find-variable</tt> that takes as arguments a\nvariable and a compile-time environment and returns the lexical\naddress of the variable with respect to that environment.  For\nexample, in the program fragment that is shown above, the compile-time\nenvironment during the compilation of expression &lt;<em>e1</em>&gt; is <tt>((y\nz) (a b c d e) (x y))</tt>.  <tt>Find-variable</tt> should produce<p>\n\n<p><p><tt>(find-variable&nbsp;\'c&nbsp;\'((y&nbsp;z)&nbsp;(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)&nbsp;(x&nbsp;y)))<br>\n<i>(1&nbsp;2)</i><br>\n<br>\n(find-variable&nbsp;\'x&nbsp;\'((y&nbsp;z)&nbsp;(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)&nbsp;(x&nbsp;y)))<br>\n<i>(2&nbsp;0)</i><br>\n<br>\n(find-variable&nbsp;\'w&nbsp;\'((y&nbsp;z)&nbsp;(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)&nbsp;(x&nbsp;y)))<br>\n<i>not-found</i><br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_5.42"></a>\n<b>Exercise 5.42.</b>&nbsp;&nbsp;Using <tt>find-variable</tt> from exercise&nbsp;<a href="#%_thm_5.41">5.41</a>,\nrewrite <tt>compile-variable</tt> and <tt>compile-assignment</tt> to output\nlexical-address instructions.  In cases where <tt>find-variable</tt>\nreturns <tt>not-found</tt> (that is, where the variable is not in the\ncompile-time environment), you should have the code generators use the\nevaluator operations, as before, to search for the binding.\n(The only place a variable that is not found at compile time can be is in\nthe global environment, which is part of the run-time environment but\nis not part of the compile-time environment.<a name="call_footnote_Temp_830" href="#footnote_Temp_830"><sup><small>47</small></sup></a>\nThus, if you wish, you may have the evaluator operations look directly in\nthe global environment, which can be obtained with the operation <tt>(op&nbsp;get-global-environment)</tt>, instead of having them search the whole run-time\nenvironment found in <tt>env</tt>.)\nTest the modified compiler on a few simple cases, such as the nested\n<tt>lambda</tt> combination at the beginning of this section.\n\n<p><p>\n\n<p><a name="%_thm_5.43"></a>\n<b>Exercise 5.43.</b>&nbsp;&nbsp;<a name="%_idx_6454"></a><a name="%_idx_6456"></a>We argued in section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.6">4.1.6</a> that internal definitions\nfor block structure should not be considered ``real\'\' <tt>define</tt>s.  Rather,\na procedure body should be interpreted as if the internal variables being\ndefined were installed as ordinary <tt>lambda</tt> variables initialized to their\ncorrect values using <tt>set!</tt>.  Section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.6">4.1.6</a> and\nexercise&nbsp;<a href="book-Z-H-26.html#%_thm_4.16">4.16</a> showed how to modify the metacircular\ninterpreter to accomplish this by scanning out internal definitions.  Modify\nthe compiler to perform the same transformation before it compiles a procedure\nbody.\n\n\n<p><p>\n\n<p><a name="%_thm_5.44"></a>\n<b>Exercise 5.44.</b>&nbsp;&nbsp;<a name="%_idx_6458"></a><a name="%_idx_6460"></a><a name="%_idx_6462"></a><a name="%_idx_6464"></a>In this section we have focused on the use of the compile-time\nenvironment to produce lexical addresses.  But there are other uses\nfor compile-time environments.  For instance, in\nexercise&nbsp;<a href="#%_thm_5.38">5.38</a> we increased the efficiency of compiled\ncode by open-coding primitive procedures.  Our implementation treated\nthe names of open-coded procedures as reserved words.  If a program\nwere to rebind such a name, the mechanism described in\nexercise&nbsp;<a href="#%_thm_5.38">5.38</a> would still open-code it as a primitive,\nignoring the new binding.  For example, consider the procedure<p>\n\n<p><p><tt>(lambda&nbsp;(+&nbsp;*&nbsp;a&nbsp;b&nbsp;x&nbsp;y)<br>\n&nbsp;&nbsp;(+&nbsp;(*&nbsp;a&nbsp;x)&nbsp;(*&nbsp;b&nbsp;y)))<br>\n</tt><p><p>\nwhich computes a linear combination of <tt>x</tt> and <tt>y</tt>.  We might\ncall it with arguments <tt>+matrix</tt>, <tt>*matrix</tt>, and four\nmatrices, but the open-coding compiler would still open-code the <tt>+</tt> and the <tt>*</tt> in <tt>(+ (* a x) (* b y))</tt> as primitive <tt>+</tt>\nand <tt>*</tt>.  Modify the open-coding compiler to consult the\ncompile-time environment in order to compile the correct code for\nexpressions involving the names of primitive procedures.\n(The code will work correctly as long as the program does not <tt>define</tt> or <tt>set!</tt> these names.)\n\n<p><p>\n\n<a name="%_sec_5.5.7"></a>\n<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.7">5.5.7&nbsp;&nbsp;Interfacing Compiled Code to the Evaluator</a></h3><p>\n\n\n<a name="%_idx_6466"></a><a name="%_idx_6468"></a><a name="%_idx_6470"></a>\nWe have not yet explained how to load compiled code into the evaluator machine\nor how to run it.  We will assume that the explicit-control-evaluator machine\nhas been defined as in section&nbsp;<a href="book-Z-H-34.html#%_sec_5.4.4">5.4.4</a>, with the\nadditional operations specified in footnote&nbsp;<a href="#footnote_Temp_809">38</a>.\nWe will implement\na procedure <a name="%_idx_6472"></a><tt>compile-and-go</tt> that compiles a Scheme expression, loads the\nresulting object code into the evaluator machine,\nand causes the machine to run the code in the\nevaluator global environment, print the result, and\nenter the evaluator\'s driver loop.  We will also modify the evaluator so that\ninterpreted expressions can call compiled procedures as well as interpreted\nones.  We can then put a compiled procedure into the machine and use the\nevaluator to call it:<p>\n\n<p><p><tt>(compile-and-go<br>\n&nbsp;\'(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1))&nbsp;n))))<br>\n<i>&nbsp;;;;&nbsp;EC-Eval&nbsp;value:</i><br>\n<i>ok</i><br>\n<i>&nbsp;;;;&nbsp;EC-Eval&nbsp;input:</i><br>\n(factorial&nbsp;5)<br>\n<i>;;;&nbsp;EC-Eval&nbsp;value:</i><br>\n<i>120</i><br>\n</tt><p><p><p>\n\n\nTo allow the evaluator to handle compiled procedures (for example,\nto evaluate the call to <tt>factorial</tt> above),\nwe need to change the code at <tt>apply-dispatch</tt>\n(section&nbsp;<a href="book-Z-H-34.html#%_sec_5.4.1">5.4.1</a>) so that it recognizes\ncompiled procedures (as distinct from compound or primitive\nprocedures) and transfers control directly to the entry point of the\ncompiled code:<a name="call_footnote_Temp_833" href="#footnote_Temp_833"><sup><small>48</small></sup></a>\n<p><p><tt><a name="%_idx_6474"></a>apply-dispatch<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;primitive-procedure?)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;primitive-apply))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;compound-procedure?)&nbsp;(reg&nbsp;proc))&nbsp;&nbsp;<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;compound-apply))<br>\n&nbsp;&nbsp;(test&nbsp;(op&nbsp;compiled-procedure?)&nbsp;(reg&nbsp;proc))&nbsp;&nbsp;<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;compiled-apply))<br>\n&nbsp;&nbsp;(goto&nbsp;(label&nbsp;unknown-procedure-type))<br>\n<a name="%_idx_6476"></a>compiled-apply<br>\n&nbsp;&nbsp;(restore&nbsp;continue)<br>\n&nbsp;&nbsp;(assign&nbsp;val&nbsp;(op&nbsp;compiled-procedure-entry)&nbsp;(reg&nbsp;proc))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\n</tt><p><p>\nNote the restore of <tt>continue</tt> at <tt>compiled-apply</tt>.  Recall that the\nevaluator was arranged so that at <tt>apply-dispatch</tt>, the continuation would\nbe at the top of the stack.  The compiled code entry point, on the other hand,\nexpects the continuation to be in <tt>continue</tt>, so <tt>continue</tt> must be\nrestored before the compiled code is executed.<p>\n\n\nTo enable us to run some compiled code when we start the evaluator\nmachine, we add a <tt>branch</tt> instruction at\nthe beginning of the evaluator machine, which causes the machine to\ngo to a new entry point if the <tt>flag</tt> register is set.<a name="call_footnote_Temp_834" href="#footnote_Temp_834"><sup><small>49</small></sup></a><p>\n\n\n<p><p><tt>&nbsp;&nbsp;(branch&nbsp;(label&nbsp;external-entry))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;branches&nbsp;if&nbsp;<tt>flag</tt>&nbsp;is&nbsp;set</em><br>\nread-eval-print-loop<br>\n&nbsp;&nbsp;(perform&nbsp;(op&nbsp;initialize-stack))<br>\n&nbsp;&nbsp;<tt>...</tt></tt><p><p>\n<tt>External-entry</tt> assumes that the machine is started with\n<tt>val</tt> containing the location of an instruction sequence that\nputs a result into <tt>val</tt> and ends with <tt>(goto (reg\ncontinue))</tt>.  Starting at this entry point jumps to the location designated\nby <tt>val</tt>, but first assigns <tt>continue</tt> so that execution will return\nto <tt>print-result</tt>, which prints the value in <tt>val</tt> and then goes to\nthe beginning of the evaluator\'s read-eval-print loop.<a name="call_footnote_Temp_835" href="#footnote_Temp_835"><sup><small>50</small></sup></a><p>\n\n\n<p><p><tt><a name="%_idx_6482"></a>external-entry<br>\n&nbsp;&nbsp;(perform&nbsp;(op&nbsp;initialize-stack))<br>\n&nbsp;&nbsp;(assign&nbsp;env&nbsp;(op&nbsp;get-global-environment))<br>\n&nbsp;&nbsp;(assign&nbsp;continue&nbsp;(label&nbsp;print-result))<br>\n&nbsp;&nbsp;(goto&nbsp;(reg&nbsp;val))<br>\n</tt><p><p>\n\nNow we can use the following procedure to compile a procedure definition,\nexecute the compiled code, and run the read-eval-print loop so we can try the\nprocedure.  Because we want the compiled code to return to the location in\n<tt>continue</tt> with its result in <tt>val</tt>, we compile the expression with a\ntarget of <tt>val</tt> and a linkage of <tt>return</tt>.  In order to transform the\nobject code produced by the compiler into executable instructions for the\nevaluator register machine, we use the procedure <tt>assemble</tt> from the\nregister-machine simulator (section&nbsp;<a href="book-Z-H-32.html#%_sec_5.2.2">5.2.2</a>).  We then initialize\nthe <tt>val</tt> register to point to the list of instructions, set the\n<tt>flag</tt> so that the evaluator will go to <tt>external-entry</tt>, and start\nthe evaluator.<p>\n\n<p><p><tt><a name="%_idx_6484"></a>(define&nbsp;(compile-and-go&nbsp;expression)<br>\n&nbsp;&nbsp;(let&nbsp;((instructions<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assemble&nbsp;(statements<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(compile&nbsp;expression&nbsp;\'val&nbsp;\'return))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eceval)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;the-global-environment&nbsp;(setup-environment))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set-register-contents!&nbsp;eceval&nbsp;\'val&nbsp;instructions)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(set-register-contents!&nbsp;eceval&nbsp;\'flag&nbsp;true)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(start&nbsp;eceval)))<br>\n</tt><p><p><p>\n\n<a name="%_idx_6486"></a>If we have set up stack monitoring, as at the end of\nsection&nbsp;<a href="book-Z-H-34.html#%_sec_5.4.4">5.4.4</a>, we can examine the\nstack usage of compiled code:<p>\n\n<p><p><tt>(compile-and-go<br>\n&nbsp;\'(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1))&nbsp;n))))<br>\n<br>\n<i>(total-pushes&nbsp;=&nbsp;0&nbsp;maximum-depth&nbsp;=&nbsp;0)</i><br>\n<i>&nbsp;;;;&nbsp;EC-Eval&nbsp;value:</i><br>\n<i>ok</i><br>\n<i>&nbsp;;;;&nbsp;EC-Eval&nbsp;input:</i><br>\n(factorial&nbsp;5)<br>\n<i>(total-pushes&nbsp;=&nbsp;31&nbsp;maximum-depth&nbsp;=&nbsp;14)</i><br>\n<i>;;;&nbsp;EC-Eval&nbsp;value:</i><br>\n<i>120</i><br>\n</tt><p><p>\n<a name="%_idx_6488"></a>Compare this example with the evaluation of <tt>(factorial 5)</tt> using\nthe interpreted version of the same procedure, shown at the end of\nsection&nbsp;<a href="book-Z-H-34.html#%_sec_5.4.4">5.4.4</a>.  The interpreted version required\n144 pushes and a maximum stack depth of 28.  This illustrates the\noptimization that results from our compilation strategy.<p>\n\n<a name="%_sec_Temp_836"></a>\n<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_836">Interpretation and compilation</a></h4><p>\n\n<a name="%_idx_6490"></a><a name="%_idx_6492"></a>\nWith the programs in this section, we can now experiment with the\nalternative execution strategies of interpretation and\ncompilation.<a name="call_footnote_Temp_837" href="#footnote_Temp_837"><sup><small>51</small></sup></a>  An interpreter raises\nthe machine to the level of the user program; a compiler lowers the\nuser program to the level of the machine language.  We can regard the\nScheme language (or any programming language) as a coherent family of\nabstractions erected on the machine language.  Interpreters are good\nfor interactive program development and debugging because the steps of\nprogram execution are organized in terms of these abstractions, and\nare therefore more intelligible to the programmer.  Compiled code can\nexecute faster, because the steps of program execution are organized\nin terms of the machine language, and the compiler is free to make\noptimizations that cut across the higher-level\nabstractions.<a name="call_footnote_Temp_838" href="#footnote_Temp_838"><sup><small>52</small></sup></a><p>\n\n\nThe alternatives of interpretation and compilation also lead to\n<a name="%_idx_6504"></a>different strategies for porting languages to new computers. Suppose\nthat we wish to implement Lisp for a new machine.  One strategy is\nto begin with the explicit-control evaluator of section&nbsp;<a href="book-Z-H-34.html#%_sec_5.4">5.4</a>\nand translate its instructions to instructions for the\nnew machine.  A different strategy is to begin with the compiler and\nchange the code generators so that they generate code for the new\nmachine.  The second strategy allows us to run any Lisp program on\nthe new machine by first compiling it with the compiler running on our\noriginal Lisp system, and linking it with a compiled version of the\nrun-time library.<a name="call_footnote_Temp_839" href="#footnote_Temp_839"><sup><small>53</small></sup></a>  Better yet, we can compile the compiler itself, and run\nthis on the new machine to compile other Lisp programs.<a name="call_footnote_Temp_840" href="#footnote_Temp_840"><sup><small>54</small></sup></a>  Or we can\ncompile one of the interpreters of section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1">4.1</a> to\nproduce an interpreter that runs on the new machine.<p>\n\n<p><a name="%_thm_5.45"></a>\n<b>Exercise 5.45.</b>&nbsp;&nbsp;<a name="%_idx_6506"></a><a name="%_idx_6508"></a>By comparing the stack operations used by compiled code to the stack\noperations used by the evaluator for the same computation, we can\ndetermine the extent to which the compiler optimizes use of the stack,\nboth in speed (reducing the total number of stack operations) and in\nspace (reducing the maximum stack depth).  Comparing this optimized\nstack use to the performance of a special-purpose machine for the same\ncomputation gives some indication of the quality of the compiler.<p>\n\n<p><p>a. Exercise&nbsp;<a href="book-Z-H-34.html#%_thm_5.27">5.27</a> asked you to determine, as a function of\n<em>n</em>, the number of pushes and the maximum stack depth needed by the\nevaluator to compute <em>n</em>! using the recursive factorial procedure\ngiven above.  Exercise&nbsp;<a href="book-Z-H-32.html#%_thm_5.14">5.14</a> asked you to do the same\nmeasurements for the special-purpose factorial machine shown in\nfigure&nbsp;<a href="book-Z-H-31.html#%_fig_5.11">5.11</a>. Now perform the same analysis using the\ncompiled <tt>factorial</tt> procedure.<p>\n\nTake the ratio of the number of pushes in the compiled version to the\nnumber of pushes in the interpreted version, and do the same for the\nmaximum stack depth.  Since the number of operations and the stack\ndepth used to compute <em>n</em>! are linear in <em>n</em>, these ratios should\napproach constants as <em>n</em> becomes large.  What are these constants?\nSimilarly, find the ratios of the stack usage in the special-purpose\nmachine to the usage in the interpreted version.<p>\n\nCompare the ratios for special-purpose versus interpreted code to the ratios\nfor compiled versus interpreted code.  You should find that the\nspecial-purpose machine does much better than the compiled code, since\nthe hand-tailored controller code should be much better than what is\nproduced by our rudimentary general-purpose compiler.<p>\n\n<p><p>b. Can you suggest improvements to the compiler that would help it\ngenerate code that would come closer in performance to the\nhand-tailored version?\n\n<p><p>\n\n<p><a name="%_thm_5.46"></a>\n<b>Exercise 5.46.</b>&nbsp;&nbsp;<a name="%_idx_6510"></a><a name="%_idx_6512"></a>Carry out an analysis like the one in\nexercise&nbsp;<a href="#%_thm_5.45">5.45</a> to determine the effectiveness of\ncompiling the tree-recursive Fibonacci procedure<p>\n\n<p><p><tt>(define&nbsp;(fib&nbsp;n)<br>\n&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;2)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(fib&nbsp;(-&nbsp;n&nbsp;1))&nbsp;(fib&nbsp;(-&nbsp;n&nbsp;2)))))<br>\n</tt><p><p>\ncompared to the effectiveness of using the special-purpose Fibonacci machine of\nfigure&nbsp;<a href="book-Z-H-31.html#%_fig_5.12">5.12</a>.  (For measurement of the interpreted\nperformance, see exercise&nbsp;<a href="book-Z-H-34.html#%_thm_5.29">5.29</a>.)\nFor Fibonacci, the time resource used is not linear in <em>n</em>; hence the\nratios of stack operations will not approach a limiting value that is\nindependent of <em>n</em>.\n<p><p>\n\n<p><a name="%_thm_5.47"></a>\n<b>Exercise 5.47.</b>&nbsp;&nbsp;This section described how to modify the explicit-control evaluator so\nthat interpreted code can call compiled procedures.  Show how to\nmodify the compiler so that compiled procedures can call not only\nprimitive procedures and compiled procedures, but interpreted\nprocedures as well.  This requires modifying <tt>compile-procedure-call</tt>\nto handle the case of compound (interpreted) procedures.\nBe sure to handle all the same <tt>target</tt> and <tt>linkage</tt> combinations\nas in <tt>compile-proc-appl</tt>.  To do the actual procedure application,\nthe code needs to jump to the evaluator\'s <tt>compound-apply</tt> entry point.\nThis label cannot be directly referenced in object code\n(since the assembler requires that all labels referenced by the\ncode it is assembling be defined there), so we will add a register\ncalled <tt>compapp</tt> to the evaluator machine to hold this\nentry point, and add an instruction to initialize it:\n<p><p><tt>&nbsp;&nbsp;(assign&nbsp;compapp&nbsp;(label&nbsp;compound-apply))<br>\n&nbsp;&nbsp;(branch&nbsp;(label&nbsp;external-entry))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>;&nbsp;branches&nbsp;if&nbsp;<tt>flag</tt>&nbsp;is&nbsp;set</em><br>\nread-eval-print-loop<br>\n&nbsp;&nbsp;<tt>...</tt></tt><p><p>\nTo test your code, start by defining a procedure <tt>f</tt> that calls a\nprocedure <tt>g</tt>.  Use <tt>compile-and-go</tt> to compile the definition\nof <tt>f</tt> and start the evaluator.  Now, typing at the evaluator,\ndefine <tt>g</tt> and try to call <tt>f</tt>.\n\n<p><p>\n\n<p><a name="%_thm_5.48"></a>\n<b>Exercise 5.48.</b>&nbsp;&nbsp;<a name="%_idx_6514"></a>The <tt>compile-and-go</tt> interface implemented in this section is\nawkward, since the compiler can be called only once (when the\nevaluator machine is started).  Augment the compiler-interpreter\ninterface by providing a <tt>compile-and-run</tt> primitive that can be\ncalled from within the explicit-control evaluator as follows:<p>\n\n<p><p><tt><i>;;;&nbsp;EC-Eval&nbsp;input:</i><br>\n(compile-and-run<br>\n&nbsp;\'(define&nbsp;(factorial&nbsp;n)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(factorial&nbsp;(-&nbsp;n&nbsp;1))&nbsp;n))))<br>\n<i>;;;&nbsp;EC-Eval&nbsp;value:</i><br>\n<i>ok</i><br>\n<i>;;;&nbsp;EC-Eval&nbsp;input:</i><br>\n(factorial&nbsp;5)<br>\n<i>;;;&nbsp;EC-Eval&nbsp;value:</i><br>\n<i>120</i><br>\n</tt><p><p>\n<p><p>\n\n<p><a name="%_thm_5.49"></a>\n<b>Exercise 5.49.</b>&nbsp;&nbsp;As an alternative to using the explicit-control evaluator\'s\nread-eval-print loop, design a register machine that performs a\nread-compile-execute-print loop.  That is, the machine should run a\nloop that reads an expression, compiles it, assembles and\nexecutes the resulting code, and prints the result.  This is easy to\nrun in our simulated setup, since we can arrange to call the\nprocedures <tt>compile</tt> and <tt>assemble</tt> as ``register-machine\noperations.\'\'\n\n<p><p>\n\n<p><a name="%_thm_5.50"></a>\n<b>Exercise 5.50.</b>&nbsp;&nbsp;<a name="%_idx_6516"></a>Use the compiler to compile the metacircular evaluator of\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1">4.1</a> and run this program using the register-machine\nsimulator.  (To compile more than one definition at a time, you can\npackage the definitions in a <tt>begin</tt>.)  The resulting interpreter\nwill run very slowly because of the multiple levels of interpretation,\nbut getting all the details to work is an instructive exercise.\n<p><p>\n\n<p><a name="%_thm_5.51"></a>\n<b>Exercise 5.51.</b>&nbsp;&nbsp;<a name="%_idx_6518"></a>Develop a rudimentary implementation of Scheme in C (or some other\nlow-level language of your choice) by translating the explicit-control\nevaluator of section&nbsp;<a href="book-Z-H-34.html#%_sec_5.4">5.4</a> into C.  In order to run this code\nyou will need to also\nprovide appropriate storage-allocation routines and other run-time\nsupport.\n\n<p><p>\n\n<p><a name="%_thm_5.52"></a>\n<b>Exercise 5.52.</b>&nbsp;&nbsp;<a name="%_idx_6520"></a><a name="%_idx_6522"></a><a name="%_idx_6524"></a>As a counterpoint to exercise&nbsp;<a href="#%_thm_5.51">5.51</a>, modify the compiler\nso that it compiles Scheme procedures into sequences of C\ninstructions.  Compile the metacircular evaluator of\nsection&nbsp;<a href="book-Z-H-26.html#%_sec_4.1">4.1</a> to produce a Scheme interpreter written in C.\n\n<p>\n<p>\n\n\n\n<p><div class=smallprint><hr></div><p>\n<div class=footnote><p><a name="footnote_Temp_794" href="#call_footnote_Temp_794"><sup><small>33</small></sup></a> This is a theoretical statement.  We are not claiming\nthat the evaluator\'s data paths are a particularly convenient or\nefficient set of data paths for a general-purpose computer.  For example,\nthey are not very good for implementing high-performance floating-point\ncalculations or calculations that intensively manipulate bit vectors.\n\n<p><a name="footnote_Temp_795" href="#call_footnote_Temp_795"><sup><small>34</small></sup></a> Actually, the machine that runs\ncompiled code can be simpler than the interpreter machine, because we\n<a name="%_idx_6220"></a>won\'t use the <tt>exp</tt> and <tt>unev</tt> registers.  The interpreter\nused these to hold pieces of unevaluated expressions.  With the\ncompiler, however, these expressions get built into the\ncompiled code that the register machine will run.  For the same\nreason, <a name="%_idx_6222"></a>we don\'t need the machine operations that deal with expression\nsyntax.  But compiled code will use a few additional machine\noperations (to represent compiled procedure objects) that didn\'t\nappear in the explicit-control evaluator machine.\n\n<p><a name="footnote_Temp_797" href="#call_footnote_Temp_797"><sup><small>35</small></sup></a> Notice, however, that our\ncompiler is a Scheme program, and the syntax procedures that it uses\nto manipulate expressions are the actual Scheme procedures used with\nthe metacircular evaluator.  For the explicit-control evaluator, in\ncontrast, we assumed that equivalent syntax operations were available\nas operations for the register machine.  (Of course, when we simulated\nthe register machine in Scheme, we used the actual Scheme procedures\nin our register machine simulation.)\n\n<p><a name="footnote_Temp_803" href="#call_footnote_Temp_803"><sup><small>36</small></sup></a> This procedure uses a feature of Lisp called <em><a name="%_idx_6280"></a><a name="%_idx_6282"></a><a name="%_idx_6284"></a><a name="%_idx_6286"></a><a name="%_idx_6288"></a><a name="%_idx_6290"></a>backquote</em> (or <em>quasiquote</em>) that is handy for constructing lists.\nPreceding a list with a backquote symbol is much like quoting it,\nexcept that anything in the list that is flagged with a comma is evaluated.<p>\n\nFor example, if the value of <tt>linkage</tt> is the symbol\n<tt>branch25</tt>, then the expression\n<tt>`((goto (label ,linkage)))</tt>\nevaluates to the list\n<tt>((goto (label branch25)))</tt>.\nSimilarly, if the value of <tt>x</tt> is the list <tt>(a b c)</tt>, then\n<tt>`(1 2 ,(car x))</tt>\nevaluates to the list\n<tt>(1 2 a)</tt>.\n\n<p><a name="footnote_Temp_806" href="#call_footnote_Temp_806"><sup><small>37</small></sup></a> We can\'t just\nuse the labels <tt>true-branch</tt>, <tt>false-branch</tt>, and\n<tt>after-if</tt> as shown above,\nbecause there might be more than one <tt>if</tt> in the program.\n<a name="%_idx_6318"></a>The compiler uses the procedure <tt>make-label</tt> to generate labels.\n<tt>Make-label</tt> takes a symbol as argument and returns a new symbol\nthat begins with the given symbol.  For example, successive calls to\n<tt>(make-label \'a)</tt> would return <tt>a1</tt>, <tt>a2</tt>, and so on.\n<tt>Make-label</tt> can be implemented similarly to the generation of\nunique variable names in the query language, as follows:\n<p><p><tt>(define&nbsp;label-counter&nbsp;0)<br>\n<br>\n(define&nbsp;(new-label-number)<br>\n&nbsp;&nbsp;(set!&nbsp;label-counter&nbsp;(+&nbsp;1&nbsp;label-counter))<br>\n&nbsp;&nbsp;label-counter)<br>\n<br>\n<a name="%_idx_6320"></a><a name="%_idx_6322"></a>(define&nbsp;(make-label&nbsp;name)<br>\n&nbsp;&nbsp;(string-&gt;symbol<br>\n&nbsp;&nbsp;&nbsp;&nbsp;(string-append&nbsp;(symbol-&gt;string&nbsp;name)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(number-&gt;string&nbsp;(new-label-number)))))<br>\n</tt><p><p>\n\n\n<p><a name="footnote_Temp_809" href="#call_footnote_Temp_809"><sup><small>38</small></sup></a> We need machine operations to implement a data\nstructure for representing compiled procedures, analogous to the structure for\ncompound procedures described in section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.3">4.1.3</a>:\n<p><p><tt><a name="%_idx_6332"></a>(define&nbsp;(make-compiled-procedure&nbsp;entry&nbsp;env)<br>\n&nbsp;&nbsp;(list&nbsp;\'compiled-procedure&nbsp;entry&nbsp;env))<br>\n<br>\n<a name="%_idx_6334"></a>(define&nbsp;(compiled-procedure?&nbsp;proc)<br>\n&nbsp;&nbsp;(tagged-list?&nbsp;proc&nbsp;\'compiled-procedure))<br>\n<br>\n<a name="%_idx_6336"></a>(define&nbsp;(compiled-procedure-entry&nbsp;c-proc)&nbsp;(cadr&nbsp;c-proc))<br>\n<br>\n<a name="%_idx_6338"></a>(define&nbsp;(compiled-procedure-env&nbsp;c-proc)&nbsp;(caddr&nbsp;c-proc))<br>\n</tt><p><p>\n\n\n<p><a name="footnote_Temp_812" href="#call_footnote_Temp_812"><sup><small>39</small></sup></a> Actually, we signal an error when the target is not <tt>val</tt>\nand the linkage is <tt>return</tt>, since\nthe only place we request <tt>return</tt> linkages is in compiling\nprocedures, and our convention is that procedures return their\nvalues in <tt>val</tt>.\n\n<p><a name="footnote_Temp_813" href="#call_footnote_Temp_813"><sup><small>40</small></sup></a> Making a\n<a name="%_idx_6356"></a>compiler generate tail-recursive code might seem like a\nstraightforward idea.  But most compilers for common languages,\nincluding C and Pascal, do not do this, and therefore these languages\ncannot represent iterative processes in terms of procedure call alone.\nThe difficulty with <a name="%_idx_6358"></a><a name="%_idx_6360"></a><a name="%_idx_6362"></a>tail recursion in these languages is that their\nimplementations use the stack to store procedure arguments and local\nvariables as well as return addresses.  The Scheme implementations\ndescribed in this book store arguments and variables in memory to be\ngarbage-collected.  The reason for using the stack for variables and\narguments is that it avoids the need for garbage collection in\nlanguages that would not otherwise require it, and is generally\nbelieved to be more efficient.  Sophisticated Lisp compilers can, in\nfact, use the stack for arguments without destroying tail recursion.\n(See <a name="%_idx_6364"></a>Hanson 1990 for a description.)  There is also some debate about\nwhether stack allocation is actually more efficient than garbage\ncollection in the first place, but the details seem to hinge on fine\npoints of computer architecture.  (See <a name="%_idx_6366"></a>Appel 1987 and <a name="%_idx_6368"></a><a name="%_idx_6370"></a>Miller and Rozas\n1994 for opposing views on this issue.)\n\n<p><a name="footnote_Temp_814" href="#call_footnote_Temp_814"><sup><small>41</small></sup></a> The variable\n<a name="%_idx_6372"></a><tt>all-regs</tt> is bound to the list of names of all the registers:\n<p><p><tt><a name="%_idx_6374"></a>(define&nbsp;all-regs&nbsp;\'(env&nbsp;proc&nbsp;val&nbsp;argl&nbsp;continue))<br>\n</tt><p><p>\n\n\n<p><a name="footnote_Temp_815" href="#call_footnote_Temp_815"><sup><small>42</small></sup></a> Note that <tt>preserving</tt> calls <tt>append</tt> with three\n<a name="%_idx_6396"></a>arguments.  Though the definition of <tt>append</tt> shown in this book\naccepts only two arguments, Scheme standardly provides an <tt>append</tt>\nprocedure that takes an arbitrary number of arguments.\n\n<p><a name="footnote_Temp_822" href="#call_footnote_Temp_822"><sup><small>43</small></sup></a> We have used\nthe same symbol <tt>+</tt> here to denote both the source-language\nprocedure and the machine operation.  In general there will not be a\none-to-one correspondence between primitives of the source language\nand primitives of the machine.\n\n<p><a name="footnote_Temp_823" href="#call_footnote_Temp_823"><sup><small>44</small></sup></a> Making the primitives into reserved\nwords is in general a bad idea, since a user cannot then rebind these\nnames to different procedures.  Moreover, if we add reserved words to\na compiler that is in use, existing programs that define procedures\nwith these names will stop working.  See\nexercise&nbsp;<a href="#%_thm_5.44">5.44</a> for ideas on how to avoid this\nproblem.\n\n<p><a name="footnote_Temp_824" href="#call_footnote_Temp_824"><sup><small>45</small></sup></a> This is not true if we allow\ninternal definitions, unless we scan them out.\nSee exercise&nbsp;<a href="#%_thm_5.43">5.43</a>.\n\n<p><a name="footnote_Temp_826" href="#call_footnote_Temp_826"><sup><small>46</small></sup></a> This is the modification to variable lookup\n<a name="%_idx_6446"></a><a name="%_idx_6448"></a>required if we implement the scanning method to eliminate internal\ndefinitions (exercise&nbsp;<a href="#%_thm_5.43">5.43</a>).  We will need\nto eliminate these definitions in order for lexical addressing to\nwork.\n\n<p><a name="footnote_Temp_830" href="#call_footnote_Temp_830"><sup><small>47</small></sup></a> Lexical addresses cannot be used to access variables in the global\nenvironment, because these names can be defined and redefined\ninteractively at any time.  With internal definitions scanned out, as\nin exercise&nbsp;<a href="#%_thm_5.43">5.43</a>, the only definitions the\ncompiler sees are those at top level, which act on the global\nenvironment.  Compilation of a definition does not cause the defined\nname to be entered in the compile-time environment.\n\n<p><a name="footnote_Temp_833" href="#call_footnote_Temp_833"><sup><small>48</small></sup></a> Of course, compiled procedures as well as interpreted\nprocedures are compound (nonprimitive).  For compatibility with\nthe terminology used in the explicit-control evaluator, in this\nsection we will use ``compound\'\' to mean interpreted (as opposed\nto compiled).\n\n<p><a name="footnote_Temp_834" href="#call_footnote_Temp_834"><sup><small>49</small></sup></a> Now that the evaluator machine starts\nwith a <tt>branch</tt>, we must always initialize the <tt>flag</tt> register\nbefore starting the evaluator machine.  To start the machine at\nits ordinary read-eval-print loop, we could use\n<p><p><tt><a name="%_idx_6478"></a>(define&nbsp;(start-eceval)<br>\n&nbsp;&nbsp;(set!&nbsp;the-global-environment&nbsp;(setup-environment))<br>\n&nbsp;&nbsp;(set-register-contents!&nbsp;eceval&nbsp;\'flag&nbsp;false)<br>\n&nbsp;&nbsp;(start&nbsp;eceval))<br>\n</tt><p><p>\n\n<p><a name="footnote_Temp_835" href="#call_footnote_Temp_835"><sup><small>50</small></sup></a> Since a compiled procedure is an\nobject that the system may try to print, we also modify the system\nprint operation <tt>user-print</tt> (from section&nbsp;<a href="book-Z-H-26.html#%_sec_4.1.4">4.1.4</a>)\nso that it will not attempt to print the\ncomponents of a compiled procedure:\n<p><p><tt><a name="%_idx_6480"></a>(define&nbsp;(user-print&nbsp;object)<br>\n&nbsp;&nbsp;(cond&nbsp;((compound-procedure?&nbsp;object)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;(list&nbsp;\'compound-procedure<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure-parameters&nbsp;object)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure-body&nbsp;object)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'&lt;procedure-env&gt;)))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((compiled-procedure?&nbsp;object)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;\'&lt;compiled-procedure&gt;))<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(display&nbsp;object))))<br>\n</tt><p><p>\n\n\n<p><a name="footnote_Temp_837" href="#call_footnote_Temp_837"><sup><small>51</small></sup></a> We can do even better by extending the compiler\nto allow compiled code to call interpreted procedures.  See\nexercise&nbsp;<a href="#%_thm_5.47">5.47</a>.\n\n<p><a name="footnote_Temp_838" href="#call_footnote_Temp_838"><sup><small>52</small></sup></a> Independent of the strategy of execution, we\n<a name="%_idx_6494"></a>incur significant overhead if we insist that errors encountered in\nexecution of a user program be detected and signaled, rather than being\nallowed to kill the system or produce wrong answers.  For example, an\nout-of-bounds array reference can be detected by checking the validity\nof the reference before performing it.  The overhead of checking,\nhowever, can be many times the cost of the array reference itself, and\na programmer should weigh speed against safety in determining whether\nsuch a check is desirable.  A good compiler should be able to produce\ncode with such checks, should avoid redundant checks, and should allow\nprogrammers to control the extent and type of error checking in the\ncompiled code.<p>\n\n<a name="%_idx_6496"></a>Compilers for popular languages, such as C and C++,\nput hardly any error-checking operations into\nrunning code, so as to make things run as fast as possible.  As a\nresult, it falls to programmers to explicitly provide error checking.\nUnfortunately, people often neglect to do this, even in\ncritical applications where speed is not a constraint.  Their programs\nlead fast and dangerous lives.  For example, the notorious <a name="%_idx_6498"></a>``Worm\'\'\nthat paralyzed the Internet in 1988 exploited the <a name="%_idx_6500"></a>UNIX<sup> <em>T</em><em>M</em></sup>\noperating system\'s failure to check whether the input buffer has\n<a name="%_idx_6502"></a>overflowed in the finger daemon. (See Spafford 1989.)\n\n<p><a name="footnote_Temp_839" href="#call_footnote_Temp_839"><sup><small>53</small></sup></a> Of course, with either the\ninterpretation or the compilation strategy we must also implement for\nthe new machine storage allocation, input and output, and all the\nvarious operations that we took as ``primitive\'\' in our discussion of\nthe evaluator and compiler.  One strategy for minimizing work here is\nto write as many of these operations as possible in Lisp and then\ncompile them for the new machine.  Ultimately, everything reduces to a\nsmall kernel (such as garbage collection and the mechanism for\napplying actual machine primitives) that is hand-coded for the new\nmachine.\n\n<p><a name="footnote_Temp_840" href="#call_footnote_Temp_840"><sup><small>54</small></sup></a> \nThis strategy leads to amusing tests of correctness of\nthe compiler, such as checking\nwhether the compilation of a program on the new machine, using the\ncompiled compiler, is identical with the\ncompilation of the program on the original Lisp system.  Tracking\ndown the source of differences is fun but often frustrating, because\nthe results are extremely sensitive to minuscule details.\n\n</div>\n\n<p>